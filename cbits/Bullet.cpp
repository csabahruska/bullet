#include "Bullet.h"
#include "HaskellBulletAPI.h"
#include "LinearMath/btAlignedAllocator.h"
// ::btGLDebugDrawer
//constructor: btGLDebugDrawer  ( ::btGLDebugDrawer::* )(  ) 
void* btGLDebugDrawer_new() {
	::btGLDebugDrawer *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGLDebugDrawer),16);
	o = new (mem)::btGLDebugDrawer();
	return (void*)o;
}
void btGLDebugDrawer_free(void *c) {
	::btGLDebugDrawer *o = (::btGLDebugDrawer*)c;
	delete o;
}
//method: draw3dText void ( ::btGLDebugDrawer::* )( ::btVector3 const &,char const * ) 
void btGLDebugDrawer_draw3dText(void *c,float* p0,char const * p1) {
	::btGLDebugDrawer *o = (::btGLDebugDrawer*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->draw3dText(tp0,p1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: drawTriangle void ( ::btGLDebugDrawer::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
void btGLDebugDrawer_drawTriangle(void *c,float* p0,float* p1,float* p2,float* p3,float p4) {
	::btGLDebugDrawer *o = (::btGLDebugDrawer*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	o->drawTriangle(tp0,tp1,tp2,tp3,p4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
}
//method: drawBox void ( ::btGLDebugDrawer::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
void btGLDebugDrawer_drawBox(void *c,float* p0,float* p1,float* p2,float p3) {
	::btGLDebugDrawer *o = (::btGLDebugDrawer*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->drawBox(tp0,tp1,tp2,p3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: drawContactPoint void ( ::btGLDebugDrawer::* )( ::btVector3 const &,::btVector3 const &,::btScalar,int,::btVector3 const & ) 
void btGLDebugDrawer_drawContactPoint(void *c,float* p0,float* p1,float p2,int p3,float* p4) {
	::btGLDebugDrawer *o = (::btGLDebugDrawer*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->drawContactPoint(tp0,tp1,p2,p3,tp4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: drawLine void ( ::btGLDebugDrawer::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btGLDebugDrawer_drawLine(void *c,float* p0,float* p1,float* p2,float* p3) {
	::btGLDebugDrawer *o = (::btGLDebugDrawer*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	o->drawLine(tp0,tp1,tp2,tp3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
}
//method: drawLine void ( ::btGLDebugDrawer::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btGLDebugDrawer_drawLine0(void *c,float* p0,float* p1,float* p2,float* p3) {
	::btGLDebugDrawer *o = (::btGLDebugDrawer*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	o->drawLine(tp0,tp1,tp2,tp3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
}
//method: drawLine void ( ::btGLDebugDrawer::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btGLDebugDrawer_drawLine1(void *c,float* p0,float* p1,float* p2) {
	::btGLDebugDrawer *o = (::btGLDebugDrawer*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->drawLine(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: reportErrorWarning void ( ::btGLDebugDrawer::* )( char const * ) 
void btGLDebugDrawer_reportErrorWarning(void *c,char const * p0) {
	::btGLDebugDrawer *o = (::btGLDebugDrawer*)c;
	o->reportErrorWarning(p0);
}
//method: getDebugMode int ( ::btGLDebugDrawer::* )(  ) const
int btGLDebugDrawer_getDebugMode(void *c) {
	::btGLDebugDrawer *o = (::btGLDebugDrawer*)c;
	int retVal = (int)o->getDebugMode();
	return retVal;
}
//method: setDebugMode void ( ::btGLDebugDrawer::* )( int ) 
void btGLDebugDrawer_setDebugMode(void *c,int p0) {
	::btGLDebugDrawer *o = (::btGLDebugDrawer*)c;
	o->setDebugMode(p0);
}
//method: drawSphere void ( ::btGLDebugDrawer::* )( ::btVector3 const &,::btScalar,::btVector3 const & ) 
void btGLDebugDrawer_drawSphere(void *c,float* p0,float p1,float* p2) {
	::btGLDebugDrawer *o = (::btGLDebugDrawer*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->drawSphere(tp0,p1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}

// ::btSoftBody::AJoint
//constructor: AJoint  ( ::btSoftBody::AJoint::* )(  ) 
void* btSoftBody_AJoint_new() {
	::btSoftBody::AJoint *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::AJoint),16);
	o = new (mem)::btSoftBody::AJoint();
	return (void*)o;
}
void btSoftBody_AJoint_free(void *c) {
	::btSoftBody::AJoint *o = (::btSoftBody::AJoint*)c;
	delete o;
}
//method: Terminate void ( ::btSoftBody::AJoint::* )( ::btScalar ) 
void btSoftBody_AJoint_Terminate(void *c,float p0) {
	::btSoftBody::AJoint *o = (::btSoftBody::AJoint*)c;
	o->Terminate(p0);
}
//not supported method: Type ::btSoftBody::Joint::eType::_ ( ::btSoftBody::AJoint::* )(  ) const
// error:  - unsupported

//method: Solve void ( ::btSoftBody::AJoint::* )( ::btScalar,::btScalar ) 
void btSoftBody_AJoint_Solve(void *c,float p0,float p1) {
	::btSoftBody::AJoint *o = (::btSoftBody::AJoint*)c;
	o->Solve(p0,p1);
}
//method: Prepare void ( ::btSoftBody::AJoint::* )( ::btScalar,int ) 
void btSoftBody_AJoint_Prepare(void *c,float p0,int p1) {
	::btSoftBody::AJoint *o = (::btSoftBody::AJoint*)c;
	o->Prepare(p0,p1);
}
//attribute: ::btVector3[2] btSoftBody_AJoint->m_axis
// attribute not supported: //attribute: ::btVector3[2] btSoftBody_AJoint->m_axis
//attribute: ::btSoftBody::AJoint::IControl * btSoftBody_AJoint->m_icontrol
void btSoftBody_AJoint_m_icontrol_set(void *c,void* a) {
	::btSoftBody::AJoint *o = (::btSoftBody::AJoint*)c;
	::btSoftBody::AJoint::IControl * ta = (::btSoftBody::AJoint::IControl *)a;
	o->m_icontrol = ta;
}
void* btSoftBody_AJoint_m_icontrol_get(void *c) {
	::btSoftBody::AJoint *o = (::btSoftBody::AJoint*)c;
	return (void*)(o->m_icontrol);
}


// ::btSoftBody::Anchor
//constructor: Anchor  ( ::btSoftBody::Anchor::* )(  ) 
void* btSoftBody_Anchor_new() {
	::btSoftBody::Anchor *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Anchor),16);
	o = new (mem)::btSoftBody::Anchor();
	return (void*)o;
}
void btSoftBody_Anchor_free(void *c) {
	::btSoftBody::Anchor *o = (::btSoftBody::Anchor*)c;
	delete o;
}
//attribute: ::btSoftBody::Node * btSoftBody_Anchor->m_node
void btSoftBody_Anchor_m_node_set(void *c,void* a) {
	::btSoftBody::Anchor *o = (::btSoftBody::Anchor*)c;
	::btSoftBody::Node * ta = (::btSoftBody::Node *)a;
	o->m_node = ta;
}
void* btSoftBody_Anchor_m_node_get(void *c) {
	::btSoftBody::Anchor *o = (::btSoftBody::Anchor*)c;
	return (void*)(o->m_node);
}

//attribute: ::btVector3 btSoftBody_Anchor->m_local
void btSoftBody_Anchor_m_local_set(void *c,float* a) {
	::btSoftBody::Anchor *o = (::btSoftBody::Anchor*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_local = ta;
}
void btSoftBody_Anchor_m_local_get(void *c,float* a) {
	::btSoftBody::Anchor *o = (::btSoftBody::Anchor*)c;
	a[0]=(o->m_local).m_floats[0];a[1]=(o->m_local).m_floats[1];a[2]=(o->m_local).m_floats[2];
}

//attribute: ::btRigidBody * btSoftBody_Anchor->m_body
void btSoftBody_Anchor_m_body_set(void *c,void* a) {
	::btSoftBody::Anchor *o = (::btSoftBody::Anchor*)c;
	::btRigidBody * ta = (::btRigidBody *)a;
	o->m_body = ta;
}
void* btSoftBody_Anchor_m_body_get(void *c) {
	::btSoftBody::Anchor *o = (::btSoftBody::Anchor*)c;
	return (void*)(o->m_body);
}

//attribute: ::btScalar btSoftBody_Anchor->m_influence
void btSoftBody_Anchor_m_influence_set(void *c,float a) {
	::btSoftBody::Anchor *o = (::btSoftBody::Anchor*)c;
	o->m_influence = a;
}
float btSoftBody_Anchor_m_influence_get(void *c) {
	::btSoftBody::Anchor *o = (::btSoftBody::Anchor*)c;
	return (float)(o->m_influence);
}

//attribute: ::btMatrix3x3 btSoftBody_Anchor->m_c0
void btSoftBody_Anchor_m_c0_set(void *c,float* a) {
	::btSoftBody::Anchor *o = (::btSoftBody::Anchor*)c;
	btMatrix3x3 ta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	o->m_c0 = ta;
}
void btSoftBody_Anchor_m_c0_get(void *c,float* a) {
	::btSoftBody::Anchor *o = (::btSoftBody::Anchor*)c;
	a[0]=(o->m_c0).getRow(0).m_floats[0];a[1]=(o->m_c0).getRow(0).m_floats[1];a[2]=(o->m_c0).getRow(0).m_floats[2];a[3]=(o->m_c0).getRow(1).m_floats[0];a[4]=(o->m_c0).getRow(1).m_floats[1];a[5]=(o->m_c0).getRow(1).m_floats[2];a[6]=(o->m_c0).getRow(2).m_floats[0];a[7]=(o->m_c0).getRow(2).m_floats[1];a[8]=(o->m_c0).getRow(2).m_floats[2];
}

//attribute: ::btVector3 btSoftBody_Anchor->m_c1
void btSoftBody_Anchor_m_c1_set(void *c,float* a) {
	::btSoftBody::Anchor *o = (::btSoftBody::Anchor*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_c1 = ta;
}
void btSoftBody_Anchor_m_c1_get(void *c,float* a) {
	::btSoftBody::Anchor *o = (::btSoftBody::Anchor*)c;
	a[0]=(o->m_c1).m_floats[0];a[1]=(o->m_c1).m_floats[1];a[2]=(o->m_c1).m_floats[2];
}

//attribute: ::btScalar btSoftBody_Anchor->m_c2
void btSoftBody_Anchor_m_c2_set(void *c,float a) {
	::btSoftBody::Anchor *o = (::btSoftBody::Anchor*)c;
	o->m_c2 = a;
}
float btSoftBody_Anchor_m_c2_get(void *c) {
	::btSoftBody::Anchor *o = (::btSoftBody::Anchor*)c;
	return (float)(o->m_c2);
}


// ::btSoftBody::Body
//constructor: Body  ( ::btSoftBody::Body::* )(  ) 
void* btSoftBody_Body_new0() {
	::btSoftBody::Body *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Body),16);
	o = new (mem)::btSoftBody::Body();
	return (void*)o;
}
//constructor: Body  ( ::btSoftBody::Body::* )( ::btSoftBody::Cluster * ) 
void* btSoftBody_Body_new1(void* p0) {
	::btSoftBody::Body *o = 0;
	 void *mem = 0;
	::btSoftBody::Cluster * tp0 = (::btSoftBody::Cluster *)p0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Body),16);
	o = new (mem)::btSoftBody::Body(tp0);
	return (void*)o;
}
//constructor: Body  ( ::btSoftBody::Body::* )( ::btCollisionObject * ) 
void* btSoftBody_Body_new2(void* p0) {
	::btSoftBody::Body *o = 0;
	 void *mem = 0;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Body),16);
	o = new (mem)::btSoftBody::Body(tp0);
	return (void*)o;
}
void btSoftBody_Body_free(void *c) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	delete o;
}
//method: invWorldInertia ::btMatrix3x3 const & ( ::btSoftBody::Body::* )(  ) const
void btSoftBody_Body_invWorldInertia(void *c,float* ret) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	btMatrix3x3 tret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	tret = o->invWorldInertia();
	ret[0]=tret.getRow(0).m_floats[0];ret[1]=tret.getRow(0).m_floats[1];ret[2]=tret.getRow(0).m_floats[2];ret[3]=tret.getRow(1).m_floats[0];ret[4]=tret.getRow(1).m_floats[1];ret[5]=tret.getRow(1).m_floats[2];ret[6]=tret.getRow(2).m_floats[0];ret[7]=tret.getRow(2).m_floats[1];ret[8]=tret.getRow(2).m_floats[2];
}
//method: activate void ( ::btSoftBody::Body::* )(  ) const
void btSoftBody_Body_activate(void *c) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	o->activate();
}
//method: linearVelocity ::btVector3 ( ::btSoftBody::Body::* )(  ) const
void btSoftBody_Body_linearVelocity(void *c,float* ret) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->linearVelocity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: applyVImpulse void ( ::btSoftBody::Body::* )( ::btVector3 const &,::btVector3 const & ) const
void btSoftBody_Body_applyVImpulse(void *c,float* p0,float* p1) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->applyVImpulse(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: applyDImpulse void ( ::btSoftBody::Body::* )( ::btVector3 const &,::btVector3 const & ) const
void btSoftBody_Body_applyDImpulse(void *c,float* p0,float* p1) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->applyDImpulse(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: applyDCImpulse void ( ::btSoftBody::Body::* )( ::btVector3 const & ) const
void btSoftBody_Body_applyDCImpulse(void *c,float* p0) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->applyDCImpulse(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: applyAImpulse void ( ::btSoftBody::Body::* )( ::btSoftBody::Impulse const & ) const
void btSoftBody_Body_applyAImpulse(void *c,void* p0) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	::btSoftBody::Impulse const & tp0 = *(::btSoftBody::Impulse const *)p0;
	o->applyAImpulse(tp0);
}
//method: angularVelocity ::btVector3 ( ::btSoftBody::Body::* )( ::btVector3 const & ) const
void btSoftBody_Body_angularVelocity(void *c,float* p0,float* ret) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->angularVelocity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: angularVelocity ::btVector3 ( ::btSoftBody::Body::* )( ::btVector3 const & ) const
void btSoftBody_Body_angularVelocity0(void *c,float* p0,float* ret) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->angularVelocity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: angularVelocity ::btVector3 ( ::btSoftBody::Body::* )(  ) const
void btSoftBody_Body_angularVelocity1(void *c,float* ret) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->angularVelocity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: applyVAImpulse void ( ::btSoftBody::Body::* )( ::btVector3 const & ) const
void btSoftBody_Body_applyVAImpulse(void *c,float* p0) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->applyVAImpulse(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: applyImpulse void ( ::btSoftBody::Body::* )( ::btSoftBody::Impulse const &,::btVector3 const & ) const
void btSoftBody_Body_applyImpulse(void *c,void* p0,float* p1) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	::btSoftBody::Impulse const & tp0 = *(::btSoftBody::Impulse const *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->applyImpulse(tp0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: applyDAImpulse void ( ::btSoftBody::Body::* )( ::btVector3 const & ) const
void btSoftBody_Body_applyDAImpulse(void *c,float* p0) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->applyDAImpulse(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: velocity ::btVector3 ( ::btSoftBody::Body::* )( ::btVector3 const & ) const
void btSoftBody_Body_velocity(void *c,float* p0,float* ret) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->velocity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: invMass ::btScalar ( ::btSoftBody::Body::* )(  ) const
float btSoftBody_Body_invMass(void *c) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	float retVal = (float)o->invMass();
	return retVal;
}
//method: xform ::btTransform const & ( ::btSoftBody::Body::* )(  ) const
void btSoftBody_Body_xform(void *c,float* ret) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->xform();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//attribute: ::btSoftBody::Cluster * btSoftBody_Body->m_soft
void btSoftBody_Body_m_soft_set(void *c,void* a) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	::btSoftBody::Cluster * ta = (::btSoftBody::Cluster *)a;
	o->m_soft = ta;
}
void* btSoftBody_Body_m_soft_get(void *c) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	return (void*)(o->m_soft);
}

//attribute: ::btRigidBody * btSoftBody_Body->m_rigid
void btSoftBody_Body_m_rigid_set(void *c,void* a) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	::btRigidBody * ta = (::btRigidBody *)a;
	o->m_rigid = ta;
}
void* btSoftBody_Body_m_rigid_get(void *c) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	return (void*)(o->m_rigid);
}

//attribute: ::btCollisionObject * btSoftBody_Body->m_collisionObject
void btSoftBody_Body_m_collisionObject_set(void *c,void* a) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	::btCollisionObject * ta = (::btCollisionObject *)a;
	o->m_collisionObject = ta;
}
void* btSoftBody_Body_m_collisionObject_get(void *c) {
	::btSoftBody::Body *o = (::btSoftBody::Body*)c;
	return (void*)(o->m_collisionObject);
}


// ::btSoftBody::CJoint
//constructor: CJoint  ( ::btSoftBody::CJoint::* )(  ) 
void* btSoftBody_CJoint_new() {
	::btSoftBody::CJoint *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::CJoint),16);
	o = new (mem)::btSoftBody::CJoint();
	return (void*)o;
}
void btSoftBody_CJoint_free(void *c) {
	::btSoftBody::CJoint *o = (::btSoftBody::CJoint*)c;
	delete o;
}
//method: Terminate void ( ::btSoftBody::CJoint::* )( ::btScalar ) 
void btSoftBody_CJoint_Terminate(void *c,float p0) {
	::btSoftBody::CJoint *o = (::btSoftBody::CJoint*)c;
	o->Terminate(p0);
}
//not supported method: Type ::btSoftBody::Joint::eType::_ ( ::btSoftBody::CJoint::* )(  ) const
// error:  - unsupported

//method: Solve void ( ::btSoftBody::CJoint::* )( ::btScalar,::btScalar ) 
void btSoftBody_CJoint_Solve(void *c,float p0,float p1) {
	::btSoftBody::CJoint *o = (::btSoftBody::CJoint*)c;
	o->Solve(p0,p1);
}
//method: Prepare void ( ::btSoftBody::CJoint::* )( ::btScalar,int ) 
void btSoftBody_CJoint_Prepare(void *c,float p0,int p1) {
	::btSoftBody::CJoint *o = (::btSoftBody::CJoint*)c;
	o->Prepare(p0,p1);
}
//attribute: int btSoftBody_CJoint->m_life
void btSoftBody_CJoint_m_life_set(void *c,int a) {
	::btSoftBody::CJoint *o = (::btSoftBody::CJoint*)c;
	o->m_life = a;
}
int btSoftBody_CJoint_m_life_get(void *c) {
	::btSoftBody::CJoint *o = (::btSoftBody::CJoint*)c;
	return (int)(o->m_life);
}

//attribute: int btSoftBody_CJoint->m_maxlife
void btSoftBody_CJoint_m_maxlife_set(void *c,int a) {
	::btSoftBody::CJoint *o = (::btSoftBody::CJoint*)c;
	o->m_maxlife = a;
}
int btSoftBody_CJoint_m_maxlife_get(void *c) {
	::btSoftBody::CJoint *o = (::btSoftBody::CJoint*)c;
	return (int)(o->m_maxlife);
}

//attribute: ::btVector3[2] btSoftBody_CJoint->m_rpos
// attribute not supported: //attribute: ::btVector3[2] btSoftBody_CJoint->m_rpos
//attribute: ::btVector3 btSoftBody_CJoint->m_normal
void btSoftBody_CJoint_m_normal_set(void *c,float* a) {
	::btSoftBody::CJoint *o = (::btSoftBody::CJoint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_normal = ta;
}
void btSoftBody_CJoint_m_normal_get(void *c,float* a) {
	::btSoftBody::CJoint *o = (::btSoftBody::CJoint*)c;
	a[0]=(o->m_normal).m_floats[0];a[1]=(o->m_normal).m_floats[1];a[2]=(o->m_normal).m_floats[2];
}

//attribute: ::btScalar btSoftBody_CJoint->m_friction
void btSoftBody_CJoint_m_friction_set(void *c,float a) {
	::btSoftBody::CJoint *o = (::btSoftBody::CJoint*)c;
	o->m_friction = a;
}
float btSoftBody_CJoint_m_friction_get(void *c) {
	::btSoftBody::CJoint *o = (::btSoftBody::CJoint*)c;
	return (float)(o->m_friction);
}


// ::btSoftBody::Cluster
//constructor: Cluster  ( ::btSoftBody::Cluster::* )(  ) 
void* btSoftBody_Cluster_new() {
	::btSoftBody::Cluster *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Cluster),16);
	o = new (mem)::btSoftBody::Cluster();
	return (void*)o;
}
void btSoftBody_Cluster_free(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	delete o;
}
//attribute: ::btScalar btSoftBody_Cluster->m_adamping
void btSoftBody_Cluster_m_adamping_set(void *c,float a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	o->m_adamping = a;
}
float btSoftBody_Cluster_m_adamping_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (float)(o->m_adamping);
}

//attribute: ::btVector3 btSoftBody_Cluster->m_av
void btSoftBody_Cluster_m_av_set(void *c,float* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_av = ta;
}
void btSoftBody_Cluster_m_av_get(void *c,float* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	a[0]=(o->m_av).m_floats[0];a[1]=(o->m_av).m_floats[1];a[2]=(o->m_av).m_floats[2];
}

//attribute: int btSoftBody_Cluster->m_clusterIndex
void btSoftBody_Cluster_m_clusterIndex_set(void *c,int a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	o->m_clusterIndex = a;
}
int btSoftBody_Cluster_m_clusterIndex_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (int)(o->m_clusterIndex);
}

//attribute: bool btSoftBody_Cluster->m_collide
void btSoftBody_Cluster_m_collide_set(void *c,int a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	o->m_collide = a;
}
int btSoftBody_Cluster_m_collide_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (int)(o->m_collide);
}

//attribute: ::btVector3 btSoftBody_Cluster->m_com
void btSoftBody_Cluster_m_com_set(void *c,float* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_com = ta;
}
void btSoftBody_Cluster_m_com_get(void *c,float* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	a[0]=(o->m_com).m_floats[0];a[1]=(o->m_com).m_floats[1];a[2]=(o->m_com).m_floats[2];
}

//attribute: bool btSoftBody_Cluster->m_containsAnchor
void btSoftBody_Cluster_m_containsAnchor_set(void *c,int a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	o->m_containsAnchor = a;
}
int btSoftBody_Cluster_m_containsAnchor_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (int)(o->m_containsAnchor);
}

//attribute: ::btVector3[2] btSoftBody_Cluster->m_dimpulses
// attribute not supported: //attribute: ::btVector3[2] btSoftBody_Cluster->m_dimpulses
//attribute: ::btAlignedObjectArray<btVector3> btSoftBody_Cluster->m_framerefs
void btSoftBody_Cluster_m_framerefs_set(void *c,void* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	::btAlignedObjectArray<btVector3> & ta = *(::btAlignedObjectArray<btVector3> *)a;
	o->m_framerefs = ta;
}
void* btSoftBody_Cluster_m_framerefs_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (void*)&(o->m_framerefs);
}

//attribute: ::btTransform btSoftBody_Cluster->m_framexform
void btSoftBody_Cluster_m_framexform_set(void *c,float* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_framexform = ta;
}
void btSoftBody_Cluster_m_framexform_get(void *c,float* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	a[0]=(o->m_framexform).getBasis().getRow(0).m_floats[0];a[1]=(o->m_framexform).getBasis().getRow(0).m_floats[1];a[2]=(o->m_framexform).getBasis().getRow(0).m_floats[2];a[3]=(o->m_framexform).getBasis().getRow(1).m_floats[0];a[4]=(o->m_framexform).getBasis().getRow(1).m_floats[1];a[5]=(o->m_framexform).getBasis().getRow(1).m_floats[2];a[6]=(o->m_framexform).getBasis().getRow(2).m_floats[0];a[7]=(o->m_framexform).getBasis().getRow(2).m_floats[1];a[8]=(o->m_framexform).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_framexform).getOrigin().m_floats[0];a[10]=(o->m_framexform).getOrigin().m_floats[1];a[11]=(o->m_framexform).getOrigin().m_floats[2];
}

//attribute: ::btScalar btSoftBody_Cluster->m_idmass
void btSoftBody_Cluster_m_idmass_set(void *c,float a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	o->m_idmass = a;
}
float btSoftBody_Cluster_m_idmass_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (float)(o->m_idmass);
}

//attribute: ::btScalar btSoftBody_Cluster->m_imass
void btSoftBody_Cluster_m_imass_set(void *c,float a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	o->m_imass = a;
}
float btSoftBody_Cluster_m_imass_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (float)(o->m_imass);
}

//attribute: ::btMatrix3x3 btSoftBody_Cluster->m_invwi
void btSoftBody_Cluster_m_invwi_set(void *c,float* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	btMatrix3x3 ta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	o->m_invwi = ta;
}
void btSoftBody_Cluster_m_invwi_get(void *c,float* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	a[0]=(o->m_invwi).getRow(0).m_floats[0];a[1]=(o->m_invwi).getRow(0).m_floats[1];a[2]=(o->m_invwi).getRow(0).m_floats[2];a[3]=(o->m_invwi).getRow(1).m_floats[0];a[4]=(o->m_invwi).getRow(1).m_floats[1];a[5]=(o->m_invwi).getRow(1).m_floats[2];a[6]=(o->m_invwi).getRow(2).m_floats[0];a[7]=(o->m_invwi).getRow(2).m_floats[1];a[8]=(o->m_invwi).getRow(2).m_floats[2];
}

//attribute: ::btScalar btSoftBody_Cluster->m_ldamping
void btSoftBody_Cluster_m_ldamping_set(void *c,float a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	o->m_ldamping = a;
}
float btSoftBody_Cluster_m_ldamping_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (float)(o->m_ldamping);
}

//attribute: ::btDbvtNode * btSoftBody_Cluster->m_leaf
void btSoftBody_Cluster_m_leaf_set(void *c,void* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	::btDbvtNode * ta = (::btDbvtNode *)a;
	o->m_leaf = ta;
}
void* btSoftBody_Cluster_m_leaf_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (void*)(o->m_leaf);
}

//attribute: ::btMatrix3x3 btSoftBody_Cluster->m_locii
void btSoftBody_Cluster_m_locii_set(void *c,float* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	btMatrix3x3 ta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	o->m_locii = ta;
}
void btSoftBody_Cluster_m_locii_get(void *c,float* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	a[0]=(o->m_locii).getRow(0).m_floats[0];a[1]=(o->m_locii).getRow(0).m_floats[1];a[2]=(o->m_locii).getRow(0).m_floats[2];a[3]=(o->m_locii).getRow(1).m_floats[0];a[4]=(o->m_locii).getRow(1).m_floats[1];a[5]=(o->m_locii).getRow(1).m_floats[2];a[6]=(o->m_locii).getRow(2).m_floats[0];a[7]=(o->m_locii).getRow(2).m_floats[1];a[8]=(o->m_locii).getRow(2).m_floats[2];
}

//attribute: ::btVector3 btSoftBody_Cluster->m_lv
void btSoftBody_Cluster_m_lv_set(void *c,float* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_lv = ta;
}
void btSoftBody_Cluster_m_lv_get(void *c,float* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	a[0]=(o->m_lv).m_floats[0];a[1]=(o->m_lv).m_floats[1];a[2]=(o->m_lv).m_floats[2];
}

//attribute: ::btAlignedObjectArray<float> btSoftBody_Cluster->m_masses
void btSoftBody_Cluster_m_masses_set(void *c,void* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	::btAlignedObjectArray<float> & ta = *(::btAlignedObjectArray<float> *)a;
	o->m_masses = ta;
}
void* btSoftBody_Cluster_m_masses_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (void*)&(o->m_masses);
}

//attribute: ::btScalar btSoftBody_Cluster->m_matching
void btSoftBody_Cluster_m_matching_set(void *c,float a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	o->m_matching = a;
}
float btSoftBody_Cluster_m_matching_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (float)(o->m_matching);
}

//attribute: ::btScalar btSoftBody_Cluster->m_maxSelfCollisionImpulse
void btSoftBody_Cluster_m_maxSelfCollisionImpulse_set(void *c,float a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	o->m_maxSelfCollisionImpulse = a;
}
float btSoftBody_Cluster_m_maxSelfCollisionImpulse_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (float)(o->m_maxSelfCollisionImpulse);
}

//attribute: ::btScalar btSoftBody_Cluster->m_ndamping
void btSoftBody_Cluster_m_ndamping_set(void *c,float a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	o->m_ndamping = a;
}
float btSoftBody_Cluster_m_ndamping_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (float)(o->m_ndamping);
}

//attribute: int btSoftBody_Cluster->m_ndimpulses
void btSoftBody_Cluster_m_ndimpulses_set(void *c,int a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	o->m_ndimpulses = a;
}
int btSoftBody_Cluster_m_ndimpulses_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (int)(o->m_ndimpulses);
}

//attribute: ::btAlignedObjectArray<btSoftBody::Node*> btSoftBody_Cluster->m_nodes
void btSoftBody_Cluster_m_nodes_set(void *c,void* a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	::btAlignedObjectArray<btSoftBody::Node*> & ta = *(::btAlignedObjectArray<btSoftBody::Node*> *)a;
	o->m_nodes = ta;
}
void* btSoftBody_Cluster_m_nodes_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (void*)&(o->m_nodes);
}

//attribute: int btSoftBody_Cluster->m_nvimpulses
void btSoftBody_Cluster_m_nvimpulses_set(void *c,int a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	o->m_nvimpulses = a;
}
int btSoftBody_Cluster_m_nvimpulses_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (int)(o->m_nvimpulses);
}

//attribute: ::btScalar btSoftBody_Cluster->m_selfCollisionImpulseFactor
void btSoftBody_Cluster_m_selfCollisionImpulseFactor_set(void *c,float a) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	o->m_selfCollisionImpulseFactor = a;
}
float btSoftBody_Cluster_m_selfCollisionImpulseFactor_get(void *c) {
	::btSoftBody::Cluster *o = (::btSoftBody::Cluster*)c;
	return (float)(o->m_selfCollisionImpulseFactor);
}

//attribute: ::btVector3[2] btSoftBody_Cluster->m_vimpulses
// attribute not supported: //attribute: ::btVector3[2] btSoftBody_Cluster->m_vimpulses

// ::btSoftBody::Config
//constructor: Config  ( ::btSoftBody::Config::* )(  ) 
void* btSoftBody_Config_new() {
	::btSoftBody::Config *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Config),16);
	o = new (mem)::btSoftBody::Config();
	return (void*)o;
}
void btSoftBody_Config_free(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	delete o;
}
//attribute: ::btSoftBody::eAeroModel::_ btSoftBody_Config->aeromodel
// attribute not supported: //attribute: ::btSoftBody::eAeroModel::_ btSoftBody_Config->aeromodel
//attribute: ::btScalar btSoftBody_Config->kVCF
void btSoftBody_Config_kVCF_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kVCF = a;
}
float btSoftBody_Config_kVCF_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kVCF);
}

//attribute: ::btScalar btSoftBody_Config->kDP
void btSoftBody_Config_kDP_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kDP = a;
}
float btSoftBody_Config_kDP_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kDP);
}

//attribute: ::btScalar btSoftBody_Config->kDG
void btSoftBody_Config_kDG_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kDG = a;
}
float btSoftBody_Config_kDG_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kDG);
}

//attribute: ::btScalar btSoftBody_Config->kLF
void btSoftBody_Config_kLF_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kLF = a;
}
float btSoftBody_Config_kLF_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kLF);
}

//attribute: ::btScalar btSoftBody_Config->kPR
void btSoftBody_Config_kPR_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kPR = a;
}
float btSoftBody_Config_kPR_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kPR);
}

//attribute: ::btScalar btSoftBody_Config->kVC
void btSoftBody_Config_kVC_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kVC = a;
}
float btSoftBody_Config_kVC_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kVC);
}

//attribute: ::btScalar btSoftBody_Config->kDF
void btSoftBody_Config_kDF_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kDF = a;
}
float btSoftBody_Config_kDF_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kDF);
}

//attribute: ::btScalar btSoftBody_Config->kMT
void btSoftBody_Config_kMT_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kMT = a;
}
float btSoftBody_Config_kMT_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kMT);
}

//attribute: ::btScalar btSoftBody_Config->kCHR
void btSoftBody_Config_kCHR_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kCHR = a;
}
float btSoftBody_Config_kCHR_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kCHR);
}

//attribute: ::btScalar btSoftBody_Config->kKHR
void btSoftBody_Config_kKHR_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kKHR = a;
}
float btSoftBody_Config_kKHR_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kKHR);
}

//attribute: ::btScalar btSoftBody_Config->kSHR
void btSoftBody_Config_kSHR_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kSHR = a;
}
float btSoftBody_Config_kSHR_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kSHR);
}

//attribute: ::btScalar btSoftBody_Config->kAHR
void btSoftBody_Config_kAHR_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kAHR = a;
}
float btSoftBody_Config_kAHR_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kAHR);
}

//attribute: ::btScalar btSoftBody_Config->kSRHR_CL
void btSoftBody_Config_kSRHR_CL_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kSRHR_CL = a;
}
float btSoftBody_Config_kSRHR_CL_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kSRHR_CL);
}

//attribute: ::btScalar btSoftBody_Config->kSKHR_CL
void btSoftBody_Config_kSKHR_CL_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kSKHR_CL = a;
}
float btSoftBody_Config_kSKHR_CL_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kSKHR_CL);
}

//attribute: ::btScalar btSoftBody_Config->kSSHR_CL
void btSoftBody_Config_kSSHR_CL_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kSSHR_CL = a;
}
float btSoftBody_Config_kSSHR_CL_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kSSHR_CL);
}

//attribute: ::btScalar btSoftBody_Config->kSR_SPLT_CL
void btSoftBody_Config_kSR_SPLT_CL_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kSR_SPLT_CL = a;
}
float btSoftBody_Config_kSR_SPLT_CL_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kSR_SPLT_CL);
}

//attribute: ::btScalar btSoftBody_Config->kSK_SPLT_CL
void btSoftBody_Config_kSK_SPLT_CL_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kSK_SPLT_CL = a;
}
float btSoftBody_Config_kSK_SPLT_CL_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kSK_SPLT_CL);
}

//attribute: ::btScalar btSoftBody_Config->kSS_SPLT_CL
void btSoftBody_Config_kSS_SPLT_CL_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->kSS_SPLT_CL = a;
}
float btSoftBody_Config_kSS_SPLT_CL_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->kSS_SPLT_CL);
}

//attribute: ::btScalar btSoftBody_Config->maxvolume
void btSoftBody_Config_maxvolume_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->maxvolume = a;
}
float btSoftBody_Config_maxvolume_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->maxvolume);
}

//attribute: ::btScalar btSoftBody_Config->timescale
void btSoftBody_Config_timescale_set(void *c,float a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->timescale = a;
}
float btSoftBody_Config_timescale_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (float)(o->timescale);
}

//attribute: int btSoftBody_Config->viterations
void btSoftBody_Config_viterations_set(void *c,int a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->viterations = a;
}
int btSoftBody_Config_viterations_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (int)(o->viterations);
}

//attribute: int btSoftBody_Config->piterations
void btSoftBody_Config_piterations_set(void *c,int a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->piterations = a;
}
int btSoftBody_Config_piterations_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (int)(o->piterations);
}

//attribute: int btSoftBody_Config->diterations
void btSoftBody_Config_diterations_set(void *c,int a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->diterations = a;
}
int btSoftBody_Config_diterations_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (int)(o->diterations);
}

//attribute: int btSoftBody_Config->citerations
void btSoftBody_Config_citerations_set(void *c,int a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->citerations = a;
}
int btSoftBody_Config_citerations_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (int)(o->citerations);
}

//attribute: int btSoftBody_Config->collisions
void btSoftBody_Config_collisions_set(void *c,int a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	o->collisions = a;
}
int btSoftBody_Config_collisions_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (int)(o->collisions);
}

//attribute: ::btAlignedObjectArray<btSoftBody::eVSolver::_> btSoftBody_Config->m_vsequence
void btSoftBody_Config_m_vsequence_set(void *c,void* a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	::btAlignedObjectArray<btSoftBody::eVSolver::_> & ta = *(::btAlignedObjectArray<btSoftBody::eVSolver::_> *)a;
	o->m_vsequence = ta;
}
void* btSoftBody_Config_m_vsequence_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (void*)&(o->m_vsequence);
}

//attribute: ::btAlignedObjectArray<btSoftBody::ePSolver::_> btSoftBody_Config->m_psequence
void btSoftBody_Config_m_psequence_set(void *c,void* a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	::btAlignedObjectArray<btSoftBody::ePSolver::_> & ta = *(::btAlignedObjectArray<btSoftBody::ePSolver::_> *)a;
	o->m_psequence = ta;
}
void* btSoftBody_Config_m_psequence_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (void*)&(o->m_psequence);
}

//attribute: ::btAlignedObjectArray<btSoftBody::ePSolver::_> btSoftBody_Config->m_dsequence
void btSoftBody_Config_m_dsequence_set(void *c,void* a) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	::btAlignedObjectArray<btSoftBody::ePSolver::_> & ta = *(::btAlignedObjectArray<btSoftBody::ePSolver::_> *)a;
	o->m_dsequence = ta;
}
void* btSoftBody_Config_m_dsequence_get(void *c) {
	::btSoftBody::Config *o = (::btSoftBody::Config*)c;
	return (void*)&(o->m_dsequence);
}


// ::btSoftBody::Element
//constructor: Element  ( ::btSoftBody::Element::* )(  ) 
void* btSoftBody_Element_new() {
	::btSoftBody::Element *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Element),16);
	o = new (mem)::btSoftBody::Element();
	return (void*)o;
}
void btSoftBody_Element_free(void *c) {
	::btSoftBody::Element *o = (::btSoftBody::Element*)c;
	delete o;
}
//attribute: void * btSoftBody_Element->m_tag
void btSoftBody_Element_m_tag_set(void *c,void* a) {
	::btSoftBody::Element *o = (::btSoftBody::Element*)c;
	void * ta = (void *)a;
	o->m_tag = ta;
}
void* btSoftBody_Element_m_tag_get(void *c) {
	::btSoftBody::Element *o = (::btSoftBody::Element*)c;
	return (void*)(o->m_tag);
}


// ::btSoftBody::Face
//constructor: Face  ( ::btSoftBody::Face::* )(  ) 
void* btSoftBody_Face_new() {
	::btSoftBody::Face *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Face),16);
	o = new (mem)::btSoftBody::Face();
	return (void*)o;
}
void btSoftBody_Face_free(void *c) {
	::btSoftBody::Face *o = (::btSoftBody::Face*)c;
	delete o;
}
//attribute: ::btSoftBody::Node *[3] btSoftBody_Face->m_n
// attribute not supported: //attribute: ::btSoftBody::Node *[3] btSoftBody_Face->m_n
//attribute: ::btVector3 btSoftBody_Face->m_normal
void btSoftBody_Face_m_normal_set(void *c,float* a) {
	::btSoftBody::Face *o = (::btSoftBody::Face*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_normal = ta;
}
void btSoftBody_Face_m_normal_get(void *c,float* a) {
	::btSoftBody::Face *o = (::btSoftBody::Face*)c;
	a[0]=(o->m_normal).m_floats[0];a[1]=(o->m_normal).m_floats[1];a[2]=(o->m_normal).m_floats[2];
}

//attribute: ::btScalar btSoftBody_Face->m_ra
void btSoftBody_Face_m_ra_set(void *c,float a) {
	::btSoftBody::Face *o = (::btSoftBody::Face*)c;
	o->m_ra = a;
}
float btSoftBody_Face_m_ra_get(void *c) {
	::btSoftBody::Face *o = (::btSoftBody::Face*)c;
	return (float)(o->m_ra);
}

//attribute: ::btDbvtNode * btSoftBody_Face->m_leaf
void btSoftBody_Face_m_leaf_set(void *c,void* a) {
	::btSoftBody::Face *o = (::btSoftBody::Face*)c;
	::btDbvtNode * ta = (::btDbvtNode *)a;
	o->m_leaf = ta;
}
void* btSoftBody_Face_m_leaf_get(void *c) {
	::btSoftBody::Face *o = (::btSoftBody::Face*)c;
	return (void*)(o->m_leaf);
}


// ::btSoftBody::Feature
//constructor: Feature  ( ::btSoftBody::Feature::* )(  ) 
void* btSoftBody_Feature_new() {
	::btSoftBody::Feature *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Feature),16);
	o = new (mem)::btSoftBody::Feature();
	return (void*)o;
}
void btSoftBody_Feature_free(void *c) {
	::btSoftBody::Feature *o = (::btSoftBody::Feature*)c;
	delete o;
}
//attribute: ::btSoftBody::Material * btSoftBody_Feature->m_material
void btSoftBody_Feature_m_material_set(void *c,void* a) {
	::btSoftBody::Feature *o = (::btSoftBody::Feature*)c;
	::btSoftBody::Material * ta = (::btSoftBody::Material *)a;
	o->m_material = ta;
}
void* btSoftBody_Feature_m_material_get(void *c) {
	::btSoftBody::Feature *o = (::btSoftBody::Feature*)c;
	return (void*)(o->m_material);
}


// ::btSoftBody::AJoint::IControl
//constructor: IControl  ( ::btSoftBody::AJoint::IControl::* )(  ) 
void* btSoftBody_AJoint_IControl_new() {
	::btSoftBody::AJoint::IControl *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::AJoint::IControl),16);
	o = new (mem)::btSoftBody::AJoint::IControl();
	return (void*)o;
}
void btSoftBody_AJoint_IControl_free(void *c) {
	::btSoftBody::AJoint::IControl *o = (::btSoftBody::AJoint::IControl*)c;
	delete o;
}
//method: Default ::btSoftBody::AJoint::IControl * (*)(  )
void* btSoftBody_AJoint_IControl_Default() {
	void* retVal = (void*) ::btSoftBody::AJoint::IControl::Default();
	return retVal;
}
//method: Speed ::btScalar ( ::btSoftBody::AJoint::IControl::* )( ::btSoftBody::AJoint *,::btScalar ) 
float btSoftBody_AJoint_IControl_Speed(void *c,void* p0,float p1) {
	::btSoftBody::AJoint::IControl *o = (::btSoftBody::AJoint::IControl*)c;
	::btSoftBody::AJoint * tp0 = (::btSoftBody::AJoint *)p0;
	float retVal = (float)o->Speed(tp0,p1);
	return retVal;
}
//method: Prepare void ( ::btSoftBody::AJoint::IControl::* )( ::btSoftBody::AJoint * ) 
void btSoftBody_AJoint_IControl_Prepare(void *c,void* p0) {
	::btSoftBody::AJoint::IControl *o = (::btSoftBody::AJoint::IControl*)c;
	::btSoftBody::AJoint * tp0 = (::btSoftBody::AJoint *)p0;
	o->Prepare(tp0);
}

// ::btSoftBody::ImplicitFn
//method: Eval ::btScalar ( ::btSoftBody::ImplicitFn::* )( ::btVector3 const & ) 
float btSoftBody_ImplicitFn_Eval(void *c,float* p0) {
	::btSoftBody::ImplicitFn *o = (::btSoftBody::ImplicitFn*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	float retVal = (float)o->Eval(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return retVal;
}

// ::btSoftBody::Impulse
//constructor: Impulse  ( ::btSoftBody::Impulse::* )(  ) 
void* btSoftBody_Impulse_new() {
	::btSoftBody::Impulse *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Impulse),16);
	o = new (mem)::btSoftBody::Impulse();
	return (void*)o;
}
void btSoftBody_Impulse_free(void *c) {
	::btSoftBody::Impulse *o = (::btSoftBody::Impulse*)c;
	delete o;
}
//attribute: int btSoftBody_Impulse->m_asDrift
void btSoftBody_Impulse_m_asDrift_set(void *c,int a) {
	::btSoftBody::Impulse *o = (::btSoftBody::Impulse*)c;
	o->m_asDrift = a;
}
int btSoftBody_Impulse_m_asDrift_get(void *c) {
	::btSoftBody::Impulse *o = (::btSoftBody::Impulse*)c;
	return (int)(o->m_asDrift);
}

//attribute: int btSoftBody_Impulse->m_asVelocity
void btSoftBody_Impulse_m_asVelocity_set(void *c,int a) {
	::btSoftBody::Impulse *o = (::btSoftBody::Impulse*)c;
	o->m_asVelocity = a;
}
int btSoftBody_Impulse_m_asVelocity_get(void *c) {
	::btSoftBody::Impulse *o = (::btSoftBody::Impulse*)c;
	return (int)(o->m_asVelocity);
}

//attribute: ::btVector3 btSoftBody_Impulse->m_drift
void btSoftBody_Impulse_m_drift_set(void *c,float* a) {
	::btSoftBody::Impulse *o = (::btSoftBody::Impulse*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_drift = ta;
}
void btSoftBody_Impulse_m_drift_get(void *c,float* a) {
	::btSoftBody::Impulse *o = (::btSoftBody::Impulse*)c;
	a[0]=(o->m_drift).m_floats[0];a[1]=(o->m_drift).m_floats[1];a[2]=(o->m_drift).m_floats[2];
}

//attribute: ::btVector3 btSoftBody_Impulse->m_velocity
void btSoftBody_Impulse_m_velocity_set(void *c,float* a) {
	::btSoftBody::Impulse *o = (::btSoftBody::Impulse*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_velocity = ta;
}
void btSoftBody_Impulse_m_velocity_get(void *c,float* a) {
	::btSoftBody::Impulse *o = (::btSoftBody::Impulse*)c;
	a[0]=(o->m_velocity).m_floats[0];a[1]=(o->m_velocity).m_floats[1];a[2]=(o->m_velocity).m_floats[2];
}


// ::btSoftBody::Joint
//method: Terminate void ( ::btSoftBody::Joint::* )( ::btScalar ) 
void btSoftBody_Joint_Terminate(void *c,float p0) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	o->Terminate(p0);
}
//not supported method: Type ::btSoftBody::Joint::eType::_ ( ::btSoftBody::Joint::* )(  ) const
// error:  - unsupported

//method: Solve void ( ::btSoftBody::Joint::* )( ::btScalar,::btScalar ) 
void btSoftBody_Joint_Solve(void *c,float p0,float p1) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	o->Solve(p0,p1);
}
//method: Prepare void ( ::btSoftBody::Joint::* )( ::btScalar,int ) 
void btSoftBody_Joint_Prepare(void *c,float p0,int p1) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	o->Prepare(p0,p1);
}
//attribute: ::btSoftBody::Body[2] btSoftBody_Joint->m_bodies
// attribute not supported: //attribute: ::btSoftBody::Body[2] btSoftBody_Joint->m_bodies
//attribute: ::btVector3[2] btSoftBody_Joint->m_refs
// attribute not supported: //attribute: ::btVector3[2] btSoftBody_Joint->m_refs
//attribute: ::btScalar btSoftBody_Joint->m_cfm
void btSoftBody_Joint_m_cfm_set(void *c,float a) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	o->m_cfm = a;
}
float btSoftBody_Joint_m_cfm_get(void *c) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	return (float)(o->m_cfm);
}

//attribute: ::btScalar btSoftBody_Joint->m_erp
void btSoftBody_Joint_m_erp_set(void *c,float a) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	o->m_erp = a;
}
float btSoftBody_Joint_m_erp_get(void *c) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	return (float)(o->m_erp);
}

//attribute: ::btScalar btSoftBody_Joint->m_split
void btSoftBody_Joint_m_split_set(void *c,float a) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	o->m_split = a;
}
float btSoftBody_Joint_m_split_get(void *c) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	return (float)(o->m_split);
}

//attribute: ::btVector3 btSoftBody_Joint->m_drift
void btSoftBody_Joint_m_drift_set(void *c,float* a) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_drift = ta;
}
void btSoftBody_Joint_m_drift_get(void *c,float* a) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	a[0]=(o->m_drift).m_floats[0];a[1]=(o->m_drift).m_floats[1];a[2]=(o->m_drift).m_floats[2];
}

//attribute: ::btVector3 btSoftBody_Joint->m_sdrift
void btSoftBody_Joint_m_sdrift_set(void *c,float* a) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_sdrift = ta;
}
void btSoftBody_Joint_m_sdrift_get(void *c,float* a) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	a[0]=(o->m_sdrift).m_floats[0];a[1]=(o->m_sdrift).m_floats[1];a[2]=(o->m_sdrift).m_floats[2];
}

//attribute: ::btMatrix3x3 btSoftBody_Joint->m_massmatrix
void btSoftBody_Joint_m_massmatrix_set(void *c,float* a) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	btMatrix3x3 ta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	o->m_massmatrix = ta;
}
void btSoftBody_Joint_m_massmatrix_get(void *c,float* a) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	a[0]=(o->m_massmatrix).getRow(0).m_floats[0];a[1]=(o->m_massmatrix).getRow(0).m_floats[1];a[2]=(o->m_massmatrix).getRow(0).m_floats[2];a[3]=(o->m_massmatrix).getRow(1).m_floats[0];a[4]=(o->m_massmatrix).getRow(1).m_floats[1];a[5]=(o->m_massmatrix).getRow(1).m_floats[2];a[6]=(o->m_massmatrix).getRow(2).m_floats[0];a[7]=(o->m_massmatrix).getRow(2).m_floats[1];a[8]=(o->m_massmatrix).getRow(2).m_floats[2];
}

//attribute: bool btSoftBody_Joint->m_delete
void btSoftBody_Joint_m_delete_set(void *c,int a) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	o->m_delete = a;
}
int btSoftBody_Joint_m_delete_get(void *c) {
	::btSoftBody::Joint *o = (::btSoftBody::Joint*)c;
	return (int)(o->m_delete);
}


// ::btSoftBody::LJoint
//constructor: LJoint  ( ::btSoftBody::LJoint::* )(  ) 
void* btSoftBody_LJoint_new() {
	::btSoftBody::LJoint *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::LJoint),16);
	o = new (mem)::btSoftBody::LJoint();
	return (void*)o;
}
void btSoftBody_LJoint_free(void *c) {
	::btSoftBody::LJoint *o = (::btSoftBody::LJoint*)c;
	delete o;
}
//method: Terminate void ( ::btSoftBody::LJoint::* )( ::btScalar ) 
void btSoftBody_LJoint_Terminate(void *c,float p0) {
	::btSoftBody::LJoint *o = (::btSoftBody::LJoint*)c;
	o->Terminate(p0);
}
//not supported method: Type ::btSoftBody::Joint::eType::_ ( ::btSoftBody::LJoint::* )(  ) const
// error:  - unsupported

//method: Solve void ( ::btSoftBody::LJoint::* )( ::btScalar,::btScalar ) 
void btSoftBody_LJoint_Solve(void *c,float p0,float p1) {
	::btSoftBody::LJoint *o = (::btSoftBody::LJoint*)c;
	o->Solve(p0,p1);
}
//method: Prepare void ( ::btSoftBody::LJoint::* )( ::btScalar,int ) 
void btSoftBody_LJoint_Prepare(void *c,float p0,int p1) {
	::btSoftBody::LJoint *o = (::btSoftBody::LJoint*)c;
	o->Prepare(p0,p1);
}
//attribute: ::btVector3[2] btSoftBody_LJoint->m_rpos
// attribute not supported: //attribute: ::btVector3[2] btSoftBody_LJoint->m_rpos

// ::btSoftBody::Link
//constructor: Link  ( ::btSoftBody::Link::* )(  ) 
void* btSoftBody_Link_new() {
	::btSoftBody::Link *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Link),16);
	o = new (mem)::btSoftBody::Link();
	return (void*)o;
}
void btSoftBody_Link_free(void *c) {
	::btSoftBody::Link *o = (::btSoftBody::Link*)c;
	delete o;
}
//attribute: ::btSoftBody::Node *[2] btSoftBody_Link->m_n
// attribute not supported: //attribute: ::btSoftBody::Node *[2] btSoftBody_Link->m_n
//attribute: ::btScalar btSoftBody_Link->m_rl
void btSoftBody_Link_m_rl_set(void *c,float a) {
	::btSoftBody::Link *o = (::btSoftBody::Link*)c;
	o->m_rl = a;
}
float btSoftBody_Link_m_rl_get(void *c) {
	::btSoftBody::Link *o = (::btSoftBody::Link*)c;
	return (float)(o->m_rl);
}

//attribute: int btSoftBody_Link->m_bbending
void btSoftBody_Link_m_bbending_set(void *c,int a) {
	::btSoftBody::Link *o = (::btSoftBody::Link*)c;
	o->m_bbending = a;
}
int btSoftBody_Link_m_bbending_get(void *c) {
	::btSoftBody::Link *o = (::btSoftBody::Link*)c;
	return (int)(o->m_bbending);
}

//attribute: ::btScalar btSoftBody_Link->m_c0
void btSoftBody_Link_m_c0_set(void *c,float a) {
	::btSoftBody::Link *o = (::btSoftBody::Link*)c;
	o->m_c0 = a;
}
float btSoftBody_Link_m_c0_get(void *c) {
	::btSoftBody::Link *o = (::btSoftBody::Link*)c;
	return (float)(o->m_c0);
}

//attribute: ::btScalar btSoftBody_Link->m_c1
void btSoftBody_Link_m_c1_set(void *c,float a) {
	::btSoftBody::Link *o = (::btSoftBody::Link*)c;
	o->m_c1 = a;
}
float btSoftBody_Link_m_c1_get(void *c) {
	::btSoftBody::Link *o = (::btSoftBody::Link*)c;
	return (float)(o->m_c1);
}

//attribute: ::btScalar btSoftBody_Link->m_c2
void btSoftBody_Link_m_c2_set(void *c,float a) {
	::btSoftBody::Link *o = (::btSoftBody::Link*)c;
	o->m_c2 = a;
}
float btSoftBody_Link_m_c2_get(void *c) {
	::btSoftBody::Link *o = (::btSoftBody::Link*)c;
	return (float)(o->m_c2);
}

//attribute: ::btVector3 btSoftBody_Link->m_c3
void btSoftBody_Link_m_c3_set(void *c,float* a) {
	::btSoftBody::Link *o = (::btSoftBody::Link*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_c3 = ta;
}
void btSoftBody_Link_m_c3_get(void *c,float* a) {
	::btSoftBody::Link *o = (::btSoftBody::Link*)c;
	a[0]=(o->m_c3).m_floats[0];a[1]=(o->m_c3).m_floats[1];a[2]=(o->m_c3).m_floats[2];
}


// ::btSoftBody::Material
//constructor: Material  ( ::btSoftBody::Material::* )(  ) 
void* btSoftBody_Material_new() {
	::btSoftBody::Material *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Material),16);
	o = new (mem)::btSoftBody::Material();
	return (void*)o;
}
void btSoftBody_Material_free(void *c) {
	::btSoftBody::Material *o = (::btSoftBody::Material*)c;
	delete o;
}
//attribute: int btSoftBody_Material->m_flags
void btSoftBody_Material_m_flags_set(void *c,int a) {
	::btSoftBody::Material *o = (::btSoftBody::Material*)c;
	o->m_flags = a;
}
int btSoftBody_Material_m_flags_get(void *c) {
	::btSoftBody::Material *o = (::btSoftBody::Material*)c;
	return (int)(o->m_flags);
}

//attribute: ::btScalar btSoftBody_Material->m_kAST
void btSoftBody_Material_m_kAST_set(void *c,float a) {
	::btSoftBody::Material *o = (::btSoftBody::Material*)c;
	o->m_kAST = a;
}
float btSoftBody_Material_m_kAST_get(void *c) {
	::btSoftBody::Material *o = (::btSoftBody::Material*)c;
	return (float)(o->m_kAST);
}

//attribute: ::btScalar btSoftBody_Material->m_kLST
void btSoftBody_Material_m_kLST_set(void *c,float a) {
	::btSoftBody::Material *o = (::btSoftBody::Material*)c;
	o->m_kLST = a;
}
float btSoftBody_Material_m_kLST_get(void *c) {
	::btSoftBody::Material *o = (::btSoftBody::Material*)c;
	return (float)(o->m_kLST);
}

//attribute: ::btScalar btSoftBody_Material->m_kVST
void btSoftBody_Material_m_kVST_set(void *c,float a) {
	::btSoftBody::Material *o = (::btSoftBody::Material*)c;
	o->m_kVST = a;
}
float btSoftBody_Material_m_kVST_get(void *c) {
	::btSoftBody::Material *o = (::btSoftBody::Material*)c;
	return (float)(o->m_kVST);
}


// ::btSoftBody::Node
//constructor: Node  ( ::btSoftBody::Node::* )(  ) 
void* btSoftBody_Node_new() {
	::btSoftBody::Node *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Node),16);
	o = new (mem)::btSoftBody::Node();
	return (void*)o;
}
void btSoftBody_Node_free(void *c) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	delete o;
}
//attribute: ::btScalar btSoftBody_Node->m_area
void btSoftBody_Node_m_area_set(void *c,float a) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	o->m_area = a;
}
float btSoftBody_Node_m_area_get(void *c) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	return (float)(o->m_area);
}

//attribute: int btSoftBody_Node->m_battach
void btSoftBody_Node_m_battach_set(void *c,int a) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	o->m_battach = a;
}
int btSoftBody_Node_m_battach_get(void *c) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	return (int)(o->m_battach);
}

//attribute: ::btVector3 btSoftBody_Node->m_f
void btSoftBody_Node_m_f_set(void *c,float* a) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_f = ta;
}
void btSoftBody_Node_m_f_get(void *c,float* a) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	a[0]=(o->m_f).m_floats[0];a[1]=(o->m_f).m_floats[1];a[2]=(o->m_f).m_floats[2];
}

//attribute: ::btScalar btSoftBody_Node->m_im
void btSoftBody_Node_m_im_set(void *c,float a) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	o->m_im = a;
}
float btSoftBody_Node_m_im_get(void *c) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	return (float)(o->m_im);
}

//attribute: ::btDbvtNode * btSoftBody_Node->m_leaf
void btSoftBody_Node_m_leaf_set(void *c,void* a) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	::btDbvtNode * ta = (::btDbvtNode *)a;
	o->m_leaf = ta;
}
void* btSoftBody_Node_m_leaf_get(void *c) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	return (void*)(o->m_leaf);
}

//attribute: ::btVector3 btSoftBody_Node->m_n
void btSoftBody_Node_m_n_set(void *c,float* a) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_n = ta;
}
void btSoftBody_Node_m_n_get(void *c,float* a) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	a[0]=(o->m_n).m_floats[0];a[1]=(o->m_n).m_floats[1];a[2]=(o->m_n).m_floats[2];
}

//attribute: ::btVector3 btSoftBody_Node->m_q
void btSoftBody_Node_m_q_set(void *c,float* a) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_q = ta;
}
void btSoftBody_Node_m_q_get(void *c,float* a) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	a[0]=(o->m_q).m_floats[0];a[1]=(o->m_q).m_floats[1];a[2]=(o->m_q).m_floats[2];
}

//attribute: ::btVector3 btSoftBody_Node->m_v
void btSoftBody_Node_m_v_set(void *c,float* a) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_v = ta;
}
void btSoftBody_Node_m_v_get(void *c,float* a) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	a[0]=(o->m_v).m_floats[0];a[1]=(o->m_v).m_floats[1];a[2]=(o->m_v).m_floats[2];
}

//attribute: ::btVector3 btSoftBody_Node->m_x
void btSoftBody_Node_m_x_set(void *c,float* a) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_x = ta;
}
void btSoftBody_Node_m_x_get(void *c,float* a) {
	::btSoftBody::Node *o = (::btSoftBody::Node*)c;
	a[0]=(o->m_x).m_floats[0];a[1]=(o->m_x).m_floats[1];a[2]=(o->m_x).m_floats[2];
}


// ::btSoftBody::Note
//constructor: Note  ( ::btSoftBody::Note::* )(  ) 
void* btSoftBody_Note_new() {
	::btSoftBody::Note *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Note),16);
	o = new (mem)::btSoftBody::Note();
	return (void*)o;
}
void btSoftBody_Note_free(void *c) {
	::btSoftBody::Note *o = (::btSoftBody::Note*)c;
	delete o;
}
//attribute: char const * btSoftBody_Note->m_text
void btSoftBody_Note_m_text_set(void *c,char const * a) {
	::btSoftBody::Note *o = (::btSoftBody::Note*)c;
	o->m_text = a;
}
char const * btSoftBody_Note_m_text_get(void *c) {
	::btSoftBody::Note *o = (::btSoftBody::Note*)c;
	return (char const *)(o->m_text);
}

//attribute: ::btVector3 btSoftBody_Note->m_offset
void btSoftBody_Note_m_offset_set(void *c,float* a) {
	::btSoftBody::Note *o = (::btSoftBody::Note*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_offset = ta;
}
void btSoftBody_Note_m_offset_get(void *c,float* a) {
	::btSoftBody::Note *o = (::btSoftBody::Note*)c;
	a[0]=(o->m_offset).m_floats[0];a[1]=(o->m_offset).m_floats[1];a[2]=(o->m_offset).m_floats[2];
}

//attribute: int btSoftBody_Note->m_rank
void btSoftBody_Note_m_rank_set(void *c,int a) {
	::btSoftBody::Note *o = (::btSoftBody::Note*)c;
	o->m_rank = a;
}
int btSoftBody_Note_m_rank_get(void *c) {
	::btSoftBody::Note *o = (::btSoftBody::Note*)c;
	return (int)(o->m_rank);
}

//attribute: ::btSoftBody::Node *[4] btSoftBody_Note->m_nodes
// attribute not supported: //attribute: ::btSoftBody::Node *[4] btSoftBody_Note->m_nodes
//attribute: ::btScalar[4] btSoftBody_Note->m_coords
// attribute not supported: //attribute: ::btScalar[4] btSoftBody_Note->m_coords

// ::btSoftBody::Pose
//constructor: Pose  ( ::btSoftBody::Pose::* )(  ) 
void* btSoftBody_Pose_new() {
	::btSoftBody::Pose *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Pose),16);
	o = new (mem)::btSoftBody::Pose();
	return (void*)o;
}
void btSoftBody_Pose_free(void *c) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	delete o;
}
//attribute: bool btSoftBody_Pose->m_bvolume
void btSoftBody_Pose_m_bvolume_set(void *c,int a) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	o->m_bvolume = a;
}
int btSoftBody_Pose_m_bvolume_get(void *c) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	return (int)(o->m_bvolume);
}

//attribute: bool btSoftBody_Pose->m_bframe
void btSoftBody_Pose_m_bframe_set(void *c,int a) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	o->m_bframe = a;
}
int btSoftBody_Pose_m_bframe_get(void *c) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	return (int)(o->m_bframe);
}

//attribute: ::btScalar btSoftBody_Pose->m_volume
void btSoftBody_Pose_m_volume_set(void *c,float a) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	o->m_volume = a;
}
float btSoftBody_Pose_m_volume_get(void *c) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	return (float)(o->m_volume);
}

//attribute: ::btAlignedObjectArray<btVector3> btSoftBody_Pose->m_pos
void btSoftBody_Pose_m_pos_set(void *c,void* a) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	::btAlignedObjectArray<btVector3> & ta = *(::btAlignedObjectArray<btVector3> *)a;
	o->m_pos = ta;
}
void* btSoftBody_Pose_m_pos_get(void *c) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	return (void*)&(o->m_pos);
}

//attribute: ::btAlignedObjectArray<float> btSoftBody_Pose->m_wgh
void btSoftBody_Pose_m_wgh_set(void *c,void* a) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	::btAlignedObjectArray<float> & ta = *(::btAlignedObjectArray<float> *)a;
	o->m_wgh = ta;
}
void* btSoftBody_Pose_m_wgh_get(void *c) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	return (void*)&(o->m_wgh);
}

//attribute: ::btVector3 btSoftBody_Pose->m_com
void btSoftBody_Pose_m_com_set(void *c,float* a) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_com = ta;
}
void btSoftBody_Pose_m_com_get(void *c,float* a) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	a[0]=(o->m_com).m_floats[0];a[1]=(o->m_com).m_floats[1];a[2]=(o->m_com).m_floats[2];
}

//attribute: ::btMatrix3x3 btSoftBody_Pose->m_rot
void btSoftBody_Pose_m_rot_set(void *c,float* a) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	btMatrix3x3 ta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	o->m_rot = ta;
}
void btSoftBody_Pose_m_rot_get(void *c,float* a) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	a[0]=(o->m_rot).getRow(0).m_floats[0];a[1]=(o->m_rot).getRow(0).m_floats[1];a[2]=(o->m_rot).getRow(0).m_floats[2];a[3]=(o->m_rot).getRow(1).m_floats[0];a[4]=(o->m_rot).getRow(1).m_floats[1];a[5]=(o->m_rot).getRow(1).m_floats[2];a[6]=(o->m_rot).getRow(2).m_floats[0];a[7]=(o->m_rot).getRow(2).m_floats[1];a[8]=(o->m_rot).getRow(2).m_floats[2];
}

//attribute: ::btMatrix3x3 btSoftBody_Pose->m_scl
void btSoftBody_Pose_m_scl_set(void *c,float* a) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	btMatrix3x3 ta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	o->m_scl = ta;
}
void btSoftBody_Pose_m_scl_get(void *c,float* a) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	a[0]=(o->m_scl).getRow(0).m_floats[0];a[1]=(o->m_scl).getRow(0).m_floats[1];a[2]=(o->m_scl).getRow(0).m_floats[2];a[3]=(o->m_scl).getRow(1).m_floats[0];a[4]=(o->m_scl).getRow(1).m_floats[1];a[5]=(o->m_scl).getRow(1).m_floats[2];a[6]=(o->m_scl).getRow(2).m_floats[0];a[7]=(o->m_scl).getRow(2).m_floats[1];a[8]=(o->m_scl).getRow(2).m_floats[2];
}

//attribute: ::btMatrix3x3 btSoftBody_Pose->m_aqq
void btSoftBody_Pose_m_aqq_set(void *c,float* a) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	btMatrix3x3 ta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	o->m_aqq = ta;
}
void btSoftBody_Pose_m_aqq_get(void *c,float* a) {
	::btSoftBody::Pose *o = (::btSoftBody::Pose*)c;
	a[0]=(o->m_aqq).getRow(0).m_floats[0];a[1]=(o->m_aqq).getRow(0).m_floats[1];a[2]=(o->m_aqq).getRow(0).m_floats[2];a[3]=(o->m_aqq).getRow(1).m_floats[0];a[4]=(o->m_aqq).getRow(1).m_floats[1];a[5]=(o->m_aqq).getRow(1).m_floats[2];a[6]=(o->m_aqq).getRow(2).m_floats[0];a[7]=(o->m_aqq).getRow(2).m_floats[1];a[8]=(o->m_aqq).getRow(2).m_floats[2];
}


// ::btSoftBody::RContact
//constructor: RContact  ( ::btSoftBody::RContact::* )(  ) 
void* btSoftBody_RContact_new() {
	::btSoftBody::RContact *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::RContact),16);
	o = new (mem)::btSoftBody::RContact();
	return (void*)o;
}
void btSoftBody_RContact_free(void *c) {
	::btSoftBody::RContact *o = (::btSoftBody::RContact*)c;
	delete o;
}
//attribute: ::btSoftBody::sCti btSoftBody_RContact->m_cti
void btSoftBody_RContact_m_cti_set(void *c,void* a) {
	::btSoftBody::RContact *o = (::btSoftBody::RContact*)c;
	::btSoftBody::sCti & ta = *(::btSoftBody::sCti *)a;
	o->m_cti = ta;
}
void* btSoftBody_RContact_m_cti_get(void *c) {
	::btSoftBody::RContact *o = (::btSoftBody::RContact*)c;
	return (void*)&(o->m_cti);
}

//attribute: ::btSoftBody::Node * btSoftBody_RContact->m_node
void btSoftBody_RContact_m_node_set(void *c,void* a) {
	::btSoftBody::RContact *o = (::btSoftBody::RContact*)c;
	::btSoftBody::Node * ta = (::btSoftBody::Node *)a;
	o->m_node = ta;
}
void* btSoftBody_RContact_m_node_get(void *c) {
	::btSoftBody::RContact *o = (::btSoftBody::RContact*)c;
	return (void*)(o->m_node);
}

//attribute: ::btMatrix3x3 btSoftBody_RContact->m_c0
void btSoftBody_RContact_m_c0_set(void *c,float* a) {
	::btSoftBody::RContact *o = (::btSoftBody::RContact*)c;
	btMatrix3x3 ta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	o->m_c0 = ta;
}
void btSoftBody_RContact_m_c0_get(void *c,float* a) {
	::btSoftBody::RContact *o = (::btSoftBody::RContact*)c;
	a[0]=(o->m_c0).getRow(0).m_floats[0];a[1]=(o->m_c0).getRow(0).m_floats[1];a[2]=(o->m_c0).getRow(0).m_floats[2];a[3]=(o->m_c0).getRow(1).m_floats[0];a[4]=(o->m_c0).getRow(1).m_floats[1];a[5]=(o->m_c0).getRow(1).m_floats[2];a[6]=(o->m_c0).getRow(2).m_floats[0];a[7]=(o->m_c0).getRow(2).m_floats[1];a[8]=(o->m_c0).getRow(2).m_floats[2];
}

//attribute: ::btVector3 btSoftBody_RContact->m_c1
void btSoftBody_RContact_m_c1_set(void *c,float* a) {
	::btSoftBody::RContact *o = (::btSoftBody::RContact*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_c1 = ta;
}
void btSoftBody_RContact_m_c1_get(void *c,float* a) {
	::btSoftBody::RContact *o = (::btSoftBody::RContact*)c;
	a[0]=(o->m_c1).m_floats[0];a[1]=(o->m_c1).m_floats[1];a[2]=(o->m_c1).m_floats[2];
}

//attribute: ::btScalar btSoftBody_RContact->m_c2
void btSoftBody_RContact_m_c2_set(void *c,float a) {
	::btSoftBody::RContact *o = (::btSoftBody::RContact*)c;
	o->m_c2 = a;
}
float btSoftBody_RContact_m_c2_get(void *c) {
	::btSoftBody::RContact *o = (::btSoftBody::RContact*)c;
	return (float)(o->m_c2);
}

//attribute: ::btScalar btSoftBody_RContact->m_c3
void btSoftBody_RContact_m_c3_set(void *c,float a) {
	::btSoftBody::RContact *o = (::btSoftBody::RContact*)c;
	o->m_c3 = a;
}
float btSoftBody_RContact_m_c3_get(void *c) {
	::btSoftBody::RContact *o = (::btSoftBody::RContact*)c;
	return (float)(o->m_c3);
}

//attribute: ::btScalar btSoftBody_RContact->m_c4
void btSoftBody_RContact_m_c4_set(void *c,float a) {
	::btSoftBody::RContact *o = (::btSoftBody::RContact*)c;
	o->m_c4 = a;
}
float btSoftBody_RContact_m_c4_get(void *c) {
	::btSoftBody::RContact *o = (::btSoftBody::RContact*)c;
	return (float)(o->m_c4);
}


// ::btSoftBody::RayFromToCaster
//constructor: RayFromToCaster  ( ::btSoftBody::RayFromToCaster::* )( ::btVector3 const &,::btVector3 const &,::btScalar ) 
void* btSoftBody_RayFromToCaster_new(float* p0,float* p1,float p2) {
	::btSoftBody::RayFromToCaster *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	mem = btAlignedAlloc(sizeof(::btSoftBody::RayFromToCaster),16);
	o = new (mem)::btSoftBody::RayFromToCaster(tp0,tp1,p2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return (void*)o;
}
void btSoftBody_RayFromToCaster_free(void *c) {
	::btSoftBody::RayFromToCaster *o = (::btSoftBody::RayFromToCaster*)c;
	delete o;
}
//method: Process void ( ::btSoftBody::RayFromToCaster::* )( ::btDbvtNode const * ) 
void btSoftBody_RayFromToCaster_Process(void *c,void* p0) {
	::btSoftBody::RayFromToCaster *o = (::btSoftBody::RayFromToCaster*)c;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	o->Process(tp0);
}
//attribute: ::btVector3 btSoftBody_RayFromToCaster->m_rayFrom
void btSoftBody_RayFromToCaster_m_rayFrom_set(void *c,float* a) {
	::btSoftBody::RayFromToCaster *o = (::btSoftBody::RayFromToCaster*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_rayFrom = ta;
}
void btSoftBody_RayFromToCaster_m_rayFrom_get(void *c,float* a) {
	::btSoftBody::RayFromToCaster *o = (::btSoftBody::RayFromToCaster*)c;
	a[0]=(o->m_rayFrom).m_floats[0];a[1]=(o->m_rayFrom).m_floats[1];a[2]=(o->m_rayFrom).m_floats[2];
}

//attribute: ::btVector3 btSoftBody_RayFromToCaster->m_rayTo
void btSoftBody_RayFromToCaster_m_rayTo_set(void *c,float* a) {
	::btSoftBody::RayFromToCaster *o = (::btSoftBody::RayFromToCaster*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_rayTo = ta;
}
void btSoftBody_RayFromToCaster_m_rayTo_get(void *c,float* a) {
	::btSoftBody::RayFromToCaster *o = (::btSoftBody::RayFromToCaster*)c;
	a[0]=(o->m_rayTo).m_floats[0];a[1]=(o->m_rayTo).m_floats[1];a[2]=(o->m_rayTo).m_floats[2];
}

//attribute: ::btVector3 btSoftBody_RayFromToCaster->m_rayNormalizedDirection
void btSoftBody_RayFromToCaster_m_rayNormalizedDirection_set(void *c,float* a) {
	::btSoftBody::RayFromToCaster *o = (::btSoftBody::RayFromToCaster*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_rayNormalizedDirection = ta;
}
void btSoftBody_RayFromToCaster_m_rayNormalizedDirection_get(void *c,float* a) {
	::btSoftBody::RayFromToCaster *o = (::btSoftBody::RayFromToCaster*)c;
	a[0]=(o->m_rayNormalizedDirection).m_floats[0];a[1]=(o->m_rayNormalizedDirection).m_floats[1];a[2]=(o->m_rayNormalizedDirection).m_floats[2];
}

//attribute: ::btScalar btSoftBody_RayFromToCaster->m_mint
void btSoftBody_RayFromToCaster_m_mint_set(void *c,float a) {
	::btSoftBody::RayFromToCaster *o = (::btSoftBody::RayFromToCaster*)c;
	o->m_mint = a;
}
float btSoftBody_RayFromToCaster_m_mint_get(void *c) {
	::btSoftBody::RayFromToCaster *o = (::btSoftBody::RayFromToCaster*)c;
	return (float)(o->m_mint);
}

//attribute: ::btSoftBody::Face * btSoftBody_RayFromToCaster->m_face
void btSoftBody_RayFromToCaster_m_face_set(void *c,void* a) {
	::btSoftBody::RayFromToCaster *o = (::btSoftBody::RayFromToCaster*)c;
	::btSoftBody::Face * ta = (::btSoftBody::Face *)a;
	o->m_face = ta;
}
void* btSoftBody_RayFromToCaster_m_face_get(void *c) {
	::btSoftBody::RayFromToCaster *o = (::btSoftBody::RayFromToCaster*)c;
	return (void*)(o->m_face);
}

//attribute: int btSoftBody_RayFromToCaster->m_tests
void btSoftBody_RayFromToCaster_m_tests_set(void *c,int a) {
	::btSoftBody::RayFromToCaster *o = (::btSoftBody::RayFromToCaster*)c;
	o->m_tests = a;
}
int btSoftBody_RayFromToCaster_m_tests_get(void *c) {
	::btSoftBody::RayFromToCaster *o = (::btSoftBody::RayFromToCaster*)c;
	return (int)(o->m_tests);
}


// ::btSoftBody::SContact
//constructor: SContact  ( ::btSoftBody::SContact::* )(  ) 
void* btSoftBody_SContact_new() {
	::btSoftBody::SContact *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::SContact),16);
	o = new (mem)::btSoftBody::SContact();
	return (void*)o;
}
void btSoftBody_SContact_free(void *c) {
	::btSoftBody::SContact *o = (::btSoftBody::SContact*)c;
	delete o;
}
//attribute: ::btSoftBody::Node * btSoftBody_SContact->m_node
void btSoftBody_SContact_m_node_set(void *c,void* a) {
	::btSoftBody::SContact *o = (::btSoftBody::SContact*)c;
	::btSoftBody::Node * ta = (::btSoftBody::Node *)a;
	o->m_node = ta;
}
void* btSoftBody_SContact_m_node_get(void *c) {
	::btSoftBody::SContact *o = (::btSoftBody::SContact*)c;
	return (void*)(o->m_node);
}

//attribute: ::btSoftBody::Face * btSoftBody_SContact->m_face
void btSoftBody_SContact_m_face_set(void *c,void* a) {
	::btSoftBody::SContact *o = (::btSoftBody::SContact*)c;
	::btSoftBody::Face * ta = (::btSoftBody::Face *)a;
	o->m_face = ta;
}
void* btSoftBody_SContact_m_face_get(void *c) {
	::btSoftBody::SContact *o = (::btSoftBody::SContact*)c;
	return (void*)(o->m_face);
}

//attribute: ::btVector3 btSoftBody_SContact->m_weights
void btSoftBody_SContact_m_weights_set(void *c,float* a) {
	::btSoftBody::SContact *o = (::btSoftBody::SContact*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_weights = ta;
}
void btSoftBody_SContact_m_weights_get(void *c,float* a) {
	::btSoftBody::SContact *o = (::btSoftBody::SContact*)c;
	a[0]=(o->m_weights).m_floats[0];a[1]=(o->m_weights).m_floats[1];a[2]=(o->m_weights).m_floats[2];
}

//attribute: ::btVector3 btSoftBody_SContact->m_normal
void btSoftBody_SContact_m_normal_set(void *c,float* a) {
	::btSoftBody::SContact *o = (::btSoftBody::SContact*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_normal = ta;
}
void btSoftBody_SContact_m_normal_get(void *c,float* a) {
	::btSoftBody::SContact *o = (::btSoftBody::SContact*)c;
	a[0]=(o->m_normal).m_floats[0];a[1]=(o->m_normal).m_floats[1];a[2]=(o->m_normal).m_floats[2];
}

//attribute: ::btScalar btSoftBody_SContact->m_margin
void btSoftBody_SContact_m_margin_set(void *c,float a) {
	::btSoftBody::SContact *o = (::btSoftBody::SContact*)c;
	o->m_margin = a;
}
float btSoftBody_SContact_m_margin_get(void *c) {
	::btSoftBody::SContact *o = (::btSoftBody::SContact*)c;
	return (float)(o->m_margin);
}

//attribute: ::btScalar btSoftBody_SContact->m_friction
void btSoftBody_SContact_m_friction_set(void *c,float a) {
	::btSoftBody::SContact *o = (::btSoftBody::SContact*)c;
	o->m_friction = a;
}
float btSoftBody_SContact_m_friction_get(void *c) {
	::btSoftBody::SContact *o = (::btSoftBody::SContact*)c;
	return (float)(o->m_friction);
}

//attribute: ::btScalar[2] btSoftBody_SContact->m_cfm
// attribute not supported: //attribute: ::btScalar[2] btSoftBody_SContact->m_cfm

// ::btSoftBody::SolverState
//constructor: SolverState  ( ::btSoftBody::SolverState::* )(  ) 
void* btSoftBody_SolverState_new() {
	::btSoftBody::SolverState *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::SolverState),16);
	o = new (mem)::btSoftBody::SolverState();
	return (void*)o;
}
void btSoftBody_SolverState_free(void *c) {
	::btSoftBody::SolverState *o = (::btSoftBody::SolverState*)c;
	delete o;
}
//attribute: ::btScalar btSoftBody_SolverState->sdt
void btSoftBody_SolverState_sdt_set(void *c,float a) {
	::btSoftBody::SolverState *o = (::btSoftBody::SolverState*)c;
	o->sdt = a;
}
float btSoftBody_SolverState_sdt_get(void *c) {
	::btSoftBody::SolverState *o = (::btSoftBody::SolverState*)c;
	return (float)(o->sdt);
}

//attribute: ::btScalar btSoftBody_SolverState->isdt
void btSoftBody_SolverState_isdt_set(void *c,float a) {
	::btSoftBody::SolverState *o = (::btSoftBody::SolverState*)c;
	o->isdt = a;
}
float btSoftBody_SolverState_isdt_get(void *c) {
	::btSoftBody::SolverState *o = (::btSoftBody::SolverState*)c;
	return (float)(o->isdt);
}

//attribute: ::btScalar btSoftBody_SolverState->velmrg
void btSoftBody_SolverState_velmrg_set(void *c,float a) {
	::btSoftBody::SolverState *o = (::btSoftBody::SolverState*)c;
	o->velmrg = a;
}
float btSoftBody_SolverState_velmrg_get(void *c) {
	::btSoftBody::SolverState *o = (::btSoftBody::SolverState*)c;
	return (float)(o->velmrg);
}

//attribute: ::btScalar btSoftBody_SolverState->radmrg
void btSoftBody_SolverState_radmrg_set(void *c,float a) {
	::btSoftBody::SolverState *o = (::btSoftBody::SolverState*)c;
	o->radmrg = a;
}
float btSoftBody_SolverState_radmrg_get(void *c) {
	::btSoftBody::SolverState *o = (::btSoftBody::SolverState*)c;
	return (float)(o->radmrg);
}

//attribute: ::btScalar btSoftBody_SolverState->updmrg
void btSoftBody_SolverState_updmrg_set(void *c,float a) {
	::btSoftBody::SolverState *o = (::btSoftBody::SolverState*)c;
	o->updmrg = a;
}
float btSoftBody_SolverState_updmrg_get(void *c) {
	::btSoftBody::SolverState *o = (::btSoftBody::SolverState*)c;
	return (float)(o->updmrg);
}


// ::btSoftBody::Joint::Specs
//constructor: Specs  ( ::btSoftBody::Joint::Specs::* )(  ) 
void* btSoftBody_Joint_Specs_new() {
	::btSoftBody::Joint::Specs *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Joint::Specs),16);
	o = new (mem)::btSoftBody::Joint::Specs();
	return (void*)o;
}
void btSoftBody_Joint_Specs_free(void *c) {
	::btSoftBody::Joint::Specs *o = (::btSoftBody::Joint::Specs*)c;
	delete o;
}
//attribute: ::btScalar btSoftBody_Joint_Specs->erp
void btSoftBody_Joint_Specs_erp_set(void *c,float a) {
	::btSoftBody::Joint::Specs *o = (::btSoftBody::Joint::Specs*)c;
	o->erp = a;
}
float btSoftBody_Joint_Specs_erp_get(void *c) {
	::btSoftBody::Joint::Specs *o = (::btSoftBody::Joint::Specs*)c;
	return (float)(o->erp);
}

//attribute: ::btScalar btSoftBody_Joint_Specs->cfm
void btSoftBody_Joint_Specs_cfm_set(void *c,float a) {
	::btSoftBody::Joint::Specs *o = (::btSoftBody::Joint::Specs*)c;
	o->cfm = a;
}
float btSoftBody_Joint_Specs_cfm_get(void *c) {
	::btSoftBody::Joint::Specs *o = (::btSoftBody::Joint::Specs*)c;
	return (float)(o->cfm);
}

//attribute: ::btScalar btSoftBody_Joint_Specs->split
void btSoftBody_Joint_Specs_split_set(void *c,float a) {
	::btSoftBody::Joint::Specs *o = (::btSoftBody::Joint::Specs*)c;
	o->split = a;
}
float btSoftBody_Joint_Specs_split_get(void *c) {
	::btSoftBody::Joint::Specs *o = (::btSoftBody::Joint::Specs*)c;
	return (float)(o->split);
}


// ::btSoftBody::LJoint::Specs
//constructor: Specs  ( ::btSoftBody::LJoint::Specs::* )(  ) 
void* btSoftBody_LJoint_Specs_new() {
	::btSoftBody::LJoint::Specs *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::LJoint::Specs),16);
	o = new (mem)::btSoftBody::LJoint::Specs();
	return (void*)o;
}
void btSoftBody_LJoint_Specs_free(void *c) {
	::btSoftBody::LJoint::Specs *o = (::btSoftBody::LJoint::Specs*)c;
	delete o;
}
//attribute: ::btVector3 btSoftBody_LJoint_Specs->position
void btSoftBody_LJoint_Specs_position_set(void *c,float* a) {
	::btSoftBody::LJoint::Specs *o = (::btSoftBody::LJoint::Specs*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->position = ta;
}
void btSoftBody_LJoint_Specs_position_get(void *c,float* a) {
	::btSoftBody::LJoint::Specs *o = (::btSoftBody::LJoint::Specs*)c;
	a[0]=(o->position).m_floats[0];a[1]=(o->position).m_floats[1];a[2]=(o->position).m_floats[2];
}


// ::btSoftBody::AJoint::Specs
//constructor: Specs  ( ::btSoftBody::AJoint::Specs::* )(  ) 
void* btSoftBody_AJoint_Specs_new() {
	::btSoftBody::AJoint::Specs *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::AJoint::Specs),16);
	o = new (mem)::btSoftBody::AJoint::Specs();
	return (void*)o;
}
void btSoftBody_AJoint_Specs_free(void *c) {
	::btSoftBody::AJoint::Specs *o = (::btSoftBody::AJoint::Specs*)c;
	delete o;
}
//attribute: ::btVector3 btSoftBody_AJoint_Specs->axis
void btSoftBody_AJoint_Specs_axis_set(void *c,float* a) {
	::btSoftBody::AJoint::Specs *o = (::btSoftBody::AJoint::Specs*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->axis = ta;
}
void btSoftBody_AJoint_Specs_axis_get(void *c,float* a) {
	::btSoftBody::AJoint::Specs *o = (::btSoftBody::AJoint::Specs*)c;
	a[0]=(o->axis).m_floats[0];a[1]=(o->axis).m_floats[1];a[2]=(o->axis).m_floats[2];
}

//attribute: ::btSoftBody::AJoint::IControl * btSoftBody_AJoint_Specs->icontrol
void btSoftBody_AJoint_Specs_icontrol_set(void *c,void* a) {
	::btSoftBody::AJoint::Specs *o = (::btSoftBody::AJoint::Specs*)c;
	::btSoftBody::AJoint::IControl * ta = (::btSoftBody::AJoint::IControl *)a;
	o->icontrol = ta;
}
void* btSoftBody_AJoint_Specs_icontrol_get(void *c) {
	::btSoftBody::AJoint::Specs *o = (::btSoftBody::AJoint::Specs*)c;
	return (void*)(o->icontrol);
}


// ::btSoftBody::Tetra
//constructor: Tetra  ( ::btSoftBody::Tetra::* )(  ) 
void* btSoftBody_Tetra_new() {
	::btSoftBody::Tetra *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Tetra),16);
	o = new (mem)::btSoftBody::Tetra();
	return (void*)o;
}
void btSoftBody_Tetra_free(void *c) {
	::btSoftBody::Tetra *o = (::btSoftBody::Tetra*)c;
	delete o;
}
//attribute: ::btSoftBody::Node *[4] btSoftBody_Tetra->m_n
// attribute not supported: //attribute: ::btSoftBody::Node *[4] btSoftBody_Tetra->m_n
//attribute: ::btScalar btSoftBody_Tetra->m_rv
void btSoftBody_Tetra_m_rv_set(void *c,float a) {
	::btSoftBody::Tetra *o = (::btSoftBody::Tetra*)c;
	o->m_rv = a;
}
float btSoftBody_Tetra_m_rv_get(void *c) {
	::btSoftBody::Tetra *o = (::btSoftBody::Tetra*)c;
	return (float)(o->m_rv);
}

//attribute: ::btDbvtNode * btSoftBody_Tetra->m_leaf
void btSoftBody_Tetra_m_leaf_set(void *c,void* a) {
	::btSoftBody::Tetra *o = (::btSoftBody::Tetra*)c;
	::btDbvtNode * ta = (::btDbvtNode *)a;
	o->m_leaf = ta;
}
void* btSoftBody_Tetra_m_leaf_get(void *c) {
	::btSoftBody::Tetra *o = (::btSoftBody::Tetra*)c;
	return (void*)(o->m_leaf);
}

//attribute: ::btVector3[4] btSoftBody_Tetra->m_c0
// attribute not supported: //attribute: ::btVector3[4] btSoftBody_Tetra->m_c0
//attribute: ::btScalar btSoftBody_Tetra->m_c1
void btSoftBody_Tetra_m_c1_set(void *c,float a) {
	::btSoftBody::Tetra *o = (::btSoftBody::Tetra*)c;
	o->m_c1 = a;
}
float btSoftBody_Tetra_m_c1_get(void *c) {
	::btSoftBody::Tetra *o = (::btSoftBody::Tetra*)c;
	return (float)(o->m_c1);
}

//attribute: ::btScalar btSoftBody_Tetra->m_c2
void btSoftBody_Tetra_m_c2_set(void *c,float a) {
	::btSoftBody::Tetra *o = (::btSoftBody::Tetra*)c;
	o->m_c2 = a;
}
float btSoftBody_Tetra_m_c2_get(void *c) {
	::btSoftBody::Tetra *o = (::btSoftBody::Tetra*)c;
	return (float)(o->m_c2);
}


// ::btSoftBody
//not supported constructor: btSoftBody  ( ::btSoftBody::* )( ::btSoftBodyWorldInfo *,int,::btVector3 const *,::btScalar const * ) 
// error: ::btSoftBodyWorldInfo * - ok, int - ok,  - unsupported,  - unsupported

//constructor: btSoftBody  ( ::btSoftBody::* )( ::btSoftBodyWorldInfo * ) 
void* btSoftBody_new1(void* p0) {
	::btSoftBody *o = 0;
	 void *mem = 0;
	::btSoftBodyWorldInfo * tp0 = (::btSoftBodyWorldInfo *)p0;
	mem = btAlignedAlloc(sizeof(::btSoftBody),16);
	o = new (mem)::btSoftBody(tp0);
	return (void*)o;
}
void btSoftBody_free(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	delete o;
}
//method: getVolume ::btScalar ( ::btSoftBody::* )(  ) const
float btSoftBody_getVolume(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	float retVal = (float)o->getVolume();
	return retVal;
}
//method: cutLink bool ( ::btSoftBody::* )( int,int,::btScalar ) 
int btSoftBody_cutLink(void *c,int p0,int p1,float p2) {
	::btSoftBody *o = (::btSoftBody*)c;
	int retVal = (int)o->cutLink(p0,p1,p2);
	return retVal;
}
//method: cutLink bool ( ::btSoftBody::* )( int,int,::btScalar ) 
int btSoftBody_cutLink0(void *c,int p0,int p1,float p2) {
	::btSoftBody *o = (::btSoftBody*)c;
	int retVal = (int)o->cutLink(p0,p1,p2);
	return retVal;
}
//method: cutLink bool ( ::btSoftBody::* )( ::btSoftBody::Node const *,::btSoftBody::Node const *,::btScalar ) 
int btSoftBody_cutLink1(void *c,void* p0,void* p1,float p2) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::Node const * tp0 = (::btSoftBody::Node const *)p0;
	::btSoftBody::Node const * tp1 = (::btSoftBody::Node const *)p1;
	int retVal = (int)o->cutLink(tp0,tp1,p2);
	return retVal;
}
//method: PSolve_Links void (*)( ::btSoftBody *,::btScalar,::btScalar )
void btSoftBody_PSolve_Links(void* p0,float p1,float p2) {
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	::btSoftBody::PSolve_Links(tp0,p1,p2);
}
//method: generateClusters int ( ::btSoftBody::* )( int,int ) 
int btSoftBody_generateClusters(void *c,int p0,int p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	int retVal = (int)o->generateClusters(p0,p1);
	return retVal;
}
//method: setCollisionShape void ( ::btSoftBody::* )( ::btCollisionShape * ) 
void btSoftBody_setCollisionShape(void *c,void* p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btCollisionShape * tp0 = (::btCollisionShape *)p0;
	o->setCollisionShape(tp0);
}
//method: initializeClusters void ( ::btSoftBody::* )(  ) 
void btSoftBody_initializeClusters(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->initializeClusters();
}
//method: clusterVAImpulse void (*)( ::btSoftBody::Cluster *,::btVector3 const & )
void btSoftBody_clusterVAImpulse(void* p0,float* p1) {
	::btSoftBody::Cluster * tp0 = (::btSoftBody::Cluster *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btSoftBody::clusterVAImpulse(tp0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: addForce void ( ::btSoftBody::* )( ::btVector3 const & ) 
void btSoftBody_addForce(void *c,float* p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->addForce(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: addForce void ( ::btSoftBody::* )( ::btVector3 const & ) 
void btSoftBody_addForce0(void *c,float* p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->addForce(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: addForce void ( ::btSoftBody::* )( ::btVector3 const &,int ) 
void btSoftBody_addForce1(void *c,float* p0,int p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->addForce(tp0,p1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: serialize char const * ( ::btSoftBody::* )( void *,::btSerializer * ) const
char const * btSoftBody_serialize(void *c,void* p0,void* p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: updateBounds void ( ::btSoftBody::* )(  ) 
void btSoftBody_updateBounds(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->updateBounds();
}
//method: rotate void ( ::btSoftBody::* )( ::btQuaternion const & ) 
void btSoftBody_rotate(void *c,float* p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	btQuaternion tp0(p0[0],p0[1],p0[2],p0[3]);
	o->rotate(tp0);
	p0[0]=tp0.getX();p0[1]=tp0.getY();p0[2]=tp0.getZ();p0[3]=tp0.getW();
}
//method: releaseCluster void ( ::btSoftBody::* )( int ) 
void btSoftBody_releaseCluster(void *c,int p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->releaseCluster(p0);
}
//method: updateNormals void ( ::btSoftBody::* )(  ) 
void btSoftBody_updateNormals(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->updateNormals();
}
//method: prepareClusters void ( ::btSoftBody::* )( int ) 
void btSoftBody_prepareClusters(void *c,int p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->prepareClusters(p0);
}
//method: releaseClusters void ( ::btSoftBody::* )(  ) 
void btSoftBody_releaseClusters(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->releaseClusters();
}
//method: getTotalMass ::btScalar ( ::btSoftBody::* )(  ) const
float btSoftBody_getTotalMass(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	float retVal = (float)o->getTotalMass();
	return retVal;
}
//method: checkContact bool ( ::btSoftBody::* )( ::btCollisionObject *,::btVector3 const &,::btScalar,::btSoftBody::sCti & ) const
int btSoftBody_checkContact(void *c,void* p0,float* p1,float p2,void* p3) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btSoftBody::sCti & tp3 = *(::btSoftBody::sCti *)p3;
	int retVal = (int)o->checkContact(tp0,tp1,p2,tp3);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//not supported method: indicesToPointers void ( ::btSoftBody::* )( int const * ) 
// error:  - unsupported, void - ok

//method: clusterDImpulse void (*)( ::btSoftBody::Cluster *,::btVector3 const &,::btVector3 const & )
void btSoftBody_clusterDImpulse(void* p0,float* p1,float* p2) {
	::btSoftBody::Cluster * tp0 = (::btSoftBody::Cluster *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	::btSoftBody::clusterDImpulse(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: initDefaults void ( ::btSoftBody::* )(  ) 
void btSoftBody_initDefaults(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->initDefaults();
}
//method: checkLink bool ( ::btSoftBody::* )( int,int ) const
int btSoftBody_checkLink(void *c,int p0,int p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	int retVal = (int)o->checkLink(p0,p1);
	return retVal;
}
//method: checkLink bool ( ::btSoftBody::* )( int,int ) const
int btSoftBody_checkLink0(void *c,int p0,int p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	int retVal = (int)o->checkLink(p0,p1);
	return retVal;
}
//method: checkLink bool ( ::btSoftBody::* )( ::btSoftBody::Node const *,::btSoftBody::Node const * ) const
int btSoftBody_checkLink1(void *c,void* p0,void* p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::Node const * tp0 = (::btSoftBody::Node const *)p0;
	::btSoftBody::Node const * tp1 = (::btSoftBody::Node const *)p1;
	int retVal = (int)o->checkLink(tp0,tp1);
	return retVal;
}
//method: setVolumeMass void ( ::btSoftBody::* )( ::btScalar ) 
void btSoftBody_setVolumeMass(void *c,float p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->setVolumeMass(p0);
}
//method: clusterImpulse void (*)( ::btSoftBody::Cluster *,::btVector3 const &,::btSoftBody::Impulse const & )
void btSoftBody_clusterImpulse(void* p0,float* p1,void* p2) {
	::btSoftBody::Cluster * tp0 = (::btSoftBody::Cluster *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btSoftBody::Impulse const & tp2 = *(::btSoftBody::Impulse const *)p2;
	::btSoftBody::clusterImpulse(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: checkFace bool ( ::btSoftBody::* )( int,int,int ) const
int btSoftBody_checkFace(void *c,int p0,int p1,int p2) {
	::btSoftBody *o = (::btSoftBody*)c;
	int retVal = (int)o->checkFace(p0,p1,p2);
	return retVal;
}
//method: evaluateCom ::btVector3 ( ::btSoftBody::* )(  ) const
void btSoftBody_evaluateCom(void *c,float* ret) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->evaluateCom();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: clusterDAImpulse void (*)( ::btSoftBody::Cluster *,::btVector3 const & )
void btSoftBody_clusterDAImpulse(void* p0,float* p1) {
	::btSoftBody::Cluster * tp0 = (::btSoftBody::Cluster *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btSoftBody::clusterDAImpulse(tp0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: VSolve_Links void (*)( ::btSoftBody *,::btScalar )
void btSoftBody_VSolve_Links(void* p0,float p1) {
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	::btSoftBody::VSolve_Links(tp0,p1);
}
//method: setTotalMass void ( ::btSoftBody::* )( ::btScalar,bool ) 
void btSoftBody_setTotalMass(void *c,float p0,int p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->setTotalMass(p0,p1);
}
//method: clusterDCImpulse void (*)( ::btSoftBody::Cluster *,::btVector3 const & )
void btSoftBody_clusterDCImpulse(void* p0,float* p1) {
	::btSoftBody::Cluster * tp0 = (::btSoftBody::Cluster *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btSoftBody::clusterDCImpulse(tp0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: clusterVelocity ::btVector3 (*)( ::btSoftBody::Cluster const *,::btVector3 const & )
void btSoftBody_clusterVelocity(void* p0,float* p1,float* ret) {
	::btSoftBody::Cluster const * tp0 = (::btSoftBody::Cluster const *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = ::btSoftBody::clusterVelocity(tp0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: generateBendingConstraints int ( ::btSoftBody::* )( int,::btSoftBody::Material * ) 
int btSoftBody_generateBendingConstraints(void *c,int p0,void* p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::Material * tp1 = (::btSoftBody::Material *)p1;
	int retVal = (int)o->generateBendingConstraints(p0,tp1);
	return retVal;
}
//method: updateClusters void ( ::btSoftBody::* )(  ) 
void btSoftBody_updateClusters(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->updateClusters();
}
//method: appendAnchor void ( ::btSoftBody::* )( int,::btRigidBody *,bool,::btScalar ) 
void btSoftBody_appendAnchor(void *c,int p0,void* p1,int p2,float p3) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btRigidBody * tp1 = (::btRigidBody *)p1;
	o->appendAnchor(p0,tp1,p2,p3);
}
//method: appendAnchor void ( ::btSoftBody::* )( int,::btRigidBody *,bool,::btScalar ) 
void btSoftBody_appendAnchor0(void *c,int p0,void* p1,int p2,float p3) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btRigidBody * tp1 = (::btRigidBody *)p1;
	o->appendAnchor(p0,tp1,p2,p3);
}
//method: appendAnchor void ( ::btSoftBody::* )( int,::btRigidBody *,::btVector3 const &,bool,::btScalar ) 
void btSoftBody_appendAnchor1(void *c,int p0,void* p1,float* p2,int p3,float p4) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btRigidBody * tp1 = (::btRigidBody *)p1;
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->appendAnchor(p0,tp1,tp2,p3,p4);
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: applyClusters void ( ::btSoftBody::* )( bool ) 
void btSoftBody_applyClusters(void *c,int p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->applyClusters(p0);
}
//method: setVelocity void ( ::btSoftBody::* )( ::btVector3 const & ) 
void btSoftBody_setVelocity(void *c,float* p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setVelocity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: clusterCount int ( ::btSoftBody::* )(  ) const
int btSoftBody_clusterCount(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	int retVal = (int)o->clusterCount();
	return retVal;
}
//method: upcast ::btSoftBody const * (*)( ::btCollisionObject const * )
void* btSoftBody_upcast(void* p0) {
	::btCollisionObject const * tp0 = (::btCollisionObject const *)p0;
	void* retVal = (void*) ::btSoftBody::upcast(tp0);
	return retVal;
}
//method: upcast ::btSoftBody const * (*)( ::btCollisionObject const * )
void* btSoftBody_upcast0(void* p0) {
	::btCollisionObject const * tp0 = (::btCollisionObject const *)p0;
	void* retVal = (void*) ::btSoftBody::upcast(tp0);
	return retVal;
}
//method: upcast ::btSoftBody * (*)( ::btCollisionObject * )
void* btSoftBody_upcast1(void* p0) {
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	void* retVal = (void*) ::btSoftBody::upcast(tp0);
	return retVal;
}
//method: getWindVelocity ::btVector3 const & ( ::btSoftBody::* )(  ) 
void btSoftBody_getWindVelocity(void *c,float* ret) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getWindVelocity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: predictMotion void ( ::btSoftBody::* )( ::btScalar ) 
void btSoftBody_predictMotion(void *c,float p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->predictMotion(p0);
}
//method: pointersToIndices void ( ::btSoftBody::* )(  ) 
void btSoftBody_pointersToIndices(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->pointersToIndices();
}
//method: getMass ::btScalar ( ::btSoftBody::* )( int ) const
float btSoftBody_getMass(void *c,int p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	float retVal = (float)o->getMass(p0);
	return retVal;
}
//method: PSolve_RContacts void (*)( ::btSoftBody *,::btScalar,::btScalar )
void btSoftBody_PSolve_RContacts(void* p0,float p1,float p2) {
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	::btSoftBody::PSolve_RContacts(tp0,p1,p2);
}
//method: initializeFaceTree void ( ::btSoftBody::* )(  ) 
void btSoftBody_initializeFaceTree(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->initializeFaceTree();
}
//method: addVelocity void ( ::btSoftBody::* )( ::btVector3 const & ) 
void btSoftBody_addVelocity(void *c,float* p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->addVelocity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: addVelocity void ( ::btSoftBody::* )( ::btVector3 const & ) 
void btSoftBody_addVelocity0(void *c,float* p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->addVelocity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: addVelocity void ( ::btSoftBody::* )( ::btVector3 const &,int ) 
void btSoftBody_addVelocity1(void *c,float* p0,int p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->addVelocity(tp0,p1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: PSolve_Anchors void (*)( ::btSoftBody *,::btScalar,::btScalar )
void btSoftBody_PSolve_Anchors(void* p0,float p1,float p2) {
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	::btSoftBody::PSolve_Anchors(tp0,p1,p2);
}
//method: cleanupClusters void ( ::btSoftBody::* )(  ) 
void btSoftBody_cleanupClusters(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->cleanupClusters();
}
//method: transform void ( ::btSoftBody::* )( ::btTransform const & ) 
void btSoftBody_transform(void *c,float* p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	o->transform(tp0);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//not supported method: appendLinearJoint void ( ::btSoftBody::* )( ::btSoftBody::LJoint::Specs const &,::btSoftBody::Cluster *,::btSoftBody::Body ) 
// error: ::btSoftBody::LJoint::Specs const & - ok, ::btSoftBody::Cluster * - ok,  - unsupported, void - ok

//not supported method: appendLinearJoint void ( ::btSoftBody::* )( ::btSoftBody::LJoint::Specs const &,::btSoftBody::Cluster *,::btSoftBody::Body ) 
// error: ::btSoftBody::LJoint::Specs const & - ok, ::btSoftBody::Cluster * - ok,  - unsupported, void - ok

//not supported method: appendLinearJoint void ( ::btSoftBody::* )( ::btSoftBody::LJoint::Specs const &,::btSoftBody::Body ) 
// error: ::btSoftBody::LJoint::Specs const & - ok,  - unsupported, void - ok

//method: appendLinearJoint void ( ::btSoftBody::* )( ::btSoftBody::LJoint::Specs const &,::btSoftBody * ) 
void btSoftBody_appendLinearJoint2(void *c,void* p0,void* p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::LJoint::Specs const & tp0 = *(::btSoftBody::LJoint::Specs const *)p0;
	::btSoftBody * tp1 = (::btSoftBody *)p1;
	o->appendLinearJoint(tp0,tp1);
}
//method: randomizeConstraints void ( ::btSoftBody::* )(  ) 
void btSoftBody_randomizeConstraints(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->randomizeConstraints();
}
//method: updatePose void ( ::btSoftBody::* )(  ) 
void btSoftBody_updatePose(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->updatePose();
}
//method: translate void ( ::btSoftBody::* )( ::btVector3 const & ) 
void btSoftBody_translate(void *c,float* p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->translate(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getAabb void ( ::btSoftBody::* )( ::btVector3 &,::btVector3 & ) const
void btSoftBody_getAabb(void *c,float* p0,float* p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getAabb(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: PSolve_SContacts void (*)( ::btSoftBody *,::btScalar,::btScalar )
void btSoftBody_PSolve_SContacts(void* p0,float p1,float p2) {
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	::btSoftBody::PSolve_SContacts(tp0,p1,p2);
}
//method: appendMaterial ::btSoftBody::Material * ( ::btSoftBody::* )(  ) 
void* btSoftBody_appendMaterial(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	void* retVal = (void*) o->appendMaterial();
	return retVal;
}
//method: appendNode void ( ::btSoftBody::* )( ::btVector3 const &,::btScalar ) 
void btSoftBody_appendNode(void *c,float* p0,float p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->appendNode(tp0,p1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: setMass void ( ::btSoftBody::* )( int,::btScalar ) 
void btSoftBody_setMass(void *c,int p0,float p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->setMass(p0,p1);
}
//method: integrateMotion void ( ::btSoftBody::* )(  ) 
void btSoftBody_integrateMotion(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->integrateMotion();
}
//method: defaultCollisionHandler void ( ::btSoftBody::* )( ::btCollisionObject * ) 
void btSoftBody_defaultCollisionHandler(void *c,void* p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	o->defaultCollisionHandler(tp0);
}
//method: defaultCollisionHandler void ( ::btSoftBody::* )( ::btCollisionObject * ) 
void btSoftBody_defaultCollisionHandler0(void *c,void* p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	o->defaultCollisionHandler(tp0);
}
//method: defaultCollisionHandler void ( ::btSoftBody::* )( ::btSoftBody * ) 
void btSoftBody_defaultCollisionHandler1(void *c,void* p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	o->defaultCollisionHandler(tp0);
}
//method: solveConstraints void ( ::btSoftBody::* )(  ) 
void btSoftBody_solveConstraints(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->solveConstraints();
}
//method: setTotalDensity void ( ::btSoftBody::* )( ::btScalar ) 
void btSoftBody_setTotalDensity(void *c,float p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->setTotalDensity(p0);
}
//method: appendNote void ( ::btSoftBody::* )( char const *,::btVector3 const &,::btVector4 const &,::btSoftBody::Node *,::btSoftBody::Node *,::btSoftBody::Node *,::btSoftBody::Node * ) 
void btSoftBody_appendNote(void *c,char const * p0,float* p1,float* p2,void* p3,void* p4,void* p5,void* p6) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector4 tp2(p2[0],p2[1],p2[2],p2[3]);
	::btSoftBody::Node * tp3 = (::btSoftBody::Node *)p3;
	::btSoftBody::Node * tp4 = (::btSoftBody::Node *)p4;
	::btSoftBody::Node * tp5 = (::btSoftBody::Node *)p5;
	::btSoftBody::Node * tp6 = (::btSoftBody::Node *)p6;
	o->appendNote(p0,tp1,tp2,tp3,tp4,tp5,tp6);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.getX();p2[1]=tp2.getY();p2[2]=tp2.getZ();p2[3]=tp2.getW();
}
//method: appendNote void ( ::btSoftBody::* )( char const *,::btVector3 const &,::btVector4 const &,::btSoftBody::Node *,::btSoftBody::Node *,::btSoftBody::Node *,::btSoftBody::Node * ) 
void btSoftBody_appendNote0(void *c,char const * p0,float* p1,float* p2,void* p3,void* p4,void* p5,void* p6) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector4 tp2(p2[0],p2[1],p2[2],p2[3]);
	::btSoftBody::Node * tp3 = (::btSoftBody::Node *)p3;
	::btSoftBody::Node * tp4 = (::btSoftBody::Node *)p4;
	::btSoftBody::Node * tp5 = (::btSoftBody::Node *)p5;
	::btSoftBody::Node * tp6 = (::btSoftBody::Node *)p6;
	o->appendNote(p0,tp1,tp2,tp3,tp4,tp5,tp6);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.getX();p2[1]=tp2.getY();p2[2]=tp2.getZ();p2[3]=tp2.getW();
}
//method: appendNote void ( ::btSoftBody::* )( char const *,::btVector3 const &,::btSoftBody::Node * ) 
void btSoftBody_appendNote1(void *c,char const * p0,float* p1,void* p2) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btSoftBody::Node * tp2 = (::btSoftBody::Node *)p2;
	o->appendNote(p0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: appendNote void ( ::btSoftBody::* )( char const *,::btVector3 const &,::btSoftBody::Link * ) 
void btSoftBody_appendNote2(void *c,char const * p0,float* p1,void* p2) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btSoftBody::Link * tp2 = (::btSoftBody::Link *)p2;
	o->appendNote(p0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: appendNote void ( ::btSoftBody::* )( char const *,::btVector3 const &,::btSoftBody::Face * ) 
void btSoftBody_appendNote3(void *c,char const * p0,float* p1,void* p2) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btSoftBody::Face * tp2 = (::btSoftBody::Face *)p2;
	o->appendNote(p0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: setVolumeDensity void ( ::btSoftBody::* )( ::btScalar ) 
void btSoftBody_setVolumeDensity(void *c,float p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->setVolumeDensity(p0);
}
//not supported method: solveCommonConstraints void (*)( ::btSoftBody * *,int,int )
// error:  - unsupported, int - ok, int - ok, void - ok

//method: updateConstants void ( ::btSoftBody::* )(  ) 
void btSoftBody_updateConstants(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->updateConstants();
}
//method: staticSolve void ( ::btSoftBody::* )( int ) 
void btSoftBody_staticSolve(void *c,int p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->staticSolve(p0);
}
//not supported method: getSoftBodySolver ::btSoftBodySolver * ( ::btSoftBody::* )(  ) 
// error:  - unsupported

//not supported method: getSoftBodySolver ::btSoftBodySolver * ( ::btSoftBody::* )(  ) 
// error:  - unsupported

//not supported method: getSoftBodySolver ::btSoftBodySolver * ( ::btSoftBody::* )(  ) const
// error:  - unsupported

//method: refine void ( ::btSoftBody::* )( ::btSoftBody::ImplicitFn *,::btScalar,bool ) 
void btSoftBody_refine(void *c,void* p0,float p1,int p2) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::ImplicitFn * tp0 = (::btSoftBody::ImplicitFn *)p0;
	o->refine(tp0,p1,p2);
}
//method: appendLink void ( ::btSoftBody::* )( int,::btSoftBody::Material * ) 
void btSoftBody_appendLink(void *c,int p0,void* p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::Material * tp1 = (::btSoftBody::Material *)p1;
	o->appendLink(p0,tp1);
}
//method: appendLink void ( ::btSoftBody::* )( int,::btSoftBody::Material * ) 
void btSoftBody_appendLink0(void *c,int p0,void* p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::Material * tp1 = (::btSoftBody::Material *)p1;
	o->appendLink(p0,tp1);
}
//method: appendLink void ( ::btSoftBody::* )( int,int,::btSoftBody::Material *,bool ) 
void btSoftBody_appendLink1(void *c,int p0,int p1,void* p2,int p3) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::Material * tp2 = (::btSoftBody::Material *)p2;
	o->appendLink(p0,p1,tp2,p3);
}
//method: appendLink void ( ::btSoftBody::* )( ::btSoftBody::Node *,::btSoftBody::Node *,::btSoftBody::Material *,bool ) 
void btSoftBody_appendLink2(void *c,void* p0,void* p1,void* p2,int p3) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::Node * tp0 = (::btSoftBody::Node *)p0;
	::btSoftBody::Node * tp1 = (::btSoftBody::Node *)p1;
	::btSoftBody::Material * tp2 = (::btSoftBody::Material *)p2;
	o->appendLink(tp0,tp1,tp2,p3);
}
//method: calculateSerializeBufferSize int ( ::btSoftBody::* )(  ) const
int btSoftBody_calculateSerializeBufferSize(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: solveClusters void (*)( ::btAlignedObjectArray<btSoftBody*> const & )
void btSoftBody_solveClusters(void* p0) {
	::btAlignedObjectArray<btSoftBody*> const & tp0 = *(::btAlignedObjectArray<btSoftBody*> const *)p0;
	::btSoftBody::solveClusters(tp0);
}
//method: solveClusters void (*)( ::btAlignedObjectArray<btSoftBody*> const & )
void btSoftBody_solveClusters0(void* p0) {
	::btAlignedObjectArray<btSoftBody*> const & tp0 = *(::btAlignedObjectArray<btSoftBody*> const *)p0;
	::btSoftBody::solveClusters(tp0);
}
//method: solveClusters void ( ::btSoftBody::* )( ::btScalar ) 
void btSoftBody_solveClusters1(void *c,float p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->solveClusters(p0);
}
//method: rayTest bool ( ::btSoftBody::* )( ::btVector3 const &,::btVector3 const &,::btSoftBody::sRayCast & ) 
int btSoftBody_rayTest(void *c,float* p0,float* p1,void* p2) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btSoftBody::sRayCast & tp2 = *(::btSoftBody::sRayCast *)p2;
	int retVal = (int)o->rayTest(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//method: rayTest bool ( ::btSoftBody::* )( ::btVector3 const &,::btVector3 const &,::btSoftBody::sRayCast & ) 
int btSoftBody_rayTest0(void *c,float* p0,float* p1,void* p2) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btSoftBody::sRayCast & tp2 = *(::btSoftBody::sRayCast *)p2;
	int retVal = (int)o->rayTest(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//not supported method: rayTest int ( ::btSoftBody::* )( ::btVector3 const &,::btVector3 const &,::btScalar &,::btSoftBody::eFeature::_ &,int &,bool ) const
// error: ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported,  - unsupported,  - unsupported, bool - ok, int - ok

//method: setPose void ( ::btSoftBody::* )( bool,bool ) 
void btSoftBody_setPose(void *c,int p0,int p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->setPose(p0,p1);
}
//method: appendFace void ( ::btSoftBody::* )( int,::btSoftBody::Material * ) 
void btSoftBody_appendFace(void *c,int p0,void* p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::Material * tp1 = (::btSoftBody::Material *)p1;
	o->appendFace(p0,tp1);
}
//method: appendFace void ( ::btSoftBody::* )( int,::btSoftBody::Material * ) 
void btSoftBody_appendFace0(void *c,int p0,void* p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::Material * tp1 = (::btSoftBody::Material *)p1;
	o->appendFace(p0,tp1);
}
//method: appendFace void ( ::btSoftBody::* )( int,int,int,::btSoftBody::Material * ) 
void btSoftBody_appendFace1(void *c,int p0,int p1,int p2,void* p3) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::Material * tp3 = (::btSoftBody::Material *)p3;
	o->appendFace(p0,p1,p2,tp3);
}
//method: dampClusters void ( ::btSoftBody::* )(  ) 
void btSoftBody_dampClusters(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->dampClusters();
}
//method: getWorldInfo ::btSoftBodyWorldInfo * ( ::btSoftBody::* )(  ) 
void* btSoftBody_getWorldInfo(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	void* retVal = (void*) o->getWorldInfo();
	return retVal;
}
//not supported method: appendAngularJoint void ( ::btSoftBody::* )( ::btSoftBody::AJoint::Specs const &,::btSoftBody::Cluster *,::btSoftBody::Body ) 
// error: ::btSoftBody::AJoint::Specs const & - ok, ::btSoftBody::Cluster * - ok,  - unsupported, void - ok

//not supported method: appendAngularJoint void ( ::btSoftBody::* )( ::btSoftBody::AJoint::Specs const &,::btSoftBody::Cluster *,::btSoftBody::Body ) 
// error: ::btSoftBody::AJoint::Specs const & - ok, ::btSoftBody::Cluster * - ok,  - unsupported, void - ok

//not supported method: appendAngularJoint void ( ::btSoftBody::* )( ::btSoftBody::AJoint::Specs const &,::btSoftBody::Body ) 
// error: ::btSoftBody::AJoint::Specs const & - ok,  - unsupported, void - ok

//method: appendAngularJoint void ( ::btSoftBody::* )( ::btSoftBody::AJoint::Specs const &,::btSoftBody * ) 
void btSoftBody_appendAngularJoint2(void *c,void* p0,void* p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::AJoint::Specs const & tp0 = *(::btSoftBody::AJoint::Specs const *)p0;
	::btSoftBody * tp1 = (::btSoftBody *)p1;
	o->appendAngularJoint(tp0,tp1);
}
//not supported method: setSolver void ( ::btSoftBody::* )( ::btSoftBody::eSolverPresets::_ ) 
// error:  - unsupported, void - ok

//method: clusterVImpulse void (*)( ::btSoftBody::Cluster *,::btVector3 const &,::btVector3 const & )
void btSoftBody_clusterVImpulse(void* p0,float* p1,float* p2) {
	::btSoftBody::Cluster * tp0 = (::btSoftBody::Cluster *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	::btSoftBody::clusterVImpulse(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: scale void ( ::btSoftBody::* )( ::btVector3 const & ) 
void btSoftBody_scale(void *c,float* p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->scale(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: clusterAImpulse void (*)( ::btSoftBody::Cluster *,::btSoftBody::Impulse const & )
void btSoftBody_clusterAImpulse(void* p0,void* p1) {
	::btSoftBody::Cluster * tp0 = (::btSoftBody::Cluster *)p0;
	::btSoftBody::Impulse const & tp1 = *(::btSoftBody::Impulse const *)p1;
	::btSoftBody::clusterAImpulse(tp0,tp1);
}
//method: clusterCom ::btVector3 (*)( ::btSoftBody::Cluster const * )
void btSoftBody_clusterCom(void* p0,float* ret) {
	::btSoftBody::Cluster const * tp0 = (::btSoftBody::Cluster const *)p0;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = ::btSoftBody::clusterCom(tp0);
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: clusterCom ::btVector3 (*)( ::btSoftBody::Cluster const * )
void btSoftBody_clusterCom0(void* p0,float* ret) {
	::btSoftBody::Cluster const * tp0 = (::btSoftBody::Cluster const *)p0;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = ::btSoftBody::clusterCom(tp0);
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: clusterCom ::btVector3 ( ::btSoftBody::* )( int ) const
void btSoftBody_clusterCom1(void *c,int p0,float* ret) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->clusterCom(p0);
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//not supported method: setSoftBodySolver void ( ::btSoftBody::* )( ::btSoftBodySolver * ) 
// error:  - unsupported, void - ok

//method: setWindVelocity void ( ::btSoftBody::* )( ::btVector3 const & ) 
void btSoftBody_setWindVelocity(void *c,float* p0) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setWindVelocity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//not supported method: getSolver void (*)( ::btSoftBody *,::btScalar,::btScalar ) * (*)( ::btSoftBody::ePSolver::_ )
// error:  - unsupported,  - unsupported

//not supported method: getSolver void (*)( ::btSoftBody *,::btScalar,::btScalar ) * (*)( ::btSoftBody::ePSolver::_ )
// error:  - unsupported,  - unsupported

//not supported method: getSolver void (*)( ::btSoftBody *,::btScalar ) * (*)( ::btSoftBody::eVSolver::_ )
// error:  - unsupported,  - unsupported

//method: applyForces void ( ::btSoftBody::* )(  ) 
void btSoftBody_applyForces(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->applyForces();
}
//method: appendTetra void ( ::btSoftBody::* )( int,::btSoftBody::Material * ) 
void btSoftBody_appendTetra(void *c,int p0,void* p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::Material * tp1 = (::btSoftBody::Material *)p1;
	o->appendTetra(p0,tp1);
}
//method: appendTetra void ( ::btSoftBody::* )( int,::btSoftBody::Material * ) 
void btSoftBody_appendTetra0(void *c,int p0,void* p1) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::Material * tp1 = (::btSoftBody::Material *)p1;
	o->appendTetra(p0,tp1);
}
//method: appendTetra void ( ::btSoftBody::* )( int,int,int,int,::btSoftBody::Material * ) 
void btSoftBody_appendTetra1(void *c,int p0,int p1,int p2,int p3,void* p4) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::Material * tp4 = (::btSoftBody::Material *)p4;
	o->appendTetra(p0,p1,p2,p3,tp4);
}
//attribute: ::btAlignedObjectArray<btSoftBody::Anchor> btSoftBody->m_anchors
void btSoftBody_m_anchors_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btAlignedObjectArray<btSoftBody::Anchor> & ta = *(::btAlignedObjectArray<btSoftBody::Anchor> *)a;
	o->m_anchors = ta;
}
void* btSoftBody_m_anchors_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_anchors);
}

//attribute: bool btSoftBody->m_bUpdateRtCst
void btSoftBody_m_bUpdateRtCst_set(void *c,int a) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->m_bUpdateRtCst = a;
}
int btSoftBody_m_bUpdateRtCst_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (int)(o->m_bUpdateRtCst);
}

//attribute: ::btVector3[2] btSoftBody->m_bounds
// attribute not supported: //attribute: ::btVector3[2] btSoftBody->m_bounds
//attribute: ::btDbvt btSoftBody->m_cdbvt
void btSoftBody_m_cdbvt_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btDbvt & ta = *(::btDbvt *)a;
	o->m_cdbvt = ta;
}
void* btSoftBody_m_cdbvt_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_cdbvt);
}

//attribute: ::btSoftBody::Config btSoftBody->m_cfg
void btSoftBody_m_cfg_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::Config & ta = *(::btSoftBody::Config *)a;
	o->m_cfg = ta;
}
void* btSoftBody_m_cfg_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_cfg);
}

//attribute: ::btAlignedObjectArray<bool> btSoftBody->m_clusterConnectivity
void btSoftBody_m_clusterConnectivity_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btAlignedObjectArray<bool> & ta = *(::btAlignedObjectArray<bool> *)a;
	o->m_clusterConnectivity = ta;
}
void* btSoftBody_m_clusterConnectivity_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_clusterConnectivity);
}

//attribute: ::btAlignedObjectArray<btSoftBody::Cluster*> btSoftBody->m_clusters
void btSoftBody_m_clusters_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btAlignedObjectArray<btSoftBody::Cluster*> & ta = *(::btAlignedObjectArray<btSoftBody::Cluster*> *)a;
	o->m_clusters = ta;
}
void* btSoftBody_m_clusters_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_clusters);
}

//attribute: ::btAlignedObjectArray<btCollisionObject*> btSoftBody->m_collisionDisabledObjects
void btSoftBody_m_collisionDisabledObjects_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btAlignedObjectArray<btCollisionObject*> & ta = *(::btAlignedObjectArray<btCollisionObject*> *)a;
	o->m_collisionDisabledObjects = ta;
}
void* btSoftBody_m_collisionDisabledObjects_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_collisionDisabledObjects);
}

//attribute: ::btAlignedObjectArray<btSoftBody::Face> btSoftBody->m_faces
void btSoftBody_m_faces_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btAlignedObjectArray<btSoftBody::Face> & ta = *(::btAlignedObjectArray<btSoftBody::Face> *)a;
	o->m_faces = ta;
}
void* btSoftBody_m_faces_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_faces);
}

//attribute: ::btDbvt btSoftBody->m_fdbvt
void btSoftBody_m_fdbvt_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btDbvt & ta = *(::btDbvt *)a;
	o->m_fdbvt = ta;
}
void* btSoftBody_m_fdbvt_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_fdbvt);
}

//attribute: ::btTransform btSoftBody->m_initialWorldTransform
void btSoftBody_m_initialWorldTransform_set(void *c,float* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_initialWorldTransform = ta;
}
void btSoftBody_m_initialWorldTransform_get(void *c,float* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	a[0]=(o->m_initialWorldTransform).getBasis().getRow(0).m_floats[0];a[1]=(o->m_initialWorldTransform).getBasis().getRow(0).m_floats[1];a[2]=(o->m_initialWorldTransform).getBasis().getRow(0).m_floats[2];a[3]=(o->m_initialWorldTransform).getBasis().getRow(1).m_floats[0];a[4]=(o->m_initialWorldTransform).getBasis().getRow(1).m_floats[1];a[5]=(o->m_initialWorldTransform).getBasis().getRow(1).m_floats[2];a[6]=(o->m_initialWorldTransform).getBasis().getRow(2).m_floats[0];a[7]=(o->m_initialWorldTransform).getBasis().getRow(2).m_floats[1];a[8]=(o->m_initialWorldTransform).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_initialWorldTransform).getOrigin().m_floats[0];a[10]=(o->m_initialWorldTransform).getOrigin().m_floats[1];a[11]=(o->m_initialWorldTransform).getOrigin().m_floats[2];
}

//attribute: ::btAlignedObjectArray<btSoftBody::Joint*> btSoftBody->m_joints
void btSoftBody_m_joints_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btAlignedObjectArray<btSoftBody::Joint*> & ta = *(::btAlignedObjectArray<btSoftBody::Joint*> *)a;
	o->m_joints = ta;
}
void* btSoftBody_m_joints_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_joints);
}

//attribute: ::btAlignedObjectArray<btSoftBody::Link> btSoftBody->m_links
void btSoftBody_m_links_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btAlignedObjectArray<btSoftBody::Link> & ta = *(::btAlignedObjectArray<btSoftBody::Link> *)a;
	o->m_links = ta;
}
void* btSoftBody_m_links_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_links);
}

//attribute: ::btAlignedObjectArray<btSoftBody::Material*> btSoftBody->m_materials
void btSoftBody_m_materials_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btAlignedObjectArray<btSoftBody::Material*> & ta = *(::btAlignedObjectArray<btSoftBody::Material*> *)a;
	o->m_materials = ta;
}
void* btSoftBody_m_materials_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_materials);
}

//attribute: ::btDbvt btSoftBody->m_ndbvt
void btSoftBody_m_ndbvt_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btDbvt & ta = *(::btDbvt *)a;
	o->m_ndbvt = ta;
}
void* btSoftBody_m_ndbvt_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_ndbvt);
}

//attribute: ::btAlignedObjectArray<btSoftBody::Node> btSoftBody->m_nodes
void btSoftBody_m_nodes_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btAlignedObjectArray<btSoftBody::Node> & ta = *(::btAlignedObjectArray<btSoftBody::Node> *)a;
	o->m_nodes = ta;
}
void* btSoftBody_m_nodes_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_nodes);
}

//attribute: ::btAlignedObjectArray<btSoftBody::Note> btSoftBody->m_notes
void btSoftBody_m_notes_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btAlignedObjectArray<btSoftBody::Note> & ta = *(::btAlignedObjectArray<btSoftBody::Note> *)a;
	o->m_notes = ta;
}
void* btSoftBody_m_notes_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_notes);
}

//attribute: ::btSoftBody::Pose btSoftBody->m_pose
void btSoftBody_m_pose_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::Pose & ta = *(::btSoftBody::Pose *)a;
	o->m_pose = ta;
}
void* btSoftBody_m_pose_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_pose);
}

//attribute: ::btAlignedObjectArray<btSoftBody::RContact> btSoftBody->m_rcontacts
void btSoftBody_m_rcontacts_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btAlignedObjectArray<btSoftBody::RContact> & ta = *(::btAlignedObjectArray<btSoftBody::RContact> *)a;
	o->m_rcontacts = ta;
}
void* btSoftBody_m_rcontacts_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_rcontacts);
}

//attribute: ::btAlignedObjectArray<btSoftBody::SContact> btSoftBody->m_scontacts
void btSoftBody_m_scontacts_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btAlignedObjectArray<btSoftBody::SContact> & ta = *(::btAlignedObjectArray<btSoftBody::SContact> *)a;
	o->m_scontacts = ta;
}
void* btSoftBody_m_scontacts_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_scontacts);
}

//attribute: ::btSoftBodySolver * btSoftBody->m_softBodySolver
// attribute not supported: //attribute: ::btSoftBodySolver * btSoftBody->m_softBodySolver
//attribute: ::btSoftBody::SolverState btSoftBody->m_sst
void btSoftBody_m_sst_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBody::SolverState & ta = *(::btSoftBody::SolverState *)a;
	o->m_sst = ta;
}
void* btSoftBody_m_sst_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_sst);
}

//attribute: void * btSoftBody->m_tag
void btSoftBody_m_tag_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	void * ta = (void *)a;
	o->m_tag = ta;
}
void* btSoftBody_m_tag_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)(o->m_tag);
}

//attribute: ::btAlignedObjectArray<btSoftBody::Tetra> btSoftBody->m_tetras
void btSoftBody_m_tetras_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btAlignedObjectArray<btSoftBody::Tetra> & ta = *(::btAlignedObjectArray<btSoftBody::Tetra> *)a;
	o->m_tetras = ta;
}
void* btSoftBody_m_tetras_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_tetras);
}

//attribute: ::btScalar btSoftBody->m_timeacc
void btSoftBody_m_timeacc_set(void *c,float a) {
	::btSoftBody *o = (::btSoftBody*)c;
	o->m_timeacc = a;
}
float btSoftBody_m_timeacc_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (float)(o->m_timeacc);
}

//attribute: ::btAlignedObjectArray<int> btSoftBody->m_userIndexMapping
void btSoftBody_m_userIndexMapping_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_userIndexMapping = ta;
}
void* btSoftBody_m_userIndexMapping_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)&(o->m_userIndexMapping);
}

//attribute: ::btVector3 btSoftBody->m_windVelocity
void btSoftBody_m_windVelocity_set(void *c,float* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_windVelocity = ta;
}
void btSoftBody_m_windVelocity_get(void *c,float* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	a[0]=(o->m_windVelocity).m_floats[0];a[1]=(o->m_windVelocity).m_floats[1];a[2]=(o->m_windVelocity).m_floats[2];
}

//attribute: ::btSoftBodyWorldInfo * btSoftBody->m_worldInfo
void btSoftBody_m_worldInfo_set(void *c,void* a) {
	::btSoftBody *o = (::btSoftBody*)c;
	::btSoftBodyWorldInfo * ta = (::btSoftBodyWorldInfo *)a;
	o->m_worldInfo = ta;
}
void* btSoftBody_m_worldInfo_get(void *c) {
	::btSoftBody *o = (::btSoftBody*)c;
	return (void*)(o->m_worldInfo);
}


// ::btSoftBodyHelpers
//constructor: btSoftBodyHelpers  ( ::btSoftBodyHelpers::* )(  ) 
void* btSoftBodyHelpers_new() {
	::btSoftBodyHelpers *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBodyHelpers),16);
	o = new (mem)::btSoftBodyHelpers();
	return (void*)o;
}
void btSoftBodyHelpers_free(void *c) {
	::btSoftBodyHelpers *o = (::btSoftBodyHelpers*)c;
	delete o;
}
//method: DrawInfos void (*)( ::btSoftBody *,::btIDebugDraw *,bool,bool,bool )
void btSoftBodyHelpers_DrawInfos(void* p0,void* p1,int p2,int p3,int p4) {
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	::btIDebugDraw * tp1 = (::btIDebugDraw *)p1;
	::btSoftBodyHelpers::DrawInfos(tp0,tp1,p2,p3,p4);
}
//method: Draw void (*)( ::btSoftBody *,::btIDebugDraw *,int )
void btSoftBodyHelpers_Draw(void* p0,void* p1,int p2) {
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	::btIDebugDraw * tp1 = (::btIDebugDraw *)p1;
	::btSoftBodyHelpers::Draw(tp0,tp1,p2);
}
//method: CreateEllipsoid ::btSoftBody * (*)( ::btSoftBodyWorldInfo &,::btVector3 const &,::btVector3 const &,int )
void* btSoftBodyHelpers_CreateEllipsoid(void* p0,float* p1,float* p2,int p3) {
	::btSoftBodyWorldInfo & tp0 = *(::btSoftBodyWorldInfo *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	void* retVal = (void*) ::btSoftBodyHelpers::CreateEllipsoid(tp0,tp1,tp2,p3);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	return retVal;
}
//method: CreateFromTetGenData ::btSoftBody * (*)( ::btSoftBodyWorldInfo &,char const *,char const *,char const *,bool,bool,bool )
void* btSoftBodyHelpers_CreateFromTetGenData(void* p0,char const * p1,char const * p2,char const * p3,int p4,int p5,int p6) {
	::btSoftBodyWorldInfo & tp0 = *(::btSoftBodyWorldInfo *)p0;
	void* retVal = (void*) ::btSoftBodyHelpers::CreateFromTetGenData(tp0,p1,p2,p3,p4,p5,p6);
	return retVal;
}
//method: DrawFrame void (*)( ::btSoftBody *,::btIDebugDraw * )
void btSoftBodyHelpers_DrawFrame(void* p0,void* p1) {
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	::btIDebugDraw * tp1 = (::btIDebugDraw *)p1;
	::btSoftBodyHelpers::DrawFrame(tp0,tp1);
}
//method: CreateRope ::btSoftBody * (*)( ::btSoftBodyWorldInfo &,::btVector3 const &,::btVector3 const &,int,int )
void* btSoftBodyHelpers_CreateRope(void* p0,float* p1,float* p2,int p3,int p4) {
	::btSoftBodyWorldInfo & tp0 = *(::btSoftBodyWorldInfo *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	void* retVal = (void*) ::btSoftBodyHelpers::CreateRope(tp0,tp1,tp2,p3,p4);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	return retVal;
}
//method: CalculateUV float (*)( int,int,int,int,int )
float btSoftBodyHelpers_CalculateUV(int p0,int p1,int p2,int p3,int p4) {
	float retVal = (float)::btSoftBodyHelpers::CalculateUV(p0,p1,p2,p3,p4);
	return retVal;
}
//method: DrawFaceTree void (*)( ::btSoftBody *,::btIDebugDraw *,int,int )
void btSoftBodyHelpers_DrawFaceTree(void* p0,void* p1,int p2,int p3) {
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	::btIDebugDraw * tp1 = (::btIDebugDraw *)p1;
	::btSoftBodyHelpers::DrawFaceTree(tp0,tp1,p2,p3);
}
//method: DrawClusterTree void (*)( ::btSoftBody *,::btIDebugDraw *,int,int )
void btSoftBodyHelpers_DrawClusterTree(void* p0,void* p1,int p2,int p3) {
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	::btIDebugDraw * tp1 = (::btIDebugDraw *)p1;
	::btSoftBodyHelpers::DrawClusterTree(tp0,tp1,p2,p3);
}
//not supported method: CreateFromTriMesh ::btSoftBody * (*)( ::btSoftBodyWorldInfo &,::btScalar const *,int const *,int,bool )
// error: ::btSoftBodyWorldInfo & - ok,  - unsupported,  - unsupported, int - ok, bool - ok, ::btSoftBody * - ok

//method: DrawNodeTree void (*)( ::btSoftBody *,::btIDebugDraw *,int,int )
void btSoftBodyHelpers_DrawNodeTree(void* p0,void* p1,int p2,int p3) {
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	::btIDebugDraw * tp1 = (::btIDebugDraw *)p1;
	::btSoftBodyHelpers::DrawNodeTree(tp0,tp1,p2,p3);
}
//not supported method: CreateFromConvexHull ::btSoftBody * (*)( ::btSoftBodyWorldInfo &,::btVector3 const *,int,bool )
// error: ::btSoftBodyWorldInfo & - ok,  - unsupported, int - ok, bool - ok, ::btSoftBody * - ok

//method: CreatePatch ::btSoftBody * (*)( ::btSoftBodyWorldInfo &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,int,int,int,bool )
void* btSoftBodyHelpers_CreatePatch(void* p0,float* p1,float* p2,float* p3,float* p4,int p5,int p6,int p7,int p8) {
	::btSoftBodyWorldInfo & tp0 = *(::btSoftBodyWorldInfo *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	void* retVal = (void*) ::btSoftBodyHelpers::CreatePatch(tp0,tp1,tp2,tp3,tp4,p5,p6,p7,p8);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	return retVal;
}
//not supported method: CreatePatchUV ::btSoftBody * (*)( ::btSoftBodyWorldInfo &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,int,int,int,bool,float * )
// error: ::btSoftBodyWorldInfo & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, int - ok, int - ok, int - ok, bool - ok,  - unsupported, ::btSoftBody * - ok


// ::btSoftBodyRigidBodyCollisionConfiguration
//constructor: btSoftBodyRigidBodyCollisionConfiguration  ( ::btSoftBodyRigidBodyCollisionConfiguration::* )( ::btDefaultCollisionConstructionInfo const & ) 
void* btSoftBodyRigidBodyCollisionConfiguration_new(void* p0) {
	::btSoftBodyRigidBodyCollisionConfiguration *o = 0;
	 void *mem = 0;
	::btDefaultCollisionConstructionInfo const & tp0 = *(::btDefaultCollisionConstructionInfo const *)p0;
	mem = btAlignedAlloc(sizeof(::btSoftBodyRigidBodyCollisionConfiguration),16);
	o = new (mem)::btSoftBodyRigidBodyCollisionConfiguration(tp0);
	return (void*)o;
}
void btSoftBodyRigidBodyCollisionConfiguration_free(void *c) {
	::btSoftBodyRigidBodyCollisionConfiguration *o = (::btSoftBodyRigidBodyCollisionConfiguration*)c;
	delete o;
}
//method: getCollisionAlgorithmCreateFunc ::btCollisionAlgorithmCreateFunc * ( ::btSoftBodyRigidBodyCollisionConfiguration::* )( int,int ) 
void* btSoftBodyRigidBodyCollisionConfiguration_getCollisionAlgorithmCreateFunc(void *c,int p0,int p1) {
	::btSoftBodyRigidBodyCollisionConfiguration *o = (::btSoftBodyRigidBodyCollisionConfiguration*)c;
	void* retVal = (void*) o->getCollisionAlgorithmCreateFunc(p0,p1);
	return retVal;
}
//attribute: ::btCollisionAlgorithmCreateFunc * btSoftBodyRigidBodyCollisionConfiguration->m_softSoftCreateFunc
void btSoftBodyRigidBodyCollisionConfiguration_m_softSoftCreateFunc_set(void *c,void* a) {
	::btSoftBodyRigidBodyCollisionConfiguration *o = (::btSoftBodyRigidBodyCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_softSoftCreateFunc = ta;
}
void* btSoftBodyRigidBodyCollisionConfiguration_m_softSoftCreateFunc_get(void *c) {
	::btSoftBodyRigidBodyCollisionConfiguration *o = (::btSoftBodyRigidBodyCollisionConfiguration*)c;
	return (void*)(o->m_softSoftCreateFunc);
}

//attribute: ::btCollisionAlgorithmCreateFunc * btSoftBodyRigidBodyCollisionConfiguration->m_softRigidConvexCreateFunc
void btSoftBodyRigidBodyCollisionConfiguration_m_softRigidConvexCreateFunc_set(void *c,void* a) {
	::btSoftBodyRigidBodyCollisionConfiguration *o = (::btSoftBodyRigidBodyCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_softRigidConvexCreateFunc = ta;
}
void* btSoftBodyRigidBodyCollisionConfiguration_m_softRigidConvexCreateFunc_get(void *c) {
	::btSoftBodyRigidBodyCollisionConfiguration *o = (::btSoftBodyRigidBodyCollisionConfiguration*)c;
	return (void*)(o->m_softRigidConvexCreateFunc);
}

//attribute: ::btCollisionAlgorithmCreateFunc * btSoftBodyRigidBodyCollisionConfiguration->m_swappedSoftRigidConvexCreateFunc
void btSoftBodyRigidBodyCollisionConfiguration_m_swappedSoftRigidConvexCreateFunc_set(void *c,void* a) {
	::btSoftBodyRigidBodyCollisionConfiguration *o = (::btSoftBodyRigidBodyCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_swappedSoftRigidConvexCreateFunc = ta;
}
void* btSoftBodyRigidBodyCollisionConfiguration_m_swappedSoftRigidConvexCreateFunc_get(void *c) {
	::btSoftBodyRigidBodyCollisionConfiguration *o = (::btSoftBodyRigidBodyCollisionConfiguration*)c;
	return (void*)(o->m_swappedSoftRigidConvexCreateFunc);
}

//attribute: ::btCollisionAlgorithmCreateFunc * btSoftBodyRigidBodyCollisionConfiguration->m_softRigidConcaveCreateFunc
void btSoftBodyRigidBodyCollisionConfiguration_m_softRigidConcaveCreateFunc_set(void *c,void* a) {
	::btSoftBodyRigidBodyCollisionConfiguration *o = (::btSoftBodyRigidBodyCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_softRigidConcaveCreateFunc = ta;
}
void* btSoftBodyRigidBodyCollisionConfiguration_m_softRigidConcaveCreateFunc_get(void *c) {
	::btSoftBodyRigidBodyCollisionConfiguration *o = (::btSoftBodyRigidBodyCollisionConfiguration*)c;
	return (void*)(o->m_softRigidConcaveCreateFunc);
}

//attribute: ::btCollisionAlgorithmCreateFunc * btSoftBodyRigidBodyCollisionConfiguration->m_swappedSoftRigidConcaveCreateFunc
void btSoftBodyRigidBodyCollisionConfiguration_m_swappedSoftRigidConcaveCreateFunc_set(void *c,void* a) {
	::btSoftBodyRigidBodyCollisionConfiguration *o = (::btSoftBodyRigidBodyCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_swappedSoftRigidConcaveCreateFunc = ta;
}
void* btSoftBodyRigidBodyCollisionConfiguration_m_swappedSoftRigidConcaveCreateFunc_get(void *c) {
	::btSoftBodyRigidBodyCollisionConfiguration *o = (::btSoftBodyRigidBodyCollisionConfiguration*)c;
	return (void*)(o->m_swappedSoftRigidConcaveCreateFunc);
}


// ::btSoftBodyWorldInfo
//constructor: btSoftBodyWorldInfo  ( ::btSoftBodyWorldInfo::* )(  ) 
void* btSoftBodyWorldInfo_new() {
	::btSoftBodyWorldInfo *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBodyWorldInfo),16);
	o = new (mem)::btSoftBodyWorldInfo();
	return (void*)o;
}
void btSoftBodyWorldInfo_free(void *c) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	delete o;
}
//attribute: ::btScalar btSoftBodyWorldInfo->air_density
void btSoftBodyWorldInfo_air_density_set(void *c,float a) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	o->air_density = a;
}
float btSoftBodyWorldInfo_air_density_get(void *c) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	return (float)(o->air_density);
}

//attribute: ::btBroadphaseInterface * btSoftBodyWorldInfo->m_broadphase
void btSoftBodyWorldInfo_m_broadphase_set(void *c,void* a) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	::btBroadphaseInterface * ta = (::btBroadphaseInterface *)a;
	o->m_broadphase = ta;
}
void* btSoftBodyWorldInfo_m_broadphase_get(void *c) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	return (void*)(o->m_broadphase);
}

//attribute: ::btDispatcher * btSoftBodyWorldInfo->m_dispatcher
void btSoftBodyWorldInfo_m_dispatcher_set(void *c,void* a) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	::btDispatcher * ta = (::btDispatcher *)a;
	o->m_dispatcher = ta;
}
void* btSoftBodyWorldInfo_m_dispatcher_get(void *c) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	return (void*)(o->m_dispatcher);
}

//attribute: ::btVector3 btSoftBodyWorldInfo->m_gravity
void btSoftBodyWorldInfo_m_gravity_set(void *c,float* a) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_gravity = ta;
}
void btSoftBodyWorldInfo_m_gravity_get(void *c,float* a) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	a[0]=(o->m_gravity).m_floats[0];a[1]=(o->m_gravity).m_floats[1];a[2]=(o->m_gravity).m_floats[2];
}

//attribute: ::btSparseSdf<3> btSoftBodyWorldInfo->m_sparsesdf
void btSoftBodyWorldInfo_m_sparsesdf_set(void *c,void* a) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	::btSparseSdf<3> & ta = *(::btSparseSdf<3> *)a;
	o->m_sparsesdf = ta;
}
void* btSoftBodyWorldInfo_m_sparsesdf_get(void *c) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	return (void*)&(o->m_sparsesdf);
}

//attribute: ::btScalar btSoftBodyWorldInfo->water_density
void btSoftBodyWorldInfo_water_density_set(void *c,float a) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	o->water_density = a;
}
float btSoftBodyWorldInfo_water_density_get(void *c) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	return (float)(o->water_density);
}

//attribute: ::btVector3 btSoftBodyWorldInfo->water_normal
void btSoftBodyWorldInfo_water_normal_set(void *c,float* a) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->water_normal = ta;
}
void btSoftBodyWorldInfo_water_normal_get(void *c,float* a) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	a[0]=(o->water_normal).m_floats[0];a[1]=(o->water_normal).m_floats[1];a[2]=(o->water_normal).m_floats[2];
}

//attribute: ::btScalar btSoftBodyWorldInfo->water_offset
void btSoftBodyWorldInfo_water_offset_set(void *c,float a) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	o->water_offset = a;
}
float btSoftBodyWorldInfo_water_offset_get(void *c) {
	::btSoftBodyWorldInfo *o = (::btSoftBodyWorldInfo*)c;
	return (float)(o->water_offset);
}


// ::btSoftRigidDynamicsWorld
//not supported constructor: btSoftRigidDynamicsWorld  ( ::btSoftRigidDynamicsWorld::* )( ::btDispatcher *,::btBroadphaseInterface *,::btConstraintSolver *,::btCollisionConfiguration *,::btSoftBodySolver * ) 
// error: ::btDispatcher * - ok, ::btBroadphaseInterface * - ok, ::btConstraintSolver * - ok, ::btCollisionConfiguration * - ok,  - unsupported

void btSoftRigidDynamicsWorld_free(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	delete o;
}
//method: predictUnconstraintMotion void ( ::btSoftRigidDynamicsWorld::* )( ::btScalar ) 
void btSoftRigidDynamicsWorld_predictUnconstraintMotion(void *c,float p0) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	o->predictUnconstraintMotion(p0);
}
//method: getWorldInfo ::btSoftBodyWorldInfo & ( ::btSoftRigidDynamicsWorld::* )(  ) 
void* btSoftRigidDynamicsWorld_getWorldInfo(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	void* retVal = (void*) &(o->getWorldInfo());
	return retVal;
}
//method: getWorldInfo ::btSoftBodyWorldInfo & ( ::btSoftRigidDynamicsWorld::* )(  ) 
void* btSoftRigidDynamicsWorld_getWorldInfo0(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	void* retVal = (void*) &(o->getWorldInfo());
	return retVal;
}
//method: getWorldInfo ::btSoftBodyWorldInfo const & ( ::btSoftRigidDynamicsWorld::* )(  ) const
void* btSoftRigidDynamicsWorld_getWorldInfo1(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	void* retVal = (void*) &(o->getWorldInfo());
	return retVal;
}
//method: setDrawFlags void ( ::btSoftRigidDynamicsWorld::* )( int ) 
void btSoftRigidDynamicsWorld_setDrawFlags(void *c,int p0) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	o->setDrawFlags(p0);
}
//method: getSoftBodyArray ::btSoftBodyArray & ( ::btSoftRigidDynamicsWorld::* )(  ) 
void* btSoftRigidDynamicsWorld_getSoftBodyArray(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	void* retVal = (void*) &(o->getSoftBodyArray());
	return retVal;
}
//method: getSoftBodyArray ::btSoftBodyArray & ( ::btSoftRigidDynamicsWorld::* )(  ) 
void* btSoftRigidDynamicsWorld_getSoftBodyArray0(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	void* retVal = (void*) &(o->getSoftBodyArray());
	return retVal;
}
//method: getSoftBodyArray ::btSoftBodyArray const & ( ::btSoftRigidDynamicsWorld::* )(  ) const
void* btSoftRigidDynamicsWorld_getSoftBodyArray1(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	void* retVal = (void*) &(o->getSoftBodyArray());
	return retVal;
}
//method: serialize void ( ::btSoftRigidDynamicsWorld::* )( ::btSerializer * ) 
void btSoftRigidDynamicsWorld_serialize(void *c,void* p0) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	::btSerializer * tp0 = (::btSerializer *)p0;
	o->serialize(tp0);
}
//method: rayTest void ( ::btSoftRigidDynamicsWorld::* )( ::btVector3 const &,::btVector3 const &,::btCollisionWorld::RayResultCallback & ) const
void btSoftRigidDynamicsWorld_rayTest(void *c,float* p0,float* p1,void* p2) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btCollisionWorld::RayResultCallback & tp2 = *(::btCollisionWorld::RayResultCallback *)p2;
	o->rayTest(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//not supported method: getWorldType ::btDynamicsWorldType ( ::btSoftRigidDynamicsWorld::* )(  ) const
// error:  - unsupported

//method: solveSoftBodiesConstraints void ( ::btSoftRigidDynamicsWorld::* )( ::btScalar ) 
void btSoftRigidDynamicsWorld_solveSoftBodiesConstraints(void *c,float p0) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	o->solveSoftBodiesConstraints(p0);
}
//method: removeCollisionObject void ( ::btSoftRigidDynamicsWorld::* )( ::btCollisionObject * ) 
void btSoftRigidDynamicsWorld_removeCollisionObject(void *c,void* p0) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	o->removeCollisionObject(tp0);
}
//method: addSoftBody void ( ::btSoftRigidDynamicsWorld::* )( ::btSoftBody *,short int,short int ) 
void btSoftRigidDynamicsWorld_addSoftBody(void *c,void* p0,short int p1,short int p2) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	o->addSoftBody(tp0,p1,p2);
}
//method: rayTestSingle void (*)( ::btTransform const &,::btTransform const &,::btCollisionObject *,::btCollisionShape const *,::btTransform const &,::btCollisionWorld::RayResultCallback & )
void btSoftRigidDynamicsWorld_rayTestSingle(float* p0,float* p1,void* p2,void* p3,float* p4,void* p5) {
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	::btCollisionObject * tp2 = (::btCollisionObject *)p2;
	::btCollisionShape const * tp3 = (::btCollisionShape const *)p3;
	btMatrix3x3 mtp4(p4[0],p4[1],p4[2],p4[3],p4[4],p4[5],p4[6],p4[7],p4[8]);
	btVector3 vtp4(p4[9],p4[10],p4[11]);
	btTransform tp4(mtp4,vtp4);
	::btCollisionWorld::RayResultCallback & tp5 = *(::btCollisionWorld::RayResultCallback *)p5;
	::btSoftRigidDynamicsWorld::rayTestSingle(tp0,tp1,tp2,tp3,tp4,tp5);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p4[0]=tp4.getBasis().getRow(0).m_floats[0];p4[1]=tp4.getBasis().getRow(0).m_floats[1];p4[2]=tp4.getBasis().getRow(0).m_floats[2];p4[3]=tp4.getBasis().getRow(1).m_floats[0];p4[4]=tp4.getBasis().getRow(1).m_floats[1];p4[5]=tp4.getBasis().getRow(1).m_floats[2];p4[6]=tp4.getBasis().getRow(2).m_floats[0];p4[7]=tp4.getBasis().getRow(2).m_floats[1];p4[8]=tp4.getBasis().getRow(2).m_floats[2];
	p4[9]=tp4.getOrigin().m_floats[0];p4[10]=tp4.getOrigin().m_floats[1];p4[11]=tp4.getOrigin().m_floats[2];
}
//method: internalSingleStepSimulation void ( ::btSoftRigidDynamicsWorld::* )( ::btScalar ) 
void btSoftRigidDynamicsWorld_internalSingleStepSimulation(void *c,float p0) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	o->internalSingleStepSimulation(p0);
}
//method: serializeSoftBodies void ( ::btSoftRigidDynamicsWorld::* )( ::btSerializer * ) 
void btSoftRigidDynamicsWorld_serializeSoftBodies(void *c,void* p0) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	::btSerializer * tp0 = (::btSerializer *)p0;
	o->serializeSoftBodies(tp0);
}
//method: removeSoftBody void ( ::btSoftRigidDynamicsWorld::* )( ::btSoftBody * ) 
void btSoftRigidDynamicsWorld_removeSoftBody(void *c,void* p0) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	o->removeSoftBody(tp0);
}
//method: getDrawFlags int ( ::btSoftRigidDynamicsWorld::* )(  ) const
int btSoftRigidDynamicsWorld_getDrawFlags(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	int retVal = (int)o->getDrawFlags();
	return retVal;
}
//method: debugDrawWorld void ( ::btSoftRigidDynamicsWorld::* )(  ) 
void btSoftRigidDynamicsWorld_debugDrawWorld(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	o->debugDrawWorld();
}
//attribute: ::btSoftBodyArray btSoftRigidDynamicsWorld->m_softBodies
void btSoftRigidDynamicsWorld_m_softBodies_set(void *c,void* a) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	::btSoftBodyArray & ta = *(::btAlignedObjectArray<btSoftBody*> *)a;
	o->m_softBodies = ta;
}
void* btSoftRigidDynamicsWorld_m_softBodies_get(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	return (void*)&(o->m_softBodies);
}

//attribute: int btSoftRigidDynamicsWorld->m_drawFlags
void btSoftRigidDynamicsWorld_m_drawFlags_set(void *c,int a) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	o->m_drawFlags = a;
}
int btSoftRigidDynamicsWorld_m_drawFlags_get(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	return (int)(o->m_drawFlags);
}

//attribute: bool btSoftRigidDynamicsWorld->m_drawNodeTree
void btSoftRigidDynamicsWorld_m_drawNodeTree_set(void *c,int a) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	o->m_drawNodeTree = a;
}
int btSoftRigidDynamicsWorld_m_drawNodeTree_get(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	return (int)(o->m_drawNodeTree);
}

//attribute: bool btSoftRigidDynamicsWorld->m_drawFaceTree
void btSoftRigidDynamicsWorld_m_drawFaceTree_set(void *c,int a) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	o->m_drawFaceTree = a;
}
int btSoftRigidDynamicsWorld_m_drawFaceTree_get(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	return (int)(o->m_drawFaceTree);
}

//attribute: bool btSoftRigidDynamicsWorld->m_drawClusterTree
void btSoftRigidDynamicsWorld_m_drawClusterTree_set(void *c,int a) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	o->m_drawClusterTree = a;
}
int btSoftRigidDynamicsWorld_m_drawClusterTree_get(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	return (int)(o->m_drawClusterTree);
}

//attribute: ::btSoftBodyWorldInfo btSoftRigidDynamicsWorld->m_sbi
void btSoftRigidDynamicsWorld_m_sbi_set(void *c,void* a) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	::btSoftBodyWorldInfo & ta = *(::btSoftBodyWorldInfo *)a;
	o->m_sbi = ta;
}
void* btSoftRigidDynamicsWorld_m_sbi_get(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	return (void*)&(o->m_sbi);
}

//attribute: ::btSoftBodySolver * btSoftRigidDynamicsWorld->m_softBodySolver
// attribute not supported: //attribute: ::btSoftBodySolver * btSoftRigidDynamicsWorld->m_softBodySolver
//attribute: bool btSoftRigidDynamicsWorld->m_ownsSolver
void btSoftRigidDynamicsWorld_m_ownsSolver_set(void *c,int a) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	o->m_ownsSolver = a;
}
int btSoftRigidDynamicsWorld_m_ownsSolver_get(void *c) {
	::btSoftRigidDynamicsWorld *o = (::btSoftRigidDynamicsWorld*)c;
	return (int)(o->m_ownsSolver);
}


// ::btSparseSdf< 3 >
//constructor: btSparseSdf  ( ::btSparseSdf<3>::* )(  ) 
void* btSparseSdf_3__new() {
	::btSparseSdf< 3 > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSparseSdf< 3 >),16);
	o = new (mem)::btSparseSdf< 3 >();
	return (void*)o;
}
void btSparseSdf_3__free(void *c) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	delete o;
}
//method: Reset void ( ::btSparseSdf<3>::* )(  ) 
void btSparseSdf_3__Reset(void *c) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	o->Reset();
}
//method: Hash unsigned int (*)( int,int,int,::btCollisionShape * )
unsigned int btSparseSdf_3__Hash(int p0,int p1,int p2,void* p3) {
	::btCollisionShape * tp3 = (::btCollisionShape *)p3;
	unsigned int retVal = (unsigned int)::btSparseSdf< 3 >::Hash(p0,p1,p2,tp3);
	return retVal;
}
//method: RemoveReferences int ( ::btSparseSdf<3>::* )( ::btCollisionShape * ) 
int btSparseSdf_3__RemoveReferences(void *c,void* p0) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	::btCollisionShape * tp0 = (::btCollisionShape *)p0;
	int retVal = (int)o->RemoveReferences(tp0);
	return retVal;
}
//method: Lerp ::btScalar (*)( ::btScalar,::btScalar,::btScalar )
float btSparseSdf_3__Lerp(float p0,float p1,float p2) {
	float retVal = (float)::btSparseSdf< 3 >::Lerp(p0,p1,p2);
	return retVal;
}
//method: Evaluate ::btScalar ( ::btSparseSdf<3>::* )( ::btVector3 const &,::btCollisionShape *,::btVector3 &,::btScalar ) 
float btSparseSdf_3__Evaluate(void *c,float* p0,void* p1,float* p2,float p3) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	::btCollisionShape * tp1 = (::btCollisionShape *)p1;
	btVector3 tp2(p2[0],p2[1],p2[2]);
	float retVal = (float)o->Evaluate(tp0,tp1,tp2,p3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	return retVal;
}
//method: GarbageCollect void ( ::btSparseSdf<3>::* )( int ) 
void btSparseSdf_3__GarbageCollect(void *c,int p0) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	o->GarbageCollect(p0);
}
//not supported method: BuildCell void ( ::btSparseSdf<3>::* )( ::btSparseSdf<3>::Cell & ) 
// error:  - unsupported, void - ok

//method: DistanceToShape ::btScalar (*)( ::btVector3 const &,::btCollisionShape * )
float btSparseSdf_3__DistanceToShape(float* p0,void* p1) {
	btVector3 tp0(p0[0],p0[1],p0[2]);
	::btCollisionShape * tp1 = (::btCollisionShape *)p1;
	float retVal = (float)::btSparseSdf< 3 >::DistanceToShape(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return retVal;
}
//method: Initialize void ( ::btSparseSdf<3>::* )( int ) 
void btSparseSdf_3__Initialize(void *c,int p0) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	o->Initialize(p0);
}
//not supported method: Decompose ::btSparseSdf<3>::IntFrac (*)( ::btScalar )
// error: ::btScalar - ok,  - unsupported

//attribute: ::btAlignedObjectArray<btSparseSdf<3>::Cell*> btSparseSdf_3_->cells
void btSparseSdf_3__cells_set(void *c,void* a) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	::btAlignedObjectArray<btSparseSdf<3>::Cell*> & ta = *(::btAlignedObjectArray<btSparseSdf<3>::Cell*> *)a;
	o->cells = ta;
}
void* btSparseSdf_3__cells_get(void *c) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	return (void*)&(o->cells);
}

//attribute: int btSparseSdf_3_->ncells
void btSparseSdf_3__ncells_set(void *c,int a) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	o->ncells = a;
}
int btSparseSdf_3__ncells_get(void *c) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	return (int)(o->ncells);
}

//attribute: int btSparseSdf_3_->nprobes
void btSparseSdf_3__nprobes_set(void *c,int a) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	o->nprobes = a;
}
int btSparseSdf_3__nprobes_get(void *c) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	return (int)(o->nprobes);
}

//attribute: int btSparseSdf_3_->nqueries
void btSparseSdf_3__nqueries_set(void *c,int a) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	o->nqueries = a;
}
int btSparseSdf_3__nqueries_get(void *c) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	return (int)(o->nqueries);
}

//attribute: int btSparseSdf_3_->puid
void btSparseSdf_3__puid_set(void *c,int a) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	o->puid = a;
}
int btSparseSdf_3__puid_get(void *c) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	return (int)(o->puid);
}

//attribute: ::btScalar btSparseSdf_3_->voxelsz
void btSparseSdf_3__voxelsz_set(void *c,float a) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	o->voxelsz = a;
}
float btSparseSdf_3__voxelsz_get(void *c) {
	::btSparseSdf< 3 > *o = (::btSparseSdf< 3 >*)c;
	return (float)(o->voxelsz);
}


// ::btSoftBody::eAeroModel
//constructor: eAeroModel  ( ::btSoftBody::eAeroModel::* )(  ) 
void* btSoftBody_eAeroModel_new() {
	::btSoftBody::eAeroModel *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::eAeroModel),16);
	o = new (mem)::btSoftBody::eAeroModel();
	return (void*)o;
}
void btSoftBody_eAeroModel_free(void *c) {
	::btSoftBody::eAeroModel *o = (::btSoftBody::eAeroModel*)c;
	delete o;
}

// ::btSoftBody::eFeature
//constructor: eFeature  ( ::btSoftBody::eFeature::* )(  ) 
void* btSoftBody_eFeature_new() {
	::btSoftBody::eFeature *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::eFeature),16);
	o = new (mem)::btSoftBody::eFeature();
	return (void*)o;
}
void btSoftBody_eFeature_free(void *c) {
	::btSoftBody::eFeature *o = (::btSoftBody::eFeature*)c;
	delete o;
}

// ::btSoftBody::ePSolver
//constructor: ePSolver  ( ::btSoftBody::ePSolver::* )(  ) 
void* btSoftBody_ePSolver_new() {
	::btSoftBody::ePSolver *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::ePSolver),16);
	o = new (mem)::btSoftBody::ePSolver();
	return (void*)o;
}
void btSoftBody_ePSolver_free(void *c) {
	::btSoftBody::ePSolver *o = (::btSoftBody::ePSolver*)c;
	delete o;
}

// ::btSoftBody::eSolverPresets
//constructor: eSolverPresets  ( ::btSoftBody::eSolverPresets::* )(  ) 
void* btSoftBody_eSolverPresets_new() {
	::btSoftBody::eSolverPresets *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::eSolverPresets),16);
	o = new (mem)::btSoftBody::eSolverPresets();
	return (void*)o;
}
void btSoftBody_eSolverPresets_free(void *c) {
	::btSoftBody::eSolverPresets *o = (::btSoftBody::eSolverPresets*)c;
	delete o;
}

// ::btSoftBody::Joint::eType
//constructor: eType  ( ::btSoftBody::Joint::eType::* )(  ) 
void* btSoftBody_Joint_eType_new() {
	::btSoftBody::Joint::eType *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::Joint::eType),16);
	o = new (mem)::btSoftBody::Joint::eType();
	return (void*)o;
}
void btSoftBody_Joint_eType_free(void *c) {
	::btSoftBody::Joint::eType *o = (::btSoftBody::Joint::eType*)c;
	delete o;
}

// ::btSoftBody::eVSolver
//constructor: eVSolver  ( ::btSoftBody::eVSolver::* )(  ) 
void* btSoftBody_eVSolver_new() {
	::btSoftBody::eVSolver *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::eVSolver),16);
	o = new (mem)::btSoftBody::eVSolver();
	return (void*)o;
}
void btSoftBody_eVSolver_free(void *c) {
	::btSoftBody::eVSolver *o = (::btSoftBody::eVSolver*)c;
	delete o;
}

// ::btSoftBody::fCollision
//constructor: fCollision  ( ::btSoftBody::fCollision::* )(  ) 
void* btSoftBody_fCollision_new() {
	::btSoftBody::fCollision *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::fCollision),16);
	o = new (mem)::btSoftBody::fCollision();
	return (void*)o;
}
void btSoftBody_fCollision_free(void *c) {
	::btSoftBody::fCollision *o = (::btSoftBody::fCollision*)c;
	delete o;
}

// ::fDrawFlags
//constructor: fDrawFlags  ( ::fDrawFlags::* )(  ) 
void* fDrawFlags_new() {
	::fDrawFlags *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::fDrawFlags),16);
	o = new (mem)::fDrawFlags();
	return (void*)o;
}
void fDrawFlags_free(void *c) {
	::fDrawFlags *o = (::fDrawFlags*)c;
	delete o;
}

// ::btSoftBody::fMaterial
//constructor: fMaterial  ( ::btSoftBody::fMaterial::* )(  ) 
void* btSoftBody_fMaterial_new() {
	::btSoftBody::fMaterial *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::fMaterial),16);
	o = new (mem)::btSoftBody::fMaterial();
	return (void*)o;
}
void btSoftBody_fMaterial_free(void *c) {
	::btSoftBody::fMaterial *o = (::btSoftBody::fMaterial*)c;
	delete o;
}

// ::btSoftBody::sCti
//constructor: sCti  ( ::btSoftBody::sCti::* )(  ) 
void* btSoftBody_sCti_new() {
	::btSoftBody::sCti *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::sCti),16);
	o = new (mem)::btSoftBody::sCti();
	return (void*)o;
}
void btSoftBody_sCti_free(void *c) {
	::btSoftBody::sCti *o = (::btSoftBody::sCti*)c;
	delete o;
}
//attribute: ::btCollisionObject * btSoftBody_sCti->m_colObj
void btSoftBody_sCti_m_colObj_set(void *c,void* a) {
	::btSoftBody::sCti *o = (::btSoftBody::sCti*)c;
	::btCollisionObject * ta = (::btCollisionObject *)a;
	o->m_colObj = ta;
}
void* btSoftBody_sCti_m_colObj_get(void *c) {
	::btSoftBody::sCti *o = (::btSoftBody::sCti*)c;
	return (void*)(o->m_colObj);
}

//attribute: ::btVector3 btSoftBody_sCti->m_normal
void btSoftBody_sCti_m_normal_set(void *c,float* a) {
	::btSoftBody::sCti *o = (::btSoftBody::sCti*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_normal = ta;
}
void btSoftBody_sCti_m_normal_get(void *c,float* a) {
	::btSoftBody::sCti *o = (::btSoftBody::sCti*)c;
	a[0]=(o->m_normal).m_floats[0];a[1]=(o->m_normal).m_floats[1];a[2]=(o->m_normal).m_floats[2];
}

//attribute: ::btScalar btSoftBody_sCti->m_offset
void btSoftBody_sCti_m_offset_set(void *c,float a) {
	::btSoftBody::sCti *o = (::btSoftBody::sCti*)c;
	o->m_offset = a;
}
float btSoftBody_sCti_m_offset_get(void *c) {
	::btSoftBody::sCti *o = (::btSoftBody::sCti*)c;
	return (float)(o->m_offset);
}


// ::btSoftBody::sMedium
//constructor: sMedium  ( ::btSoftBody::sMedium::* )(  ) 
void* btSoftBody_sMedium_new() {
	::btSoftBody::sMedium *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::sMedium),16);
	o = new (mem)::btSoftBody::sMedium();
	return (void*)o;
}
void btSoftBody_sMedium_free(void *c) {
	::btSoftBody::sMedium *o = (::btSoftBody::sMedium*)c;
	delete o;
}
//attribute: ::btScalar btSoftBody_sMedium->m_density
void btSoftBody_sMedium_m_density_set(void *c,float a) {
	::btSoftBody::sMedium *o = (::btSoftBody::sMedium*)c;
	o->m_density = a;
}
float btSoftBody_sMedium_m_density_get(void *c) {
	::btSoftBody::sMedium *o = (::btSoftBody::sMedium*)c;
	return (float)(o->m_density);
}

//attribute: ::btScalar btSoftBody_sMedium->m_pressure
void btSoftBody_sMedium_m_pressure_set(void *c,float a) {
	::btSoftBody::sMedium *o = (::btSoftBody::sMedium*)c;
	o->m_pressure = a;
}
float btSoftBody_sMedium_m_pressure_get(void *c) {
	::btSoftBody::sMedium *o = (::btSoftBody::sMedium*)c;
	return (float)(o->m_pressure);
}

//attribute: ::btVector3 btSoftBody_sMedium->m_velocity
void btSoftBody_sMedium_m_velocity_set(void *c,float* a) {
	::btSoftBody::sMedium *o = (::btSoftBody::sMedium*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_velocity = ta;
}
void btSoftBody_sMedium_m_velocity_get(void *c,float* a) {
	::btSoftBody::sMedium *o = (::btSoftBody::sMedium*)c;
	a[0]=(o->m_velocity).m_floats[0];a[1]=(o->m_velocity).m_floats[1];a[2]=(o->m_velocity).m_floats[2];
}


// ::btSoftBody::sRayCast
//constructor: sRayCast  ( ::btSoftBody::sRayCast::* )(  ) 
void* btSoftBody_sRayCast_new() {
	::btSoftBody::sRayCast *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSoftBody::sRayCast),16);
	o = new (mem)::btSoftBody::sRayCast();
	return (void*)o;
}
void btSoftBody_sRayCast_free(void *c) {
	::btSoftBody::sRayCast *o = (::btSoftBody::sRayCast*)c;
	delete o;
}
//attribute: ::btSoftBody * btSoftBody_sRayCast->body
void btSoftBody_sRayCast_body_set(void *c,void* a) {
	::btSoftBody::sRayCast *o = (::btSoftBody::sRayCast*)c;
	::btSoftBody * ta = (::btSoftBody *)a;
	o->body = ta;
}
void* btSoftBody_sRayCast_body_get(void *c) {
	::btSoftBody::sRayCast *o = (::btSoftBody::sRayCast*)c;
	return (void*)(o->body);
}

//attribute: ::btSoftBody::eFeature::_ btSoftBody_sRayCast->feature
// attribute not supported: //attribute: ::btSoftBody::eFeature::_ btSoftBody_sRayCast->feature
//attribute: ::btScalar btSoftBody_sRayCast->fraction
void btSoftBody_sRayCast_fraction_set(void *c,float a) {
	::btSoftBody::sRayCast *o = (::btSoftBody::sRayCast*)c;
	o->fraction = a;
}
float btSoftBody_sRayCast_fraction_get(void *c) {
	::btSoftBody::sRayCast *o = (::btSoftBody::sRayCast*)c;
	return (float)(o->fraction);
}

//attribute: int btSoftBody_sRayCast->index
void btSoftBody_sRayCast_index_set(void *c,int a) {
	::btSoftBody::sRayCast *o = (::btSoftBody::sRayCast*)c;
	o->index = a;
}
int btSoftBody_sRayCast_index_get(void *c) {
	::btSoftBody::sRayCast *o = (::btSoftBody::sRayCast*)c;
	return (int)(o->index);
}


// ::CProfileIterator
//constructor: CProfileIterator  ( ::CProfileIterator::* )( ::CProfileNode * ) 
void* cProfileIterator_new(void* p0) {
	::CProfileIterator *o = 0;
	 void *mem = 0;
	::CProfileNode * tp0 = (::CProfileNode *)p0;
	mem = btAlignedAlloc(sizeof(::CProfileIterator),16);
	o = new (mem)::CProfileIterator(tp0);
	return (void*)o;
}
void cProfileIterator_free(void *c) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	delete o;
}
//method: Get_Current_Name char const * ( ::CProfileIterator::* )(  ) 
char const * cProfileIterator_Get_Current_Name(void *c) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	char const * retVal = (char const *)o->Get_Current_Name();
	return retVal;
}
//method: Get_Current_Total_Calls int ( ::CProfileIterator::* )(  ) 
int cProfileIterator_Get_Current_Total_Calls(void *c) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	int retVal = (int)o->Get_Current_Total_Calls();
	return retVal;
}
//method: Get_Current_Total_Time float ( ::CProfileIterator::* )(  ) 
float cProfileIterator_Get_Current_Total_Time(void *c) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	float retVal = (float)o->Get_Current_Total_Time();
	return retVal;
}
//method: Enter_Child void ( ::CProfileIterator::* )( int ) 
void cProfileIterator_Enter_Child(void *c,int p0) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	o->Enter_Child(p0);
}
//method: Is_Done bool ( ::CProfileIterator::* )(  ) 
int cProfileIterator_Is_Done(void *c) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	int retVal = (int)o->Is_Done();
	return retVal;
}
//method: Next void ( ::CProfileIterator::* )(  ) 
void cProfileIterator_Next(void *c) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	o->Next();
}
//method: Is_Root bool ( ::CProfileIterator::* )(  ) 
int cProfileIterator_Is_Root(void *c) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	int retVal = (int)o->Is_Root();
	return retVal;
}
//method: Get_Current_Parent_Name char const * ( ::CProfileIterator::* )(  ) 
char const * cProfileIterator_Get_Current_Parent_Name(void *c) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	char const * retVal = (char const *)o->Get_Current_Parent_Name();
	return retVal;
}
//method: Get_Current_UserPointer void * ( ::CProfileIterator::* )(  ) 
void* cProfileIterator_Get_Current_UserPointer(void *c) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	void* retVal = (void*) o->Get_Current_UserPointer();
	return retVal;
}
//method: Get_Current_Parent_Total_Calls int ( ::CProfileIterator::* )(  ) 
int cProfileIterator_Get_Current_Parent_Total_Calls(void *c) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	int retVal = (int)o->Get_Current_Parent_Total_Calls();
	return retVal;
}
//method: Set_Current_UserPointer void ( ::CProfileIterator::* )( void * ) 
void cProfileIterator_Set_Current_UserPointer(void *c,void* p0) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	void * tp0 = (void *)p0;
	o->Set_Current_UserPointer(tp0);
}
//method: Get_Current_Parent_Total_Time float ( ::CProfileIterator::* )(  ) 
float cProfileIterator_Get_Current_Parent_Total_Time(void *c) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	float retVal = (float)o->Get_Current_Parent_Total_Time();
	return retVal;
}
//method: Enter_Parent void ( ::CProfileIterator::* )(  ) 
void cProfileIterator_Enter_Parent(void *c) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	o->Enter_Parent();
}
//method: First void ( ::CProfileIterator::* )(  ) 
void cProfileIterator_First(void *c) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	o->First();
}
//attribute: ::CProfileNode * cProfileIterator->CurrentParent
void cProfileIterator_CurrentParent_set(void *c,void* a) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	::CProfileNode * ta = (::CProfileNode *)a;
	o->CurrentParent = ta;
}
void* cProfileIterator_CurrentParent_get(void *c) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	return (void*)(o->CurrentParent);
}

//attribute: ::CProfileNode * cProfileIterator->CurrentChild
void cProfileIterator_CurrentChild_set(void *c,void* a) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	::CProfileNode * ta = (::CProfileNode *)a;
	o->CurrentChild = ta;
}
void* cProfileIterator_CurrentChild_get(void *c) {
	::CProfileIterator *o = (::CProfileIterator*)c;
	return (void*)(o->CurrentChild);
}


// ::CProfileManager
//constructor: CProfileManager  ( ::CProfileManager::* )(  ) 
void* cProfileManager_new() {
	::CProfileManager *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::CProfileManager),16);
	o = new (mem)::CProfileManager();
	return (void*)o;
}
void cProfileManager_free(void *c) {
	::CProfileManager *o = (::CProfileManager*)c;
	delete o;
}
//method: Reset void (*)(  )
void cProfileManager_Reset() {
	::CProfileManager::Reset();
}
//method: dumpAll void (*)(  )
void cProfileManager_dumpAll() {
	::CProfileManager::dumpAll();
}
//method: Get_Frame_Count_Since_Reset int (*)(  )
int cProfileManager_Get_Frame_Count_Since_Reset() {
	int retVal = (int)::CProfileManager::Get_Frame_Count_Since_Reset();
	return retVal;
}
//method: Release_Iterator void (*)( ::CProfileIterator * )
void cProfileManager_Release_Iterator(void* p0) {
	::CProfileIterator * tp0 = (::CProfileIterator *)p0;
	::CProfileManager::Release_Iterator(tp0);
}
//method: Stop_Profile void (*)(  )
void cProfileManager_Stop_Profile() {
	::CProfileManager::Stop_Profile();
}
//method: CleanupMemory void (*)(  )
void cProfileManager_CleanupMemory() {
	::CProfileManager::CleanupMemory();
}
//method: Get_Time_Since_Reset float (*)(  )
float cProfileManager_Get_Time_Since_Reset() {
	float retVal = (float)::CProfileManager::Get_Time_Since_Reset();
	return retVal;
}
//method: Start_Profile void (*)( char const * )
void cProfileManager_Start_Profile(char const * p0) {
	::CProfileManager::Start_Profile(p0);
}
//method: Increment_Frame_Counter void (*)(  )
void cProfileManager_Increment_Frame_Counter() {
	::CProfileManager::Increment_Frame_Counter();
}
//method: dumpRecursive void (*)( ::CProfileIterator *,int )
void cProfileManager_dumpRecursive(void* p0,int p1) {
	::CProfileIterator * tp0 = (::CProfileIterator *)p0;
	::CProfileManager::dumpRecursive(tp0,p1);
}
//method: Get_Iterator ::CProfileIterator * (*)(  )
void* cProfileManager_Get_Iterator() {
	void* retVal = (void*) ::CProfileManager::Get_Iterator();
	return retVal;
}
//attribute: ::CProfileNode cProfileManager->Root
void cProfileManager_Root_set(void *c,void* a) {
	::CProfileManager *o = (::CProfileManager*)c;
	::CProfileNode & ta = *(::CProfileNode *)a;
	o->Root = ta;
}
void* cProfileManager_Root_get(void *c) {
	::CProfileManager *o = (::CProfileManager*)c;
	return (void*)&(o->Root);
}

//attribute: ::CProfileNode * cProfileManager->CurrentNode
void cProfileManager_CurrentNode_set(void *c,void* a) {
	::CProfileManager *o = (::CProfileManager*)c;
	::CProfileNode * ta = (::CProfileNode *)a;
	o->CurrentNode = ta;
}
void* cProfileManager_CurrentNode_get(void *c) {
	::CProfileManager *o = (::CProfileManager*)c;
	return (void*)(o->CurrentNode);
}

//attribute: int cProfileManager->FrameCounter
void cProfileManager_FrameCounter_set(void *c,int a) {
	::CProfileManager *o = (::CProfileManager*)c;
	o->FrameCounter = a;
}
int cProfileManager_FrameCounter_get(void *c) {
	::CProfileManager *o = (::CProfileManager*)c;
	return (int)(o->FrameCounter);
}

//attribute: long unsigned int cProfileManager->ResetTime
void cProfileManager_ResetTime_set(void *c,long unsigned int a) {
	::CProfileManager *o = (::CProfileManager*)c;
	o->ResetTime = a;
}
long unsigned int cProfileManager_ResetTime_get(void *c) {
	::CProfileManager *o = (::CProfileManager*)c;
	return (long unsigned int)(o->ResetTime);
}


// ::CProfileNode
//constructor: CProfileNode  ( ::CProfileNode::* )( char const *,::CProfileNode * ) 
void* cProfileNode_new(char const * p0,void* p1) {
	::CProfileNode *o = 0;
	 void *mem = 0;
	::CProfileNode * tp1 = (::CProfileNode *)p1;
	mem = btAlignedAlloc(sizeof(::CProfileNode),16);
	o = new (mem)::CProfileNode(p0,tp1);
	return (void*)o;
}
void cProfileNode_free(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	delete o;
}
//method: Reset void ( ::CProfileNode::* )(  ) 
void cProfileNode_Reset(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	o->Reset();
}
//method: Return bool ( ::CProfileNode::* )(  ) 
int cProfileNode_Return(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	int retVal = (int)o->Return();
	return retVal;
}
//method: SetUserPointer void ( ::CProfileNode::* )( void * ) 
void cProfileNode_SetUserPointer(void *c,void* p0) {
	::CProfileNode *o = (::CProfileNode*)c;
	void * tp0 = (void *)p0;
	o->SetUserPointer(tp0);
}
//method: Get_Sub_Node ::CProfileNode * ( ::CProfileNode::* )( char const * ) 
void* cProfileNode_Get_Sub_Node(void *c,char const * p0) {
	::CProfileNode *o = (::CProfileNode*)c;
	void* retVal = (void*) o->Get_Sub_Node(p0);
	return retVal;
}
//method: CleanupMemory void ( ::CProfileNode::* )(  ) 
void cProfileNode_CleanupMemory(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	o->CleanupMemory();
}
//method: Get_Parent ::CProfileNode * ( ::CProfileNode::* )(  ) 
void* cProfileNode_Get_Parent(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	void* retVal = (void*) o->Get_Parent();
	return retVal;
}
//method: GetUserPointer void * ( ::CProfileNode::* )(  ) const
void* cProfileNode_GetUserPointer(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	void* retVal = (void*) o->GetUserPointer();
	return retVal;
}
//method: Get_Name char const * ( ::CProfileNode::* )(  ) 
char const * cProfileNode_Get_Name(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	char const * retVal = (char const *)o->Get_Name();
	return retVal;
}
//method: Get_Total_Time float ( ::CProfileNode::* )(  ) 
float cProfileNode_Get_Total_Time(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	float retVal = (float)o->Get_Total_Time();
	return retVal;
}
//method: Call void ( ::CProfileNode::* )(  ) 
void cProfileNode_Call(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	o->Call();
}
//method: Get_Sibling ::CProfileNode * ( ::CProfileNode::* )(  ) 
void* cProfileNode_Get_Sibling(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	void* retVal = (void*) o->Get_Sibling();
	return retVal;
}
//method: Get_Child ::CProfileNode * ( ::CProfileNode::* )(  ) 
void* cProfileNode_Get_Child(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	void* retVal = (void*) o->Get_Child();
	return retVal;
}
//method: Get_Total_Calls int ( ::CProfileNode::* )(  ) 
int cProfileNode_Get_Total_Calls(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	int retVal = (int)o->Get_Total_Calls();
	return retVal;
}
//attribute: ::CProfileNode * cProfileNode->Child
void cProfileNode_Child_set(void *c,void* a) {
	::CProfileNode *o = (::CProfileNode*)c;
	::CProfileNode * ta = (::CProfileNode *)a;
	o->Child = ta;
}
void* cProfileNode_Child_get(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	return (void*)(o->Child);
}

//attribute: char const * cProfileNode->Name
void cProfileNode_Name_set(void *c,char const * a) {
	::CProfileNode *o = (::CProfileNode*)c;
	o->Name = a;
}
char const * cProfileNode_Name_get(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	return (char const *)(o->Name);
}

//attribute: ::CProfileNode * cProfileNode->Parent
void cProfileNode_Parent_set(void *c,void* a) {
	::CProfileNode *o = (::CProfileNode*)c;
	::CProfileNode * ta = (::CProfileNode *)a;
	o->Parent = ta;
}
void* cProfileNode_Parent_get(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	return (void*)(o->Parent);
}

//attribute: int cProfileNode->RecursionCounter
void cProfileNode_RecursionCounter_set(void *c,int a) {
	::CProfileNode *o = (::CProfileNode*)c;
	o->RecursionCounter = a;
}
int cProfileNode_RecursionCounter_get(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	return (int)(o->RecursionCounter);
}

//attribute: ::CProfileNode * cProfileNode->Sibling
void cProfileNode_Sibling_set(void *c,void* a) {
	::CProfileNode *o = (::CProfileNode*)c;
	::CProfileNode * ta = (::CProfileNode *)a;
	o->Sibling = ta;
}
void* cProfileNode_Sibling_get(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	return (void*)(o->Sibling);
}

//attribute: long unsigned int cProfileNode->StartTime
void cProfileNode_StartTime_set(void *c,long unsigned int a) {
	::CProfileNode *o = (::CProfileNode*)c;
	o->StartTime = a;
}
long unsigned int cProfileNode_StartTime_get(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	return (long unsigned int)(o->StartTime);
}

//attribute: int cProfileNode->TotalCalls
void cProfileNode_TotalCalls_set(void *c,int a) {
	::CProfileNode *o = (::CProfileNode*)c;
	o->TotalCalls = a;
}
int cProfileNode_TotalCalls_get(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	return (int)(o->TotalCalls);
}

//attribute: float cProfileNode->TotalTime
void cProfileNode_TotalTime_set(void *c,float a) {
	::CProfileNode *o = (::CProfileNode*)c;
	o->TotalTime = a;
}
float cProfileNode_TotalTime_get(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	return (float)(o->TotalTime);
}

//attribute: void * cProfileNode->m_userPtr
void cProfileNode_m_userPtr_set(void *c,void* a) {
	::CProfileNode *o = (::CProfileNode*)c;
	void * ta = (void *)a;
	o->m_userPtr = ta;
}
void* cProfileNode_m_userPtr_get(void *c) {
	::CProfileNode *o = (::CProfileNode*)c;
	return (void*)(o->m_userPtr);
}


// ::CProfileSample
//constructor: CProfileSample  ( ::CProfileSample::* )( char const * ) 
void* cProfileSample_new(char const * p0) {
	::CProfileSample *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::CProfileSample),16);
	o = new (mem)::CProfileSample(p0);
	return (void*)o;
}
void cProfileSample_free(void *c) {
	::CProfileSample *o = (::CProfileSample*)c;
	delete o;
}

// ::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )(  ) 
void* btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__new() {
	::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u >),16);
	o = new (mem)::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u >();
	return (void*)o;
}
void btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__free(void *c) {
	::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u > *o = (::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )( ::BT_QUANTIZED_BVH_NODE * ) 
void btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u > *o = (::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u >*)c;
	::BT_QUANTIZED_BVH_NODE * tp0 = (::BT_QUANTIZED_BVH_NODE *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )( ::BT_QUANTIZED_BVH_NODE * ) 
void btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u > *o = (::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u >*)c;
	::BT_QUANTIZED_BVH_NODE * tp0 = (::BT_QUANTIZED_BVH_NODE *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::BT_QUANTIZED_BVH_NODE * ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )( ::size_type,::BT_QUANTIZED_BVH_NODE const * * ) 
// error:  - unsupported,  - unsupported, ::BT_QUANTIZED_BVH_NODE * - ok

//method: construct void ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )( ::BT_QUANTIZED_BVH_NODE *,::BT_QUANTIZED_BVH_NODE const & ) 
void btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u > *o = (::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u >*)c;
	::BT_QUANTIZED_BVH_NODE * tp0 = (::BT_QUANTIZED_BVH_NODE *)p0;
	::BT_QUANTIZED_BVH_NODE const & tp1 = *(::BT_QUANTIZED_BVH_NODE const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::BT_QUANTIZED_BVH_NODE * ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )( ::BT_QUANTIZED_BVH_NODE & ) const
void* btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__address(void *c,void* p0) {
	::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u > *o = (::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u >*)c;
	::BT_QUANTIZED_BVH_NODE & tp0 = *(::BT_QUANTIZED_BVH_NODE *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::BT_QUANTIZED_BVH_NODE * ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )( ::BT_QUANTIZED_BVH_NODE & ) const
void* btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u > *o = (::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u >*)c;
	::BT_QUANTIZED_BVH_NODE & tp0 = *(::BT_QUANTIZED_BVH_NODE *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::BT_QUANTIZED_BVH_NODE const * ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )( ::BT_QUANTIZED_BVH_NODE const & ) const
void* btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u > *o = (::btAlignedAllocator< BT_QUANTIZED_BVH_NODE, 16u >*)c;
	::BT_QUANTIZED_BVH_NODE const & tp0 = *(::BT_QUANTIZED_BVH_NODE const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< GIM_BVH_DATA, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )(  ) 
void* btAlignedAllocator_GIM_BVH_DATA_16u__new() {
	::btAlignedAllocator< GIM_BVH_DATA, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< GIM_BVH_DATA, 16u >),16);
	o = new (mem)::btAlignedAllocator< GIM_BVH_DATA, 16u >();
	return (void*)o;
}
void btAlignedAllocator_GIM_BVH_DATA_16u__free(void *c) {
	::btAlignedAllocator< GIM_BVH_DATA, 16u > *o = (::btAlignedAllocator< GIM_BVH_DATA, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )( ::GIM_BVH_DATA * ) 
void btAlignedAllocator_GIM_BVH_DATA_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< GIM_BVH_DATA, 16u > *o = (::btAlignedAllocator< GIM_BVH_DATA, 16u >*)c;
	::GIM_BVH_DATA * tp0 = (::GIM_BVH_DATA *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )( ::GIM_BVH_DATA * ) 
void btAlignedAllocator_GIM_BVH_DATA_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< GIM_BVH_DATA, 16u > *o = (::btAlignedAllocator< GIM_BVH_DATA, 16u >*)c;
	::GIM_BVH_DATA * tp0 = (::GIM_BVH_DATA *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::GIM_BVH_DATA * ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )( ::size_type,::GIM_BVH_DATA const * * ) 
// error:  - unsupported,  - unsupported, ::GIM_BVH_DATA * - ok

//method: construct void ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )( ::GIM_BVH_DATA *,::GIM_BVH_DATA const & ) 
void btAlignedAllocator_GIM_BVH_DATA_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< GIM_BVH_DATA, 16u > *o = (::btAlignedAllocator< GIM_BVH_DATA, 16u >*)c;
	::GIM_BVH_DATA * tp0 = (::GIM_BVH_DATA *)p0;
	::GIM_BVH_DATA const & tp1 = *(::GIM_BVH_DATA const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::GIM_BVH_DATA * ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )( ::GIM_BVH_DATA & ) const
void* btAlignedAllocator_GIM_BVH_DATA_16u__address(void *c,void* p0) {
	::btAlignedAllocator< GIM_BVH_DATA, 16u > *o = (::btAlignedAllocator< GIM_BVH_DATA, 16u >*)c;
	::GIM_BVH_DATA & tp0 = *(::GIM_BVH_DATA *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::GIM_BVH_DATA * ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )( ::GIM_BVH_DATA & ) const
void* btAlignedAllocator_GIM_BVH_DATA_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< GIM_BVH_DATA, 16u > *o = (::btAlignedAllocator< GIM_BVH_DATA, 16u >*)c;
	::GIM_BVH_DATA & tp0 = *(::GIM_BVH_DATA *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::GIM_BVH_DATA const * ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )( ::GIM_BVH_DATA const & ) const
void* btAlignedAllocator_GIM_BVH_DATA_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< GIM_BVH_DATA, 16u > *o = (::btAlignedAllocator< GIM_BVH_DATA, 16u >*)c;
	::GIM_BVH_DATA const & tp0 = *(::GIM_BVH_DATA const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )(  ) 
void* btAlignedAllocator_GIM_BVH_TREE_NODE_16u__new() {
	::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u >),16);
	o = new (mem)::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u >();
	return (void*)o;
}
void btAlignedAllocator_GIM_BVH_TREE_NODE_16u__free(void *c) {
	::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u > *o = (::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )( ::GIM_BVH_TREE_NODE * ) 
void btAlignedAllocator_GIM_BVH_TREE_NODE_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u > *o = (::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u >*)c;
	::GIM_BVH_TREE_NODE * tp0 = (::GIM_BVH_TREE_NODE *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )( ::GIM_BVH_TREE_NODE * ) 
void btAlignedAllocator_GIM_BVH_TREE_NODE_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u > *o = (::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u >*)c;
	::GIM_BVH_TREE_NODE * tp0 = (::GIM_BVH_TREE_NODE *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::GIM_BVH_TREE_NODE * ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )( ::size_type,::GIM_BVH_TREE_NODE const * * ) 
// error:  - unsupported,  - unsupported, ::GIM_BVH_TREE_NODE * - ok

//method: construct void ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )( ::GIM_BVH_TREE_NODE *,::GIM_BVH_TREE_NODE const & ) 
void btAlignedAllocator_GIM_BVH_TREE_NODE_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u > *o = (::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u >*)c;
	::GIM_BVH_TREE_NODE * tp0 = (::GIM_BVH_TREE_NODE *)p0;
	::GIM_BVH_TREE_NODE const & tp1 = *(::GIM_BVH_TREE_NODE const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::GIM_BVH_TREE_NODE * ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )( ::GIM_BVH_TREE_NODE & ) const
void* btAlignedAllocator_GIM_BVH_TREE_NODE_16u__address(void *c,void* p0) {
	::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u > *o = (::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u >*)c;
	::GIM_BVH_TREE_NODE & tp0 = *(::GIM_BVH_TREE_NODE *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::GIM_BVH_TREE_NODE * ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )( ::GIM_BVH_TREE_NODE & ) const
void* btAlignedAllocator_GIM_BVH_TREE_NODE_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u > *o = (::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u >*)c;
	::GIM_BVH_TREE_NODE & tp0 = *(::GIM_BVH_TREE_NODE *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::GIM_BVH_TREE_NODE const * ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )( ::GIM_BVH_TREE_NODE const & ) const
void* btAlignedAllocator_GIM_BVH_TREE_NODE_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u > *o = (::btAlignedAllocator< GIM_BVH_TREE_NODE, 16u >*)c;
	::GIM_BVH_TREE_NODE const & tp0 = *(::GIM_BVH_TREE_NODE const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< GIM_PAIR, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )(  ) 
void* btAlignedAllocator_GIM_PAIR_16u__new() {
	::btAlignedAllocator< GIM_PAIR, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< GIM_PAIR, 16u >),16);
	o = new (mem)::btAlignedAllocator< GIM_PAIR, 16u >();
	return (void*)o;
}
void btAlignedAllocator_GIM_PAIR_16u__free(void *c) {
	::btAlignedAllocator< GIM_PAIR, 16u > *o = (::btAlignedAllocator< GIM_PAIR, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )( ::GIM_PAIR * ) 
void btAlignedAllocator_GIM_PAIR_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< GIM_PAIR, 16u > *o = (::btAlignedAllocator< GIM_PAIR, 16u >*)c;
	::GIM_PAIR * tp0 = (::GIM_PAIR *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )( ::GIM_PAIR * ) 
void btAlignedAllocator_GIM_PAIR_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< GIM_PAIR, 16u > *o = (::btAlignedAllocator< GIM_PAIR, 16u >*)c;
	::GIM_PAIR * tp0 = (::GIM_PAIR *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::GIM_PAIR * ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )( ::size_type,::GIM_PAIR const * * ) 
// error:  - unsupported,  - unsupported, ::GIM_PAIR * - ok

//method: construct void ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )( ::GIM_PAIR *,::GIM_PAIR const & ) 
void btAlignedAllocator_GIM_PAIR_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< GIM_PAIR, 16u > *o = (::btAlignedAllocator< GIM_PAIR, 16u >*)c;
	::GIM_PAIR * tp0 = (::GIM_PAIR *)p0;
	::GIM_PAIR const & tp1 = *(::GIM_PAIR const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::GIM_PAIR * ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )( ::GIM_PAIR & ) const
void* btAlignedAllocator_GIM_PAIR_16u__address(void *c,void* p0) {
	::btAlignedAllocator< GIM_PAIR, 16u > *o = (::btAlignedAllocator< GIM_PAIR, 16u >*)c;
	::GIM_PAIR & tp0 = *(::GIM_PAIR *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::GIM_PAIR * ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )( ::GIM_PAIR & ) const
void* btAlignedAllocator_GIM_PAIR_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< GIM_PAIR, 16u > *o = (::btAlignedAllocator< GIM_PAIR, 16u >*)c;
	::GIM_PAIR & tp0 = *(::GIM_PAIR *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::GIM_PAIR const * ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )( ::GIM_PAIR const & ) const
void* btAlignedAllocator_GIM_PAIR_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< GIM_PAIR, 16u > *o = (::btAlignedAllocator< GIM_PAIR, 16u >*)c;
	::GIM_PAIR const & tp0 = *(::GIM_PAIR const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< bool, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<bool, 16u>::* )(  ) 
void* btAlignedAllocator_bool_16u__new() {
	::btAlignedAllocator< bool, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< bool, 16u >),16);
	o = new (mem)::btAlignedAllocator< bool, 16u >();
	return (void*)o;
}
void btAlignedAllocator_bool_16u__free(void *c) {
	::btAlignedAllocator< bool, 16u > *o = (::btAlignedAllocator< bool, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<bool, 16u>::* )( bool * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<bool, 16u>::* )( bool * ) 
// error:  - unsupported, void - ok

//not supported method: allocate bool * ( ::btAlignedAllocator<bool, 16u>::* )( ::size_type,bool const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<bool, 16u>::* )( bool *,bool const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address bool * ( ::btAlignedAllocator<bool, 16u>::* )( bool & ) const
// error:  - unsupported,  - unsupported

//not supported method: address bool * ( ::btAlignedAllocator<bool, 16u>::* )( bool & ) const
// error:  - unsupported,  - unsupported

//not supported method: address bool const * ( ::btAlignedAllocator<bool, 16u>::* )( bool const & ) const
// error:  - unsupported,  - unsupported


// ::btAlignedAllocator< btActionInterface*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btActionInterface*, 16u>::* )(  ) 
void* btAlignedAllocator_btActionInterface_ptr_16u__new() {
	::btAlignedAllocator< btActionInterface*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btActionInterface*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btActionInterface*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btActionInterface_ptr_16u__free(void *c) {
	::btAlignedAllocator< btActionInterface*, 16u > *o = (::btAlignedAllocator< btActionInterface*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btActionInterface*, 16u>::* )( ::btActionInterface * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btActionInterface*, 16u>::* )( ::btActionInterface * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btActionInterface * * ( ::btAlignedAllocator<btActionInterface*, 16u>::* )( ::size_type,::btActionInterface * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btActionInterface*, 16u>::* )( ::btActionInterface * *,::btActionInterface * const & ) 
// error:  - unsupported, ::btActionInterface * - ok, void - ok

//not supported method: address ::btActionInterface * * ( ::btAlignedAllocator<btActionInterface*, 16u>::* )( ::btActionInterface * & ) const
// error: ::btActionInterface * - ok,  - unsupported

//not supported method: address ::btActionInterface * * ( ::btAlignedAllocator<btActionInterface*, 16u>::* )( ::btActionInterface * & ) const
// error: ::btActionInterface * - ok,  - unsupported

//not supported method: address ::btActionInterface * const * ( ::btAlignedAllocator<btActionInterface*, 16u>::* )( ::btActionInterface * const & ) const
// error: ::btActionInterface * - ok,  - unsupported


// ::btAlignedAllocator< btBroadphaseInterface*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )(  ) 
void* btAlignedAllocator_btBroadphaseInterface_ptr_16u__new() {
	::btAlignedAllocator< btBroadphaseInterface*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btBroadphaseInterface*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btBroadphaseInterface*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btBroadphaseInterface_ptr_16u__free(void *c) {
	::btAlignedAllocator< btBroadphaseInterface*, 16u > *o = (::btAlignedAllocator< btBroadphaseInterface*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )( ::btBroadphaseInterface * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )( ::btBroadphaseInterface * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btBroadphaseInterface * * ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )( ::size_type,::btBroadphaseInterface * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )( ::btBroadphaseInterface * *,::btBroadphaseInterface * const & ) 
// error:  - unsupported, ::btBroadphaseInterface * - ok, void - ok

//not supported method: address ::btBroadphaseInterface * * ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )( ::btBroadphaseInterface * & ) const
// error: ::btBroadphaseInterface * - ok,  - unsupported

//not supported method: address ::btBroadphaseInterface * * ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )( ::btBroadphaseInterface * & ) const
// error: ::btBroadphaseInterface * - ok,  - unsupported

//not supported method: address ::btBroadphaseInterface * const * ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )( ::btBroadphaseInterface * const & ) const
// error: ::btBroadphaseInterface * - ok,  - unsupported


// ::btAlignedAllocator< btBroadphasePair, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )(  ) 
void* btAlignedAllocator_btBroadphasePair_16u__new() {
	::btAlignedAllocator< btBroadphasePair, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btBroadphasePair, 16u >),16);
	o = new (mem)::btAlignedAllocator< btBroadphasePair, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btBroadphasePair_16u__free(void *c) {
	::btAlignedAllocator< btBroadphasePair, 16u > *o = (::btAlignedAllocator< btBroadphasePair, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )( ::btBroadphasePair * ) 
void btAlignedAllocator_btBroadphasePair_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btBroadphasePair, 16u > *o = (::btAlignedAllocator< btBroadphasePair, 16u >*)c;
	::btBroadphasePair * tp0 = (::btBroadphasePair *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )( ::btBroadphasePair * ) 
void btAlignedAllocator_btBroadphasePair_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btBroadphasePair, 16u > *o = (::btAlignedAllocator< btBroadphasePair, 16u >*)c;
	::btBroadphasePair * tp0 = (::btBroadphasePair *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btBroadphasePair * ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )( ::size_type,::btBroadphasePair const * * ) 
// error:  - unsupported,  - unsupported, ::btBroadphasePair * - ok

//method: construct void ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )( ::btBroadphasePair *,::btBroadphasePair const & ) 
void btAlignedAllocator_btBroadphasePair_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btBroadphasePair, 16u > *o = (::btAlignedAllocator< btBroadphasePair, 16u >*)c;
	::btBroadphasePair * tp0 = (::btBroadphasePair *)p0;
	::btBroadphasePair const & tp1 = *(::btBroadphasePair const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btBroadphasePair * ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )( ::btBroadphasePair & ) const
void* btAlignedAllocator_btBroadphasePair_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btBroadphasePair, 16u > *o = (::btAlignedAllocator< btBroadphasePair, 16u >*)c;
	::btBroadphasePair & tp0 = *(::btBroadphasePair *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btBroadphasePair * ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )( ::btBroadphasePair & ) const
void* btAlignedAllocator_btBroadphasePair_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btBroadphasePair, 16u > *o = (::btAlignedAllocator< btBroadphasePair, 16u >*)c;
	::btBroadphasePair & tp0 = *(::btBroadphasePair *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btBroadphasePair const * ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )( ::btBroadphasePair const & ) const
void* btAlignedAllocator_btBroadphasePair_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btBroadphasePair, 16u > *o = (::btAlignedAllocator< btBroadphasePair, 16u >*)c;
	::btBroadphasePair const & tp0 = *(::btBroadphasePair const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btBvhSubtreeInfo, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )(  ) 
void* btAlignedAllocator_btBvhSubtreeInfo_16u__new() {
	::btAlignedAllocator< btBvhSubtreeInfo, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btBvhSubtreeInfo, 16u >),16);
	o = new (mem)::btAlignedAllocator< btBvhSubtreeInfo, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btBvhSubtreeInfo_16u__free(void *c) {
	::btAlignedAllocator< btBvhSubtreeInfo, 16u > *o = (::btAlignedAllocator< btBvhSubtreeInfo, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )( ::btBvhSubtreeInfo * ) 
void btAlignedAllocator_btBvhSubtreeInfo_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btBvhSubtreeInfo, 16u > *o = (::btAlignedAllocator< btBvhSubtreeInfo, 16u >*)c;
	::btBvhSubtreeInfo * tp0 = (::btBvhSubtreeInfo *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )( ::btBvhSubtreeInfo * ) 
void btAlignedAllocator_btBvhSubtreeInfo_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btBvhSubtreeInfo, 16u > *o = (::btAlignedAllocator< btBvhSubtreeInfo, 16u >*)c;
	::btBvhSubtreeInfo * tp0 = (::btBvhSubtreeInfo *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btBvhSubtreeInfo * ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )( ::size_type,::btBvhSubtreeInfo const * * ) 
// error:  - unsupported,  - unsupported, ::btBvhSubtreeInfo * - ok

//method: construct void ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )( ::btBvhSubtreeInfo *,::btBvhSubtreeInfo const & ) 
void btAlignedAllocator_btBvhSubtreeInfo_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btBvhSubtreeInfo, 16u > *o = (::btAlignedAllocator< btBvhSubtreeInfo, 16u >*)c;
	::btBvhSubtreeInfo * tp0 = (::btBvhSubtreeInfo *)p0;
	::btBvhSubtreeInfo const & tp1 = *(::btBvhSubtreeInfo const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btBvhSubtreeInfo * ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )( ::btBvhSubtreeInfo & ) const
void* btAlignedAllocator_btBvhSubtreeInfo_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btBvhSubtreeInfo, 16u > *o = (::btAlignedAllocator< btBvhSubtreeInfo, 16u >*)c;
	::btBvhSubtreeInfo & tp0 = *(::btBvhSubtreeInfo *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btBvhSubtreeInfo * ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )( ::btBvhSubtreeInfo & ) const
void* btAlignedAllocator_btBvhSubtreeInfo_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btBvhSubtreeInfo, 16u > *o = (::btAlignedAllocator< btBvhSubtreeInfo, 16u >*)c;
	::btBvhSubtreeInfo & tp0 = *(::btBvhSubtreeInfo *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btBvhSubtreeInfo const * ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )( ::btBvhSubtreeInfo const & ) const
void* btAlignedAllocator_btBvhSubtreeInfo_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btBvhSubtreeInfo, 16u > *o = (::btAlignedAllocator< btBvhSubtreeInfo, 16u >*)c;
	::btBvhSubtreeInfo const & tp0 = *(::btBvhSubtreeInfo const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btChunk*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btChunk*, 16u>::* )(  ) 
void* btAlignedAllocator_btChunk_ptr_16u__new() {
	::btAlignedAllocator< btChunk*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btChunk*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btChunk*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btChunk_ptr_16u__free(void *c) {
	::btAlignedAllocator< btChunk*, 16u > *o = (::btAlignedAllocator< btChunk*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btChunk*, 16u>::* )( ::btChunk * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btChunk*, 16u>::* )( ::btChunk * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btChunk * * ( ::btAlignedAllocator<btChunk*, 16u>::* )( ::size_type,::btChunk * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btChunk*, 16u>::* )( ::btChunk * *,::btChunk * const & ) 
// error:  - unsupported, ::btChunk * - ok, void - ok

//not supported method: address ::btChunk * * ( ::btAlignedAllocator<btChunk*, 16u>::* )( ::btChunk * & ) const
// error: ::btChunk * - ok,  - unsupported

//not supported method: address ::btChunk * * ( ::btAlignedAllocator<btChunk*, 16u>::* )( ::btChunk * & ) const
// error: ::btChunk * - ok,  - unsupported

//not supported method: address ::btChunk * const * ( ::btAlignedAllocator<btChunk*, 16u>::* )( ::btChunk * const & ) const
// error: ::btChunk * - ok,  - unsupported


// ::btAlignedAllocator< btCollisionObject*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )(  ) 
void* btAlignedAllocator_btCollisionObject_ptr_16u__new() {
	::btAlignedAllocator< btCollisionObject*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btCollisionObject*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btCollisionObject*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btCollisionObject_ptr_16u__free(void *c) {
	::btAlignedAllocator< btCollisionObject*, 16u > *o = (::btAlignedAllocator< btCollisionObject*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )( ::btCollisionObject * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )( ::btCollisionObject * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btCollisionObject * * ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )( ::size_type,::btCollisionObject * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )( ::btCollisionObject * *,::btCollisionObject * const & ) 
// error:  - unsupported, ::btCollisionObject * - ok, void - ok

//not supported method: address ::btCollisionObject * * ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )( ::btCollisionObject * & ) const
// error: ::btCollisionObject * - ok,  - unsupported

//not supported method: address ::btCollisionObject * * ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )( ::btCollisionObject * & ) const
// error: ::btCollisionObject * - ok,  - unsupported

//not supported method: address ::btCollisionObject * const * ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )( ::btCollisionObject * const & ) const
// error: ::btCollisionObject * - ok,  - unsupported


// ::btAlignedAllocator< btCollisionShape*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )(  ) 
void* btAlignedAllocator_btCollisionShape_ptr_16u__new() {
	::btAlignedAllocator< btCollisionShape*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btCollisionShape*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btCollisionShape*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btCollisionShape_ptr_16u__free(void *c) {
	::btAlignedAllocator< btCollisionShape*, 16u > *o = (::btAlignedAllocator< btCollisionShape*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )( ::btCollisionShape * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )( ::btCollisionShape * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btCollisionShape * * ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )( ::size_type,::btCollisionShape * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )( ::btCollisionShape * *,::btCollisionShape * const & ) 
// error:  - unsupported, ::btCollisionShape * - ok, void - ok

//not supported method: address ::btCollisionShape * * ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )( ::btCollisionShape * & ) const
// error: ::btCollisionShape * - ok,  - unsupported

//not supported method: address ::btCollisionShape * * ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )( ::btCollisionShape * & ) const
// error: ::btCollisionShape * - ok,  - unsupported

//not supported method: address ::btCollisionShape * const * ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )( ::btCollisionShape * const & ) const
// error: ::btCollisionShape * - ok,  - unsupported


// ::btAlignedAllocator< btCompoundShapeChild, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )(  ) 
void* btAlignedAllocator_btCompoundShapeChild_16u__new() {
	::btAlignedAllocator< btCompoundShapeChild, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btCompoundShapeChild, 16u >),16);
	o = new (mem)::btAlignedAllocator< btCompoundShapeChild, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btCompoundShapeChild_16u__free(void *c) {
	::btAlignedAllocator< btCompoundShapeChild, 16u > *o = (::btAlignedAllocator< btCompoundShapeChild, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )( ::btCompoundShapeChild * ) 
void btAlignedAllocator_btCompoundShapeChild_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btCompoundShapeChild, 16u > *o = (::btAlignedAllocator< btCompoundShapeChild, 16u >*)c;
	::btCompoundShapeChild * tp0 = (::btCompoundShapeChild *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )( ::btCompoundShapeChild * ) 
void btAlignedAllocator_btCompoundShapeChild_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btCompoundShapeChild, 16u > *o = (::btAlignedAllocator< btCompoundShapeChild, 16u >*)c;
	::btCompoundShapeChild * tp0 = (::btCompoundShapeChild *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btCompoundShapeChild * ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )( ::size_type,::btCompoundShapeChild const * * ) 
// error:  - unsupported,  - unsupported, ::btCompoundShapeChild * - ok

//method: construct void ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )( ::btCompoundShapeChild *,::btCompoundShapeChild const & ) 
void btAlignedAllocator_btCompoundShapeChild_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btCompoundShapeChild, 16u > *o = (::btAlignedAllocator< btCompoundShapeChild, 16u >*)c;
	::btCompoundShapeChild * tp0 = (::btCompoundShapeChild *)p0;
	::btCompoundShapeChild const & tp1 = *(::btCompoundShapeChild const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btCompoundShapeChild * ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )( ::btCompoundShapeChild & ) const
void* btAlignedAllocator_btCompoundShapeChild_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btCompoundShapeChild, 16u > *o = (::btAlignedAllocator< btCompoundShapeChild, 16u >*)c;
	::btCompoundShapeChild & tp0 = *(::btCompoundShapeChild *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btCompoundShapeChild * ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )( ::btCompoundShapeChild & ) const
void* btAlignedAllocator_btCompoundShapeChild_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btCompoundShapeChild, 16u > *o = (::btAlignedAllocator< btCompoundShapeChild, 16u >*)c;
	::btCompoundShapeChild & tp0 = *(::btCompoundShapeChild *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btCompoundShapeChild const * ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )( ::btCompoundShapeChild const & ) const
void* btAlignedAllocator_btCompoundShapeChild_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btCompoundShapeChild, 16u > *o = (::btAlignedAllocator< btCompoundShapeChild, 16u >*)c;
	::btCompoundShapeChild const & tp0 = *(::btCompoundShapeChild const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btDbvt::sStkNN, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )(  ) 
void* btAlignedAllocator_btDbvt_sStkNN_16u__new() {
	::btAlignedAllocator< btDbvt::sStkNN, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btDbvt::sStkNN, 16u >),16);
	o = new (mem)::btAlignedAllocator< btDbvt::sStkNN, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btDbvt_sStkNN_16u__free(void *c) {
	::btAlignedAllocator< btDbvt::sStkNN, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNN, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )( ::btDbvt::sStkNN * ) 
void btAlignedAllocator_btDbvt_sStkNN_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btDbvt::sStkNN, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNN, 16u >*)c;
	::btDbvt::sStkNN * tp0 = (::btDbvt::sStkNN *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )( ::btDbvt::sStkNN * ) 
void btAlignedAllocator_btDbvt_sStkNN_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btDbvt::sStkNN, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNN, 16u >*)c;
	::btDbvt::sStkNN * tp0 = (::btDbvt::sStkNN *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btDbvt::sStkNN * ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )( ::size_type,::btDbvt::sStkNN const * * ) 
// error:  - unsupported,  - unsupported, ::btDbvt::sStkNN * - ok

//method: construct void ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )( ::btDbvt::sStkNN *,::btDbvt::sStkNN const & ) 
void btAlignedAllocator_btDbvt_sStkNN_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btDbvt::sStkNN, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNN, 16u >*)c;
	::btDbvt::sStkNN * tp0 = (::btDbvt::sStkNN *)p0;
	::btDbvt::sStkNN const & tp1 = *(::btDbvt::sStkNN const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btDbvt::sStkNN * ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )( ::btDbvt::sStkNN & ) const
void* btAlignedAllocator_btDbvt_sStkNN_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btDbvt::sStkNN, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNN, 16u >*)c;
	::btDbvt::sStkNN & tp0 = *(::btDbvt::sStkNN *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btDbvt::sStkNN * ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )( ::btDbvt::sStkNN & ) const
void* btAlignedAllocator_btDbvt_sStkNN_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btDbvt::sStkNN, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNN, 16u >*)c;
	::btDbvt::sStkNN & tp0 = *(::btDbvt::sStkNN *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btDbvt::sStkNN const * ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )( ::btDbvt::sStkNN const & ) const
void* btAlignedAllocator_btDbvt_sStkNN_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btDbvt::sStkNN, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNN, 16u >*)c;
	::btDbvt::sStkNN const & tp0 = *(::btDbvt::sStkNN const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btDbvt::sStkNP, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )(  ) 
void* btAlignedAllocator_btDbvt_sStkNP_16u__new() {
	::btAlignedAllocator< btDbvt::sStkNP, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btDbvt::sStkNP, 16u >),16);
	o = new (mem)::btAlignedAllocator< btDbvt::sStkNP, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btDbvt_sStkNP_16u__free(void *c) {
	::btAlignedAllocator< btDbvt::sStkNP, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNP, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )( ::btDbvt::sStkNP * ) 
void btAlignedAllocator_btDbvt_sStkNP_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btDbvt::sStkNP, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNP, 16u >*)c;
	::btDbvt::sStkNP * tp0 = (::btDbvt::sStkNP *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )( ::btDbvt::sStkNP * ) 
void btAlignedAllocator_btDbvt_sStkNP_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btDbvt::sStkNP, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNP, 16u >*)c;
	::btDbvt::sStkNP * tp0 = (::btDbvt::sStkNP *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btDbvt::sStkNP * ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )( ::size_type,::btDbvt::sStkNP const * * ) 
// error:  - unsupported,  - unsupported, ::btDbvt::sStkNP * - ok

//method: construct void ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )( ::btDbvt::sStkNP *,::btDbvt::sStkNP const & ) 
void btAlignedAllocator_btDbvt_sStkNP_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btDbvt::sStkNP, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNP, 16u >*)c;
	::btDbvt::sStkNP * tp0 = (::btDbvt::sStkNP *)p0;
	::btDbvt::sStkNP const & tp1 = *(::btDbvt::sStkNP const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btDbvt::sStkNP * ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )( ::btDbvt::sStkNP & ) const
void* btAlignedAllocator_btDbvt_sStkNP_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btDbvt::sStkNP, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNP, 16u >*)c;
	::btDbvt::sStkNP & tp0 = *(::btDbvt::sStkNP *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btDbvt::sStkNP * ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )( ::btDbvt::sStkNP & ) const
void* btAlignedAllocator_btDbvt_sStkNP_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btDbvt::sStkNP, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNP, 16u >*)c;
	::btDbvt::sStkNP & tp0 = *(::btDbvt::sStkNP *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btDbvt::sStkNP const * ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )( ::btDbvt::sStkNP const & ) const
void* btAlignedAllocator_btDbvt_sStkNP_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btDbvt::sStkNP, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNP, 16u >*)c;
	::btDbvt::sStkNP const & tp0 = *(::btDbvt::sStkNP const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btDbvt::sStkNPS, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )(  ) 
void* btAlignedAllocator_btDbvt_sStkNPS_16u__new() {
	::btAlignedAllocator< btDbvt::sStkNPS, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btDbvt::sStkNPS, 16u >),16);
	o = new (mem)::btAlignedAllocator< btDbvt::sStkNPS, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btDbvt_sStkNPS_16u__free(void *c) {
	::btAlignedAllocator< btDbvt::sStkNPS, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNPS, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )( ::btDbvt::sStkNPS * ) 
void btAlignedAllocator_btDbvt_sStkNPS_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btDbvt::sStkNPS, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNPS, 16u >*)c;
	::btDbvt::sStkNPS * tp0 = (::btDbvt::sStkNPS *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )( ::btDbvt::sStkNPS * ) 
void btAlignedAllocator_btDbvt_sStkNPS_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btDbvt::sStkNPS, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNPS, 16u >*)c;
	::btDbvt::sStkNPS * tp0 = (::btDbvt::sStkNPS *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btDbvt::sStkNPS * ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )( ::size_type,::btDbvt::sStkNPS const * * ) 
// error:  - unsupported,  - unsupported, ::btDbvt::sStkNPS * - ok

//method: construct void ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )( ::btDbvt::sStkNPS *,::btDbvt::sStkNPS const & ) 
void btAlignedAllocator_btDbvt_sStkNPS_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btDbvt::sStkNPS, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNPS, 16u >*)c;
	::btDbvt::sStkNPS * tp0 = (::btDbvt::sStkNPS *)p0;
	::btDbvt::sStkNPS const & tp1 = *(::btDbvt::sStkNPS const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btDbvt::sStkNPS * ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )( ::btDbvt::sStkNPS & ) const
void* btAlignedAllocator_btDbvt_sStkNPS_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btDbvt::sStkNPS, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNPS, 16u >*)c;
	::btDbvt::sStkNPS & tp0 = *(::btDbvt::sStkNPS *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btDbvt::sStkNPS * ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )( ::btDbvt::sStkNPS & ) const
void* btAlignedAllocator_btDbvt_sStkNPS_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btDbvt::sStkNPS, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNPS, 16u >*)c;
	::btDbvt::sStkNPS & tp0 = *(::btDbvt::sStkNPS *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btDbvt::sStkNPS const * ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )( ::btDbvt::sStkNPS const & ) const
void* btAlignedAllocator_btDbvt_sStkNPS_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btDbvt::sStkNPS, 16u > *o = (::btAlignedAllocator< btDbvt::sStkNPS, 16u >*)c;
	::btDbvt::sStkNPS const & tp0 = *(::btDbvt::sStkNPS const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btDbvtNode const*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )(  ) 
void* btAlignedAllocator_btDbvtNodeconst_ptr_16u__new() {
	::btAlignedAllocator< btDbvtNode const*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btDbvtNode const*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btDbvtNode const*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btDbvtNodeconst_ptr_16u__free(void *c) {
	::btAlignedAllocator< btDbvtNode const*, 16u > *o = (::btAlignedAllocator< btDbvtNode const*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )( ::btDbvtNode const * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )( ::btDbvtNode const * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btDbvtNode const * * ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )( ::size_type,::btDbvtNode const * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )( ::btDbvtNode const * *,::btDbvtNode const * const & ) 
// error:  - unsupported, ::btDbvtNode const * - ok, void - ok

//not supported method: address ::btDbvtNode const * * ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )( ::btDbvtNode const * & ) const
// error: ::btDbvtNode const * - ok,  - unsupported

//not supported method: address ::btDbvtNode const * * ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )( ::btDbvtNode const * & ) const
// error: ::btDbvtNode const * - ok,  - unsupported

//not supported method: address ::btDbvtNode const * const * ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )( ::btDbvtNode const * const & ) const
// error: ::btDbvtNode const * - ok,  - unsupported


// ::btAlignedAllocator< btGImpactMeshShapePart*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )(  ) 
void* btAlignedAllocator_btGImpactMeshShapePart_ptr_16u__new() {
	::btAlignedAllocator< btGImpactMeshShapePart*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btGImpactMeshShapePart*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btGImpactMeshShapePart*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btGImpactMeshShapePart_ptr_16u__free(void *c) {
	::btAlignedAllocator< btGImpactMeshShapePart*, 16u > *o = (::btAlignedAllocator< btGImpactMeshShapePart*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )( ::btGImpactMeshShapePart * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )( ::btGImpactMeshShapePart * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btGImpactMeshShapePart * * ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )( ::size_type,::btGImpactMeshShapePart * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )( ::btGImpactMeshShapePart * *,::btGImpactMeshShapePart * const & ) 
// error:  - unsupported, ::btGImpactMeshShapePart * - ok, void - ok

//not supported method: address ::btGImpactMeshShapePart * * ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )( ::btGImpactMeshShapePart * & ) const
// error: ::btGImpactMeshShapePart * - ok,  - unsupported

//not supported method: address ::btGImpactMeshShapePart * * ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )( ::btGImpactMeshShapePart * & ) const
// error: ::btGImpactMeshShapePart * - ok,  - unsupported

//not supported method: address ::btGImpactMeshShapePart * const * ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )( ::btGImpactMeshShapePart * const & ) const
// error: ::btGImpactMeshShapePart * - ok,  - unsupported


// ::btAlignedAllocator< btHashInt, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btHashInt, 16u>::* )(  ) 
void* btAlignedAllocator_btHashInt_16u__new() {
	::btAlignedAllocator< btHashInt, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btHashInt, 16u >),16);
	o = new (mem)::btAlignedAllocator< btHashInt, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btHashInt_16u__free(void *c) {
	::btAlignedAllocator< btHashInt, 16u > *o = (::btAlignedAllocator< btHashInt, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btHashInt, 16u>::* )( ::btHashInt * ) 
void btAlignedAllocator_btHashInt_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btHashInt, 16u > *o = (::btAlignedAllocator< btHashInt, 16u >*)c;
	::btHashInt * tp0 = (::btHashInt *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btHashInt, 16u>::* )( ::btHashInt * ) 
void btAlignedAllocator_btHashInt_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btHashInt, 16u > *o = (::btAlignedAllocator< btHashInt, 16u >*)c;
	::btHashInt * tp0 = (::btHashInt *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btHashInt * ( ::btAlignedAllocator<btHashInt, 16u>::* )( ::size_type,::btHashInt const * * ) 
// error:  - unsupported,  - unsupported, ::btHashInt * - ok

//method: construct void ( ::btAlignedAllocator<btHashInt, 16u>::* )( ::btHashInt *,::btHashInt const & ) 
void btAlignedAllocator_btHashInt_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btHashInt, 16u > *o = (::btAlignedAllocator< btHashInt, 16u >*)c;
	::btHashInt * tp0 = (::btHashInt *)p0;
	::btHashInt const & tp1 = *(::btHashInt const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btHashInt * ( ::btAlignedAllocator<btHashInt, 16u>::* )( ::btHashInt & ) const
void* btAlignedAllocator_btHashInt_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btHashInt, 16u > *o = (::btAlignedAllocator< btHashInt, 16u >*)c;
	::btHashInt & tp0 = *(::btHashInt *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btHashInt * ( ::btAlignedAllocator<btHashInt, 16u>::* )( ::btHashInt & ) const
void* btAlignedAllocator_btHashInt_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btHashInt, 16u > *o = (::btAlignedAllocator< btHashInt, 16u >*)c;
	::btHashInt & tp0 = *(::btHashInt *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btHashInt const * ( ::btAlignedAllocator<btHashInt, 16u>::* )( ::btHashInt const & ) const
void* btAlignedAllocator_btHashInt_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btHashInt, 16u > *o = (::btAlignedAllocator< btHashInt, 16u >*)c;
	::btHashInt const & tp0 = *(::btHashInt const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btHashPtr, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btHashPtr, 16u>::* )(  ) 
void* btAlignedAllocator_btHashPtr_16u__new() {
	::btAlignedAllocator< btHashPtr, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btHashPtr, 16u >),16);
	o = new (mem)::btAlignedAllocator< btHashPtr, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btHashPtr_16u__free(void *c) {
	::btAlignedAllocator< btHashPtr, 16u > *o = (::btAlignedAllocator< btHashPtr, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btHashPtr, 16u>::* )( ::btHashPtr * ) 
void btAlignedAllocator_btHashPtr_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btHashPtr, 16u > *o = (::btAlignedAllocator< btHashPtr, 16u >*)c;
	::btHashPtr * tp0 = (::btHashPtr *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btHashPtr, 16u>::* )( ::btHashPtr * ) 
void btAlignedAllocator_btHashPtr_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btHashPtr, 16u > *o = (::btAlignedAllocator< btHashPtr, 16u >*)c;
	::btHashPtr * tp0 = (::btHashPtr *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btHashPtr * ( ::btAlignedAllocator<btHashPtr, 16u>::* )( ::size_type,::btHashPtr const * * ) 
// error:  - unsupported,  - unsupported, ::btHashPtr * - ok

//method: construct void ( ::btAlignedAllocator<btHashPtr, 16u>::* )( ::btHashPtr *,::btHashPtr const & ) 
void btAlignedAllocator_btHashPtr_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btHashPtr, 16u > *o = (::btAlignedAllocator< btHashPtr, 16u >*)c;
	::btHashPtr * tp0 = (::btHashPtr *)p0;
	::btHashPtr const & tp1 = *(::btHashPtr const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btHashPtr * ( ::btAlignedAllocator<btHashPtr, 16u>::* )( ::btHashPtr & ) const
void* btAlignedAllocator_btHashPtr_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btHashPtr, 16u > *o = (::btAlignedAllocator< btHashPtr, 16u >*)c;
	::btHashPtr & tp0 = *(::btHashPtr *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btHashPtr * ( ::btAlignedAllocator<btHashPtr, 16u>::* )( ::btHashPtr & ) const
void* btAlignedAllocator_btHashPtr_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btHashPtr, 16u > *o = (::btAlignedAllocator< btHashPtr, 16u >*)c;
	::btHashPtr & tp0 = *(::btHashPtr *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btHashPtr const * ( ::btAlignedAllocator<btHashPtr, 16u>::* )( ::btHashPtr const & ) const
void* btAlignedAllocator_btHashPtr_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btHashPtr, 16u > *o = (::btAlignedAllocator< btHashPtr, 16u >*)c;
	::btHashPtr const & tp0 = *(::btHashPtr const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btHashString, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btHashString, 16u>::* )(  ) 
void* btAlignedAllocator_btHashString_16u__new() {
	::btAlignedAllocator< btHashString, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btHashString, 16u >),16);
	o = new (mem)::btAlignedAllocator< btHashString, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btHashString_16u__free(void *c) {
	::btAlignedAllocator< btHashString, 16u > *o = (::btAlignedAllocator< btHashString, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btHashString, 16u>::* )( ::btHashString * ) 
void btAlignedAllocator_btHashString_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btHashString, 16u > *o = (::btAlignedAllocator< btHashString, 16u >*)c;
	::btHashString * tp0 = (::btHashString *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btHashString, 16u>::* )( ::btHashString * ) 
void btAlignedAllocator_btHashString_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btHashString, 16u > *o = (::btAlignedAllocator< btHashString, 16u >*)c;
	::btHashString * tp0 = (::btHashString *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btHashString * ( ::btAlignedAllocator<btHashString, 16u>::* )( ::size_type,::btHashString const * * ) 
// error:  - unsupported,  - unsupported, ::btHashString * - ok

//method: construct void ( ::btAlignedAllocator<btHashString, 16u>::* )( ::btHashString *,::btHashString const & ) 
void btAlignedAllocator_btHashString_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btHashString, 16u > *o = (::btAlignedAllocator< btHashString, 16u >*)c;
	::btHashString * tp0 = (::btHashString *)p0;
	::btHashString const & tp1 = *(::btHashString const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btHashString * ( ::btAlignedAllocator<btHashString, 16u>::* )( ::btHashString & ) const
void* btAlignedAllocator_btHashString_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btHashString, 16u > *o = (::btAlignedAllocator< btHashString, 16u >*)c;
	::btHashString & tp0 = *(::btHashString *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btHashString * ( ::btAlignedAllocator<btHashString, 16u>::* )( ::btHashString & ) const
void* btAlignedAllocator_btHashString_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btHashString, 16u > *o = (::btAlignedAllocator< btHashString, 16u >*)c;
	::btHashString & tp0 = *(::btHashString *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btHashString const * ( ::btAlignedAllocator<btHashString, 16u>::* )( ::btHashString const & ) const
void* btAlignedAllocator_btHashString_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btHashString, 16u > *o = (::btAlignedAllocator< btHashString, 16u >*)c;
	::btHashString const & tp0 = *(::btHashString const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btIndexedMesh, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )(  ) 
void* btAlignedAllocator_btIndexedMesh_16u__new() {
	::btAlignedAllocator< btIndexedMesh, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btIndexedMesh, 16u >),16);
	o = new (mem)::btAlignedAllocator< btIndexedMesh, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btIndexedMesh_16u__free(void *c) {
	::btAlignedAllocator< btIndexedMesh, 16u > *o = (::btAlignedAllocator< btIndexedMesh, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )( ::btIndexedMesh * ) 
void btAlignedAllocator_btIndexedMesh_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btIndexedMesh, 16u > *o = (::btAlignedAllocator< btIndexedMesh, 16u >*)c;
	::btIndexedMesh * tp0 = (::btIndexedMesh *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )( ::btIndexedMesh * ) 
void btAlignedAllocator_btIndexedMesh_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btIndexedMesh, 16u > *o = (::btAlignedAllocator< btIndexedMesh, 16u >*)c;
	::btIndexedMesh * tp0 = (::btIndexedMesh *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btIndexedMesh * ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )( ::size_type,::btIndexedMesh const * * ) 
// error:  - unsupported,  - unsupported, ::btIndexedMesh * - ok

//method: construct void ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )( ::btIndexedMesh *,::btIndexedMesh const & ) 
void btAlignedAllocator_btIndexedMesh_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btIndexedMesh, 16u > *o = (::btAlignedAllocator< btIndexedMesh, 16u >*)c;
	::btIndexedMesh * tp0 = (::btIndexedMesh *)p0;
	::btIndexedMesh const & tp1 = *(::btIndexedMesh const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btIndexedMesh * ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )( ::btIndexedMesh & ) const
void* btAlignedAllocator_btIndexedMesh_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btIndexedMesh, 16u > *o = (::btAlignedAllocator< btIndexedMesh, 16u >*)c;
	::btIndexedMesh & tp0 = *(::btIndexedMesh *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btIndexedMesh * ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )( ::btIndexedMesh & ) const
void* btAlignedAllocator_btIndexedMesh_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btIndexedMesh, 16u > *o = (::btAlignedAllocator< btIndexedMesh, 16u >*)c;
	::btIndexedMesh & tp0 = *(::btIndexedMesh *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btIndexedMesh const * ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )( ::btIndexedMesh const & ) const
void* btAlignedAllocator_btIndexedMesh_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btIndexedMesh, 16u > *o = (::btAlignedAllocator< btIndexedMesh, 16u >*)c;
	::btIndexedMesh const & tp0 = *(::btIndexedMesh const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btMultiSapBroadphase::btBridgeProxy*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )(  ) 
void* btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_ptr_16u__new() {
	::btAlignedAllocator< btMultiSapBroadphase::btBridgeProxy*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btMultiSapBroadphase::btBridgeProxy*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btMultiSapBroadphase::btBridgeProxy*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_ptr_16u__free(void *c) {
	::btAlignedAllocator< btMultiSapBroadphase::btBridgeProxy*, 16u > *o = (::btAlignedAllocator< btMultiSapBroadphase::btBridgeProxy*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )( ::btMultiSapBroadphase::btBridgeProxy * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )( ::btMultiSapBroadphase::btBridgeProxy * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btMultiSapBroadphase::btBridgeProxy * * ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )( ::size_type,::btMultiSapBroadphase::btBridgeProxy * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )( ::btMultiSapBroadphase::btBridgeProxy * *,::btMultiSapBroadphase::btBridgeProxy * const & ) 
// error:  - unsupported, ::btMultiSapBroadphase::btBridgeProxy * - ok, void - ok

//not supported method: address ::btMultiSapBroadphase::btBridgeProxy * * ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )( ::btMultiSapBroadphase::btBridgeProxy * & ) const
// error: ::btMultiSapBroadphase::btBridgeProxy * - ok,  - unsupported

//not supported method: address ::btMultiSapBroadphase::btBridgeProxy * * ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )( ::btMultiSapBroadphase::btBridgeProxy * & ) const
// error: ::btMultiSapBroadphase::btBridgeProxy * - ok,  - unsupported

//not supported method: address ::btMultiSapBroadphase::btBridgeProxy * const * ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )( ::btMultiSapBroadphase::btBridgeProxy * const & ) const
// error: ::btMultiSapBroadphase::btBridgeProxy * - ok,  - unsupported


// ::btAlignedAllocator< btMultiSapBroadphase::btMultiSapProxy*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )(  ) 
void* btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_ptr_16u__new() {
	::btAlignedAllocator< btMultiSapBroadphase::btMultiSapProxy*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btMultiSapBroadphase::btMultiSapProxy*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btMultiSapBroadphase::btMultiSapProxy*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_ptr_16u__free(void *c) {
	::btAlignedAllocator< btMultiSapBroadphase::btMultiSapProxy*, 16u > *o = (::btAlignedAllocator< btMultiSapBroadphase::btMultiSapProxy*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )( ::btMultiSapBroadphase::btMultiSapProxy * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )( ::btMultiSapBroadphase::btMultiSapProxy * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btMultiSapBroadphase::btMultiSapProxy * * ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )( ::size_type,::btMultiSapBroadphase::btMultiSapProxy * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )( ::btMultiSapBroadphase::btMultiSapProxy * *,::btMultiSapBroadphase::btMultiSapProxy * const & ) 
// error:  - unsupported, ::btMultiSapBroadphase::btMultiSapProxy * - ok, void - ok

//not supported method: address ::btMultiSapBroadphase::btMultiSapProxy * * ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )( ::btMultiSapBroadphase::btMultiSapProxy * & ) const
// error: ::btMultiSapBroadphase::btMultiSapProxy * - ok,  - unsupported

//not supported method: address ::btMultiSapBroadphase::btMultiSapProxy * * ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )( ::btMultiSapBroadphase::btMultiSapProxy * & ) const
// error: ::btMultiSapBroadphase::btMultiSapProxy * - ok,  - unsupported

//not supported method: address ::btMultiSapBroadphase::btMultiSapProxy * const * ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )( ::btMultiSapBroadphase::btMultiSapProxy * const & ) const
// error: ::btMultiSapBroadphase::btMultiSapProxy * - ok,  - unsupported


// ::btAlignedAllocator< btOptimizedBvhNode, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )(  ) 
void* btAlignedAllocator_btOptimizedBvhNode_16u__new() {
	::btAlignedAllocator< btOptimizedBvhNode, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btOptimizedBvhNode, 16u >),16);
	o = new (mem)::btAlignedAllocator< btOptimizedBvhNode, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btOptimizedBvhNode_16u__free(void *c) {
	::btAlignedAllocator< btOptimizedBvhNode, 16u > *o = (::btAlignedAllocator< btOptimizedBvhNode, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )( ::btOptimizedBvhNode * ) 
void btAlignedAllocator_btOptimizedBvhNode_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btOptimizedBvhNode, 16u > *o = (::btAlignedAllocator< btOptimizedBvhNode, 16u >*)c;
	::btOptimizedBvhNode * tp0 = (::btOptimizedBvhNode *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )( ::btOptimizedBvhNode * ) 
void btAlignedAllocator_btOptimizedBvhNode_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btOptimizedBvhNode, 16u > *o = (::btAlignedAllocator< btOptimizedBvhNode, 16u >*)c;
	::btOptimizedBvhNode * tp0 = (::btOptimizedBvhNode *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btOptimizedBvhNode * ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )( ::size_type,::btOptimizedBvhNode const * * ) 
// error:  - unsupported,  - unsupported, ::btOptimizedBvhNode * - ok

//method: construct void ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )( ::btOptimizedBvhNode *,::btOptimizedBvhNode const & ) 
void btAlignedAllocator_btOptimizedBvhNode_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btOptimizedBvhNode, 16u > *o = (::btAlignedAllocator< btOptimizedBvhNode, 16u >*)c;
	::btOptimizedBvhNode * tp0 = (::btOptimizedBvhNode *)p0;
	::btOptimizedBvhNode const & tp1 = *(::btOptimizedBvhNode const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btOptimizedBvhNode * ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )( ::btOptimizedBvhNode & ) const
void* btAlignedAllocator_btOptimizedBvhNode_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btOptimizedBvhNode, 16u > *o = (::btAlignedAllocator< btOptimizedBvhNode, 16u >*)c;
	::btOptimizedBvhNode & tp0 = *(::btOptimizedBvhNode *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btOptimizedBvhNode * ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )( ::btOptimizedBvhNode & ) const
void* btAlignedAllocator_btOptimizedBvhNode_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btOptimizedBvhNode, 16u > *o = (::btAlignedAllocator< btOptimizedBvhNode, 16u >*)c;
	::btOptimizedBvhNode & tp0 = *(::btOptimizedBvhNode *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btOptimizedBvhNode const * ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )( ::btOptimizedBvhNode const & ) const
void* btAlignedAllocator_btOptimizedBvhNode_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btOptimizedBvhNode, 16u > *o = (::btAlignedAllocator< btOptimizedBvhNode, 16u >*)c;
	::btOptimizedBvhNode const & tp0 = *(::btOptimizedBvhNode const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btPersistentManifold*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )(  ) 
void* btAlignedAllocator_btPersistentManifold_ptr_16u__new() {
	::btAlignedAllocator< btPersistentManifold*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btPersistentManifold*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btPersistentManifold*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btPersistentManifold_ptr_16u__free(void *c) {
	::btAlignedAllocator< btPersistentManifold*, 16u > *o = (::btAlignedAllocator< btPersistentManifold*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )( ::btPersistentManifold * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )( ::btPersistentManifold * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btPersistentManifold * * ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )( ::size_type,::btPersistentManifold * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )( ::btPersistentManifold * *,::btPersistentManifold * const & ) 
// error:  - unsupported, ::btPersistentManifold * - ok, void - ok

//not supported method: address ::btPersistentManifold * * ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )( ::btPersistentManifold * & ) const
// error: ::btPersistentManifold * - ok,  - unsupported

//not supported method: address ::btPersistentManifold * * ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )( ::btPersistentManifold * & ) const
// error: ::btPersistentManifold * - ok,  - unsupported

//not supported method: address ::btPersistentManifold * const * ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )( ::btPersistentManifold * const & ) const
// error: ::btPersistentManifold * - ok,  - unsupported


// ::btAlignedAllocator< btPointerUid, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btPointerUid, 16u>::* )(  ) 
void* btAlignedAllocator_btPointerUid_16u__new() {
	::btAlignedAllocator< btPointerUid, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btPointerUid, 16u >),16);
	o = new (mem)::btAlignedAllocator< btPointerUid, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btPointerUid_16u__free(void *c) {
	::btAlignedAllocator< btPointerUid, 16u > *o = (::btAlignedAllocator< btPointerUid, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btPointerUid, 16u>::* )( ::btPointerUid * ) 
void btAlignedAllocator_btPointerUid_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btPointerUid, 16u > *o = (::btAlignedAllocator< btPointerUid, 16u >*)c;
	::btPointerUid * tp0 = (::btPointerUid *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btPointerUid, 16u>::* )( ::btPointerUid * ) 
void btAlignedAllocator_btPointerUid_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btPointerUid, 16u > *o = (::btAlignedAllocator< btPointerUid, 16u >*)c;
	::btPointerUid * tp0 = (::btPointerUid *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btPointerUid * ( ::btAlignedAllocator<btPointerUid, 16u>::* )( ::size_type,::btPointerUid const * * ) 
// error:  - unsupported,  - unsupported, ::btPointerUid * - ok

//method: construct void ( ::btAlignedAllocator<btPointerUid, 16u>::* )( ::btPointerUid *,::btPointerUid const & ) 
void btAlignedAllocator_btPointerUid_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btPointerUid, 16u > *o = (::btAlignedAllocator< btPointerUid, 16u >*)c;
	::btPointerUid * tp0 = (::btPointerUid *)p0;
	::btPointerUid const & tp1 = *(::btPointerUid const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btPointerUid * ( ::btAlignedAllocator<btPointerUid, 16u>::* )( ::btPointerUid & ) const
void* btAlignedAllocator_btPointerUid_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btPointerUid, 16u > *o = (::btAlignedAllocator< btPointerUid, 16u >*)c;
	::btPointerUid & tp0 = *(::btPointerUid *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btPointerUid * ( ::btAlignedAllocator<btPointerUid, 16u>::* )( ::btPointerUid & ) const
void* btAlignedAllocator_btPointerUid_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btPointerUid, 16u > *o = (::btAlignedAllocator< btPointerUid, 16u >*)c;
	::btPointerUid & tp0 = *(::btPointerUid *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btPointerUid const * ( ::btAlignedAllocator<btPointerUid, 16u>::* )( ::btPointerUid const & ) const
void* btAlignedAllocator_btPointerUid_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btPointerUid, 16u > *o = (::btAlignedAllocator< btPointerUid, 16u >*)c;
	::btPointerUid const & tp0 = *(::btPointerUid const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btQuantizedBvhNode, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )(  ) 
void* btAlignedAllocator_btQuantizedBvhNode_16u__new() {
	::btAlignedAllocator< btQuantizedBvhNode, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btQuantizedBvhNode, 16u >),16);
	o = new (mem)::btAlignedAllocator< btQuantizedBvhNode, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btQuantizedBvhNode_16u__free(void *c) {
	::btAlignedAllocator< btQuantizedBvhNode, 16u > *o = (::btAlignedAllocator< btQuantizedBvhNode, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )( ::btQuantizedBvhNode * ) 
void btAlignedAllocator_btQuantizedBvhNode_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btQuantizedBvhNode, 16u > *o = (::btAlignedAllocator< btQuantizedBvhNode, 16u >*)c;
	::btQuantizedBvhNode * tp0 = (::btQuantizedBvhNode *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )( ::btQuantizedBvhNode * ) 
void btAlignedAllocator_btQuantizedBvhNode_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btQuantizedBvhNode, 16u > *o = (::btAlignedAllocator< btQuantizedBvhNode, 16u >*)c;
	::btQuantizedBvhNode * tp0 = (::btQuantizedBvhNode *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btQuantizedBvhNode * ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )( ::size_type,::btQuantizedBvhNode const * * ) 
// error:  - unsupported,  - unsupported, ::btQuantizedBvhNode * - ok

//method: construct void ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )( ::btQuantizedBvhNode *,::btQuantizedBvhNode const & ) 
void btAlignedAllocator_btQuantizedBvhNode_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btQuantizedBvhNode, 16u > *o = (::btAlignedAllocator< btQuantizedBvhNode, 16u >*)c;
	::btQuantizedBvhNode * tp0 = (::btQuantizedBvhNode *)p0;
	::btQuantizedBvhNode const & tp1 = *(::btQuantizedBvhNode const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btQuantizedBvhNode * ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )( ::btQuantizedBvhNode & ) const
void* btAlignedAllocator_btQuantizedBvhNode_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btQuantizedBvhNode, 16u > *o = (::btAlignedAllocator< btQuantizedBvhNode, 16u >*)c;
	::btQuantizedBvhNode & tp0 = *(::btQuantizedBvhNode *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btQuantizedBvhNode * ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )( ::btQuantizedBvhNode & ) const
void* btAlignedAllocator_btQuantizedBvhNode_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btQuantizedBvhNode, 16u > *o = (::btAlignedAllocator< btQuantizedBvhNode, 16u >*)c;
	::btQuantizedBvhNode & tp0 = *(::btQuantizedBvhNode *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btQuantizedBvhNode const * ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )( ::btQuantizedBvhNode const & ) const
void* btAlignedAllocator_btQuantizedBvhNode_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btQuantizedBvhNode, 16u > *o = (::btAlignedAllocator< btQuantizedBvhNode, 16u >*)c;
	::btQuantizedBvhNode const & tp0 = *(::btQuantizedBvhNode const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btRigidBody*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btRigidBody*, 16u>::* )(  ) 
void* btAlignedAllocator_btRigidBody_ptr_16u__new() {
	::btAlignedAllocator< btRigidBody*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btRigidBody*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btRigidBody*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btRigidBody_ptr_16u__free(void *c) {
	::btAlignedAllocator< btRigidBody*, 16u > *o = (::btAlignedAllocator< btRigidBody*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btRigidBody*, 16u>::* )( ::btRigidBody * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btRigidBody*, 16u>::* )( ::btRigidBody * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btRigidBody * * ( ::btAlignedAllocator<btRigidBody*, 16u>::* )( ::size_type,::btRigidBody * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btRigidBody*, 16u>::* )( ::btRigidBody * *,::btRigidBody * const & ) 
// error:  - unsupported, ::btRigidBody * - ok, void - ok

//not supported method: address ::btRigidBody * * ( ::btAlignedAllocator<btRigidBody*, 16u>::* )( ::btRigidBody * & ) const
// error: ::btRigidBody * - ok,  - unsupported

//not supported method: address ::btRigidBody * * ( ::btAlignedAllocator<btRigidBody*, 16u>::* )( ::btRigidBody * & ) const
// error: ::btRigidBody * - ok,  - unsupported

//not supported method: address ::btRigidBody * const * ( ::btAlignedAllocator<btRigidBody*, 16u>::* )( ::btRigidBody * const & ) const
// error: ::btRigidBody * - ok,  - unsupported


// ::btAlignedAllocator< btSoftBody*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody*, 16u>::* )(  ) 
void* btAlignedAllocator_btSoftBody_ptr_16u__new() {
	::btAlignedAllocator< btSoftBody*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSoftBody*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSoftBody*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSoftBody_ptr_16u__free(void *c) {
	::btAlignedAllocator< btSoftBody*, 16u > *o = (::btAlignedAllocator< btSoftBody*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btSoftBody*, 16u>::* )( ::btSoftBody * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSoftBody*, 16u>::* )( ::btSoftBody * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSoftBody * * ( ::btAlignedAllocator<btSoftBody*, 16u>::* )( ::size_type,::btSoftBody * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSoftBody*, 16u>::* )( ::btSoftBody * *,::btSoftBody * const & ) 
// error:  - unsupported, ::btSoftBody * - ok, void - ok

//not supported method: address ::btSoftBody * * ( ::btAlignedAllocator<btSoftBody*, 16u>::* )( ::btSoftBody * & ) const
// error: ::btSoftBody * - ok,  - unsupported

//not supported method: address ::btSoftBody * * ( ::btAlignedAllocator<btSoftBody*, 16u>::* )( ::btSoftBody * & ) const
// error: ::btSoftBody * - ok,  - unsupported

//not supported method: address ::btSoftBody * const * ( ::btAlignedAllocator<btSoftBody*, 16u>::* )( ::btSoftBody * const & ) const
// error: ::btSoftBody * - ok,  - unsupported


// ::btAlignedAllocator< btSoftBody::Anchor, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )(  ) 
void* btAlignedAllocator_btSoftBody_Anchor_16u__new() {
	::btAlignedAllocator< btSoftBody::Anchor, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSoftBody::Anchor, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSoftBody::Anchor, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSoftBody_Anchor_16u__free(void *c) {
	::btAlignedAllocator< btSoftBody::Anchor, 16u > *o = (::btAlignedAllocator< btSoftBody::Anchor, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )( ::btSoftBody::Anchor * ) 
void btAlignedAllocator_btSoftBody_Anchor_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Anchor, 16u > *o = (::btAlignedAllocator< btSoftBody::Anchor, 16u >*)c;
	::btSoftBody::Anchor * tp0 = (::btSoftBody::Anchor *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )( ::btSoftBody::Anchor * ) 
void btAlignedAllocator_btSoftBody_Anchor_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Anchor, 16u > *o = (::btAlignedAllocator< btSoftBody::Anchor, 16u >*)c;
	::btSoftBody::Anchor * tp0 = (::btSoftBody::Anchor *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btSoftBody::Anchor * ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )( ::size_type,::btSoftBody::Anchor const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::Anchor * - ok

//method: construct void ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )( ::btSoftBody::Anchor *,::btSoftBody::Anchor const & ) 
void btAlignedAllocator_btSoftBody_Anchor_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btSoftBody::Anchor, 16u > *o = (::btAlignedAllocator< btSoftBody::Anchor, 16u >*)c;
	::btSoftBody::Anchor * tp0 = (::btSoftBody::Anchor *)p0;
	::btSoftBody::Anchor const & tp1 = *(::btSoftBody::Anchor const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btSoftBody::Anchor * ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )( ::btSoftBody::Anchor & ) const
void* btAlignedAllocator_btSoftBody_Anchor_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Anchor, 16u > *o = (::btAlignedAllocator< btSoftBody::Anchor, 16u >*)c;
	::btSoftBody::Anchor & tp0 = *(::btSoftBody::Anchor *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::Anchor * ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )( ::btSoftBody::Anchor & ) const
void* btAlignedAllocator_btSoftBody_Anchor_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Anchor, 16u > *o = (::btAlignedAllocator< btSoftBody::Anchor, 16u >*)c;
	::btSoftBody::Anchor & tp0 = *(::btSoftBody::Anchor *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::Anchor const * ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )( ::btSoftBody::Anchor const & ) const
void* btAlignedAllocator_btSoftBody_Anchor_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Anchor, 16u > *o = (::btAlignedAllocator< btSoftBody::Anchor, 16u >*)c;
	::btSoftBody::Anchor const & tp0 = *(::btSoftBody::Anchor const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btSoftBody::Cluster*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )(  ) 
void* btAlignedAllocator_btSoftBody_Cluster_ptr_16u__new() {
	::btAlignedAllocator< btSoftBody::Cluster*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSoftBody::Cluster*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSoftBody::Cluster*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSoftBody_Cluster_ptr_16u__free(void *c) {
	::btAlignedAllocator< btSoftBody::Cluster*, 16u > *o = (::btAlignedAllocator< btSoftBody::Cluster*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )( ::btSoftBody::Cluster * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )( ::btSoftBody::Cluster * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSoftBody::Cluster * * ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )( ::size_type,::btSoftBody::Cluster * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )( ::btSoftBody::Cluster * *,::btSoftBody::Cluster * const & ) 
// error:  - unsupported, ::btSoftBody::Cluster * - ok, void - ok

//not supported method: address ::btSoftBody::Cluster * * ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )( ::btSoftBody::Cluster * & ) const
// error: ::btSoftBody::Cluster * - ok,  - unsupported

//not supported method: address ::btSoftBody::Cluster * * ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )( ::btSoftBody::Cluster * & ) const
// error: ::btSoftBody::Cluster * - ok,  - unsupported

//not supported method: address ::btSoftBody::Cluster * const * ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )( ::btSoftBody::Cluster * const & ) const
// error: ::btSoftBody::Cluster * - ok,  - unsupported


// ::btAlignedAllocator< btSoftBody::Face, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )(  ) 
void* btAlignedAllocator_btSoftBody_Face_16u__new() {
	::btAlignedAllocator< btSoftBody::Face, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSoftBody::Face, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSoftBody::Face, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSoftBody_Face_16u__free(void *c) {
	::btAlignedAllocator< btSoftBody::Face, 16u > *o = (::btAlignedAllocator< btSoftBody::Face, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )( ::btSoftBody::Face * ) 
void btAlignedAllocator_btSoftBody_Face_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Face, 16u > *o = (::btAlignedAllocator< btSoftBody::Face, 16u >*)c;
	::btSoftBody::Face * tp0 = (::btSoftBody::Face *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )( ::btSoftBody::Face * ) 
void btAlignedAllocator_btSoftBody_Face_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Face, 16u > *o = (::btAlignedAllocator< btSoftBody::Face, 16u >*)c;
	::btSoftBody::Face * tp0 = (::btSoftBody::Face *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btSoftBody::Face * ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )( ::size_type,::btSoftBody::Face const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::Face * - ok

//method: construct void ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )( ::btSoftBody::Face *,::btSoftBody::Face const & ) 
void btAlignedAllocator_btSoftBody_Face_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btSoftBody::Face, 16u > *o = (::btAlignedAllocator< btSoftBody::Face, 16u >*)c;
	::btSoftBody::Face * tp0 = (::btSoftBody::Face *)p0;
	::btSoftBody::Face const & tp1 = *(::btSoftBody::Face const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btSoftBody::Face * ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )( ::btSoftBody::Face & ) const
void* btAlignedAllocator_btSoftBody_Face_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Face, 16u > *o = (::btAlignedAllocator< btSoftBody::Face, 16u >*)c;
	::btSoftBody::Face & tp0 = *(::btSoftBody::Face *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::Face * ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )( ::btSoftBody::Face & ) const
void* btAlignedAllocator_btSoftBody_Face_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Face, 16u > *o = (::btAlignedAllocator< btSoftBody::Face, 16u >*)c;
	::btSoftBody::Face & tp0 = *(::btSoftBody::Face *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::Face const * ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )( ::btSoftBody::Face const & ) const
void* btAlignedAllocator_btSoftBody_Face_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Face, 16u > *o = (::btAlignedAllocator< btSoftBody::Face, 16u >*)c;
	::btSoftBody::Face const & tp0 = *(::btSoftBody::Face const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btSoftBody::Joint*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )(  ) 
void* btAlignedAllocator_btSoftBody_Joint_ptr_16u__new() {
	::btAlignedAllocator< btSoftBody::Joint*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSoftBody::Joint*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSoftBody::Joint*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSoftBody_Joint_ptr_16u__free(void *c) {
	::btAlignedAllocator< btSoftBody::Joint*, 16u > *o = (::btAlignedAllocator< btSoftBody::Joint*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )( ::btSoftBody::Joint * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )( ::btSoftBody::Joint * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSoftBody::Joint * * ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )( ::size_type,::btSoftBody::Joint * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )( ::btSoftBody::Joint * *,::btSoftBody::Joint * const & ) 
// error:  - unsupported, ::btSoftBody::Joint * - ok, void - ok

//not supported method: address ::btSoftBody::Joint * * ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )( ::btSoftBody::Joint * & ) const
// error: ::btSoftBody::Joint * - ok,  - unsupported

//not supported method: address ::btSoftBody::Joint * * ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )( ::btSoftBody::Joint * & ) const
// error: ::btSoftBody::Joint * - ok,  - unsupported

//not supported method: address ::btSoftBody::Joint * const * ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )( ::btSoftBody::Joint * const & ) const
// error: ::btSoftBody::Joint * - ok,  - unsupported


// ::btAlignedAllocator< btSoftBody::Link, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )(  ) 
void* btAlignedAllocator_btSoftBody_Link_16u__new() {
	::btAlignedAllocator< btSoftBody::Link, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSoftBody::Link, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSoftBody::Link, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSoftBody_Link_16u__free(void *c) {
	::btAlignedAllocator< btSoftBody::Link, 16u > *o = (::btAlignedAllocator< btSoftBody::Link, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )( ::btSoftBody::Link * ) 
void btAlignedAllocator_btSoftBody_Link_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Link, 16u > *o = (::btAlignedAllocator< btSoftBody::Link, 16u >*)c;
	::btSoftBody::Link * tp0 = (::btSoftBody::Link *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )( ::btSoftBody::Link * ) 
void btAlignedAllocator_btSoftBody_Link_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Link, 16u > *o = (::btAlignedAllocator< btSoftBody::Link, 16u >*)c;
	::btSoftBody::Link * tp0 = (::btSoftBody::Link *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btSoftBody::Link * ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )( ::size_type,::btSoftBody::Link const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::Link * - ok

//method: construct void ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )( ::btSoftBody::Link *,::btSoftBody::Link const & ) 
void btAlignedAllocator_btSoftBody_Link_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btSoftBody::Link, 16u > *o = (::btAlignedAllocator< btSoftBody::Link, 16u >*)c;
	::btSoftBody::Link * tp0 = (::btSoftBody::Link *)p0;
	::btSoftBody::Link const & tp1 = *(::btSoftBody::Link const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btSoftBody::Link * ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )( ::btSoftBody::Link & ) const
void* btAlignedAllocator_btSoftBody_Link_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Link, 16u > *o = (::btAlignedAllocator< btSoftBody::Link, 16u >*)c;
	::btSoftBody::Link & tp0 = *(::btSoftBody::Link *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::Link * ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )( ::btSoftBody::Link & ) const
void* btAlignedAllocator_btSoftBody_Link_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Link, 16u > *o = (::btAlignedAllocator< btSoftBody::Link, 16u >*)c;
	::btSoftBody::Link & tp0 = *(::btSoftBody::Link *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::Link const * ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )( ::btSoftBody::Link const & ) const
void* btAlignedAllocator_btSoftBody_Link_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Link, 16u > *o = (::btAlignedAllocator< btSoftBody::Link, 16u >*)c;
	::btSoftBody::Link const & tp0 = *(::btSoftBody::Link const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btSoftBody::Material*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )(  ) 
void* btAlignedAllocator_btSoftBody_Material_ptr_16u__new() {
	::btAlignedAllocator< btSoftBody::Material*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSoftBody::Material*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSoftBody::Material*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSoftBody_Material_ptr_16u__free(void *c) {
	::btAlignedAllocator< btSoftBody::Material*, 16u > *o = (::btAlignedAllocator< btSoftBody::Material*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )( ::btSoftBody::Material * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )( ::btSoftBody::Material * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSoftBody::Material * * ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )( ::size_type,::btSoftBody::Material * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )( ::btSoftBody::Material * *,::btSoftBody::Material * const & ) 
// error:  - unsupported, ::btSoftBody::Material * - ok, void - ok

//not supported method: address ::btSoftBody::Material * * ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )( ::btSoftBody::Material * & ) const
// error: ::btSoftBody::Material * - ok,  - unsupported

//not supported method: address ::btSoftBody::Material * * ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )( ::btSoftBody::Material * & ) const
// error: ::btSoftBody::Material * - ok,  - unsupported

//not supported method: address ::btSoftBody::Material * const * ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )( ::btSoftBody::Material * const & ) const
// error: ::btSoftBody::Material * - ok,  - unsupported


// ::btAlignedAllocator< btSoftBody::Node*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )(  ) 
void* btAlignedAllocator_btSoftBody_Node_ptr_16u__new() {
	::btAlignedAllocator< btSoftBody::Node*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSoftBody::Node*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSoftBody::Node*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSoftBody_Node_ptr_16u__free(void *c) {
	::btAlignedAllocator< btSoftBody::Node*, 16u > *o = (::btAlignedAllocator< btSoftBody::Node*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )( ::btSoftBody::Node * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )( ::btSoftBody::Node * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSoftBody::Node * * ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )( ::size_type,::btSoftBody::Node * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )( ::btSoftBody::Node * *,::btSoftBody::Node * const & ) 
// error:  - unsupported, ::btSoftBody::Node * - ok, void - ok

//not supported method: address ::btSoftBody::Node * * ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )( ::btSoftBody::Node * & ) const
// error: ::btSoftBody::Node * - ok,  - unsupported

//not supported method: address ::btSoftBody::Node * * ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )( ::btSoftBody::Node * & ) const
// error: ::btSoftBody::Node * - ok,  - unsupported

//not supported method: address ::btSoftBody::Node * const * ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )( ::btSoftBody::Node * const & ) const
// error: ::btSoftBody::Node * - ok,  - unsupported


// ::btAlignedAllocator< btSoftBody::Node, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )(  ) 
void* btAlignedAllocator_btSoftBody_Node_16u__new() {
	::btAlignedAllocator< btSoftBody::Node, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSoftBody::Node, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSoftBody::Node, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSoftBody_Node_16u__free(void *c) {
	::btAlignedAllocator< btSoftBody::Node, 16u > *o = (::btAlignedAllocator< btSoftBody::Node, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )( ::btSoftBody::Node * ) 
void btAlignedAllocator_btSoftBody_Node_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Node, 16u > *o = (::btAlignedAllocator< btSoftBody::Node, 16u >*)c;
	::btSoftBody::Node * tp0 = (::btSoftBody::Node *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )( ::btSoftBody::Node * ) 
void btAlignedAllocator_btSoftBody_Node_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Node, 16u > *o = (::btAlignedAllocator< btSoftBody::Node, 16u >*)c;
	::btSoftBody::Node * tp0 = (::btSoftBody::Node *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btSoftBody::Node * ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )( ::size_type,::btSoftBody::Node const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::Node * - ok

//method: construct void ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )( ::btSoftBody::Node *,::btSoftBody::Node const & ) 
void btAlignedAllocator_btSoftBody_Node_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btSoftBody::Node, 16u > *o = (::btAlignedAllocator< btSoftBody::Node, 16u >*)c;
	::btSoftBody::Node * tp0 = (::btSoftBody::Node *)p0;
	::btSoftBody::Node const & tp1 = *(::btSoftBody::Node const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btSoftBody::Node * ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )( ::btSoftBody::Node & ) const
void* btAlignedAllocator_btSoftBody_Node_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Node, 16u > *o = (::btAlignedAllocator< btSoftBody::Node, 16u >*)c;
	::btSoftBody::Node & tp0 = *(::btSoftBody::Node *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::Node * ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )( ::btSoftBody::Node & ) const
void* btAlignedAllocator_btSoftBody_Node_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Node, 16u > *o = (::btAlignedAllocator< btSoftBody::Node, 16u >*)c;
	::btSoftBody::Node & tp0 = *(::btSoftBody::Node *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::Node const * ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )( ::btSoftBody::Node const & ) const
void* btAlignedAllocator_btSoftBody_Node_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Node, 16u > *o = (::btAlignedAllocator< btSoftBody::Node, 16u >*)c;
	::btSoftBody::Node const & tp0 = *(::btSoftBody::Node const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btSoftBody::Note, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )(  ) 
void* btAlignedAllocator_btSoftBody_Note_16u__new() {
	::btAlignedAllocator< btSoftBody::Note, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSoftBody::Note, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSoftBody::Note, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSoftBody_Note_16u__free(void *c) {
	::btAlignedAllocator< btSoftBody::Note, 16u > *o = (::btAlignedAllocator< btSoftBody::Note, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )( ::btSoftBody::Note * ) 
void btAlignedAllocator_btSoftBody_Note_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Note, 16u > *o = (::btAlignedAllocator< btSoftBody::Note, 16u >*)c;
	::btSoftBody::Note * tp0 = (::btSoftBody::Note *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )( ::btSoftBody::Note * ) 
void btAlignedAllocator_btSoftBody_Note_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Note, 16u > *o = (::btAlignedAllocator< btSoftBody::Note, 16u >*)c;
	::btSoftBody::Note * tp0 = (::btSoftBody::Note *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btSoftBody::Note * ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )( ::size_type,::btSoftBody::Note const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::Note * - ok

//method: construct void ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )( ::btSoftBody::Note *,::btSoftBody::Note const & ) 
void btAlignedAllocator_btSoftBody_Note_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btSoftBody::Note, 16u > *o = (::btAlignedAllocator< btSoftBody::Note, 16u >*)c;
	::btSoftBody::Note * tp0 = (::btSoftBody::Note *)p0;
	::btSoftBody::Note const & tp1 = *(::btSoftBody::Note const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btSoftBody::Note * ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )( ::btSoftBody::Note & ) const
void* btAlignedAllocator_btSoftBody_Note_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Note, 16u > *o = (::btAlignedAllocator< btSoftBody::Note, 16u >*)c;
	::btSoftBody::Note & tp0 = *(::btSoftBody::Note *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::Note * ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )( ::btSoftBody::Note & ) const
void* btAlignedAllocator_btSoftBody_Note_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Note, 16u > *o = (::btAlignedAllocator< btSoftBody::Note, 16u >*)c;
	::btSoftBody::Note & tp0 = *(::btSoftBody::Note *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::Note const * ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )( ::btSoftBody::Note const & ) const
void* btAlignedAllocator_btSoftBody_Note_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Note, 16u > *o = (::btAlignedAllocator< btSoftBody::Note, 16u >*)c;
	::btSoftBody::Note const & tp0 = *(::btSoftBody::Note const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btSoftBody::RContact, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )(  ) 
void* btAlignedAllocator_btSoftBody_RContact_16u__new() {
	::btAlignedAllocator< btSoftBody::RContact, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSoftBody::RContact, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSoftBody::RContact, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSoftBody_RContact_16u__free(void *c) {
	::btAlignedAllocator< btSoftBody::RContact, 16u > *o = (::btAlignedAllocator< btSoftBody::RContact, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )( ::btSoftBody::RContact * ) 
void btAlignedAllocator_btSoftBody_RContact_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::RContact, 16u > *o = (::btAlignedAllocator< btSoftBody::RContact, 16u >*)c;
	::btSoftBody::RContact * tp0 = (::btSoftBody::RContact *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )( ::btSoftBody::RContact * ) 
void btAlignedAllocator_btSoftBody_RContact_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::RContact, 16u > *o = (::btAlignedAllocator< btSoftBody::RContact, 16u >*)c;
	::btSoftBody::RContact * tp0 = (::btSoftBody::RContact *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btSoftBody::RContact * ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )( ::size_type,::btSoftBody::RContact const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::RContact * - ok

//method: construct void ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )( ::btSoftBody::RContact *,::btSoftBody::RContact const & ) 
void btAlignedAllocator_btSoftBody_RContact_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btSoftBody::RContact, 16u > *o = (::btAlignedAllocator< btSoftBody::RContact, 16u >*)c;
	::btSoftBody::RContact * tp0 = (::btSoftBody::RContact *)p0;
	::btSoftBody::RContact const & tp1 = *(::btSoftBody::RContact const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btSoftBody::RContact * ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )( ::btSoftBody::RContact & ) const
void* btAlignedAllocator_btSoftBody_RContact_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::RContact, 16u > *o = (::btAlignedAllocator< btSoftBody::RContact, 16u >*)c;
	::btSoftBody::RContact & tp0 = *(::btSoftBody::RContact *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::RContact * ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )( ::btSoftBody::RContact & ) const
void* btAlignedAllocator_btSoftBody_RContact_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::RContact, 16u > *o = (::btAlignedAllocator< btSoftBody::RContact, 16u >*)c;
	::btSoftBody::RContact & tp0 = *(::btSoftBody::RContact *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::RContact const * ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )( ::btSoftBody::RContact const & ) const
void* btAlignedAllocator_btSoftBody_RContact_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::RContact, 16u > *o = (::btAlignedAllocator< btSoftBody::RContact, 16u >*)c;
	::btSoftBody::RContact const & tp0 = *(::btSoftBody::RContact const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btSoftBody::SContact, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )(  ) 
void* btAlignedAllocator_btSoftBody_SContact_16u__new() {
	::btAlignedAllocator< btSoftBody::SContact, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSoftBody::SContact, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSoftBody::SContact, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSoftBody_SContact_16u__free(void *c) {
	::btAlignedAllocator< btSoftBody::SContact, 16u > *o = (::btAlignedAllocator< btSoftBody::SContact, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )( ::btSoftBody::SContact * ) 
void btAlignedAllocator_btSoftBody_SContact_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::SContact, 16u > *o = (::btAlignedAllocator< btSoftBody::SContact, 16u >*)c;
	::btSoftBody::SContact * tp0 = (::btSoftBody::SContact *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )( ::btSoftBody::SContact * ) 
void btAlignedAllocator_btSoftBody_SContact_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::SContact, 16u > *o = (::btAlignedAllocator< btSoftBody::SContact, 16u >*)c;
	::btSoftBody::SContact * tp0 = (::btSoftBody::SContact *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btSoftBody::SContact * ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )( ::size_type,::btSoftBody::SContact const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::SContact * - ok

//method: construct void ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )( ::btSoftBody::SContact *,::btSoftBody::SContact const & ) 
void btAlignedAllocator_btSoftBody_SContact_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btSoftBody::SContact, 16u > *o = (::btAlignedAllocator< btSoftBody::SContact, 16u >*)c;
	::btSoftBody::SContact * tp0 = (::btSoftBody::SContact *)p0;
	::btSoftBody::SContact const & tp1 = *(::btSoftBody::SContact const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btSoftBody::SContact * ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )( ::btSoftBody::SContact & ) const
void* btAlignedAllocator_btSoftBody_SContact_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::SContact, 16u > *o = (::btAlignedAllocator< btSoftBody::SContact, 16u >*)c;
	::btSoftBody::SContact & tp0 = *(::btSoftBody::SContact *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::SContact * ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )( ::btSoftBody::SContact & ) const
void* btAlignedAllocator_btSoftBody_SContact_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::SContact, 16u > *o = (::btAlignedAllocator< btSoftBody::SContact, 16u >*)c;
	::btSoftBody::SContact & tp0 = *(::btSoftBody::SContact *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::SContact const * ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )( ::btSoftBody::SContact const & ) const
void* btAlignedAllocator_btSoftBody_SContact_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::SContact, 16u > *o = (::btAlignedAllocator< btSoftBody::SContact, 16u >*)c;
	::btSoftBody::SContact const & tp0 = *(::btSoftBody::SContact const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btSoftBody::Tetra, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )(  ) 
void* btAlignedAllocator_btSoftBody_Tetra_16u__new() {
	::btAlignedAllocator< btSoftBody::Tetra, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSoftBody::Tetra, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSoftBody::Tetra, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSoftBody_Tetra_16u__free(void *c) {
	::btAlignedAllocator< btSoftBody::Tetra, 16u > *o = (::btAlignedAllocator< btSoftBody::Tetra, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )( ::btSoftBody::Tetra * ) 
void btAlignedAllocator_btSoftBody_Tetra_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Tetra, 16u > *o = (::btAlignedAllocator< btSoftBody::Tetra, 16u >*)c;
	::btSoftBody::Tetra * tp0 = (::btSoftBody::Tetra *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )( ::btSoftBody::Tetra * ) 
void btAlignedAllocator_btSoftBody_Tetra_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Tetra, 16u > *o = (::btAlignedAllocator< btSoftBody::Tetra, 16u >*)c;
	::btSoftBody::Tetra * tp0 = (::btSoftBody::Tetra *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btSoftBody::Tetra * ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )( ::size_type,::btSoftBody::Tetra const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::Tetra * - ok

//method: construct void ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )( ::btSoftBody::Tetra *,::btSoftBody::Tetra const & ) 
void btAlignedAllocator_btSoftBody_Tetra_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btSoftBody::Tetra, 16u > *o = (::btAlignedAllocator< btSoftBody::Tetra, 16u >*)c;
	::btSoftBody::Tetra * tp0 = (::btSoftBody::Tetra *)p0;
	::btSoftBody::Tetra const & tp1 = *(::btSoftBody::Tetra const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btSoftBody::Tetra * ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )( ::btSoftBody::Tetra & ) const
void* btAlignedAllocator_btSoftBody_Tetra_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Tetra, 16u > *o = (::btAlignedAllocator< btSoftBody::Tetra, 16u >*)c;
	::btSoftBody::Tetra & tp0 = *(::btSoftBody::Tetra *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::Tetra * ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )( ::btSoftBody::Tetra & ) const
void* btAlignedAllocator_btSoftBody_Tetra_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Tetra, 16u > *o = (::btAlignedAllocator< btSoftBody::Tetra, 16u >*)c;
	::btSoftBody::Tetra & tp0 = *(::btSoftBody::Tetra *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSoftBody::Tetra const * ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )( ::btSoftBody::Tetra const & ) const
void* btAlignedAllocator_btSoftBody_Tetra_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btSoftBody::Tetra, 16u > *o = (::btAlignedAllocator< btSoftBody::Tetra, 16u >*)c;
	::btSoftBody::Tetra const & tp0 = *(::btSoftBody::Tetra const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btSoftBody::ePSolver::_, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )(  ) 
void* btAlignedAllocator_btSoftBody_ePSolver___16u__new() {
	::btAlignedAllocator< btSoftBody::ePSolver::_, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSoftBody::ePSolver::_, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSoftBody::ePSolver::_, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSoftBody_ePSolver___16u__free(void *c) {
	::btAlignedAllocator< btSoftBody::ePSolver::_, 16u > *o = (::btAlignedAllocator< btSoftBody::ePSolver::_, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )( ::btSoftBody::ePSolver::_ * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )( ::btSoftBody::ePSolver::_ * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSoftBody::ePSolver::_ * ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )( ::size_type,::btSoftBody::ePSolver::_ const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )( ::btSoftBody::ePSolver::_ *,::btSoftBody::ePSolver::_ const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address ::btSoftBody::ePSolver::_ * ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )( ::btSoftBody::ePSolver::_ & ) const
// error:  - unsupported,  - unsupported

//not supported method: address ::btSoftBody::ePSolver::_ * ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )( ::btSoftBody::ePSolver::_ & ) const
// error:  - unsupported,  - unsupported

//not supported method: address ::btSoftBody::ePSolver::_ const * ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )( ::btSoftBody::ePSolver::_ const & ) const
// error:  - unsupported,  - unsupported


// ::btAlignedAllocator< btSoftBody::eVSolver::_, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )(  ) 
void* btAlignedAllocator_btSoftBody_eVSolver___16u__new() {
	::btAlignedAllocator< btSoftBody::eVSolver::_, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSoftBody::eVSolver::_, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSoftBody::eVSolver::_, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSoftBody_eVSolver___16u__free(void *c) {
	::btAlignedAllocator< btSoftBody::eVSolver::_, 16u > *o = (::btAlignedAllocator< btSoftBody::eVSolver::_, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )( ::btSoftBody::eVSolver::_ * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )( ::btSoftBody::eVSolver::_ * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSoftBody::eVSolver::_ * ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )( ::size_type,::btSoftBody::eVSolver::_ const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )( ::btSoftBody::eVSolver::_ *,::btSoftBody::eVSolver::_ const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address ::btSoftBody::eVSolver::_ * ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )( ::btSoftBody::eVSolver::_ & ) const
// error:  - unsupported,  - unsupported

//not supported method: address ::btSoftBody::eVSolver::_ * ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )( ::btSoftBody::eVSolver::_ & ) const
// error:  - unsupported,  - unsupported

//not supported method: address ::btSoftBody::eVSolver::_ const * ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )( ::btSoftBody::eVSolver::_ const & ) const
// error:  - unsupported,  - unsupported


// ::btAlignedAllocator< btSolverConstraint, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )(  ) 
void* btAlignedAllocator_btSolverConstraint_16u__new() {
	::btAlignedAllocator< btSolverConstraint, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSolverConstraint, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSolverConstraint, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSolverConstraint_16u__free(void *c) {
	::btAlignedAllocator< btSolverConstraint, 16u > *o = (::btAlignedAllocator< btSolverConstraint, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )( ::btSolverConstraint * ) 
void btAlignedAllocator_btSolverConstraint_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btSolverConstraint, 16u > *o = (::btAlignedAllocator< btSolverConstraint, 16u >*)c;
	::btSolverConstraint * tp0 = (::btSolverConstraint *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )( ::btSolverConstraint * ) 
void btAlignedAllocator_btSolverConstraint_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btSolverConstraint, 16u > *o = (::btAlignedAllocator< btSolverConstraint, 16u >*)c;
	::btSolverConstraint * tp0 = (::btSolverConstraint *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btSolverConstraint * ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )( ::size_type,::btSolverConstraint const * * ) 
// error:  - unsupported,  - unsupported, ::btSolverConstraint * - ok

//method: construct void ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )( ::btSolverConstraint *,::btSolverConstraint const & ) 
void btAlignedAllocator_btSolverConstraint_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btSolverConstraint, 16u > *o = (::btAlignedAllocator< btSolverConstraint, 16u >*)c;
	::btSolverConstraint * tp0 = (::btSolverConstraint *)p0;
	::btSolverConstraint const & tp1 = *(::btSolverConstraint const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btSolverConstraint * ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )( ::btSolverConstraint & ) const
void* btAlignedAllocator_btSolverConstraint_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btSolverConstraint, 16u > *o = (::btAlignedAllocator< btSolverConstraint, 16u >*)c;
	::btSolverConstraint & tp0 = *(::btSolverConstraint *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSolverConstraint * ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )( ::btSolverConstraint & ) const
void* btAlignedAllocator_btSolverConstraint_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btSolverConstraint, 16u > *o = (::btAlignedAllocator< btSolverConstraint, 16u >*)c;
	::btSolverConstraint & tp0 = *(::btSolverConstraint *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btSolverConstraint const * ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )( ::btSolverConstraint const & ) const
void* btAlignedAllocator_btSolverConstraint_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btSolverConstraint, 16u > *o = (::btAlignedAllocator< btSolverConstraint, 16u >*)c;
	::btSolverConstraint const & tp0 = *(::btSolverConstraint const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btSparseSdf<3>::Cell*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )(  ) 
void* btAlignedAllocator_btSparseSdf_3__Cell_ptr_16u__new() {
	::btAlignedAllocator< btSparseSdf<3>::Cell*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btSparseSdf<3>::Cell*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btSparseSdf<3>::Cell*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btSparseSdf_3__Cell_ptr_16u__free(void *c) {
	::btAlignedAllocator< btSparseSdf<3>::Cell*, 16u > *o = (::btAlignedAllocator< btSparseSdf<3>::Cell*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )( ::btSparseSdf<3>::Cell * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )( ::btSparseSdf<3>::Cell * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSparseSdf<3>::Cell * * ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )( ::size_type,::btSparseSdf<3>::Cell * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )( ::btSparseSdf<3>::Cell * *,::btSparseSdf<3>::Cell * const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address ::btSparseSdf<3>::Cell * * ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )( ::btSparseSdf<3>::Cell * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address ::btSparseSdf<3>::Cell * * ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )( ::btSparseSdf<3>::Cell * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address ::btSparseSdf<3>::Cell * const * ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )( ::btSparseSdf<3>::Cell * const & ) const
// error:  - unsupported,  - unsupported


// ::btAlignedAllocator< btTransform, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btTransform, 16u>::* )(  ) 
void* btAlignedAllocator_btTransform_16u__new() {
	::btAlignedAllocator< btTransform, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btTransform, 16u >),16);
	o = new (mem)::btAlignedAllocator< btTransform, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btTransform_16u__free(void *c) {
	::btAlignedAllocator< btTransform, 16u > *o = (::btAlignedAllocator< btTransform, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btTransform, 16u>::* )( ::btTransform * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btTransform, 16u>::* )( ::btTransform * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btTransform * ( ::btAlignedAllocator<btTransform, 16u>::* )( ::size_type,::btTransform const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btTransform, 16u>::* )( ::btTransform *,::btTransform const & ) 
// error:  - unsupported, ::btTransform const & - ok, void - ok

//not supported method: address ::btTransform * ( ::btAlignedAllocator<btTransform, 16u>::* )( ::btTransform & ) const
// error: ::btTransform & - ok,  - unsupported

//not supported method: address ::btTransform * ( ::btAlignedAllocator<btTransform, 16u>::* )( ::btTransform & ) const
// error: ::btTransform & - ok,  - unsupported

//not supported method: address ::btTransform const * ( ::btAlignedAllocator<btTransform, 16u>::* )( ::btTransform const & ) const
// error: ::btTransform const & - ok,  - unsupported


// ::btAlignedAllocator< btTriangleInfo, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )(  ) 
void* btAlignedAllocator_btTriangleInfo_16u__new() {
	::btAlignedAllocator< btTriangleInfo, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btTriangleInfo, 16u >),16);
	o = new (mem)::btAlignedAllocator< btTriangleInfo, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btTriangleInfo_16u__free(void *c) {
	::btAlignedAllocator< btTriangleInfo, 16u > *o = (::btAlignedAllocator< btTriangleInfo, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )( ::btTriangleInfo * ) 
void btAlignedAllocator_btTriangleInfo_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btTriangleInfo, 16u > *o = (::btAlignedAllocator< btTriangleInfo, 16u >*)c;
	::btTriangleInfo * tp0 = (::btTriangleInfo *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )( ::btTriangleInfo * ) 
void btAlignedAllocator_btTriangleInfo_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btTriangleInfo, 16u > *o = (::btAlignedAllocator< btTriangleInfo, 16u >*)c;
	::btTriangleInfo * tp0 = (::btTriangleInfo *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btTriangleInfo * ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )( ::size_type,::btTriangleInfo const * * ) 
// error:  - unsupported,  - unsupported, ::btTriangleInfo * - ok

//method: construct void ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )( ::btTriangleInfo *,::btTriangleInfo const & ) 
void btAlignedAllocator_btTriangleInfo_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btTriangleInfo, 16u > *o = (::btAlignedAllocator< btTriangleInfo, 16u >*)c;
	::btTriangleInfo * tp0 = (::btTriangleInfo *)p0;
	::btTriangleInfo const & tp1 = *(::btTriangleInfo const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btTriangleInfo * ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )( ::btTriangleInfo & ) const
void* btAlignedAllocator_btTriangleInfo_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btTriangleInfo, 16u > *o = (::btAlignedAllocator< btTriangleInfo, 16u >*)c;
	::btTriangleInfo & tp0 = *(::btTriangleInfo *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btTriangleInfo * ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )( ::btTriangleInfo & ) const
void* btAlignedAllocator_btTriangleInfo_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btTriangleInfo, 16u > *o = (::btAlignedAllocator< btTriangleInfo, 16u >*)c;
	::btTriangleInfo & tp0 = *(::btTriangleInfo *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btTriangleInfo const * ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )( ::btTriangleInfo const & ) const
void* btAlignedAllocator_btTriangleInfo_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btTriangleInfo, 16u > *o = (::btAlignedAllocator< btTriangleInfo, 16u >*)c;
	::btTriangleInfo const & tp0 = *(::btTriangleInfo const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btTypedConstraint*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )(  ) 
void* btAlignedAllocator_btTypedConstraint_ptr_16u__new() {
	::btAlignedAllocator< btTypedConstraint*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btTypedConstraint*, 16u >),16);
	o = new (mem)::btAlignedAllocator< btTypedConstraint*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btTypedConstraint_ptr_16u__free(void *c) {
	::btAlignedAllocator< btTypedConstraint*, 16u > *o = (::btAlignedAllocator< btTypedConstraint*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )( ::btTypedConstraint * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )( ::btTypedConstraint * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btTypedConstraint * * ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )( ::size_type,::btTypedConstraint * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )( ::btTypedConstraint * *,::btTypedConstraint * const & ) 
// error:  - unsupported, ::btTypedConstraint * - ok, void - ok

//not supported method: address ::btTypedConstraint * * ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )( ::btTypedConstraint * & ) const
// error: ::btTypedConstraint * - ok,  - unsupported

//not supported method: address ::btTypedConstraint * * ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )( ::btTypedConstraint * & ) const
// error: ::btTypedConstraint * - ok,  - unsupported

//not supported method: address ::btTypedConstraint * const * ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )( ::btTypedConstraint * const & ) const
// error: ::btTypedConstraint * - ok,  - unsupported


// ::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )(  ) 
void* btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__new() {
	::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u >),16);
	o = new (mem)::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__free(void *c) {
	::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u > *o = (::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u > *o = (::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u >*)c;
	::btTypedConstraint::btConstraintInfo1 * tp0 = (::btTypedConstraint::btConstraintInfo1 *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u > *o = (::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u >*)c;
	::btTypedConstraint::btConstraintInfo1 * tp0 = (::btTypedConstraint::btConstraintInfo1 *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btTypedConstraint::btConstraintInfo1 * ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )( ::size_type,::btTypedConstraint::btConstraintInfo1 const * * ) 
// error:  - unsupported,  - unsupported, ::btTypedConstraint::btConstraintInfo1 * - ok

//method: construct void ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )( ::btTypedConstraint::btConstraintInfo1 *,::btTypedConstraint::btConstraintInfo1 const & ) 
void btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u > *o = (::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u >*)c;
	::btTypedConstraint::btConstraintInfo1 * tp0 = (::btTypedConstraint::btConstraintInfo1 *)p0;
	::btTypedConstraint::btConstraintInfo1 const & tp1 = *(::btTypedConstraint::btConstraintInfo1 const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btTypedConstraint::btConstraintInfo1 * ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )( ::btTypedConstraint::btConstraintInfo1 & ) const
void* btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u > *o = (::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u >*)c;
	::btTypedConstraint::btConstraintInfo1 & tp0 = *(::btTypedConstraint::btConstraintInfo1 *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btTypedConstraint::btConstraintInfo1 * ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )( ::btTypedConstraint::btConstraintInfo1 & ) const
void* btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u > *o = (::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u >*)c;
	::btTypedConstraint::btConstraintInfo1 & tp0 = *(::btTypedConstraint::btConstraintInfo1 *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btTypedConstraint::btConstraintInfo1 const * ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )( ::btTypedConstraint::btConstraintInfo1 const & ) const
void* btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u > *o = (::btAlignedAllocator< btTypedConstraint::btConstraintInfo1, 16u >*)c;
	::btTypedConstraint::btConstraintInfo1 const & tp0 = *(::btTypedConstraint::btConstraintInfo1 const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< btVector3, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btVector3, 16u>::* )(  ) 
void* btAlignedAllocator_btVector3_16u__new() {
	::btAlignedAllocator< btVector3, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btVector3, 16u >),16);
	o = new (mem)::btAlignedAllocator< btVector3, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btVector3_16u__free(void *c) {
	::btAlignedAllocator< btVector3, 16u > *o = (::btAlignedAllocator< btVector3, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<btVector3, 16u>::* )( ::btVector3 * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btVector3, 16u>::* )( ::btVector3 * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btVector3 * ( ::btAlignedAllocator<btVector3, 16u>::* )( ::size_type,::btVector3 const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btVector3, 16u>::* )( ::btVector3 *,::btVector3 const & ) 
// error:  - unsupported, ::btVector3 const & - ok, void - ok

//not supported method: address ::btVector3 * ( ::btAlignedAllocator<btVector3, 16u>::* )( ::btVector3 & ) const
// error: ::btVector3 & - ok,  - unsupported

//not supported method: address ::btVector3 * ( ::btAlignedAllocator<btVector3, 16u>::* )( ::btVector3 & ) const
// error: ::btVector3 & - ok,  - unsupported

//not supported method: address ::btVector3 const * ( ::btAlignedAllocator<btVector3, 16u>::* )( ::btVector3 const & ) const
// error: ::btVector3 const & - ok,  - unsupported


// ::btAlignedAllocator< btWheelInfo, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<btWheelInfo, 16u>::* )(  ) 
void* btAlignedAllocator_btWheelInfo_16u__new() {
	::btAlignedAllocator< btWheelInfo, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< btWheelInfo, 16u >),16);
	o = new (mem)::btAlignedAllocator< btWheelInfo, 16u >();
	return (void*)o;
}
void btAlignedAllocator_btWheelInfo_16u__free(void *c) {
	::btAlignedAllocator< btWheelInfo, 16u > *o = (::btAlignedAllocator< btWheelInfo, 16u >*)c;
	delete o;
}
//method: destroy void ( ::btAlignedAllocator<btWheelInfo, 16u>::* )( ::btWheelInfo * ) 
void btAlignedAllocator_btWheelInfo_16u__destroy(void *c,void* p0) {
	::btAlignedAllocator< btWheelInfo, 16u > *o = (::btAlignedAllocator< btWheelInfo, 16u >*)c;
	::btWheelInfo * tp0 = (::btWheelInfo *)p0;
	o->destroy(tp0);
}
//method: deallocate void ( ::btAlignedAllocator<btWheelInfo, 16u>::* )( ::btWheelInfo * ) 
void btAlignedAllocator_btWheelInfo_16u__deallocate(void *c,void* p0) {
	::btAlignedAllocator< btWheelInfo, 16u > *o = (::btAlignedAllocator< btWheelInfo, 16u >*)c;
	::btWheelInfo * tp0 = (::btWheelInfo *)p0;
	o->deallocate(tp0);
}
//not supported method: allocate ::btWheelInfo * ( ::btAlignedAllocator<btWheelInfo, 16u>::* )( ::size_type,::btWheelInfo const * * ) 
// error:  - unsupported,  - unsupported, ::btWheelInfo * - ok

//method: construct void ( ::btAlignedAllocator<btWheelInfo, 16u>::* )( ::btWheelInfo *,::btWheelInfo const & ) 
void btAlignedAllocator_btWheelInfo_16u__construct(void *c,void* p0,void* p1) {
	::btAlignedAllocator< btWheelInfo, 16u > *o = (::btAlignedAllocator< btWheelInfo, 16u >*)c;
	::btWheelInfo * tp0 = (::btWheelInfo *)p0;
	::btWheelInfo const & tp1 = *(::btWheelInfo const *)p1;
	o->construct(tp0,tp1);
}
//method: address ::btWheelInfo * ( ::btAlignedAllocator<btWheelInfo, 16u>::* )( ::btWheelInfo & ) const
void* btAlignedAllocator_btWheelInfo_16u__address(void *c,void* p0) {
	::btAlignedAllocator< btWheelInfo, 16u > *o = (::btAlignedAllocator< btWheelInfo, 16u >*)c;
	::btWheelInfo & tp0 = *(::btWheelInfo *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btWheelInfo * ( ::btAlignedAllocator<btWheelInfo, 16u>::* )( ::btWheelInfo & ) const
void* btAlignedAllocator_btWheelInfo_16u__address0(void *c,void* p0) {
	::btAlignedAllocator< btWheelInfo, 16u > *o = (::btAlignedAllocator< btWheelInfo, 16u >*)c;
	::btWheelInfo & tp0 = *(::btWheelInfo *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}
//method: address ::btWheelInfo const * ( ::btAlignedAllocator<btWheelInfo, 16u>::* )( ::btWheelInfo const & ) const
void* btAlignedAllocator_btWheelInfo_16u__address1(void *c,void* p0) {
	::btAlignedAllocator< btWheelInfo, 16u > *o = (::btAlignedAllocator< btWheelInfo, 16u >*)c;
	::btWheelInfo const & tp0 = *(::btWheelInfo const *)p0;
	void* retVal = (void*) o->address(tp0);
	return retVal;
}

// ::btAlignedAllocator< char const*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<char const*, 16u>::* )(  ) 
void* btAlignedAllocator_charconst_ptr_16u__new() {
	::btAlignedAllocator< char const*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< char const*, 16u >),16);
	o = new (mem)::btAlignedAllocator< char const*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_charconst_ptr_16u__free(void *c) {
	::btAlignedAllocator< char const*, 16u > *o = (::btAlignedAllocator< char const*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<char const*, 16u>::* )( char const * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<char const*, 16u>::* )( char const * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate char const * * ( ::btAlignedAllocator<char const*, 16u>::* )( ::size_type,char const * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<char const*, 16u>::* )( char const * *,char const * const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address char const * * ( ::btAlignedAllocator<char const*, 16u>::* )( char const * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address char const * * ( ::btAlignedAllocator<char const*, 16u>::* )( char const * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address char const * const * ( ::btAlignedAllocator<char const*, 16u>::* )( char const * const & ) const
// error:  - unsupported,  - unsupported


// ::btAlignedAllocator< char*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<char*, 16u>::* )(  ) 
void* btAlignedAllocator_char_ptr_16u__new() {
	::btAlignedAllocator< char*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< char*, 16u >),16);
	o = new (mem)::btAlignedAllocator< char*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_char_ptr_16u__free(void *c) {
	::btAlignedAllocator< char*, 16u > *o = (::btAlignedAllocator< char*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<char*, 16u>::* )( char * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<char*, 16u>::* )( char * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate char * * ( ::btAlignedAllocator<char*, 16u>::* )( ::size_type,char * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<char*, 16u>::* )( char * *,char * const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address char * * ( ::btAlignedAllocator<char*, 16u>::* )( char * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address char * * ( ::btAlignedAllocator<char*, 16u>::* )( char * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address char * const * ( ::btAlignedAllocator<char*, 16u>::* )( char * const & ) const
// error:  - unsupported,  - unsupported


// ::btAlignedAllocator< float, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<float, 16u>::* )(  ) 
void* btAlignedAllocator_float_16u__new() {
	::btAlignedAllocator< float, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< float, 16u >),16);
	o = new (mem)::btAlignedAllocator< float, 16u >();
	return (void*)o;
}
void btAlignedAllocator_float_16u__free(void *c) {
	::btAlignedAllocator< float, 16u > *o = (::btAlignedAllocator< float, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<float, 16u>::* )( float * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<float, 16u>::* )( float * ) 
// error:  - unsupported, void - ok

//not supported method: allocate float * ( ::btAlignedAllocator<float, 16u>::* )( ::size_type,float const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<float, 16u>::* )( float *,float const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address float * ( ::btAlignedAllocator<float, 16u>::* )( float & ) const
// error:  - unsupported,  - unsupported

//not supported method: address float * ( ::btAlignedAllocator<float, 16u>::* )( float & ) const
// error:  - unsupported,  - unsupported

//not supported method: address float const * ( ::btAlignedAllocator<float, 16u>::* )( float const & ) const
// error:  - unsupported,  - unsupported


// ::btAlignedAllocator< int, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<int, 16u>::* )(  ) 
void* btAlignedAllocator_int_16u__new() {
	::btAlignedAllocator< int, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< int, 16u >),16);
	o = new (mem)::btAlignedAllocator< int, 16u >();
	return (void*)o;
}
void btAlignedAllocator_int_16u__free(void *c) {
	::btAlignedAllocator< int, 16u > *o = (::btAlignedAllocator< int, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<int, 16u>::* )( int * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<int, 16u>::* )( int * ) 
// error:  - unsupported, void - ok

//not supported method: allocate int * ( ::btAlignedAllocator<int, 16u>::* )( ::size_type,int const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<int, 16u>::* )( int *,int const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address int * ( ::btAlignedAllocator<int, 16u>::* )( int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address int * ( ::btAlignedAllocator<int, 16u>::* )( int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address int const * ( ::btAlignedAllocator<int, 16u>::* )( int const & ) const
// error:  - unsupported,  - unsupported


// ::btAlignedAllocator< short*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<short*, 16u>::* )(  ) 
void* btAlignedAllocator_short_ptr_16u__new() {
	::btAlignedAllocator< short*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< short*, 16u >),16);
	o = new (mem)::btAlignedAllocator< short*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_short_ptr_16u__free(void *c) {
	::btAlignedAllocator< short*, 16u > *o = (::btAlignedAllocator< short*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<short*, 16u>::* )( short int * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<short*, 16u>::* )( short int * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate short int * * ( ::btAlignedAllocator<short*, 16u>::* )( ::size_type,short int * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<short*, 16u>::* )( short int * *,short int * const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address short int * * ( ::btAlignedAllocator<short*, 16u>::* )( short int * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address short int * * ( ::btAlignedAllocator<short*, 16u>::* )( short int * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address short int * const * ( ::btAlignedAllocator<short*, 16u>::* )( short int * const & ) const
// error:  - unsupported,  - unsupported


// ::btAlignedAllocator< short, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<short, 16u>::* )(  ) 
void* btAlignedAllocator_short_16u__new() {
	::btAlignedAllocator< short, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< short, 16u >),16);
	o = new (mem)::btAlignedAllocator< short, 16u >();
	return (void*)o;
}
void btAlignedAllocator_short_16u__free(void *c) {
	::btAlignedAllocator< short, 16u > *o = (::btAlignedAllocator< short, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<short, 16u>::* )( short int * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<short, 16u>::* )( short int * ) 
// error:  - unsupported, void - ok

//not supported method: allocate short int * ( ::btAlignedAllocator<short, 16u>::* )( ::size_type,short int const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<short, 16u>::* )( short int *,short int const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address short int * ( ::btAlignedAllocator<short, 16u>::* )( short int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address short int * ( ::btAlignedAllocator<short, 16u>::* )( short int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address short int const * ( ::btAlignedAllocator<short, 16u>::* )( short int const & ) const
// error:  - unsupported,  - unsupported


// ::btAlignedAllocator< unsigned int, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<unsigned int, 16u>::* )(  ) 
void* btAlignedAllocator_unsignedint_16u__new() {
	::btAlignedAllocator< unsigned int, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< unsigned int, 16u >),16);
	o = new (mem)::btAlignedAllocator< unsigned int, 16u >();
	return (void*)o;
}
void btAlignedAllocator_unsignedint_16u__free(void *c) {
	::btAlignedAllocator< unsigned int, 16u > *o = (::btAlignedAllocator< unsigned int, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<unsigned int, 16u>::* )( unsigned int * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<unsigned int, 16u>::* )( unsigned int * ) 
// error:  - unsupported, void - ok

//not supported method: allocate unsigned int * ( ::btAlignedAllocator<unsigned int, 16u>::* )( ::size_type,unsigned int const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<unsigned int, 16u>::* )( unsigned int *,unsigned int const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address unsigned int * ( ::btAlignedAllocator<unsigned int, 16u>::* )( unsigned int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address unsigned int * ( ::btAlignedAllocator<unsigned int, 16u>::* )( unsigned int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address unsigned int const * ( ::btAlignedAllocator<unsigned int, 16u>::* )( unsigned int const & ) const
// error:  - unsupported,  - unsupported


// ::btAlignedAllocator< unsigned short, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<unsigned short, 16u>::* )(  ) 
void* btAlignedAllocator_unsignedshort_16u__new() {
	::btAlignedAllocator< unsigned short, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< unsigned short, 16u >),16);
	o = new (mem)::btAlignedAllocator< unsigned short, 16u >();
	return (void*)o;
}
void btAlignedAllocator_unsignedshort_16u__free(void *c) {
	::btAlignedAllocator< unsigned short, 16u > *o = (::btAlignedAllocator< unsigned short, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<unsigned short, 16u>::* )( short unsigned int * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<unsigned short, 16u>::* )( short unsigned int * ) 
// error:  - unsupported, void - ok

//not supported method: allocate short unsigned int * ( ::btAlignedAllocator<unsigned short, 16u>::* )( ::size_type,short unsigned int const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<unsigned short, 16u>::* )( short unsigned int *,short unsigned int const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address short unsigned int * ( ::btAlignedAllocator<unsigned short, 16u>::* )( short unsigned int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address short unsigned int * ( ::btAlignedAllocator<unsigned short, 16u>::* )( short unsigned int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address short unsigned int const * ( ::btAlignedAllocator<unsigned short, 16u>::* )( short unsigned int const & ) const
// error:  - unsupported,  - unsupported


// ::btAlignedAllocator< void*, 16u >
//constructor: btAlignedAllocator  ( ::btAlignedAllocator<void*, 16u>::* )(  ) 
void* btAlignedAllocator_void_ptr_16u__new() {
	::btAlignedAllocator< void*, 16u > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedAllocator< void*, 16u >),16);
	o = new (mem)::btAlignedAllocator< void*, 16u >();
	return (void*)o;
}
void btAlignedAllocator_void_ptr_16u__free(void *c) {
	::btAlignedAllocator< void*, 16u > *o = (::btAlignedAllocator< void*, 16u >*)c;
	delete o;
}
//not supported method: destroy void ( ::btAlignedAllocator<void*, 16u>::* )( void * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<void*, 16u>::* )( void * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate void * * ( ::btAlignedAllocator<void*, 16u>::* )( ::size_type,void * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<void*, 16u>::* )( void * *,void * const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address void * * ( ::btAlignedAllocator<void*, 16u>::* )( void * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address void * * ( ::btAlignedAllocator<void*, 16u>::* )( void * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address void * const * ( ::btAlignedAllocator<void*, 16u>::* )( void * const & ) const
// error:  - unsupported,  - unsupported


// ::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) 
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__new() {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >),16);
	o = new (mem)::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >();
	return (void*)o;
}
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__free(void *c) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( ::BT_QUANTIZED_BVH_NODE const & ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__push_back(void *c,void* p0) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	::BT_QUANTIZED_BVH_NODE const & tp0 = *(::BT_QUANTIZED_BVH_NODE const *)p0;
	o->push_back(tp0);
}
//method: at ::BT_QUANTIZED_BVH_NODE const & ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int ) const
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__at(void *c,int p0) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::BT_QUANTIZED_BVH_NODE const & ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int ) const
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__at0(void *c,int p0) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::BT_QUANTIZED_BVH_NODE & ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int ) 
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__at1(void *c,int p0) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) const
int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__size(void *c) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) const
int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__capacity(void *c) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__init(void *c) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int ) 
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__allocate(void *c,int p0) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__pop_back(void *c) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__deallocate(void *c) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int,int ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( void *,int,int ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::BT_QUANTIZED_BVH_NODE & ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) 
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__expandNonInitializing(void *c) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int,::BT_QUANTIZED_BVH_NODE const & ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	::BT_QUANTIZED_BVH_NODE const & tp1 = *(::BT_QUANTIZED_BVH_NODE const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int,int ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int,int,::BT_QUANTIZED_BVH_NODE * ) const
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	::BT_QUANTIZED_BVH_NODE * tp2 = (::BT_QUANTIZED_BVH_NODE *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::BT_QUANTIZED_BVH_NODE & ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( ::BT_QUANTIZED_BVH_NODE const & ) 
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__expand(void *c,void* p0) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	::BT_QUANTIZED_BVH_NODE const & tp0 = *(::BT_QUANTIZED_BVH_NODE const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__clear(void *c) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int ) 
int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__allocSize(void *c,int p0) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__reserve(void *c,int p0) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u> btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_->m_allocator
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u> & ta = *(::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_allocator_get(void *c) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_->m_size
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_size_set(void *c,int a) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_size_get(void *c) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_->m_capacity
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_capacity_get(void *c) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::BT_QUANTIZED_BVH_NODE * btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_->m_data
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	::BT_QUANTIZED_BVH_NODE * ta = (::BT_QUANTIZED_BVH_NODE *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_data_get(void *c) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_->m_ownsMemory
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE > *o = (::btAlignedObjectArray< BT_QUANTIZED_BVH_NODE >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< GIM_BVH_DATA >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) 
void* btAlignedObjectArray_GIM_BVH_DATA__new() {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< GIM_BVH_DATA >),16);
	o = new (mem)::btAlignedObjectArray< GIM_BVH_DATA >();
	return (void*)o;
}
void btAlignedObjectArray_GIM_BVH_DATA__free(void *c) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( ::GIM_BVH_DATA const & ) 
void btAlignedObjectArray_GIM_BVH_DATA__push_back(void *c,void* p0) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	::GIM_BVH_DATA const & tp0 = *(::GIM_BVH_DATA const *)p0;
	o->push_back(tp0);
}
//method: at ::GIM_BVH_DATA const & ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int ) const
void* btAlignedObjectArray_GIM_BVH_DATA__at(void *c,int p0) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::GIM_BVH_DATA const & ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int ) const
void* btAlignedObjectArray_GIM_BVH_DATA__at0(void *c,int p0) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::GIM_BVH_DATA & ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int ) 
void* btAlignedObjectArray_GIM_BVH_DATA__at1(void *c,int p0) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) const
int btAlignedObjectArray_GIM_BVH_DATA__size(void *c) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) const
int btAlignedObjectArray_GIM_BVH_DATA__capacity(void *c) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_DATA__init(void *c) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int ) 
void* btAlignedObjectArray_GIM_BVH_DATA__allocate(void *c,int p0) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_DATA__pop_back(void *c) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_DATA__deallocate(void *c) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int,int ) 
void btAlignedObjectArray_GIM_BVH_DATA__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( void *,int,int ) 
void btAlignedObjectArray_GIM_BVH_DATA__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::GIM_BVH_DATA & ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) 
void* btAlignedObjectArray_GIM_BVH_DATA__expandNonInitializing(void *c) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int,::GIM_BVH_DATA const & ) 
void btAlignedObjectArray_GIM_BVH_DATA__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	::GIM_BVH_DATA const & tp1 = *(::GIM_BVH_DATA const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int,int ) 
void btAlignedObjectArray_GIM_BVH_DATA__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int,int,::GIM_BVH_DATA * ) const
void btAlignedObjectArray_GIM_BVH_DATA__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	::GIM_BVH_DATA * tp2 = (::GIM_BVH_DATA *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::GIM_BVH_DATA & ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( ::GIM_BVH_DATA const & ) 
void* btAlignedObjectArray_GIM_BVH_DATA__expand(void *c,void* p0) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	::GIM_BVH_DATA const & tp0 = *(::GIM_BVH_DATA const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_DATA__clear(void *c) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int ) 
int btAlignedObjectArray_GIM_BVH_DATA__allocSize(void *c,int p0) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int ) 
void btAlignedObjectArray_GIM_BVH_DATA__reserve(void *c,int p0) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<GIM_BVH_DATA, 16u> btAlignedObjectArray_GIM_BVH_DATA_->m_allocator
void btAlignedObjectArray_GIM_BVH_DATA__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	::btAlignedAllocator<GIM_BVH_DATA, 16u> & ta = *(::btAlignedAllocator<GIM_BVH_DATA, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_GIM_BVH_DATA__m_allocator_get(void *c) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_GIM_BVH_DATA_->m_size
void btAlignedObjectArray_GIM_BVH_DATA__m_size_set(void *c,int a) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_GIM_BVH_DATA__m_size_get(void *c) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_GIM_BVH_DATA_->m_capacity
void btAlignedObjectArray_GIM_BVH_DATA__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_GIM_BVH_DATA__m_capacity_get(void *c) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::GIM_BVH_DATA * btAlignedObjectArray_GIM_BVH_DATA_->m_data
void btAlignedObjectArray_GIM_BVH_DATA__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	::GIM_BVH_DATA * ta = (::GIM_BVH_DATA *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_GIM_BVH_DATA__m_data_get(void *c) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_GIM_BVH_DATA_->m_ownsMemory
void btAlignedObjectArray_GIM_BVH_DATA__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_GIM_BVH_DATA__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< GIM_BVH_DATA > *o = (::btAlignedObjectArray< GIM_BVH_DATA >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< GIM_BVH_TREE_NODE >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) 
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__new() {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< GIM_BVH_TREE_NODE >),16);
	o = new (mem)::btAlignedObjectArray< GIM_BVH_TREE_NODE >();
	return (void*)o;
}
void btAlignedObjectArray_GIM_BVH_TREE_NODE__free(void *c) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( ::GIM_BVH_TREE_NODE const & ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__push_back(void *c,void* p0) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	::GIM_BVH_TREE_NODE const & tp0 = *(::GIM_BVH_TREE_NODE const *)p0;
	o->push_back(tp0);
}
//method: at ::GIM_BVH_TREE_NODE const & ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int ) const
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__at(void *c,int p0) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::GIM_BVH_TREE_NODE const & ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int ) const
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__at0(void *c,int p0) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::GIM_BVH_TREE_NODE & ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int ) 
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__at1(void *c,int p0) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) const
int btAlignedObjectArray_GIM_BVH_TREE_NODE__size(void *c) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) const
int btAlignedObjectArray_GIM_BVH_TREE_NODE__capacity(void *c) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__init(void *c) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int ) 
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__allocate(void *c,int p0) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__pop_back(void *c) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__deallocate(void *c) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int,int ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( void *,int,int ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::GIM_BVH_TREE_NODE & ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) 
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__expandNonInitializing(void *c) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int,::GIM_BVH_TREE_NODE const & ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	::GIM_BVH_TREE_NODE const & tp1 = *(::GIM_BVH_TREE_NODE const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int,int ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int,int,::GIM_BVH_TREE_NODE * ) const
void btAlignedObjectArray_GIM_BVH_TREE_NODE__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	::GIM_BVH_TREE_NODE * tp2 = (::GIM_BVH_TREE_NODE *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::GIM_BVH_TREE_NODE & ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( ::GIM_BVH_TREE_NODE const & ) 
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__expand(void *c,void* p0) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	::GIM_BVH_TREE_NODE const & tp0 = *(::GIM_BVH_TREE_NODE const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__clear(void *c) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int ) 
int btAlignedObjectArray_GIM_BVH_TREE_NODE__allocSize(void *c,int p0) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__reserve(void *c,int p0) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u> btAlignedObjectArray_GIM_BVH_TREE_NODE_->m_allocator
void btAlignedObjectArray_GIM_BVH_TREE_NODE__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u> & ta = *(::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__m_allocator_get(void *c) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_GIM_BVH_TREE_NODE_->m_size
void btAlignedObjectArray_GIM_BVH_TREE_NODE__m_size_set(void *c,int a) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_GIM_BVH_TREE_NODE__m_size_get(void *c) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_GIM_BVH_TREE_NODE_->m_capacity
void btAlignedObjectArray_GIM_BVH_TREE_NODE__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_GIM_BVH_TREE_NODE__m_capacity_get(void *c) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::GIM_BVH_TREE_NODE * btAlignedObjectArray_GIM_BVH_TREE_NODE_->m_data
void btAlignedObjectArray_GIM_BVH_TREE_NODE__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	::GIM_BVH_TREE_NODE * ta = (::GIM_BVH_TREE_NODE *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__m_data_get(void *c) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_GIM_BVH_TREE_NODE_->m_ownsMemory
void btAlignedObjectArray_GIM_BVH_TREE_NODE__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_GIM_BVH_TREE_NODE__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< GIM_BVH_TREE_NODE > *o = (::btAlignedObjectArray< GIM_BVH_TREE_NODE >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< GIM_PAIR >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) 
void* btAlignedObjectArray_GIM_PAIR__new() {
	::btAlignedObjectArray< GIM_PAIR > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< GIM_PAIR >),16);
	o = new (mem)::btAlignedObjectArray< GIM_PAIR >();
	return (void*)o;
}
void btAlignedObjectArray_GIM_PAIR__free(void *c) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<GIM_PAIR>::* )( ::GIM_PAIR const & ) 
void btAlignedObjectArray_GIM_PAIR__push_back(void *c,void* p0) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	::GIM_PAIR const & tp0 = *(::GIM_PAIR const *)p0;
	o->push_back(tp0);
}
//method: at ::GIM_PAIR const & ( ::btAlignedObjectArray<GIM_PAIR>::* )( int ) const
void* btAlignedObjectArray_GIM_PAIR__at(void *c,int p0) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::GIM_PAIR const & ( ::btAlignedObjectArray<GIM_PAIR>::* )( int ) const
void* btAlignedObjectArray_GIM_PAIR__at0(void *c,int p0) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::GIM_PAIR & ( ::btAlignedObjectArray<GIM_PAIR>::* )( int ) 
void* btAlignedObjectArray_GIM_PAIR__at1(void *c,int p0) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) const
int btAlignedObjectArray_GIM_PAIR__size(void *c) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) const
int btAlignedObjectArray_GIM_PAIR__capacity(void *c) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) 
void btAlignedObjectArray_GIM_PAIR__init(void *c) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<GIM_PAIR>::* )( int ) 
void* btAlignedObjectArray_GIM_PAIR__allocate(void *c,int p0) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) 
void btAlignedObjectArray_GIM_PAIR__pop_back(void *c) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) 
void btAlignedObjectArray_GIM_PAIR__deallocate(void *c) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<GIM_PAIR>::* )( int,int ) 
void btAlignedObjectArray_GIM_PAIR__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<GIM_PAIR>::* )( void *,int,int ) 
void btAlignedObjectArray_GIM_PAIR__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::GIM_PAIR & ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) 
void* btAlignedObjectArray_GIM_PAIR__expandNonInitializing(void *c) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<GIM_PAIR>::* )( int,::GIM_PAIR const & ) 
void btAlignedObjectArray_GIM_PAIR__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	::GIM_PAIR const & tp1 = *(::GIM_PAIR const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<GIM_PAIR>::* )( int,int ) 
void btAlignedObjectArray_GIM_PAIR__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<GIM_PAIR>::* )( int,int,::GIM_PAIR * ) const
void btAlignedObjectArray_GIM_PAIR__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	::GIM_PAIR * tp2 = (::GIM_PAIR *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::GIM_PAIR & ( ::btAlignedObjectArray<GIM_PAIR>::* )( ::GIM_PAIR const & ) 
void* btAlignedObjectArray_GIM_PAIR__expand(void *c,void* p0) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	::GIM_PAIR const & tp0 = *(::GIM_PAIR const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) 
void btAlignedObjectArray_GIM_PAIR__clear(void *c) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<GIM_PAIR>::* )( int ) 
int btAlignedObjectArray_GIM_PAIR__allocSize(void *c,int p0) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<GIM_PAIR>::* )( int ) 
void btAlignedObjectArray_GIM_PAIR__reserve(void *c,int p0) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<GIM_PAIR, 16u> btAlignedObjectArray_GIM_PAIR_->m_allocator
void btAlignedObjectArray_GIM_PAIR__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	::btAlignedAllocator<GIM_PAIR, 16u> & ta = *(::btAlignedAllocator<GIM_PAIR, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_GIM_PAIR__m_allocator_get(void *c) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_GIM_PAIR_->m_size
void btAlignedObjectArray_GIM_PAIR__m_size_set(void *c,int a) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_GIM_PAIR__m_size_get(void *c) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_GIM_PAIR_->m_capacity
void btAlignedObjectArray_GIM_PAIR__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_GIM_PAIR__m_capacity_get(void *c) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::GIM_PAIR * btAlignedObjectArray_GIM_PAIR_->m_data
void btAlignedObjectArray_GIM_PAIR__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	::GIM_PAIR * ta = (::GIM_PAIR *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_GIM_PAIR__m_data_get(void *c) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_GIM_PAIR_->m_ownsMemory
void btAlignedObjectArray_GIM_PAIR__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_GIM_PAIR__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< GIM_PAIR > *o = (::btAlignedObjectArray< GIM_PAIR >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< bool >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<bool>::* )(  ) 
void* btAlignedObjectArray_bool__new() {
	::btAlignedObjectArray< bool > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< bool >),16);
	o = new (mem)::btAlignedObjectArray< bool >();
	return (void*)o;
}
void btAlignedObjectArray_bool__free(void *c) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	delete o;
}
//not supported method: push_back void ( ::btAlignedObjectArray<bool>::* )( bool const & ) 
// error:  - unsupported, void - ok

//not supported method: at bool const & ( ::btAlignedObjectArray<bool>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at bool const & ( ::btAlignedObjectArray<bool>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at bool & ( ::btAlignedObjectArray<bool>::* )( int ) 
// error: int - ok,  - unsupported

//method: size int ( ::btAlignedObjectArray<bool>::* )(  ) const
int btAlignedObjectArray_bool__size(void *c) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<bool>::* )(  ) const
int btAlignedObjectArray_bool__capacity(void *c) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<bool>::* )(  ) 
void btAlignedObjectArray_bool__init(void *c) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<bool>::* )( int,int ) 
void btAlignedObjectArray_bool__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<bool>::* )(  ) 
void btAlignedObjectArray_bool__pop_back(void *c) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<bool>::* )(  ) 
void btAlignedObjectArray_bool__deallocate(void *c) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<bool>::* )( int ) 
void* btAlignedObjectArray_bool__allocate(void *c,int p0) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<bool>::* )( void *,int,int ) 
void btAlignedObjectArray_bool__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//not supported method: expandNonInitializing bool & ( ::btAlignedObjectArray<bool>::* )(  ) 
// error:  - unsupported

//method: destroy void ( ::btAlignedObjectArray<bool>::* )( int,int ) 
void btAlignedObjectArray_bool__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<bool>::* )( int,int,bool * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: resize void ( ::btAlignedObjectArray<bool>::* )( int,bool const & ) 
// error: int - ok,  - unsupported, void - ok

//method: clear void ( ::btAlignedObjectArray<bool>::* )(  ) 
void btAlignedObjectArray_bool__clear(void *c) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<bool>::* )( int ) 
int btAlignedObjectArray_bool__allocSize(void *c,int p0) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//not supported method: expand bool & ( ::btAlignedObjectArray<bool>::* )( bool const & ) 
// error:  - unsupported,  - unsupported

//method: reserve void ( ::btAlignedObjectArray<bool>::* )( int ) 
void btAlignedObjectArray_bool__reserve(void *c,int p0) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<bool, 16u> btAlignedObjectArray_bool_->m_allocator
void btAlignedObjectArray_bool__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	::btAlignedAllocator<bool, 16u> & ta = *(::btAlignedAllocator<bool, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_bool__m_allocator_get(void *c) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_bool_->m_capacity
void btAlignedObjectArray_bool__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_bool__m_capacity_get(void *c) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	return (int)(o->m_capacity);
}

//attribute: bool * btAlignedObjectArray_bool_->m_data
// attribute not supported: //attribute: bool * btAlignedObjectArray_bool_->m_data
//attribute: bool btAlignedObjectArray_bool_->m_ownsMemory
void btAlignedObjectArray_bool__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_bool__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_bool_->m_size
void btAlignedObjectArray_bool__m_size_set(void *c,int a) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_bool__m_size_get(void *c) {
	::btAlignedObjectArray< bool > *o = (::btAlignedObjectArray< bool >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btActionInterface* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) 
void* btAlignedObjectArray_btActionInterface_ptr__new() {
	::btAlignedObjectArray< btActionInterface* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btActionInterface* >),16);
	o = new (mem)::btAlignedObjectArray< btActionInterface* >();
	return (void*)o;
}
void btAlignedObjectArray_btActionInterface_ptr__free(void *c) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btActionInterface*>::* )( ::btActionInterface * const & ) 
void btAlignedObjectArray_btActionInterface_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	o->push_back(tp0);
}
//method: at ::btActionInterface * const & ( ::btAlignedObjectArray<btActionInterface*>::* )( int ) const
void* btAlignedObjectArray_btActionInterface_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btActionInterface * const & ( ::btAlignedObjectArray<btActionInterface*>::* )( int ) const
void* btAlignedObjectArray_btActionInterface_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btActionInterface * & ( ::btAlignedObjectArray<btActionInterface*>::* )( int ) 
void* btAlignedObjectArray_btActionInterface_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) const
int btAlignedObjectArray_btActionInterface_ptr__size(void *c) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) const
int btAlignedObjectArray_btActionInterface_ptr__capacity(void *c) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) 
void btAlignedObjectArray_btActionInterface_ptr__init(void *c) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btActionInterface*>::* )( int ) 
void* btAlignedObjectArray_btActionInterface_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) 
void btAlignedObjectArray_btActionInterface_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) 
void btAlignedObjectArray_btActionInterface_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btActionInterface*>::* )( int,int ) 
void btAlignedObjectArray_btActionInterface_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btActionInterface*>::* )( void *,int,int ) 
void btAlignedObjectArray_btActionInterface_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btActionInterface * & ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) 
void* btAlignedObjectArray_btActionInterface_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btActionInterface*>::* )( int,::btActionInterface * const & ) 
void btAlignedObjectArray_btActionInterface_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	::btActionInterface * tp1 = (::btActionInterface *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btActionInterface*>::* )( int,int ) 
void btAlignedObjectArray_btActionInterface_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btActionInterface*>::* )( int,int,::btActionInterface * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: expand ::btActionInterface * & ( ::btAlignedObjectArray<btActionInterface*>::* )( ::btActionInterface * const & ) 
void* btAlignedObjectArray_btActionInterface_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) 
void btAlignedObjectArray_btActionInterface_ptr__clear(void *c) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btActionInterface*>::* )( int ) 
int btAlignedObjectArray_btActionInterface_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btActionInterface*>::* )( int ) 
void btAlignedObjectArray_btActionInterface_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btActionInterface*, 16u> btAlignedObjectArray_btActionInterface_ptr_->m_allocator
void btAlignedObjectArray_btActionInterface_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	::btAlignedAllocator<btActionInterface*, 16u> & ta = *(::btAlignedAllocator<btActionInterface*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btActionInterface_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btActionInterface_ptr_->m_size
void btAlignedObjectArray_btActionInterface_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btActionInterface_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btActionInterface_ptr_->m_capacity
void btAlignedObjectArray_btActionInterface_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btActionInterface_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btActionInterface * * btAlignedObjectArray_btActionInterface_ptr_->m_data
// attribute not supported: //attribute: ::btActionInterface * * btAlignedObjectArray_btActionInterface_ptr_->m_data
//attribute: bool btAlignedObjectArray_btActionInterface_ptr_->m_ownsMemory
void btAlignedObjectArray_btActionInterface_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btActionInterface_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btActionInterface* > *o = (::btAlignedObjectArray< btActionInterface* >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btBroadphaseInterface* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) 
void* btAlignedObjectArray_btBroadphaseInterface_ptr__new() {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btBroadphaseInterface* >),16);
	o = new (mem)::btAlignedObjectArray< btBroadphaseInterface* >();
	return (void*)o;
}
void btAlignedObjectArray_btBroadphaseInterface_ptr__free(void *c) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( ::btBroadphaseInterface * const & ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	::btBroadphaseInterface * tp0 = (::btBroadphaseInterface *)p0;
	o->push_back(tp0);
}
//method: at ::btBroadphaseInterface * const & ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int ) const
void* btAlignedObjectArray_btBroadphaseInterface_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btBroadphaseInterface * const & ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int ) const
void* btAlignedObjectArray_btBroadphaseInterface_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btBroadphaseInterface * & ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int ) 
void* btAlignedObjectArray_btBroadphaseInterface_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) const
int btAlignedObjectArray_btBroadphaseInterface_ptr__size(void *c) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) const
int btAlignedObjectArray_btBroadphaseInterface_ptr__capacity(void *c) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__init(void *c) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int ) 
void* btAlignedObjectArray_btBroadphaseInterface_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int,int ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( void *,int,int ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btBroadphaseInterface * & ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) 
void* btAlignedObjectArray_btBroadphaseInterface_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int,::btBroadphaseInterface * const & ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	::btBroadphaseInterface * tp1 = (::btBroadphaseInterface *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int,int ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int,int,::btBroadphaseInterface * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: expand ::btBroadphaseInterface * & ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( ::btBroadphaseInterface * const & ) 
void* btAlignedObjectArray_btBroadphaseInterface_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	::btBroadphaseInterface * tp0 = (::btBroadphaseInterface *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__clear(void *c) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int ) 
int btAlignedObjectArray_btBroadphaseInterface_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btBroadphaseInterface*, 16u> btAlignedObjectArray_btBroadphaseInterface_ptr_->m_allocator
void btAlignedObjectArray_btBroadphaseInterface_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	::btAlignedAllocator<btBroadphaseInterface*, 16u> & ta = *(::btAlignedAllocator<btBroadphaseInterface*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btBroadphaseInterface_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btBroadphaseInterface_ptr_->m_size
void btAlignedObjectArray_btBroadphaseInterface_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btBroadphaseInterface_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btBroadphaseInterface_ptr_->m_capacity
void btAlignedObjectArray_btBroadphaseInterface_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btBroadphaseInterface_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btBroadphaseInterface * * btAlignedObjectArray_btBroadphaseInterface_ptr_->m_data
// attribute not supported: //attribute: ::btBroadphaseInterface * * btAlignedObjectArray_btBroadphaseInterface_ptr_->m_data
//attribute: bool btAlignedObjectArray_btBroadphaseInterface_ptr_->m_ownsMemory
void btAlignedObjectArray_btBroadphaseInterface_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btBroadphaseInterface_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btBroadphaseInterface* > *o = (::btAlignedObjectArray< btBroadphaseInterface* >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btBroadphasePair >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) 
void* btAlignedObjectArray_btBroadphasePair__new() {
	::btAlignedObjectArray< btBroadphasePair > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btBroadphasePair >),16);
	o = new (mem)::btAlignedObjectArray< btBroadphasePair >();
	return (void*)o;
}
void btAlignedObjectArray_btBroadphasePair__free(void *c) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btBroadphasePair>::* )( ::btBroadphasePair const & ) 
void btAlignedObjectArray_btBroadphasePair__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	::btBroadphasePair const & tp0 = *(::btBroadphasePair const *)p0;
	o->push_back(tp0);
}
//method: at ::btBroadphasePair const & ( ::btAlignedObjectArray<btBroadphasePair>::* )( int ) const
void* btAlignedObjectArray_btBroadphasePair__at(void *c,int p0) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btBroadphasePair const & ( ::btAlignedObjectArray<btBroadphasePair>::* )( int ) const
void* btAlignedObjectArray_btBroadphasePair__at0(void *c,int p0) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btBroadphasePair & ( ::btAlignedObjectArray<btBroadphasePair>::* )( int ) 
void* btAlignedObjectArray_btBroadphasePair__at1(void *c,int p0) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) const
int btAlignedObjectArray_btBroadphasePair__size(void *c) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) const
int btAlignedObjectArray_btBroadphasePair__capacity(void *c) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) 
void btAlignedObjectArray_btBroadphasePair__init(void *c) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btBroadphasePair>::* )( int ) 
void* btAlignedObjectArray_btBroadphasePair__allocate(void *c,int p0) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) 
void btAlignedObjectArray_btBroadphasePair__pop_back(void *c) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) 
void btAlignedObjectArray_btBroadphasePair__deallocate(void *c) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btBroadphasePair>::* )( int,int ) 
void btAlignedObjectArray_btBroadphasePair__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btBroadphasePair>::* )( void *,int,int ) 
void btAlignedObjectArray_btBroadphasePair__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btBroadphasePair & ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) 
void* btAlignedObjectArray_btBroadphasePair__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btBroadphasePair>::* )( int,::btBroadphasePair const & ) 
void btAlignedObjectArray_btBroadphasePair__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	::btBroadphasePair const & tp1 = *(::btBroadphasePair const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btBroadphasePair>::* )( int,int ) 
void btAlignedObjectArray_btBroadphasePair__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btBroadphasePair>::* )( int,int,::btBroadphasePair * ) const
void btAlignedObjectArray_btBroadphasePair__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	::btBroadphasePair * tp2 = (::btBroadphasePair *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btBroadphasePair & ( ::btAlignedObjectArray<btBroadphasePair>::* )( ::btBroadphasePair const & ) 
void* btAlignedObjectArray_btBroadphasePair__expand(void *c,void* p0) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	::btBroadphasePair const & tp0 = *(::btBroadphasePair const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) 
void btAlignedObjectArray_btBroadphasePair__clear(void *c) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btBroadphasePair>::* )( int ) 
int btAlignedObjectArray_btBroadphasePair__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btBroadphasePair>::* )( int ) 
void btAlignedObjectArray_btBroadphasePair__reserve(void *c,int p0) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btBroadphasePair, 16u> btAlignedObjectArray_btBroadphasePair_->m_allocator
void btAlignedObjectArray_btBroadphasePair__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	::btAlignedAllocator<btBroadphasePair, 16u> & ta = *(::btAlignedAllocator<btBroadphasePair, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btBroadphasePair__m_allocator_get(void *c) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btBroadphasePair_->m_size
void btAlignedObjectArray_btBroadphasePair__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btBroadphasePair__m_size_get(void *c) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btBroadphasePair_->m_capacity
void btAlignedObjectArray_btBroadphasePair__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btBroadphasePair__m_capacity_get(void *c) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btBroadphasePair * btAlignedObjectArray_btBroadphasePair_->m_data
void btAlignedObjectArray_btBroadphasePair__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	::btBroadphasePair * ta = (::btBroadphasePair *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btBroadphasePair__m_data_get(void *c) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btBroadphasePair_->m_ownsMemory
void btAlignedObjectArray_btBroadphasePair__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btBroadphasePair__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btBroadphasePair > *o = (::btAlignedObjectArray< btBroadphasePair >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btBvhSubtreeInfo >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) 
void* btAlignedObjectArray_btBvhSubtreeInfo__new() {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btBvhSubtreeInfo >),16);
	o = new (mem)::btAlignedObjectArray< btBvhSubtreeInfo >();
	return (void*)o;
}
void btAlignedObjectArray_btBvhSubtreeInfo__free(void *c) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( ::btBvhSubtreeInfo const & ) 
void btAlignedObjectArray_btBvhSubtreeInfo__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	::btBvhSubtreeInfo const & tp0 = *(::btBvhSubtreeInfo const *)p0;
	o->push_back(tp0);
}
//method: at ::btBvhSubtreeInfo const & ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int ) const
void* btAlignedObjectArray_btBvhSubtreeInfo__at(void *c,int p0) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btBvhSubtreeInfo const & ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int ) const
void* btAlignedObjectArray_btBvhSubtreeInfo__at0(void *c,int p0) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btBvhSubtreeInfo & ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int ) 
void* btAlignedObjectArray_btBvhSubtreeInfo__at1(void *c,int p0) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) const
int btAlignedObjectArray_btBvhSubtreeInfo__size(void *c) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) const
int btAlignedObjectArray_btBvhSubtreeInfo__capacity(void *c) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) 
void btAlignedObjectArray_btBvhSubtreeInfo__init(void *c) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int ) 
void* btAlignedObjectArray_btBvhSubtreeInfo__allocate(void *c,int p0) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) 
void btAlignedObjectArray_btBvhSubtreeInfo__pop_back(void *c) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) 
void btAlignedObjectArray_btBvhSubtreeInfo__deallocate(void *c) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int,int ) 
void btAlignedObjectArray_btBvhSubtreeInfo__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( void *,int,int ) 
void btAlignedObjectArray_btBvhSubtreeInfo__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btBvhSubtreeInfo & ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) 
void* btAlignedObjectArray_btBvhSubtreeInfo__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int,::btBvhSubtreeInfo const & ) 
void btAlignedObjectArray_btBvhSubtreeInfo__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	::btBvhSubtreeInfo const & tp1 = *(::btBvhSubtreeInfo const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int,int ) 
void btAlignedObjectArray_btBvhSubtreeInfo__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int,int,::btBvhSubtreeInfo * ) const
void btAlignedObjectArray_btBvhSubtreeInfo__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	::btBvhSubtreeInfo * tp2 = (::btBvhSubtreeInfo *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btBvhSubtreeInfo & ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( ::btBvhSubtreeInfo const & ) 
void* btAlignedObjectArray_btBvhSubtreeInfo__expand(void *c,void* p0) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	::btBvhSubtreeInfo const & tp0 = *(::btBvhSubtreeInfo const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) 
void btAlignedObjectArray_btBvhSubtreeInfo__clear(void *c) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int ) 
int btAlignedObjectArray_btBvhSubtreeInfo__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int ) 
void btAlignedObjectArray_btBvhSubtreeInfo__reserve(void *c,int p0) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btBvhSubtreeInfo, 16u> btAlignedObjectArray_btBvhSubtreeInfo_->m_allocator
void btAlignedObjectArray_btBvhSubtreeInfo__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	::btAlignedAllocator<btBvhSubtreeInfo, 16u> & ta = *(::btAlignedAllocator<btBvhSubtreeInfo, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btBvhSubtreeInfo__m_allocator_get(void *c) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btBvhSubtreeInfo_->m_size
void btAlignedObjectArray_btBvhSubtreeInfo__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btBvhSubtreeInfo__m_size_get(void *c) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btBvhSubtreeInfo_->m_capacity
void btAlignedObjectArray_btBvhSubtreeInfo__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btBvhSubtreeInfo__m_capacity_get(void *c) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btBvhSubtreeInfo * btAlignedObjectArray_btBvhSubtreeInfo_->m_data
void btAlignedObjectArray_btBvhSubtreeInfo__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	::btBvhSubtreeInfo * ta = (::btBvhSubtreeInfo *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btBvhSubtreeInfo__m_data_get(void *c) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btBvhSubtreeInfo_->m_ownsMemory
void btAlignedObjectArray_btBvhSubtreeInfo__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btBvhSubtreeInfo__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btBvhSubtreeInfo > *o = (::btAlignedObjectArray< btBvhSubtreeInfo >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btChunk* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btChunk*>::* )(  ) 
void* btAlignedObjectArray_btChunk_ptr__new() {
	::btAlignedObjectArray< btChunk* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btChunk* >),16);
	o = new (mem)::btAlignedObjectArray< btChunk* >();
	return (void*)o;
}
void btAlignedObjectArray_btChunk_ptr__free(void *c) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btChunk*>::* )( ::btChunk * const & ) 
void btAlignedObjectArray_btChunk_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	::btChunk * tp0 = (::btChunk *)p0;
	o->push_back(tp0);
}
//method: at ::btChunk * const & ( ::btAlignedObjectArray<btChunk*>::* )( int ) const
void* btAlignedObjectArray_btChunk_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btChunk * const & ( ::btAlignedObjectArray<btChunk*>::* )( int ) const
void* btAlignedObjectArray_btChunk_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btChunk * & ( ::btAlignedObjectArray<btChunk*>::* )( int ) 
void* btAlignedObjectArray_btChunk_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btChunk*>::* )(  ) const
int btAlignedObjectArray_btChunk_ptr__size(void *c) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btChunk*>::* )(  ) const
int btAlignedObjectArray_btChunk_ptr__capacity(void *c) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btChunk*>::* )(  ) 
void btAlignedObjectArray_btChunk_ptr__init(void *c) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btChunk*>::* )( int ) 
void* btAlignedObjectArray_btChunk_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btChunk*>::* )(  ) 
void btAlignedObjectArray_btChunk_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btChunk*>::* )(  ) 
void btAlignedObjectArray_btChunk_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btChunk*>::* )( int,int ) 
void btAlignedObjectArray_btChunk_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btChunk*>::* )( void *,int,int ) 
void btAlignedObjectArray_btChunk_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btChunk * & ( ::btAlignedObjectArray<btChunk*>::* )(  ) 
void* btAlignedObjectArray_btChunk_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btChunk*>::* )( int,::btChunk * const & ) 
void btAlignedObjectArray_btChunk_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	::btChunk * tp1 = (::btChunk *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btChunk*>::* )( int,int ) 
void btAlignedObjectArray_btChunk_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btChunk*>::* )( int,int,::btChunk * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: expand ::btChunk * & ( ::btAlignedObjectArray<btChunk*>::* )( ::btChunk * const & ) 
void* btAlignedObjectArray_btChunk_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	::btChunk * tp0 = (::btChunk *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btChunk*>::* )(  ) 
void btAlignedObjectArray_btChunk_ptr__clear(void *c) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btChunk*>::* )( int ) 
int btAlignedObjectArray_btChunk_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btChunk*>::* )( int ) 
void btAlignedObjectArray_btChunk_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btChunk*, 16u> btAlignedObjectArray_btChunk_ptr_->m_allocator
void btAlignedObjectArray_btChunk_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	::btAlignedAllocator<btChunk*, 16u> & ta = *(::btAlignedAllocator<btChunk*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btChunk_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btChunk_ptr_->m_size
void btAlignedObjectArray_btChunk_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btChunk_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btChunk_ptr_->m_capacity
void btAlignedObjectArray_btChunk_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btChunk_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btChunk * * btAlignedObjectArray_btChunk_ptr_->m_data
// attribute not supported: //attribute: ::btChunk * * btAlignedObjectArray_btChunk_ptr_->m_data
//attribute: bool btAlignedObjectArray_btChunk_ptr_->m_ownsMemory
void btAlignedObjectArray_btChunk_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btChunk_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btChunk* > *o = (::btAlignedObjectArray< btChunk* >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btCollisionObject* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) 
void* btAlignedObjectArray_btCollisionObject_ptr__new() {
	::btAlignedObjectArray< btCollisionObject* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btCollisionObject* >),16);
	o = new (mem)::btAlignedObjectArray< btCollisionObject* >();
	return (void*)o;
}
void btAlignedObjectArray_btCollisionObject_ptr__free(void *c) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btCollisionObject*>::* )( ::btCollisionObject * const & ) 
void btAlignedObjectArray_btCollisionObject_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	o->push_back(tp0);
}
//method: at ::btCollisionObject * const & ( ::btAlignedObjectArray<btCollisionObject*>::* )( int ) const
void* btAlignedObjectArray_btCollisionObject_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btCollisionObject * const & ( ::btAlignedObjectArray<btCollisionObject*>::* )( int ) const
void* btAlignedObjectArray_btCollisionObject_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btCollisionObject * & ( ::btAlignedObjectArray<btCollisionObject*>::* )( int ) 
void* btAlignedObjectArray_btCollisionObject_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) const
int btAlignedObjectArray_btCollisionObject_ptr__size(void *c) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) const
int btAlignedObjectArray_btCollisionObject_ptr__capacity(void *c) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) 
void btAlignedObjectArray_btCollisionObject_ptr__init(void *c) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btCollisionObject*>::* )( int,int ) 
void btAlignedObjectArray_btCollisionObject_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) 
void btAlignedObjectArray_btCollisionObject_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) 
void btAlignedObjectArray_btCollisionObject_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btCollisionObject*>::* )( int ) 
void* btAlignedObjectArray_btCollisionObject_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btCollisionObject*>::* )( void *,int,int ) 
void btAlignedObjectArray_btCollisionObject_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btCollisionObject * & ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) 
void* btAlignedObjectArray_btCollisionObject_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: destroy void ( ::btAlignedObjectArray<btCollisionObject*>::* )( int,int ) 
void btAlignedObjectArray_btCollisionObject_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btCollisionObject*>::* )( int,int,::btCollisionObject * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: resize void ( ::btAlignedObjectArray<btCollisionObject*>::* )( int,::btCollisionObject * const & ) 
void btAlignedObjectArray_btCollisionObject_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	o->resize(p0,tp1);
}
//method: clear void ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) 
void btAlignedObjectArray_btCollisionObject_ptr__clear(void *c) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btCollisionObject*>::* )( int ) 
int btAlignedObjectArray_btCollisionObject_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: expand ::btCollisionObject * & ( ::btAlignedObjectArray<btCollisionObject*>::* )( ::btCollisionObject * const & ) 
void* btAlignedObjectArray_btCollisionObject_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btCollisionObject*>::* )( int ) 
void btAlignedObjectArray_btCollisionObject_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btCollisionObject*, 16u> btAlignedObjectArray_btCollisionObject_ptr_->m_allocator
void btAlignedObjectArray_btCollisionObject_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	::btAlignedAllocator<btCollisionObject*, 16u> & ta = *(::btAlignedAllocator<btCollisionObject*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btCollisionObject_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btCollisionObject_ptr_->m_capacity
void btAlignedObjectArray_btCollisionObject_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btCollisionObject_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btCollisionObject * * btAlignedObjectArray_btCollisionObject_ptr_->m_data
// attribute not supported: //attribute: ::btCollisionObject * * btAlignedObjectArray_btCollisionObject_ptr_->m_data
//attribute: bool btAlignedObjectArray_btCollisionObject_ptr_->m_ownsMemory
void btAlignedObjectArray_btCollisionObject_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btCollisionObject_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btCollisionObject_ptr_->m_size
void btAlignedObjectArray_btCollisionObject_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btCollisionObject_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btCollisionObject* > *o = (::btAlignedObjectArray< btCollisionObject* >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btCollisionShape* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) 
void* btAlignedObjectArray_btCollisionShape_ptr__new() {
	::btAlignedObjectArray< btCollisionShape* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btCollisionShape* >),16);
	o = new (mem)::btAlignedObjectArray< btCollisionShape* >();
	return (void*)o;
}
void btAlignedObjectArray_btCollisionShape_ptr__free(void *c) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btCollisionShape*>::* )( ::btCollisionShape * const & ) 
void btAlignedObjectArray_btCollisionShape_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	::btCollisionShape * tp0 = (::btCollisionShape *)p0;
	o->push_back(tp0);
}
//method: at ::btCollisionShape * const & ( ::btAlignedObjectArray<btCollisionShape*>::* )( int ) const
void* btAlignedObjectArray_btCollisionShape_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btCollisionShape * const & ( ::btAlignedObjectArray<btCollisionShape*>::* )( int ) const
void* btAlignedObjectArray_btCollisionShape_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btCollisionShape * & ( ::btAlignedObjectArray<btCollisionShape*>::* )( int ) 
void* btAlignedObjectArray_btCollisionShape_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) const
int btAlignedObjectArray_btCollisionShape_ptr__size(void *c) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) const
int btAlignedObjectArray_btCollisionShape_ptr__capacity(void *c) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) 
void btAlignedObjectArray_btCollisionShape_ptr__init(void *c) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btCollisionShape*>::* )( int ) 
void* btAlignedObjectArray_btCollisionShape_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) 
void btAlignedObjectArray_btCollisionShape_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) 
void btAlignedObjectArray_btCollisionShape_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btCollisionShape*>::* )( int,int ) 
void btAlignedObjectArray_btCollisionShape_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btCollisionShape*>::* )( void *,int,int ) 
void btAlignedObjectArray_btCollisionShape_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btCollisionShape * & ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) 
void* btAlignedObjectArray_btCollisionShape_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btCollisionShape*>::* )( int,::btCollisionShape * const & ) 
void btAlignedObjectArray_btCollisionShape_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	::btCollisionShape * tp1 = (::btCollisionShape *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btCollisionShape*>::* )( int,int ) 
void btAlignedObjectArray_btCollisionShape_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btCollisionShape*>::* )( int,int,::btCollisionShape * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: expand ::btCollisionShape * & ( ::btAlignedObjectArray<btCollisionShape*>::* )( ::btCollisionShape * const & ) 
void* btAlignedObjectArray_btCollisionShape_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	::btCollisionShape * tp0 = (::btCollisionShape *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) 
void btAlignedObjectArray_btCollisionShape_ptr__clear(void *c) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btCollisionShape*>::* )( int ) 
int btAlignedObjectArray_btCollisionShape_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btCollisionShape*>::* )( int ) 
void btAlignedObjectArray_btCollisionShape_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btCollisionShape*, 16u> btAlignedObjectArray_btCollisionShape_ptr_->m_allocator
void btAlignedObjectArray_btCollisionShape_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	::btAlignedAllocator<btCollisionShape*, 16u> & ta = *(::btAlignedAllocator<btCollisionShape*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btCollisionShape_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btCollisionShape_ptr_->m_size
void btAlignedObjectArray_btCollisionShape_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btCollisionShape_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btCollisionShape_ptr_->m_capacity
void btAlignedObjectArray_btCollisionShape_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btCollisionShape_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btCollisionShape * * btAlignedObjectArray_btCollisionShape_ptr_->m_data
// attribute not supported: //attribute: ::btCollisionShape * * btAlignedObjectArray_btCollisionShape_ptr_->m_data
//attribute: bool btAlignedObjectArray_btCollisionShape_ptr_->m_ownsMemory
void btAlignedObjectArray_btCollisionShape_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btCollisionShape_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btCollisionShape* > *o = (::btAlignedObjectArray< btCollisionShape* >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btCompoundShapeChild >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) 
void* btAlignedObjectArray_btCompoundShapeChild__new() {
	::btAlignedObjectArray< btCompoundShapeChild > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btCompoundShapeChild >),16);
	o = new (mem)::btAlignedObjectArray< btCompoundShapeChild >();
	return (void*)o;
}
void btAlignedObjectArray_btCompoundShapeChild__free(void *c) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( ::btCompoundShapeChild const & ) 
void btAlignedObjectArray_btCompoundShapeChild__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	::btCompoundShapeChild const & tp0 = *(::btCompoundShapeChild const *)p0;
	o->push_back(tp0);
}
//method: at ::btCompoundShapeChild const & ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int ) const
void* btAlignedObjectArray_btCompoundShapeChild__at(void *c,int p0) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btCompoundShapeChild const & ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int ) const
void* btAlignedObjectArray_btCompoundShapeChild__at0(void *c,int p0) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btCompoundShapeChild & ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int ) 
void* btAlignedObjectArray_btCompoundShapeChild__at1(void *c,int p0) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) const
int btAlignedObjectArray_btCompoundShapeChild__size(void *c) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) const
int btAlignedObjectArray_btCompoundShapeChild__capacity(void *c) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) 
void btAlignedObjectArray_btCompoundShapeChild__init(void *c) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int ) 
void* btAlignedObjectArray_btCompoundShapeChild__allocate(void *c,int p0) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) 
void btAlignedObjectArray_btCompoundShapeChild__pop_back(void *c) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) 
void btAlignedObjectArray_btCompoundShapeChild__deallocate(void *c) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int,int ) 
void btAlignedObjectArray_btCompoundShapeChild__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( void *,int,int ) 
void btAlignedObjectArray_btCompoundShapeChild__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btCompoundShapeChild & ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) 
void* btAlignedObjectArray_btCompoundShapeChild__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int,::btCompoundShapeChild const & ) 
void btAlignedObjectArray_btCompoundShapeChild__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	::btCompoundShapeChild const & tp1 = *(::btCompoundShapeChild const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int,int ) 
void btAlignedObjectArray_btCompoundShapeChild__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int,int,::btCompoundShapeChild * ) const
void btAlignedObjectArray_btCompoundShapeChild__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	::btCompoundShapeChild * tp2 = (::btCompoundShapeChild *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btCompoundShapeChild & ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( ::btCompoundShapeChild const & ) 
void* btAlignedObjectArray_btCompoundShapeChild__expand(void *c,void* p0) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	::btCompoundShapeChild const & tp0 = *(::btCompoundShapeChild const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) 
void btAlignedObjectArray_btCompoundShapeChild__clear(void *c) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int ) 
int btAlignedObjectArray_btCompoundShapeChild__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int ) 
void btAlignedObjectArray_btCompoundShapeChild__reserve(void *c,int p0) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btCompoundShapeChild, 16u> btAlignedObjectArray_btCompoundShapeChild_->m_allocator
void btAlignedObjectArray_btCompoundShapeChild__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	::btAlignedAllocator<btCompoundShapeChild, 16u> & ta = *(::btAlignedAllocator<btCompoundShapeChild, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btCompoundShapeChild__m_allocator_get(void *c) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btCompoundShapeChild_->m_size
void btAlignedObjectArray_btCompoundShapeChild__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btCompoundShapeChild__m_size_get(void *c) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btCompoundShapeChild_->m_capacity
void btAlignedObjectArray_btCompoundShapeChild__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btCompoundShapeChild__m_capacity_get(void *c) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btCompoundShapeChild * btAlignedObjectArray_btCompoundShapeChild_->m_data
void btAlignedObjectArray_btCompoundShapeChild__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	::btCompoundShapeChild * ta = (::btCompoundShapeChild *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btCompoundShapeChild__m_data_get(void *c) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btCompoundShapeChild_->m_ownsMemory
void btAlignedObjectArray_btCompoundShapeChild__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btCompoundShapeChild__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btCompoundShapeChild > *o = (::btAlignedObjectArray< btCompoundShapeChild >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btDbvt::sStkNN >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) 
void* btAlignedObjectArray_btDbvt_sStkNN__new() {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btDbvt::sStkNN >),16);
	o = new (mem)::btAlignedObjectArray< btDbvt::sStkNN >();
	return (void*)o;
}
void btAlignedObjectArray_btDbvt_sStkNN__free(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( ::btDbvt::sStkNN const & ) 
void btAlignedObjectArray_btDbvt_sStkNN__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	::btDbvt::sStkNN const & tp0 = *(::btDbvt::sStkNN const *)p0;
	o->push_back(tp0);
}
//method: at ::btDbvt::sStkNN const & ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int ) const
void* btAlignedObjectArray_btDbvt_sStkNN__at(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btDbvt::sStkNN const & ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int ) const
void* btAlignedObjectArray_btDbvt_sStkNN__at0(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btDbvt::sStkNN & ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int ) 
void* btAlignedObjectArray_btDbvt_sStkNN__at1(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) const
int btAlignedObjectArray_btDbvt_sStkNN__size(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) const
int btAlignedObjectArray_btDbvt_sStkNN__capacity(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNN__init(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int ) 
void* btAlignedObjectArray_btDbvt_sStkNN__allocate(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNN__pop_back(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNN__deallocate(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int,int ) 
void btAlignedObjectArray_btDbvt_sStkNN__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( void *,int,int ) 
void btAlignedObjectArray_btDbvt_sStkNN__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btDbvt::sStkNN & ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) 
void* btAlignedObjectArray_btDbvt_sStkNN__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int,::btDbvt::sStkNN const & ) 
void btAlignedObjectArray_btDbvt_sStkNN__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	::btDbvt::sStkNN const & tp1 = *(::btDbvt::sStkNN const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int,int ) 
void btAlignedObjectArray_btDbvt_sStkNN__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int,int,::btDbvt::sStkNN * ) const
void btAlignedObjectArray_btDbvt_sStkNN__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	::btDbvt::sStkNN * tp2 = (::btDbvt::sStkNN *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btDbvt::sStkNN & ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( ::btDbvt::sStkNN const & ) 
void* btAlignedObjectArray_btDbvt_sStkNN__expand(void *c,void* p0) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	::btDbvt::sStkNN const & tp0 = *(::btDbvt::sStkNN const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNN__clear(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int ) 
int btAlignedObjectArray_btDbvt_sStkNN__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int ) 
void btAlignedObjectArray_btDbvt_sStkNN__reserve(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btDbvt::sStkNN, 16u> btAlignedObjectArray_btDbvt_sStkNN_->m_allocator
void btAlignedObjectArray_btDbvt_sStkNN__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	::btAlignedAllocator<btDbvt::sStkNN, 16u> & ta = *(::btAlignedAllocator<btDbvt::sStkNN, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btDbvt_sStkNN__m_allocator_get(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btDbvt_sStkNN_->m_size
void btAlignedObjectArray_btDbvt_sStkNN__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btDbvt_sStkNN__m_size_get(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btDbvt_sStkNN_->m_capacity
void btAlignedObjectArray_btDbvt_sStkNN__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btDbvt_sStkNN__m_capacity_get(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btDbvt::sStkNN * btAlignedObjectArray_btDbvt_sStkNN_->m_data
void btAlignedObjectArray_btDbvt_sStkNN__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	::btDbvt::sStkNN * ta = (::btDbvt::sStkNN *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btDbvt_sStkNN__m_data_get(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btDbvt_sStkNN_->m_ownsMemory
void btAlignedObjectArray_btDbvt_sStkNN__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btDbvt_sStkNN__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNN > *o = (::btAlignedObjectArray< btDbvt::sStkNN >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btDbvt::sStkNP >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) 
void* btAlignedObjectArray_btDbvt_sStkNP__new() {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btDbvt::sStkNP >),16);
	o = new (mem)::btAlignedObjectArray< btDbvt::sStkNP >();
	return (void*)o;
}
void btAlignedObjectArray_btDbvt_sStkNP__free(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( ::btDbvt::sStkNP const & ) 
void btAlignedObjectArray_btDbvt_sStkNP__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	::btDbvt::sStkNP const & tp0 = *(::btDbvt::sStkNP const *)p0;
	o->push_back(tp0);
}
//method: at ::btDbvt::sStkNP const & ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int ) const
void* btAlignedObjectArray_btDbvt_sStkNP__at(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btDbvt::sStkNP const & ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int ) const
void* btAlignedObjectArray_btDbvt_sStkNP__at0(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btDbvt::sStkNP & ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int ) 
void* btAlignedObjectArray_btDbvt_sStkNP__at1(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) const
int btAlignedObjectArray_btDbvt_sStkNP__size(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) const
int btAlignedObjectArray_btDbvt_sStkNP__capacity(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNP__init(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int ) 
void* btAlignedObjectArray_btDbvt_sStkNP__allocate(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNP__pop_back(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNP__deallocate(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int,int ) 
void btAlignedObjectArray_btDbvt_sStkNP__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( void *,int,int ) 
void btAlignedObjectArray_btDbvt_sStkNP__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btDbvt::sStkNP & ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) 
void* btAlignedObjectArray_btDbvt_sStkNP__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int,::btDbvt::sStkNP const & ) 
void btAlignedObjectArray_btDbvt_sStkNP__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	::btDbvt::sStkNP const & tp1 = *(::btDbvt::sStkNP const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int,int ) 
void btAlignedObjectArray_btDbvt_sStkNP__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int,int,::btDbvt::sStkNP * ) const
void btAlignedObjectArray_btDbvt_sStkNP__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	::btDbvt::sStkNP * tp2 = (::btDbvt::sStkNP *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btDbvt::sStkNP & ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( ::btDbvt::sStkNP const & ) 
void* btAlignedObjectArray_btDbvt_sStkNP__expand(void *c,void* p0) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	::btDbvt::sStkNP const & tp0 = *(::btDbvt::sStkNP const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNP__clear(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int ) 
int btAlignedObjectArray_btDbvt_sStkNP__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int ) 
void btAlignedObjectArray_btDbvt_sStkNP__reserve(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btDbvt::sStkNP, 16u> btAlignedObjectArray_btDbvt_sStkNP_->m_allocator
void btAlignedObjectArray_btDbvt_sStkNP__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	::btAlignedAllocator<btDbvt::sStkNP, 16u> & ta = *(::btAlignedAllocator<btDbvt::sStkNP, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btDbvt_sStkNP__m_allocator_get(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btDbvt_sStkNP_->m_size
void btAlignedObjectArray_btDbvt_sStkNP__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btDbvt_sStkNP__m_size_get(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btDbvt_sStkNP_->m_capacity
void btAlignedObjectArray_btDbvt_sStkNP__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btDbvt_sStkNP__m_capacity_get(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btDbvt::sStkNP * btAlignedObjectArray_btDbvt_sStkNP_->m_data
void btAlignedObjectArray_btDbvt_sStkNP__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	::btDbvt::sStkNP * ta = (::btDbvt::sStkNP *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btDbvt_sStkNP__m_data_get(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btDbvt_sStkNP_->m_ownsMemory
void btAlignedObjectArray_btDbvt_sStkNP__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btDbvt_sStkNP__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNP > *o = (::btAlignedObjectArray< btDbvt::sStkNP >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btDbvt::sStkNPS >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) 
void* btAlignedObjectArray_btDbvt_sStkNPS__new() {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btDbvt::sStkNPS >),16);
	o = new (mem)::btAlignedObjectArray< btDbvt::sStkNPS >();
	return (void*)o;
}
void btAlignedObjectArray_btDbvt_sStkNPS__free(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( ::btDbvt::sStkNPS const & ) 
void btAlignedObjectArray_btDbvt_sStkNPS__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	::btDbvt::sStkNPS const & tp0 = *(::btDbvt::sStkNPS const *)p0;
	o->push_back(tp0);
}
//method: at ::btDbvt::sStkNPS const & ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int ) const
void* btAlignedObjectArray_btDbvt_sStkNPS__at(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btDbvt::sStkNPS const & ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int ) const
void* btAlignedObjectArray_btDbvt_sStkNPS__at0(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btDbvt::sStkNPS & ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int ) 
void* btAlignedObjectArray_btDbvt_sStkNPS__at1(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) const
int btAlignedObjectArray_btDbvt_sStkNPS__size(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) const
int btAlignedObjectArray_btDbvt_sStkNPS__capacity(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNPS__init(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int ) 
void* btAlignedObjectArray_btDbvt_sStkNPS__allocate(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNPS__pop_back(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNPS__deallocate(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int,int ) 
void btAlignedObjectArray_btDbvt_sStkNPS__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( void *,int,int ) 
void btAlignedObjectArray_btDbvt_sStkNPS__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btDbvt::sStkNPS & ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) 
void* btAlignedObjectArray_btDbvt_sStkNPS__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int,::btDbvt::sStkNPS const & ) 
void btAlignedObjectArray_btDbvt_sStkNPS__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	::btDbvt::sStkNPS const & tp1 = *(::btDbvt::sStkNPS const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int,int ) 
void btAlignedObjectArray_btDbvt_sStkNPS__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int,int,::btDbvt::sStkNPS * ) const
void btAlignedObjectArray_btDbvt_sStkNPS__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	::btDbvt::sStkNPS * tp2 = (::btDbvt::sStkNPS *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btDbvt::sStkNPS & ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( ::btDbvt::sStkNPS const & ) 
void* btAlignedObjectArray_btDbvt_sStkNPS__expand(void *c,void* p0) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	::btDbvt::sStkNPS const & tp0 = *(::btDbvt::sStkNPS const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNPS__clear(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int ) 
int btAlignedObjectArray_btDbvt_sStkNPS__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int ) 
void btAlignedObjectArray_btDbvt_sStkNPS__reserve(void *c,int p0) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btDbvt::sStkNPS, 16u> btAlignedObjectArray_btDbvt_sStkNPS_->m_allocator
void btAlignedObjectArray_btDbvt_sStkNPS__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	::btAlignedAllocator<btDbvt::sStkNPS, 16u> & ta = *(::btAlignedAllocator<btDbvt::sStkNPS, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btDbvt_sStkNPS__m_allocator_get(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btDbvt_sStkNPS_->m_size
void btAlignedObjectArray_btDbvt_sStkNPS__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btDbvt_sStkNPS__m_size_get(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btDbvt_sStkNPS_->m_capacity
void btAlignedObjectArray_btDbvt_sStkNPS__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btDbvt_sStkNPS__m_capacity_get(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btDbvt::sStkNPS * btAlignedObjectArray_btDbvt_sStkNPS_->m_data
void btAlignedObjectArray_btDbvt_sStkNPS__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	::btDbvt::sStkNPS * ta = (::btDbvt::sStkNPS *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btDbvt_sStkNPS__m_data_get(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btDbvt_sStkNPS_->m_ownsMemory
void btAlignedObjectArray_btDbvt_sStkNPS__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btDbvt_sStkNPS__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btDbvt::sStkNPS > *o = (::btAlignedObjectArray< btDbvt::sStkNPS >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btDbvtNode const* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) 
void* btAlignedObjectArray_btDbvtNodeconst_ptr__new() {
	::btAlignedObjectArray< btDbvtNode const* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btDbvtNode const* >),16);
	o = new (mem)::btAlignedObjectArray< btDbvtNode const* >();
	return (void*)o;
}
void btAlignedObjectArray_btDbvtNodeconst_ptr__free(void *c) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btDbvtNode const*>::* )( ::btDbvtNode const * const & ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	o->push_back(tp0);
}
//method: at ::btDbvtNode const * const & ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int ) const
void* btAlignedObjectArray_btDbvtNodeconst_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btDbvtNode const * const & ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int ) const
void* btAlignedObjectArray_btDbvtNodeconst_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btDbvtNode const * & ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int ) 
void* btAlignedObjectArray_btDbvtNodeconst_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) const
int btAlignedObjectArray_btDbvtNodeconst_ptr__size(void *c) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) const
int btAlignedObjectArray_btDbvtNodeconst_ptr__capacity(void *c) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__init(void *c) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int ) 
void* btAlignedObjectArray_btDbvtNodeconst_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int,int ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btDbvtNode const*>::* )( void *,int,int ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btDbvtNode const * & ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) 
void* btAlignedObjectArray_btDbvtNodeconst_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int,::btDbvtNode const * const & ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	::btDbvtNode const * tp1 = (::btDbvtNode const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int,int ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int,int,::btDbvtNode const * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: expand ::btDbvtNode const * & ( ::btAlignedObjectArray<btDbvtNode const*>::* )( ::btDbvtNode const * const & ) 
void* btAlignedObjectArray_btDbvtNodeconst_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__clear(void *c) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int ) 
int btAlignedObjectArray_btDbvtNodeconst_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btDbvtNode const*, 16u> btAlignedObjectArray_btDbvtNodeconst_ptr_->m_allocator
void btAlignedObjectArray_btDbvtNodeconst_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	::btAlignedAllocator<btDbvtNode const*, 16u> & ta = *(::btAlignedAllocator<btDbvtNode const*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btDbvtNodeconst_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btDbvtNodeconst_ptr_->m_size
void btAlignedObjectArray_btDbvtNodeconst_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btDbvtNodeconst_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btDbvtNodeconst_ptr_->m_capacity
void btAlignedObjectArray_btDbvtNodeconst_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btDbvtNodeconst_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btDbvtNode const * * btAlignedObjectArray_btDbvtNodeconst_ptr_->m_data
// attribute not supported: //attribute: ::btDbvtNode const * * btAlignedObjectArray_btDbvtNodeconst_ptr_->m_data
//attribute: bool btAlignedObjectArray_btDbvtNodeconst_ptr_->m_ownsMemory
void btAlignedObjectArray_btDbvtNodeconst_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btDbvtNodeconst_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btDbvtNode const* > *o = (::btAlignedObjectArray< btDbvtNode const* >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btGImpactMeshShapePart* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) 
void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__new() {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btGImpactMeshShapePart* >),16);
	o = new (mem)::btAlignedObjectArray< btGImpactMeshShapePart* >();
	return (void*)o;
}
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__free(void *c) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( ::btGImpactMeshShapePart * const & ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	::btGImpactMeshShapePart * tp0 = (::btGImpactMeshShapePart *)p0;
	o->push_back(tp0);
}
//method: at ::btGImpactMeshShapePart * const & ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int ) const
void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btGImpactMeshShapePart * const & ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int ) const
void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btGImpactMeshShapePart * & ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int ) 
void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) const
int btAlignedObjectArray_btGImpactMeshShapePart_ptr__size(void *c) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) const
int btAlignedObjectArray_btGImpactMeshShapePart_ptr__capacity(void *c) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__init(void *c) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int ) 
void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int,int ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( void *,int,int ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btGImpactMeshShapePart * & ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) 
void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int,::btGImpactMeshShapePart * const & ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	::btGImpactMeshShapePart * tp1 = (::btGImpactMeshShapePart *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int,int ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int,int,::btGImpactMeshShapePart * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: expand ::btGImpactMeshShapePart * & ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( ::btGImpactMeshShapePart * const & ) 
void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	::btGImpactMeshShapePart * tp0 = (::btGImpactMeshShapePart *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__clear(void *c) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int ) 
int btAlignedObjectArray_btGImpactMeshShapePart_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btGImpactMeshShapePart*, 16u> btAlignedObjectArray_btGImpactMeshShapePart_ptr_->m_allocator
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	::btAlignedAllocator<btGImpactMeshShapePart*, 16u> & ta = *(::btAlignedAllocator<btGImpactMeshShapePart*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btGImpactMeshShapePart_ptr_->m_size
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btGImpactMeshShapePart_ptr_->m_capacity
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btGImpactMeshShapePart * * btAlignedObjectArray_btGImpactMeshShapePart_ptr_->m_data
// attribute not supported: //attribute: ::btGImpactMeshShapePart * * btAlignedObjectArray_btGImpactMeshShapePart_ptr_->m_data
//attribute: bool btAlignedObjectArray_btGImpactMeshShapePart_ptr_->m_ownsMemory
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btGImpactMeshShapePart* > *o = (::btAlignedObjectArray< btGImpactMeshShapePart* >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btHashInt >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btHashInt>::* )(  ) 
void* btAlignedObjectArray_btHashInt__new() {
	::btAlignedObjectArray< btHashInt > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btHashInt >),16);
	o = new (mem)::btAlignedObjectArray< btHashInt >();
	return (void*)o;
}
void btAlignedObjectArray_btHashInt__free(void *c) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btHashInt>::* )( ::btHashInt const & ) 
void btAlignedObjectArray_btHashInt__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	::btHashInt const & tp0 = *(::btHashInt const *)p0;
	o->push_back(tp0);
}
//method: at ::btHashInt const & ( ::btAlignedObjectArray<btHashInt>::* )( int ) const
void* btAlignedObjectArray_btHashInt__at(void *c,int p0) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btHashInt const & ( ::btAlignedObjectArray<btHashInt>::* )( int ) const
void* btAlignedObjectArray_btHashInt__at0(void *c,int p0) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btHashInt & ( ::btAlignedObjectArray<btHashInt>::* )( int ) 
void* btAlignedObjectArray_btHashInt__at1(void *c,int p0) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btHashInt>::* )(  ) const
int btAlignedObjectArray_btHashInt__size(void *c) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btHashInt>::* )(  ) const
int btAlignedObjectArray_btHashInt__capacity(void *c) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btHashInt>::* )(  ) 
void btAlignedObjectArray_btHashInt__init(void *c) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btHashInt>::* )( int ) 
void* btAlignedObjectArray_btHashInt__allocate(void *c,int p0) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btHashInt>::* )(  ) 
void btAlignedObjectArray_btHashInt__pop_back(void *c) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btHashInt>::* )(  ) 
void btAlignedObjectArray_btHashInt__deallocate(void *c) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btHashInt>::* )( int,int ) 
void btAlignedObjectArray_btHashInt__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btHashInt>::* )( void *,int,int ) 
void btAlignedObjectArray_btHashInt__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btHashInt & ( ::btAlignedObjectArray<btHashInt>::* )(  ) 
void* btAlignedObjectArray_btHashInt__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btHashInt>::* )( int,::btHashInt const & ) 
void btAlignedObjectArray_btHashInt__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	::btHashInt const & tp1 = *(::btHashInt const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btHashInt>::* )( int,int ) 
void btAlignedObjectArray_btHashInt__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btHashInt>::* )( int,int,::btHashInt * ) const
void btAlignedObjectArray_btHashInt__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	::btHashInt * tp2 = (::btHashInt *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btHashInt & ( ::btAlignedObjectArray<btHashInt>::* )( ::btHashInt const & ) 
void* btAlignedObjectArray_btHashInt__expand(void *c,void* p0) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	::btHashInt const & tp0 = *(::btHashInt const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btHashInt>::* )(  ) 
void btAlignedObjectArray_btHashInt__clear(void *c) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btHashInt>::* )( int ) 
int btAlignedObjectArray_btHashInt__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btHashInt>::* )( int ) 
void btAlignedObjectArray_btHashInt__reserve(void *c,int p0) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btHashInt, 16u> btAlignedObjectArray_btHashInt_->m_allocator
void btAlignedObjectArray_btHashInt__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	::btAlignedAllocator<btHashInt, 16u> & ta = *(::btAlignedAllocator<btHashInt, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btHashInt__m_allocator_get(void *c) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btHashInt_->m_size
void btAlignedObjectArray_btHashInt__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btHashInt__m_size_get(void *c) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btHashInt_->m_capacity
void btAlignedObjectArray_btHashInt__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btHashInt__m_capacity_get(void *c) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btHashInt * btAlignedObjectArray_btHashInt_->m_data
void btAlignedObjectArray_btHashInt__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	::btHashInt * ta = (::btHashInt *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btHashInt__m_data_get(void *c) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btHashInt_->m_ownsMemory
void btAlignedObjectArray_btHashInt__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btHashInt__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btHashInt > *o = (::btAlignedObjectArray< btHashInt >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btHashPtr >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btHashPtr>::* )(  ) 
void* btAlignedObjectArray_btHashPtr__new() {
	::btAlignedObjectArray< btHashPtr > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btHashPtr >),16);
	o = new (mem)::btAlignedObjectArray< btHashPtr >();
	return (void*)o;
}
void btAlignedObjectArray_btHashPtr__free(void *c) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btHashPtr>::* )( ::btHashPtr const & ) 
void btAlignedObjectArray_btHashPtr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	::btHashPtr const & tp0 = *(::btHashPtr const *)p0;
	o->push_back(tp0);
}
//method: at ::btHashPtr const & ( ::btAlignedObjectArray<btHashPtr>::* )( int ) const
void* btAlignedObjectArray_btHashPtr__at(void *c,int p0) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btHashPtr const & ( ::btAlignedObjectArray<btHashPtr>::* )( int ) const
void* btAlignedObjectArray_btHashPtr__at0(void *c,int p0) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btHashPtr & ( ::btAlignedObjectArray<btHashPtr>::* )( int ) 
void* btAlignedObjectArray_btHashPtr__at1(void *c,int p0) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btHashPtr>::* )(  ) const
int btAlignedObjectArray_btHashPtr__size(void *c) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btHashPtr>::* )(  ) const
int btAlignedObjectArray_btHashPtr__capacity(void *c) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btHashPtr>::* )(  ) 
void btAlignedObjectArray_btHashPtr__init(void *c) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btHashPtr>::* )( int ) 
void* btAlignedObjectArray_btHashPtr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btHashPtr>::* )(  ) 
void btAlignedObjectArray_btHashPtr__pop_back(void *c) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btHashPtr>::* )(  ) 
void btAlignedObjectArray_btHashPtr__deallocate(void *c) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btHashPtr>::* )( int,int ) 
void btAlignedObjectArray_btHashPtr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btHashPtr>::* )( void *,int,int ) 
void btAlignedObjectArray_btHashPtr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btHashPtr & ( ::btAlignedObjectArray<btHashPtr>::* )(  ) 
void* btAlignedObjectArray_btHashPtr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btHashPtr>::* )( int,::btHashPtr const & ) 
void btAlignedObjectArray_btHashPtr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	::btHashPtr const & tp1 = *(::btHashPtr const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btHashPtr>::* )( int,int ) 
void btAlignedObjectArray_btHashPtr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btHashPtr>::* )( int,int,::btHashPtr * ) const
void btAlignedObjectArray_btHashPtr__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	::btHashPtr * tp2 = (::btHashPtr *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btHashPtr & ( ::btAlignedObjectArray<btHashPtr>::* )( ::btHashPtr const & ) 
void* btAlignedObjectArray_btHashPtr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	::btHashPtr const & tp0 = *(::btHashPtr const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btHashPtr>::* )(  ) 
void btAlignedObjectArray_btHashPtr__clear(void *c) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btHashPtr>::* )( int ) 
int btAlignedObjectArray_btHashPtr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btHashPtr>::* )( int ) 
void btAlignedObjectArray_btHashPtr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btHashPtr, 16u> btAlignedObjectArray_btHashPtr_->m_allocator
void btAlignedObjectArray_btHashPtr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	::btAlignedAllocator<btHashPtr, 16u> & ta = *(::btAlignedAllocator<btHashPtr, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btHashPtr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btHashPtr_->m_size
void btAlignedObjectArray_btHashPtr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btHashPtr__m_size_get(void *c) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btHashPtr_->m_capacity
void btAlignedObjectArray_btHashPtr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btHashPtr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btHashPtr * btAlignedObjectArray_btHashPtr_->m_data
void btAlignedObjectArray_btHashPtr__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	::btHashPtr * ta = (::btHashPtr *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btHashPtr__m_data_get(void *c) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btHashPtr_->m_ownsMemory
void btAlignedObjectArray_btHashPtr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btHashPtr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btHashPtr > *o = (::btAlignedObjectArray< btHashPtr >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btHashString >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btHashString>::* )(  ) 
void* btAlignedObjectArray_btHashString__new() {
	::btAlignedObjectArray< btHashString > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btHashString >),16);
	o = new (mem)::btAlignedObjectArray< btHashString >();
	return (void*)o;
}
void btAlignedObjectArray_btHashString__free(void *c) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btHashString>::* )( ::btHashString const & ) 
void btAlignedObjectArray_btHashString__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	::btHashString const & tp0 = *(::btHashString const *)p0;
	o->push_back(tp0);
}
//method: at ::btHashString const & ( ::btAlignedObjectArray<btHashString>::* )( int ) const
void* btAlignedObjectArray_btHashString__at(void *c,int p0) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btHashString const & ( ::btAlignedObjectArray<btHashString>::* )( int ) const
void* btAlignedObjectArray_btHashString__at0(void *c,int p0) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btHashString & ( ::btAlignedObjectArray<btHashString>::* )( int ) 
void* btAlignedObjectArray_btHashString__at1(void *c,int p0) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btHashString>::* )(  ) const
int btAlignedObjectArray_btHashString__size(void *c) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btHashString>::* )(  ) const
int btAlignedObjectArray_btHashString__capacity(void *c) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btHashString>::* )(  ) 
void btAlignedObjectArray_btHashString__init(void *c) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btHashString>::* )( int ) 
void* btAlignedObjectArray_btHashString__allocate(void *c,int p0) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btHashString>::* )(  ) 
void btAlignedObjectArray_btHashString__pop_back(void *c) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btHashString>::* )(  ) 
void btAlignedObjectArray_btHashString__deallocate(void *c) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btHashString>::* )( int,int ) 
void btAlignedObjectArray_btHashString__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btHashString>::* )( void *,int,int ) 
void btAlignedObjectArray_btHashString__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btHashString & ( ::btAlignedObjectArray<btHashString>::* )(  ) 
void* btAlignedObjectArray_btHashString__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btHashString>::* )( int,::btHashString const & ) 
void btAlignedObjectArray_btHashString__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	::btHashString const & tp1 = *(::btHashString const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btHashString>::* )( int,int ) 
void btAlignedObjectArray_btHashString__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btHashString>::* )( int,int,::btHashString * ) const
void btAlignedObjectArray_btHashString__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	::btHashString * tp2 = (::btHashString *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btHashString & ( ::btAlignedObjectArray<btHashString>::* )( ::btHashString const & ) 
void* btAlignedObjectArray_btHashString__expand(void *c,void* p0) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	::btHashString const & tp0 = *(::btHashString const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btHashString>::* )(  ) 
void btAlignedObjectArray_btHashString__clear(void *c) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btHashString>::* )( int ) 
int btAlignedObjectArray_btHashString__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btHashString>::* )( int ) 
void btAlignedObjectArray_btHashString__reserve(void *c,int p0) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btHashString, 16u> btAlignedObjectArray_btHashString_->m_allocator
void btAlignedObjectArray_btHashString__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	::btAlignedAllocator<btHashString, 16u> & ta = *(::btAlignedAllocator<btHashString, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btHashString__m_allocator_get(void *c) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btHashString_->m_size
void btAlignedObjectArray_btHashString__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btHashString__m_size_get(void *c) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btHashString_->m_capacity
void btAlignedObjectArray_btHashString__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btHashString__m_capacity_get(void *c) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btHashString * btAlignedObjectArray_btHashString_->m_data
void btAlignedObjectArray_btHashString__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	::btHashString * ta = (::btHashString *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btHashString__m_data_get(void *c) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btHashString_->m_ownsMemory
void btAlignedObjectArray_btHashString__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btHashString__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btHashString > *o = (::btAlignedObjectArray< btHashString >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btIndexedMesh >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) 
void* btAlignedObjectArray_btIndexedMesh__new() {
	::btAlignedObjectArray< btIndexedMesh > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btIndexedMesh >),16);
	o = new (mem)::btAlignedObjectArray< btIndexedMesh >();
	return (void*)o;
}
void btAlignedObjectArray_btIndexedMesh__free(void *c) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btIndexedMesh>::* )( ::btIndexedMesh const & ) 
void btAlignedObjectArray_btIndexedMesh__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	::btIndexedMesh const & tp0 = *(::btIndexedMesh const *)p0;
	o->push_back(tp0);
}
//method: at ::btIndexedMesh const & ( ::btAlignedObjectArray<btIndexedMesh>::* )( int ) const
void* btAlignedObjectArray_btIndexedMesh__at(void *c,int p0) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btIndexedMesh const & ( ::btAlignedObjectArray<btIndexedMesh>::* )( int ) const
void* btAlignedObjectArray_btIndexedMesh__at0(void *c,int p0) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btIndexedMesh & ( ::btAlignedObjectArray<btIndexedMesh>::* )( int ) 
void* btAlignedObjectArray_btIndexedMesh__at1(void *c,int p0) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) const
int btAlignedObjectArray_btIndexedMesh__size(void *c) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) const
int btAlignedObjectArray_btIndexedMesh__capacity(void *c) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) 
void btAlignedObjectArray_btIndexedMesh__init(void *c) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btIndexedMesh>::* )( int ) 
void* btAlignedObjectArray_btIndexedMesh__allocate(void *c,int p0) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) 
void btAlignedObjectArray_btIndexedMesh__pop_back(void *c) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) 
void btAlignedObjectArray_btIndexedMesh__deallocate(void *c) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btIndexedMesh>::* )( int,int ) 
void btAlignedObjectArray_btIndexedMesh__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btIndexedMesh>::* )( void *,int,int ) 
void btAlignedObjectArray_btIndexedMesh__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btIndexedMesh & ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) 
void* btAlignedObjectArray_btIndexedMesh__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btIndexedMesh>::* )( int,::btIndexedMesh const & ) 
void btAlignedObjectArray_btIndexedMesh__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	::btIndexedMesh const & tp1 = *(::btIndexedMesh const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btIndexedMesh>::* )( int,int ) 
void btAlignedObjectArray_btIndexedMesh__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btIndexedMesh>::* )( int,int,::btIndexedMesh * ) const
void btAlignedObjectArray_btIndexedMesh__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	::btIndexedMesh * tp2 = (::btIndexedMesh *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btIndexedMesh & ( ::btAlignedObjectArray<btIndexedMesh>::* )( ::btIndexedMesh const & ) 
void* btAlignedObjectArray_btIndexedMesh__expand(void *c,void* p0) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	::btIndexedMesh const & tp0 = *(::btIndexedMesh const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) 
void btAlignedObjectArray_btIndexedMesh__clear(void *c) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btIndexedMesh>::* )( int ) 
int btAlignedObjectArray_btIndexedMesh__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btIndexedMesh>::* )( int ) 
void btAlignedObjectArray_btIndexedMesh__reserve(void *c,int p0) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btIndexedMesh, 16u> btAlignedObjectArray_btIndexedMesh_->m_allocator
void btAlignedObjectArray_btIndexedMesh__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	::btAlignedAllocator<btIndexedMesh, 16u> & ta = *(::btAlignedAllocator<btIndexedMesh, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btIndexedMesh__m_allocator_get(void *c) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btIndexedMesh_->m_size
void btAlignedObjectArray_btIndexedMesh__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btIndexedMesh__m_size_get(void *c) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btIndexedMesh_->m_capacity
void btAlignedObjectArray_btIndexedMesh__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btIndexedMesh__m_capacity_get(void *c) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btIndexedMesh * btAlignedObjectArray_btIndexedMesh_->m_data
void btAlignedObjectArray_btIndexedMesh__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	::btIndexedMesh * ta = (::btIndexedMesh *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btIndexedMesh__m_data_get(void *c) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btIndexedMesh_->m_ownsMemory
void btAlignedObjectArray_btIndexedMesh__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btIndexedMesh__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btIndexedMesh > *o = (::btAlignedObjectArray< btIndexedMesh >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__new() {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >),16);
	o = new (mem)::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >();
	return (void*)o;
}
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__free(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( ::btMultiSapBroadphase::btBridgeProxy * const & ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	::btMultiSapBroadphase::btBridgeProxy * tp0 = (::btMultiSapBroadphase::btBridgeProxy *)p0;
	o->push_back(tp0);
}
//method: at ::btMultiSapBroadphase::btBridgeProxy * const & ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int ) const
void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btMultiSapBroadphase::btBridgeProxy * const & ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int ) const
void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btMultiSapBroadphase::btBridgeProxy * & ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) const
int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__size(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) const
int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__capacity(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__init(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int,int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( void *,int,int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btMultiSapBroadphase::btBridgeProxy * & ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int,::btMultiSapBroadphase::btBridgeProxy * const & ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	::btMultiSapBroadphase::btBridgeProxy * tp1 = (::btMultiSapBroadphase::btBridgeProxy *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int,int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int,int,::btMultiSapBroadphase::btBridgeProxy * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: expand ::btMultiSapBroadphase::btBridgeProxy * & ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( ::btMultiSapBroadphase::btBridgeProxy * const & ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	::btMultiSapBroadphase::btBridgeProxy * tp0 = (::btMultiSapBroadphase::btBridgeProxy *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__clear(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int ) 
int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u> btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_->m_allocator
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u> & ta = *(::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_->m_size
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_->m_capacity
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btMultiSapBroadphase::btBridgeProxy * * btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_->m_data
// attribute not supported: //attribute: ::btMultiSapBroadphase::btBridgeProxy * * btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_->m_data
//attribute: bool btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_->m_ownsMemory
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btBridgeProxy* >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__new() {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >),16);
	o = new (mem)::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >();
	return (void*)o;
}
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__free(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( ::btMultiSapBroadphase::btMultiSapProxy * const & ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	::btMultiSapBroadphase::btMultiSapProxy * tp0 = (::btMultiSapBroadphase::btMultiSapProxy *)p0;
	o->push_back(tp0);
}
//method: at ::btMultiSapBroadphase::btMultiSapProxy * const & ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int ) const
void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btMultiSapBroadphase::btMultiSapProxy * const & ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int ) const
void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btMultiSapBroadphase::btMultiSapProxy * & ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) const
int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__size(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) const
int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__capacity(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__init(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int,int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( void *,int,int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btMultiSapBroadphase::btMultiSapProxy * & ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int,::btMultiSapBroadphase::btMultiSapProxy * const & ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	::btMultiSapBroadphase::btMultiSapProxy * tp1 = (::btMultiSapBroadphase::btMultiSapProxy *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int,int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int,int,::btMultiSapBroadphase::btMultiSapProxy * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: expand ::btMultiSapBroadphase::btMultiSapProxy * & ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( ::btMultiSapBroadphase::btMultiSapProxy * const & ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	::btMultiSapBroadphase::btMultiSapProxy * tp0 = (::btMultiSapBroadphase::btMultiSapProxy *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__clear(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int ) 
int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u> btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_->m_allocator
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u> & ta = *(::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_->m_size
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_->m_capacity
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btMultiSapBroadphase::btMultiSapProxy * * btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_->m_data
// attribute not supported: //attribute: ::btMultiSapBroadphase::btMultiSapProxy * * btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_->m_data
//attribute: bool btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_->m_ownsMemory
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* > *o = (::btAlignedObjectArray< btMultiSapBroadphase::btMultiSapProxy* >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btOptimizedBvhNode >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) 
void* btAlignedObjectArray_btOptimizedBvhNode__new() {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btOptimizedBvhNode >),16);
	o = new (mem)::btAlignedObjectArray< btOptimizedBvhNode >();
	return (void*)o;
}
void btAlignedObjectArray_btOptimizedBvhNode__free(void *c) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( ::btOptimizedBvhNode const & ) 
void btAlignedObjectArray_btOptimizedBvhNode__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	::btOptimizedBvhNode const & tp0 = *(::btOptimizedBvhNode const *)p0;
	o->push_back(tp0);
}
//method: at ::btOptimizedBvhNode const & ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int ) const
void* btAlignedObjectArray_btOptimizedBvhNode__at(void *c,int p0) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btOptimizedBvhNode const & ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int ) const
void* btAlignedObjectArray_btOptimizedBvhNode__at0(void *c,int p0) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btOptimizedBvhNode & ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int ) 
void* btAlignedObjectArray_btOptimizedBvhNode__at1(void *c,int p0) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) const
int btAlignedObjectArray_btOptimizedBvhNode__size(void *c) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) const
int btAlignedObjectArray_btOptimizedBvhNode__capacity(void *c) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btOptimizedBvhNode__init(void *c) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int ) 
void* btAlignedObjectArray_btOptimizedBvhNode__allocate(void *c,int p0) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btOptimizedBvhNode__pop_back(void *c) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btOptimizedBvhNode__deallocate(void *c) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int,int ) 
void btAlignedObjectArray_btOptimizedBvhNode__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( void *,int,int ) 
void btAlignedObjectArray_btOptimizedBvhNode__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btOptimizedBvhNode & ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) 
void* btAlignedObjectArray_btOptimizedBvhNode__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int,::btOptimizedBvhNode const & ) 
void btAlignedObjectArray_btOptimizedBvhNode__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	::btOptimizedBvhNode const & tp1 = *(::btOptimizedBvhNode const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int,int ) 
void btAlignedObjectArray_btOptimizedBvhNode__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int,int,::btOptimizedBvhNode * ) const
void btAlignedObjectArray_btOptimizedBvhNode__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	::btOptimizedBvhNode * tp2 = (::btOptimizedBvhNode *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btOptimizedBvhNode & ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( ::btOptimizedBvhNode const & ) 
void* btAlignedObjectArray_btOptimizedBvhNode__expand(void *c,void* p0) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	::btOptimizedBvhNode const & tp0 = *(::btOptimizedBvhNode const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btOptimizedBvhNode__clear(void *c) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int ) 
int btAlignedObjectArray_btOptimizedBvhNode__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int ) 
void btAlignedObjectArray_btOptimizedBvhNode__reserve(void *c,int p0) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btOptimizedBvhNode, 16u> btAlignedObjectArray_btOptimizedBvhNode_->m_allocator
void btAlignedObjectArray_btOptimizedBvhNode__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	::btAlignedAllocator<btOptimizedBvhNode, 16u> & ta = *(::btAlignedAllocator<btOptimizedBvhNode, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btOptimizedBvhNode__m_allocator_get(void *c) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btOptimizedBvhNode_->m_size
void btAlignedObjectArray_btOptimizedBvhNode__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btOptimizedBvhNode__m_size_get(void *c) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btOptimizedBvhNode_->m_capacity
void btAlignedObjectArray_btOptimizedBvhNode__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btOptimizedBvhNode__m_capacity_get(void *c) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btOptimizedBvhNode * btAlignedObjectArray_btOptimizedBvhNode_->m_data
void btAlignedObjectArray_btOptimizedBvhNode__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	::btOptimizedBvhNode * ta = (::btOptimizedBvhNode *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btOptimizedBvhNode__m_data_get(void *c) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btOptimizedBvhNode_->m_ownsMemory
void btAlignedObjectArray_btOptimizedBvhNode__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btOptimizedBvhNode__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btOptimizedBvhNode > *o = (::btAlignedObjectArray< btOptimizedBvhNode >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btPersistentManifold* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) 
void* btAlignedObjectArray_btPersistentManifold_ptr__new() {
	::btAlignedObjectArray< btPersistentManifold* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btPersistentManifold* >),16);
	o = new (mem)::btAlignedObjectArray< btPersistentManifold* >();
	return (void*)o;
}
void btAlignedObjectArray_btPersistentManifold_ptr__free(void *c) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btPersistentManifold*>::* )( ::btPersistentManifold * const & ) 
void btAlignedObjectArray_btPersistentManifold_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	::btPersistentManifold * tp0 = (::btPersistentManifold *)p0;
	o->push_back(tp0);
}
//method: at ::btPersistentManifold * const & ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int ) const
void* btAlignedObjectArray_btPersistentManifold_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btPersistentManifold * const & ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int ) const
void* btAlignedObjectArray_btPersistentManifold_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btPersistentManifold * & ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int ) 
void* btAlignedObjectArray_btPersistentManifold_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) const
int btAlignedObjectArray_btPersistentManifold_ptr__size(void *c) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) const
int btAlignedObjectArray_btPersistentManifold_ptr__capacity(void *c) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) 
void btAlignedObjectArray_btPersistentManifold_ptr__init(void *c) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int ) 
void* btAlignedObjectArray_btPersistentManifold_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) 
void btAlignedObjectArray_btPersistentManifold_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) 
void btAlignedObjectArray_btPersistentManifold_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int,int ) 
void btAlignedObjectArray_btPersistentManifold_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btPersistentManifold*>::* )( void *,int,int ) 
void btAlignedObjectArray_btPersistentManifold_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btPersistentManifold * & ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) 
void* btAlignedObjectArray_btPersistentManifold_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int,::btPersistentManifold * const & ) 
void btAlignedObjectArray_btPersistentManifold_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	::btPersistentManifold * tp1 = (::btPersistentManifold *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int,int ) 
void btAlignedObjectArray_btPersistentManifold_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int,int,::btPersistentManifold * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: expand ::btPersistentManifold * & ( ::btAlignedObjectArray<btPersistentManifold*>::* )( ::btPersistentManifold * const & ) 
void* btAlignedObjectArray_btPersistentManifold_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	::btPersistentManifold * tp0 = (::btPersistentManifold *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) 
void btAlignedObjectArray_btPersistentManifold_ptr__clear(void *c) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int ) 
int btAlignedObjectArray_btPersistentManifold_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int ) 
void btAlignedObjectArray_btPersistentManifold_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btPersistentManifold*, 16u> btAlignedObjectArray_btPersistentManifold_ptr_->m_allocator
void btAlignedObjectArray_btPersistentManifold_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	::btAlignedAllocator<btPersistentManifold*, 16u> & ta = *(::btAlignedAllocator<btPersistentManifold*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btPersistentManifold_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btPersistentManifold_ptr_->m_size
void btAlignedObjectArray_btPersistentManifold_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btPersistentManifold_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btPersistentManifold_ptr_->m_capacity
void btAlignedObjectArray_btPersistentManifold_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btPersistentManifold_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btPersistentManifold * * btAlignedObjectArray_btPersistentManifold_ptr_->m_data
// attribute not supported: //attribute: ::btPersistentManifold * * btAlignedObjectArray_btPersistentManifold_ptr_->m_data
//attribute: bool btAlignedObjectArray_btPersistentManifold_ptr_->m_ownsMemory
void btAlignedObjectArray_btPersistentManifold_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btPersistentManifold_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btPersistentManifold* > *o = (::btAlignedObjectArray< btPersistentManifold* >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btPointerUid >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btPointerUid>::* )(  ) 
void* btAlignedObjectArray_btPointerUid__new() {
	::btAlignedObjectArray< btPointerUid > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btPointerUid >),16);
	o = new (mem)::btAlignedObjectArray< btPointerUid >();
	return (void*)o;
}
void btAlignedObjectArray_btPointerUid__free(void *c) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btPointerUid>::* )( ::btPointerUid const & ) 
void btAlignedObjectArray_btPointerUid__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	::btPointerUid const & tp0 = *(::btPointerUid const *)p0;
	o->push_back(tp0);
}
//method: at ::btPointerUid const & ( ::btAlignedObjectArray<btPointerUid>::* )( int ) const
void* btAlignedObjectArray_btPointerUid__at(void *c,int p0) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btPointerUid const & ( ::btAlignedObjectArray<btPointerUid>::* )( int ) const
void* btAlignedObjectArray_btPointerUid__at0(void *c,int p0) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btPointerUid & ( ::btAlignedObjectArray<btPointerUid>::* )( int ) 
void* btAlignedObjectArray_btPointerUid__at1(void *c,int p0) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btPointerUid>::* )(  ) const
int btAlignedObjectArray_btPointerUid__size(void *c) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btPointerUid>::* )(  ) const
int btAlignedObjectArray_btPointerUid__capacity(void *c) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btPointerUid>::* )(  ) 
void btAlignedObjectArray_btPointerUid__init(void *c) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btPointerUid>::* )( int ) 
void* btAlignedObjectArray_btPointerUid__allocate(void *c,int p0) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btPointerUid>::* )(  ) 
void btAlignedObjectArray_btPointerUid__pop_back(void *c) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btPointerUid>::* )(  ) 
void btAlignedObjectArray_btPointerUid__deallocate(void *c) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btPointerUid>::* )( int,int ) 
void btAlignedObjectArray_btPointerUid__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btPointerUid>::* )( void *,int,int ) 
void btAlignedObjectArray_btPointerUid__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btPointerUid & ( ::btAlignedObjectArray<btPointerUid>::* )(  ) 
void* btAlignedObjectArray_btPointerUid__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btPointerUid>::* )( int,::btPointerUid const & ) 
void btAlignedObjectArray_btPointerUid__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	::btPointerUid const & tp1 = *(::btPointerUid const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btPointerUid>::* )( int,int ) 
void btAlignedObjectArray_btPointerUid__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btPointerUid>::* )( int,int,::btPointerUid * ) const
void btAlignedObjectArray_btPointerUid__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	::btPointerUid * tp2 = (::btPointerUid *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btPointerUid & ( ::btAlignedObjectArray<btPointerUid>::* )( ::btPointerUid const & ) 
void* btAlignedObjectArray_btPointerUid__expand(void *c,void* p0) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	::btPointerUid const & tp0 = *(::btPointerUid const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btPointerUid>::* )(  ) 
void btAlignedObjectArray_btPointerUid__clear(void *c) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btPointerUid>::* )( int ) 
int btAlignedObjectArray_btPointerUid__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btPointerUid>::* )( int ) 
void btAlignedObjectArray_btPointerUid__reserve(void *c,int p0) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btPointerUid, 16u> btAlignedObjectArray_btPointerUid_->m_allocator
void btAlignedObjectArray_btPointerUid__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	::btAlignedAllocator<btPointerUid, 16u> & ta = *(::btAlignedAllocator<btPointerUid, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btPointerUid__m_allocator_get(void *c) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btPointerUid_->m_size
void btAlignedObjectArray_btPointerUid__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btPointerUid__m_size_get(void *c) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btPointerUid_->m_capacity
void btAlignedObjectArray_btPointerUid__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btPointerUid__m_capacity_get(void *c) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btPointerUid * btAlignedObjectArray_btPointerUid_->m_data
void btAlignedObjectArray_btPointerUid__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	::btPointerUid * ta = (::btPointerUid *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btPointerUid__m_data_get(void *c) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btPointerUid_->m_ownsMemory
void btAlignedObjectArray_btPointerUid__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btPointerUid__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btPointerUid > *o = (::btAlignedObjectArray< btPointerUid >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btQuantizedBvhNode >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) 
void* btAlignedObjectArray_btQuantizedBvhNode__new() {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btQuantizedBvhNode >),16);
	o = new (mem)::btAlignedObjectArray< btQuantizedBvhNode >();
	return (void*)o;
}
void btAlignedObjectArray_btQuantizedBvhNode__free(void *c) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( ::btQuantizedBvhNode const & ) 
void btAlignedObjectArray_btQuantizedBvhNode__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	::btQuantizedBvhNode const & tp0 = *(::btQuantizedBvhNode const *)p0;
	o->push_back(tp0);
}
//method: at ::btQuantizedBvhNode const & ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int ) const
void* btAlignedObjectArray_btQuantizedBvhNode__at(void *c,int p0) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btQuantizedBvhNode const & ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int ) const
void* btAlignedObjectArray_btQuantizedBvhNode__at0(void *c,int p0) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btQuantizedBvhNode & ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int ) 
void* btAlignedObjectArray_btQuantizedBvhNode__at1(void *c,int p0) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) const
int btAlignedObjectArray_btQuantizedBvhNode__size(void *c) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) const
int btAlignedObjectArray_btQuantizedBvhNode__capacity(void *c) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btQuantizedBvhNode__init(void *c) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int ) 
void* btAlignedObjectArray_btQuantizedBvhNode__allocate(void *c,int p0) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btQuantizedBvhNode__pop_back(void *c) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btQuantizedBvhNode__deallocate(void *c) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int,int ) 
void btAlignedObjectArray_btQuantizedBvhNode__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( void *,int,int ) 
void btAlignedObjectArray_btQuantizedBvhNode__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btQuantizedBvhNode & ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) 
void* btAlignedObjectArray_btQuantizedBvhNode__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int,::btQuantizedBvhNode const & ) 
void btAlignedObjectArray_btQuantizedBvhNode__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	::btQuantizedBvhNode const & tp1 = *(::btQuantizedBvhNode const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int,int ) 
void btAlignedObjectArray_btQuantizedBvhNode__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int,int,::btQuantizedBvhNode * ) const
void btAlignedObjectArray_btQuantizedBvhNode__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	::btQuantizedBvhNode * tp2 = (::btQuantizedBvhNode *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btQuantizedBvhNode & ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( ::btQuantizedBvhNode const & ) 
void* btAlignedObjectArray_btQuantizedBvhNode__expand(void *c,void* p0) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	::btQuantizedBvhNode const & tp0 = *(::btQuantizedBvhNode const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btQuantizedBvhNode__clear(void *c) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int ) 
int btAlignedObjectArray_btQuantizedBvhNode__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int ) 
void btAlignedObjectArray_btQuantizedBvhNode__reserve(void *c,int p0) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btQuantizedBvhNode, 16u> btAlignedObjectArray_btQuantizedBvhNode_->m_allocator
void btAlignedObjectArray_btQuantizedBvhNode__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	::btAlignedAllocator<btQuantizedBvhNode, 16u> & ta = *(::btAlignedAllocator<btQuantizedBvhNode, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btQuantizedBvhNode__m_allocator_get(void *c) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btQuantizedBvhNode_->m_size
void btAlignedObjectArray_btQuantizedBvhNode__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btQuantizedBvhNode__m_size_get(void *c) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btQuantizedBvhNode_->m_capacity
void btAlignedObjectArray_btQuantizedBvhNode__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btQuantizedBvhNode__m_capacity_get(void *c) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btQuantizedBvhNode * btAlignedObjectArray_btQuantizedBvhNode_->m_data
void btAlignedObjectArray_btQuantizedBvhNode__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	::btQuantizedBvhNode * ta = (::btQuantizedBvhNode *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btQuantizedBvhNode__m_data_get(void *c) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btQuantizedBvhNode_->m_ownsMemory
void btAlignedObjectArray_btQuantizedBvhNode__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btQuantizedBvhNode__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btQuantizedBvhNode > *o = (::btAlignedObjectArray< btQuantizedBvhNode >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btRigidBody* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) 
void* btAlignedObjectArray_btRigidBody_ptr__new() {
	::btAlignedObjectArray< btRigidBody* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btRigidBody* >),16);
	o = new (mem)::btAlignedObjectArray< btRigidBody* >();
	return (void*)o;
}
void btAlignedObjectArray_btRigidBody_ptr__free(void *c) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btRigidBody*>::* )( ::btRigidBody * const & ) 
void btAlignedObjectArray_btRigidBody_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	::btRigidBody * tp0 = (::btRigidBody *)p0;
	o->push_back(tp0);
}
//method: at ::btRigidBody * const & ( ::btAlignedObjectArray<btRigidBody*>::* )( int ) const
void* btAlignedObjectArray_btRigidBody_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btRigidBody * const & ( ::btAlignedObjectArray<btRigidBody*>::* )( int ) const
void* btAlignedObjectArray_btRigidBody_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btRigidBody * & ( ::btAlignedObjectArray<btRigidBody*>::* )( int ) 
void* btAlignedObjectArray_btRigidBody_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) const
int btAlignedObjectArray_btRigidBody_ptr__size(void *c) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) const
int btAlignedObjectArray_btRigidBody_ptr__capacity(void *c) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) 
void btAlignedObjectArray_btRigidBody_ptr__init(void *c) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btRigidBody*>::* )( int ) 
void* btAlignedObjectArray_btRigidBody_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) 
void btAlignedObjectArray_btRigidBody_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) 
void btAlignedObjectArray_btRigidBody_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btRigidBody*>::* )( int,int ) 
void btAlignedObjectArray_btRigidBody_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btRigidBody*>::* )( void *,int,int ) 
void btAlignedObjectArray_btRigidBody_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btRigidBody * & ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) 
void* btAlignedObjectArray_btRigidBody_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btRigidBody*>::* )( int,::btRigidBody * const & ) 
void btAlignedObjectArray_btRigidBody_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	::btRigidBody * tp1 = (::btRigidBody *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btRigidBody*>::* )( int,int ) 
void btAlignedObjectArray_btRigidBody_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btRigidBody*>::* )( int,int,::btRigidBody * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: expand ::btRigidBody * & ( ::btAlignedObjectArray<btRigidBody*>::* )( ::btRigidBody * const & ) 
void* btAlignedObjectArray_btRigidBody_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	::btRigidBody * tp0 = (::btRigidBody *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) 
void btAlignedObjectArray_btRigidBody_ptr__clear(void *c) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btRigidBody*>::* )( int ) 
int btAlignedObjectArray_btRigidBody_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btRigidBody*>::* )( int ) 
void btAlignedObjectArray_btRigidBody_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btRigidBody*, 16u> btAlignedObjectArray_btRigidBody_ptr_->m_allocator
void btAlignedObjectArray_btRigidBody_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	::btAlignedAllocator<btRigidBody*, 16u> & ta = *(::btAlignedAllocator<btRigidBody*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btRigidBody_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btRigidBody_ptr_->m_size
void btAlignedObjectArray_btRigidBody_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btRigidBody_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btRigidBody_ptr_->m_capacity
void btAlignedObjectArray_btRigidBody_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btRigidBody_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btRigidBody * * btAlignedObjectArray_btRigidBody_ptr_->m_data
// attribute not supported: //attribute: ::btRigidBody * * btAlignedObjectArray_btRigidBody_ptr_->m_data
//attribute: bool btAlignedObjectArray_btRigidBody_ptr_->m_ownsMemory
void btAlignedObjectArray_btRigidBody_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btRigidBody_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btRigidBody* > *o = (::btAlignedObjectArray< btRigidBody* >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btSoftBody* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_ptr__new() {
	::btAlignedObjectArray< btSoftBody* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSoftBody* >),16);
	o = new (mem)::btAlignedObjectArray< btSoftBody* >();
	return (void*)o;
}
void btAlignedObjectArray_btSoftBody_ptr__free(void *c) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btSoftBody*>::* )( ::btSoftBody * const & ) 
void btAlignedObjectArray_btSoftBody_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	o->push_back(tp0);
}
//method: at ::btSoftBody * const & ( ::btAlignedObjectArray<btSoftBody*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btSoftBody * const & ( ::btAlignedObjectArray<btSoftBody*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btSoftBody * & ( ::btAlignedObjectArray<btSoftBody*>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) const
int btAlignedObjectArray_btSoftBody_ptr__size(void *c) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) const
int btAlignedObjectArray_btSoftBody_ptr__capacity(void *c) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_ptr__init(void *c) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSoftBody*>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSoftBody*>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody*>::* )( void *,int,int ) 
void btAlignedObjectArray_btSoftBody_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btSoftBody * & ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: destroy void ( ::btAlignedObjectArray<btSoftBody*>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btSoftBody*>::* )( int,int,::btSoftBody * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: resize void ( ::btAlignedObjectArray<btSoftBody*>::* )( int,::btSoftBody * const & ) 
void btAlignedObjectArray_btSoftBody_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	::btSoftBody * tp1 = (::btSoftBody *)p1;
	o->resize(p0,tp1);
}
//method: clear void ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_ptr__clear(void *c) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSoftBody*>::* )( int ) 
int btAlignedObjectArray_btSoftBody_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: expand ::btSoftBody * & ( ::btAlignedObjectArray<btSoftBody*>::* )( ::btSoftBody * const & ) 
void* btAlignedObjectArray_btSoftBody_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	::btSoftBody * tp0 = (::btSoftBody *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btSoftBody*>::* )( int ) 
void btAlignedObjectArray_btSoftBody_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSoftBody*, 16u> btAlignedObjectArray_btSoftBody_ptr_->m_allocator
void btAlignedObjectArray_btSoftBody_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	::btAlignedAllocator<btSoftBody*, 16u> & ta = *(::btAlignedAllocator<btSoftBody*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSoftBody_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSoftBody_ptr_->m_capacity
void btAlignedObjectArray_btSoftBody_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSoftBody_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSoftBody * * btAlignedObjectArray_btSoftBody_ptr_->m_data
// attribute not supported: //attribute: ::btSoftBody * * btAlignedObjectArray_btSoftBody_ptr_->m_data
//attribute: bool btAlignedObjectArray_btSoftBody_ptr_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSoftBody_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSoftBody_ptr_->m_size
void btAlignedObjectArray_btSoftBody_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSoftBody_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btSoftBody* > *o = (::btAlignedObjectArray< btSoftBody* >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btSoftBody::Anchor >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Anchor__new() {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSoftBody::Anchor >),16);
	o = new (mem)::btAlignedObjectArray< btSoftBody::Anchor >();
	return (void*)o;
}
void btAlignedObjectArray_btSoftBody_Anchor__free(void *c) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( ::btSoftBody::Anchor const & ) 
void btAlignedObjectArray_btSoftBody_Anchor__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	::btSoftBody::Anchor const & tp0 = *(::btSoftBody::Anchor const *)p0;
	o->push_back(tp0);
}
//method: at ::btSoftBody::Anchor const & ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Anchor__at(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::Anchor const & ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Anchor__at0(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::Anchor & ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Anchor__at1(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Anchor__size(void *c) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Anchor__capacity(void *c) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Anchor__init(void *c) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Anchor__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Anchor__pop_back(void *c) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Anchor__deallocate(void *c) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Anchor__allocate(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( void *,int,int ) 
void btAlignedObjectArray_btSoftBody_Anchor__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btSoftBody::Anchor & ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Anchor__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: destroy void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Anchor__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int,int,::btSoftBody::Anchor * ) const
void btAlignedObjectArray_btSoftBody_Anchor__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	::btSoftBody::Anchor * tp2 = (::btSoftBody::Anchor *)p2;
	o->copy(p0,p1,tp2);
}
//method: resize void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int,::btSoftBody::Anchor const & ) 
void btAlignedObjectArray_btSoftBody_Anchor__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	::btSoftBody::Anchor const & tp1 = *(::btSoftBody::Anchor const *)p1;
	o->resize(p0,tp1);
}
//method: clear void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Anchor__clear(void *c) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Anchor__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: expand ::btSoftBody::Anchor & ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( ::btSoftBody::Anchor const & ) 
void* btAlignedObjectArray_btSoftBody_Anchor__expand(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	::btSoftBody::Anchor const & tp0 = *(::btSoftBody::Anchor const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Anchor__reserve(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSoftBody::Anchor, 16u> btAlignedObjectArray_btSoftBody_Anchor_->m_allocator
void btAlignedObjectArray_btSoftBody_Anchor__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	::btAlignedAllocator<btSoftBody::Anchor, 16u> & ta = *(::btAlignedAllocator<btSoftBody::Anchor, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSoftBody_Anchor__m_allocator_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSoftBody_Anchor_->m_capacity
void btAlignedObjectArray_btSoftBody_Anchor__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSoftBody_Anchor__m_capacity_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSoftBody::Anchor * btAlignedObjectArray_btSoftBody_Anchor_->m_data
void btAlignedObjectArray_btSoftBody_Anchor__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	::btSoftBody::Anchor * ta = (::btSoftBody::Anchor *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btSoftBody_Anchor__m_data_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btSoftBody_Anchor_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Anchor__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSoftBody_Anchor__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSoftBody_Anchor_->m_size
void btAlignedObjectArray_btSoftBody_Anchor__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSoftBody_Anchor__m_size_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Anchor > *o = (::btAlignedObjectArray< btSoftBody::Anchor >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btSoftBody::Cluster* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__new() {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSoftBody::Cluster* >),16);
	o = new (mem)::btAlignedObjectArray< btSoftBody::Cluster* >();
	return (void*)o;
}
void btAlignedObjectArray_btSoftBody_Cluster_ptr__free(void *c) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( ::btSoftBody::Cluster * const & ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	::btSoftBody::Cluster * tp0 = (::btSoftBody::Cluster *)p0;
	o->push_back(tp0);
}
//method: at ::btSoftBody::Cluster * const & ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btSoftBody::Cluster * const & ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btSoftBody::Cluster * & ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Cluster_ptr__size(void *c) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Cluster_ptr__capacity(void *c) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__init(void *c) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( void *,int,int ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btSoftBody::Cluster * & ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: destroy void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int,int,::btSoftBody::Cluster * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: resize void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int,::btSoftBody::Cluster * const & ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	::btSoftBody::Cluster * tp1 = (::btSoftBody::Cluster *)p1;
	o->resize(p0,tp1);
}
//method: clear void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__clear(void *c) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Cluster_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: expand ::btSoftBody::Cluster * & ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( ::btSoftBody::Cluster * const & ) 
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	::btSoftBody::Cluster * tp0 = (::btSoftBody::Cluster *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSoftBody::Cluster*, 16u> btAlignedObjectArray_btSoftBody_Cluster_ptr_->m_allocator
void btAlignedObjectArray_btSoftBody_Cluster_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	::btAlignedAllocator<btSoftBody::Cluster*, 16u> & ta = *(::btAlignedAllocator<btSoftBody::Cluster*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSoftBody_Cluster_ptr_->m_capacity
void btAlignedObjectArray_btSoftBody_Cluster_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSoftBody_Cluster_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSoftBody::Cluster * * btAlignedObjectArray_btSoftBody_Cluster_ptr_->m_data
// attribute not supported: //attribute: ::btSoftBody::Cluster * * btAlignedObjectArray_btSoftBody_Cluster_ptr_->m_data
//attribute: bool btAlignedObjectArray_btSoftBody_Cluster_ptr_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Cluster_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSoftBody_Cluster_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSoftBody_Cluster_ptr_->m_size
void btAlignedObjectArray_btSoftBody_Cluster_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSoftBody_Cluster_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Cluster* > *o = (::btAlignedObjectArray< btSoftBody::Cluster* >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btSoftBody::Face >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Face__new() {
	::btAlignedObjectArray< btSoftBody::Face > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSoftBody::Face >),16);
	o = new (mem)::btAlignedObjectArray< btSoftBody::Face >();
	return (void*)o;
}
void btAlignedObjectArray_btSoftBody_Face__free(void *c) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btSoftBody::Face>::* )( ::btSoftBody::Face const & ) 
void btAlignedObjectArray_btSoftBody_Face__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	::btSoftBody::Face const & tp0 = *(::btSoftBody::Face const *)p0;
	o->push_back(tp0);
}
//method: at ::btSoftBody::Face const & ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Face__at(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::Face const & ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Face__at0(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::Face & ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Face__at1(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Face__size(void *c) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Face__capacity(void *c) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Face__init(void *c) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Face__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Face__pop_back(void *c) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Face__deallocate(void *c) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Face__allocate(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Face>::* )( void *,int,int ) 
void btAlignedObjectArray_btSoftBody_Face__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btSoftBody::Face & ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Face__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: destroy void ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Face__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int,int,::btSoftBody::Face * ) const
void btAlignedObjectArray_btSoftBody_Face__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	::btSoftBody::Face * tp2 = (::btSoftBody::Face *)p2;
	o->copy(p0,p1,tp2);
}
//method: resize void ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int,::btSoftBody::Face const & ) 
void btAlignedObjectArray_btSoftBody_Face__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	::btSoftBody::Face const & tp1 = *(::btSoftBody::Face const *)p1;
	o->resize(p0,tp1);
}
//method: clear void ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Face__clear(void *c) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Face__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: expand ::btSoftBody::Face & ( ::btAlignedObjectArray<btSoftBody::Face>::* )( ::btSoftBody::Face const & ) 
void* btAlignedObjectArray_btSoftBody_Face__expand(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	::btSoftBody::Face const & tp0 = *(::btSoftBody::Face const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Face__reserve(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSoftBody::Face, 16u> btAlignedObjectArray_btSoftBody_Face_->m_allocator
void btAlignedObjectArray_btSoftBody_Face__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	::btAlignedAllocator<btSoftBody::Face, 16u> & ta = *(::btAlignedAllocator<btSoftBody::Face, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSoftBody_Face__m_allocator_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSoftBody_Face_->m_capacity
void btAlignedObjectArray_btSoftBody_Face__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSoftBody_Face__m_capacity_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSoftBody::Face * btAlignedObjectArray_btSoftBody_Face_->m_data
void btAlignedObjectArray_btSoftBody_Face__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	::btSoftBody::Face * ta = (::btSoftBody::Face *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btSoftBody_Face__m_data_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btSoftBody_Face_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Face__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSoftBody_Face__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSoftBody_Face_->m_size
void btAlignedObjectArray_btSoftBody_Face__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSoftBody_Face__m_size_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Face > *o = (::btAlignedObjectArray< btSoftBody::Face >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btSoftBody::Joint* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Joint_ptr__new() {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSoftBody::Joint* >),16);
	o = new (mem)::btAlignedObjectArray< btSoftBody::Joint* >();
	return (void*)o;
}
void btAlignedObjectArray_btSoftBody_Joint_ptr__free(void *c) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( ::btSoftBody::Joint * const & ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	::btSoftBody::Joint * tp0 = (::btSoftBody::Joint *)p0;
	o->push_back(tp0);
}
//method: at ::btSoftBody::Joint * const & ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Joint_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btSoftBody::Joint * const & ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Joint_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btSoftBody::Joint * & ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Joint_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Joint_ptr__size(void *c) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Joint_ptr__capacity(void *c) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__init(void *c) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Joint_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( void *,int,int ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btSoftBody::Joint * & ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Joint_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: destroy void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int,int,::btSoftBody::Joint * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: resize void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int,::btSoftBody::Joint * const & ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	::btSoftBody::Joint * tp1 = (::btSoftBody::Joint *)p1;
	o->resize(p0,tp1);
}
//method: clear void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__clear(void *c) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Joint_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: expand ::btSoftBody::Joint * & ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( ::btSoftBody::Joint * const & ) 
void* btAlignedObjectArray_btSoftBody_Joint_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	::btSoftBody::Joint * tp0 = (::btSoftBody::Joint *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSoftBody::Joint*, 16u> btAlignedObjectArray_btSoftBody_Joint_ptr_->m_allocator
void btAlignedObjectArray_btSoftBody_Joint_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	::btAlignedAllocator<btSoftBody::Joint*, 16u> & ta = *(::btAlignedAllocator<btSoftBody::Joint*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSoftBody_Joint_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSoftBody_Joint_ptr_->m_capacity
void btAlignedObjectArray_btSoftBody_Joint_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSoftBody_Joint_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSoftBody::Joint * * btAlignedObjectArray_btSoftBody_Joint_ptr_->m_data
// attribute not supported: //attribute: ::btSoftBody::Joint * * btAlignedObjectArray_btSoftBody_Joint_ptr_->m_data
//attribute: bool btAlignedObjectArray_btSoftBody_Joint_ptr_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Joint_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSoftBody_Joint_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSoftBody_Joint_ptr_->m_size
void btAlignedObjectArray_btSoftBody_Joint_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSoftBody_Joint_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Joint* > *o = (::btAlignedObjectArray< btSoftBody::Joint* >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btSoftBody::Link >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Link__new() {
	::btAlignedObjectArray< btSoftBody::Link > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSoftBody::Link >),16);
	o = new (mem)::btAlignedObjectArray< btSoftBody::Link >();
	return (void*)o;
}
void btAlignedObjectArray_btSoftBody_Link__free(void *c) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btSoftBody::Link>::* )( ::btSoftBody::Link const & ) 
void btAlignedObjectArray_btSoftBody_Link__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	::btSoftBody::Link const & tp0 = *(::btSoftBody::Link const *)p0;
	o->push_back(tp0);
}
//method: at ::btSoftBody::Link const & ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Link__at(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::Link const & ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Link__at0(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::Link & ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Link__at1(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Link__size(void *c) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Link__capacity(void *c) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Link__init(void *c) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Link__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Link__pop_back(void *c) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Link__deallocate(void *c) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Link__allocate(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Link>::* )( void *,int,int ) 
void btAlignedObjectArray_btSoftBody_Link__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btSoftBody::Link & ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Link__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: destroy void ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Link__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int,int,::btSoftBody::Link * ) const
void btAlignedObjectArray_btSoftBody_Link__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	::btSoftBody::Link * tp2 = (::btSoftBody::Link *)p2;
	o->copy(p0,p1,tp2);
}
//method: resize void ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int,::btSoftBody::Link const & ) 
void btAlignedObjectArray_btSoftBody_Link__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	::btSoftBody::Link const & tp1 = *(::btSoftBody::Link const *)p1;
	o->resize(p0,tp1);
}
//method: clear void ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Link__clear(void *c) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Link__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: expand ::btSoftBody::Link & ( ::btAlignedObjectArray<btSoftBody::Link>::* )( ::btSoftBody::Link const & ) 
void* btAlignedObjectArray_btSoftBody_Link__expand(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	::btSoftBody::Link const & tp0 = *(::btSoftBody::Link const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Link__reserve(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSoftBody::Link, 16u> btAlignedObjectArray_btSoftBody_Link_->m_allocator
void btAlignedObjectArray_btSoftBody_Link__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	::btAlignedAllocator<btSoftBody::Link, 16u> & ta = *(::btAlignedAllocator<btSoftBody::Link, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSoftBody_Link__m_allocator_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSoftBody_Link_->m_capacity
void btAlignedObjectArray_btSoftBody_Link__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSoftBody_Link__m_capacity_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSoftBody::Link * btAlignedObjectArray_btSoftBody_Link_->m_data
void btAlignedObjectArray_btSoftBody_Link__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	::btSoftBody::Link * ta = (::btSoftBody::Link *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btSoftBody_Link__m_data_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btSoftBody_Link_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Link__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSoftBody_Link__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSoftBody_Link_->m_size
void btAlignedObjectArray_btSoftBody_Link__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSoftBody_Link__m_size_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Link > *o = (::btAlignedObjectArray< btSoftBody::Link >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btSoftBody::Material* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Material_ptr__new() {
	::btAlignedObjectArray< btSoftBody::Material* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSoftBody::Material* >),16);
	o = new (mem)::btAlignedObjectArray< btSoftBody::Material* >();
	return (void*)o;
}
void btAlignedObjectArray_btSoftBody_Material_ptr__free(void *c) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( ::btSoftBody::Material * const & ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	::btSoftBody::Material * tp0 = (::btSoftBody::Material *)p0;
	o->push_back(tp0);
}
//method: at ::btSoftBody::Material * const & ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Material_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btSoftBody::Material * const & ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Material_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btSoftBody::Material * & ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Material_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Material_ptr__size(void *c) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Material_ptr__capacity(void *c) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__init(void *c) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Material_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( void *,int,int ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btSoftBody::Material * & ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Material_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: destroy void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int,int,::btSoftBody::Material * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: resize void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int,::btSoftBody::Material * const & ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	::btSoftBody::Material * tp1 = (::btSoftBody::Material *)p1;
	o->resize(p0,tp1);
}
//method: clear void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__clear(void *c) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Material_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: expand ::btSoftBody::Material * & ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( ::btSoftBody::Material * const & ) 
void* btAlignedObjectArray_btSoftBody_Material_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	::btSoftBody::Material * tp0 = (::btSoftBody::Material *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSoftBody::Material*, 16u> btAlignedObjectArray_btSoftBody_Material_ptr_->m_allocator
void btAlignedObjectArray_btSoftBody_Material_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	::btAlignedAllocator<btSoftBody::Material*, 16u> & ta = *(::btAlignedAllocator<btSoftBody::Material*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSoftBody_Material_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSoftBody_Material_ptr_->m_capacity
void btAlignedObjectArray_btSoftBody_Material_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSoftBody_Material_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSoftBody::Material * * btAlignedObjectArray_btSoftBody_Material_ptr_->m_data
// attribute not supported: //attribute: ::btSoftBody::Material * * btAlignedObjectArray_btSoftBody_Material_ptr_->m_data
//attribute: bool btAlignedObjectArray_btSoftBody_Material_ptr_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Material_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSoftBody_Material_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSoftBody_Material_ptr_->m_size
void btAlignedObjectArray_btSoftBody_Material_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSoftBody_Material_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Material* > *o = (::btAlignedObjectArray< btSoftBody::Material* >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btSoftBody::Node* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Node_ptr__new() {
	::btAlignedObjectArray< btSoftBody::Node* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSoftBody::Node* >),16);
	o = new (mem)::btAlignedObjectArray< btSoftBody::Node* >();
	return (void*)o;
}
void btAlignedObjectArray_btSoftBody_Node_ptr__free(void *c) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( ::btSoftBody::Node * const & ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	::btSoftBody::Node * tp0 = (::btSoftBody::Node *)p0;
	o->push_back(tp0);
}
//method: at ::btSoftBody::Node * const & ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Node_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btSoftBody::Node * const & ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Node_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btSoftBody::Node * & ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Node_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Node_ptr__size(void *c) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Node_ptr__capacity(void *c) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__init(void *c) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Node_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( void *,int,int ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btSoftBody::Node * & ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Node_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: destroy void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int,int,::btSoftBody::Node * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: resize void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int,::btSoftBody::Node * const & ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	::btSoftBody::Node * tp1 = (::btSoftBody::Node *)p1;
	o->resize(p0,tp1);
}
//method: clear void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__clear(void *c) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Node_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: expand ::btSoftBody::Node * & ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( ::btSoftBody::Node * const & ) 
void* btAlignedObjectArray_btSoftBody_Node_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	::btSoftBody::Node * tp0 = (::btSoftBody::Node *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSoftBody::Node*, 16u> btAlignedObjectArray_btSoftBody_Node_ptr_->m_allocator
void btAlignedObjectArray_btSoftBody_Node_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	::btAlignedAllocator<btSoftBody::Node*, 16u> & ta = *(::btAlignedAllocator<btSoftBody::Node*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSoftBody_Node_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSoftBody_Node_ptr_->m_capacity
void btAlignedObjectArray_btSoftBody_Node_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSoftBody_Node_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSoftBody::Node * * btAlignedObjectArray_btSoftBody_Node_ptr_->m_data
// attribute not supported: //attribute: ::btSoftBody::Node * * btAlignedObjectArray_btSoftBody_Node_ptr_->m_data
//attribute: bool btAlignedObjectArray_btSoftBody_Node_ptr_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Node_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSoftBody_Node_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSoftBody_Node_ptr_->m_size
void btAlignedObjectArray_btSoftBody_Node_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSoftBody_Node_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Node* > *o = (::btAlignedObjectArray< btSoftBody::Node* >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btSoftBody::Node >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Node__new() {
	::btAlignedObjectArray< btSoftBody::Node > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSoftBody::Node >),16);
	o = new (mem)::btAlignedObjectArray< btSoftBody::Node >();
	return (void*)o;
}
void btAlignedObjectArray_btSoftBody_Node__free(void *c) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btSoftBody::Node>::* )( ::btSoftBody::Node const & ) 
void btAlignedObjectArray_btSoftBody_Node__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	::btSoftBody::Node const & tp0 = *(::btSoftBody::Node const *)p0;
	o->push_back(tp0);
}
//method: at ::btSoftBody::Node const & ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Node__at(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::Node const & ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Node__at0(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::Node & ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Node__at1(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Node__size(void *c) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Node__capacity(void *c) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node__init(void *c) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Node__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node__pop_back(void *c) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node__deallocate(void *c) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Node__allocate(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Node>::* )( void *,int,int ) 
void btAlignedObjectArray_btSoftBody_Node__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btSoftBody::Node & ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Node__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: destroy void ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Node__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int,int,::btSoftBody::Node * ) const
void btAlignedObjectArray_btSoftBody_Node__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	::btSoftBody::Node * tp2 = (::btSoftBody::Node *)p2;
	o->copy(p0,p1,tp2);
}
//method: resize void ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int,::btSoftBody::Node const & ) 
void btAlignedObjectArray_btSoftBody_Node__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	::btSoftBody::Node const & tp1 = *(::btSoftBody::Node const *)p1;
	o->resize(p0,tp1);
}
//method: clear void ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node__clear(void *c) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Node__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: expand ::btSoftBody::Node & ( ::btAlignedObjectArray<btSoftBody::Node>::* )( ::btSoftBody::Node const & ) 
void* btAlignedObjectArray_btSoftBody_Node__expand(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	::btSoftBody::Node const & tp0 = *(::btSoftBody::Node const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Node__reserve(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSoftBody::Node, 16u> btAlignedObjectArray_btSoftBody_Node_->m_allocator
void btAlignedObjectArray_btSoftBody_Node__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	::btAlignedAllocator<btSoftBody::Node, 16u> & ta = *(::btAlignedAllocator<btSoftBody::Node, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSoftBody_Node__m_allocator_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSoftBody_Node_->m_capacity
void btAlignedObjectArray_btSoftBody_Node__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSoftBody_Node__m_capacity_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSoftBody::Node * btAlignedObjectArray_btSoftBody_Node_->m_data
void btAlignedObjectArray_btSoftBody_Node__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	::btSoftBody::Node * ta = (::btSoftBody::Node *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btSoftBody_Node__m_data_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btSoftBody_Node_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Node__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSoftBody_Node__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSoftBody_Node_->m_size
void btAlignedObjectArray_btSoftBody_Node__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSoftBody_Node__m_size_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Node > *o = (::btAlignedObjectArray< btSoftBody::Node >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btSoftBody::Note >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Note__new() {
	::btAlignedObjectArray< btSoftBody::Note > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSoftBody::Note >),16);
	o = new (mem)::btAlignedObjectArray< btSoftBody::Note >();
	return (void*)o;
}
void btAlignedObjectArray_btSoftBody_Note__free(void *c) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btSoftBody::Note>::* )( ::btSoftBody::Note const & ) 
void btAlignedObjectArray_btSoftBody_Note__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	::btSoftBody::Note const & tp0 = *(::btSoftBody::Note const *)p0;
	o->push_back(tp0);
}
//method: at ::btSoftBody::Note const & ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Note__at(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::Note const & ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Note__at0(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::Note & ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Note__at1(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Note__size(void *c) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Note__capacity(void *c) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Note__init(void *c) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Note__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Note__pop_back(void *c) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Note__deallocate(void *c) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Note__allocate(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Note>::* )( void *,int,int ) 
void btAlignedObjectArray_btSoftBody_Note__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btSoftBody::Note & ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Note__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: destroy void ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Note__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int,int,::btSoftBody::Note * ) const
void btAlignedObjectArray_btSoftBody_Note__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	::btSoftBody::Note * tp2 = (::btSoftBody::Note *)p2;
	o->copy(p0,p1,tp2);
}
//method: resize void ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int,::btSoftBody::Note const & ) 
void btAlignedObjectArray_btSoftBody_Note__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	::btSoftBody::Note const & tp1 = *(::btSoftBody::Note const *)p1;
	o->resize(p0,tp1);
}
//method: clear void ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Note__clear(void *c) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Note__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: expand ::btSoftBody::Note & ( ::btAlignedObjectArray<btSoftBody::Note>::* )( ::btSoftBody::Note const & ) 
void* btAlignedObjectArray_btSoftBody_Note__expand(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	::btSoftBody::Note const & tp0 = *(::btSoftBody::Note const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Note__reserve(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSoftBody::Note, 16u> btAlignedObjectArray_btSoftBody_Note_->m_allocator
void btAlignedObjectArray_btSoftBody_Note__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	::btAlignedAllocator<btSoftBody::Note, 16u> & ta = *(::btAlignedAllocator<btSoftBody::Note, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSoftBody_Note__m_allocator_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSoftBody_Note_->m_capacity
void btAlignedObjectArray_btSoftBody_Note__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSoftBody_Note__m_capacity_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSoftBody::Note * btAlignedObjectArray_btSoftBody_Note_->m_data
void btAlignedObjectArray_btSoftBody_Note__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	::btSoftBody::Note * ta = (::btSoftBody::Note *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btSoftBody_Note__m_data_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btSoftBody_Note_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Note__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSoftBody_Note__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSoftBody_Note_->m_size
void btAlignedObjectArray_btSoftBody_Note__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSoftBody_Note__m_size_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Note > *o = (::btAlignedObjectArray< btSoftBody::Note >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btSoftBody::RContact >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_RContact__new() {
	::btAlignedObjectArray< btSoftBody::RContact > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSoftBody::RContact >),16);
	o = new (mem)::btAlignedObjectArray< btSoftBody::RContact >();
	return (void*)o;
}
void btAlignedObjectArray_btSoftBody_RContact__free(void *c) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( ::btSoftBody::RContact const & ) 
void btAlignedObjectArray_btSoftBody_RContact__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	::btSoftBody::RContact const & tp0 = *(::btSoftBody::RContact const *)p0;
	o->push_back(tp0);
}
//method: at ::btSoftBody::RContact const & ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_RContact__at(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::RContact const & ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_RContact__at0(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::RContact & ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_RContact__at1(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) const
int btAlignedObjectArray_btSoftBody_RContact__size(void *c) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) const
int btAlignedObjectArray_btSoftBody_RContact__capacity(void *c) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_RContact__init(void *c) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_RContact__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_RContact__pop_back(void *c) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_RContact__deallocate(void *c) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_RContact__allocate(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( void *,int,int ) 
void btAlignedObjectArray_btSoftBody_RContact__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btSoftBody::RContact & ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_RContact__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: destroy void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_RContact__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int,int,::btSoftBody::RContact * ) const
void btAlignedObjectArray_btSoftBody_RContact__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	::btSoftBody::RContact * tp2 = (::btSoftBody::RContact *)p2;
	o->copy(p0,p1,tp2);
}
//method: resize void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int,::btSoftBody::RContact const & ) 
void btAlignedObjectArray_btSoftBody_RContact__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	::btSoftBody::RContact const & tp1 = *(::btSoftBody::RContact const *)p1;
	o->resize(p0,tp1);
}
//method: clear void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_RContact__clear(void *c) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int ) 
int btAlignedObjectArray_btSoftBody_RContact__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: expand ::btSoftBody::RContact & ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( ::btSoftBody::RContact const & ) 
void* btAlignedObjectArray_btSoftBody_RContact__expand(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	::btSoftBody::RContact const & tp0 = *(::btSoftBody::RContact const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int ) 
void btAlignedObjectArray_btSoftBody_RContact__reserve(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSoftBody::RContact, 16u> btAlignedObjectArray_btSoftBody_RContact_->m_allocator
void btAlignedObjectArray_btSoftBody_RContact__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	::btAlignedAllocator<btSoftBody::RContact, 16u> & ta = *(::btAlignedAllocator<btSoftBody::RContact, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSoftBody_RContact__m_allocator_get(void *c) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSoftBody_RContact_->m_capacity
void btAlignedObjectArray_btSoftBody_RContact__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSoftBody_RContact__m_capacity_get(void *c) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSoftBody::RContact * btAlignedObjectArray_btSoftBody_RContact_->m_data
void btAlignedObjectArray_btSoftBody_RContact__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	::btSoftBody::RContact * ta = (::btSoftBody::RContact *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btSoftBody_RContact__m_data_get(void *c) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btSoftBody_RContact_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_RContact__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSoftBody_RContact__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSoftBody_RContact_->m_size
void btAlignedObjectArray_btSoftBody_RContact__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSoftBody_RContact__m_size_get(void *c) {
	::btAlignedObjectArray< btSoftBody::RContact > *o = (::btAlignedObjectArray< btSoftBody::RContact >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btSoftBody::SContact >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_SContact__new() {
	::btAlignedObjectArray< btSoftBody::SContact > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSoftBody::SContact >),16);
	o = new (mem)::btAlignedObjectArray< btSoftBody::SContact >();
	return (void*)o;
}
void btAlignedObjectArray_btSoftBody_SContact__free(void *c) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( ::btSoftBody::SContact const & ) 
void btAlignedObjectArray_btSoftBody_SContact__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	::btSoftBody::SContact const & tp0 = *(::btSoftBody::SContact const *)p0;
	o->push_back(tp0);
}
//method: at ::btSoftBody::SContact const & ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_SContact__at(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::SContact const & ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_SContact__at0(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::SContact & ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_SContact__at1(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) const
int btAlignedObjectArray_btSoftBody_SContact__size(void *c) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) const
int btAlignedObjectArray_btSoftBody_SContact__capacity(void *c) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_SContact__init(void *c) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_SContact__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_SContact__pop_back(void *c) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_SContact__deallocate(void *c) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_SContact__allocate(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( void *,int,int ) 
void btAlignedObjectArray_btSoftBody_SContact__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btSoftBody::SContact & ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_SContact__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: destroy void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_SContact__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int,int,::btSoftBody::SContact * ) const
void btAlignedObjectArray_btSoftBody_SContact__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	::btSoftBody::SContact * tp2 = (::btSoftBody::SContact *)p2;
	o->copy(p0,p1,tp2);
}
//method: resize void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int,::btSoftBody::SContact const & ) 
void btAlignedObjectArray_btSoftBody_SContact__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	::btSoftBody::SContact const & tp1 = *(::btSoftBody::SContact const *)p1;
	o->resize(p0,tp1);
}
//method: clear void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_SContact__clear(void *c) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int ) 
int btAlignedObjectArray_btSoftBody_SContact__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: expand ::btSoftBody::SContact & ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( ::btSoftBody::SContact const & ) 
void* btAlignedObjectArray_btSoftBody_SContact__expand(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	::btSoftBody::SContact const & tp0 = *(::btSoftBody::SContact const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int ) 
void btAlignedObjectArray_btSoftBody_SContact__reserve(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSoftBody::SContact, 16u> btAlignedObjectArray_btSoftBody_SContact_->m_allocator
void btAlignedObjectArray_btSoftBody_SContact__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	::btAlignedAllocator<btSoftBody::SContact, 16u> & ta = *(::btAlignedAllocator<btSoftBody::SContact, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSoftBody_SContact__m_allocator_get(void *c) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSoftBody_SContact_->m_capacity
void btAlignedObjectArray_btSoftBody_SContact__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSoftBody_SContact__m_capacity_get(void *c) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSoftBody::SContact * btAlignedObjectArray_btSoftBody_SContact_->m_data
void btAlignedObjectArray_btSoftBody_SContact__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	::btSoftBody::SContact * ta = (::btSoftBody::SContact *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btSoftBody_SContact__m_data_get(void *c) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btSoftBody_SContact_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_SContact__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSoftBody_SContact__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSoftBody_SContact_->m_size
void btAlignedObjectArray_btSoftBody_SContact__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSoftBody_SContact__m_size_get(void *c) {
	::btAlignedObjectArray< btSoftBody::SContact > *o = (::btAlignedObjectArray< btSoftBody::SContact >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btSoftBody::Tetra >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Tetra__new() {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSoftBody::Tetra >),16);
	o = new (mem)::btAlignedObjectArray< btSoftBody::Tetra >();
	return (void*)o;
}
void btAlignedObjectArray_btSoftBody_Tetra__free(void *c) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( ::btSoftBody::Tetra const & ) 
void btAlignedObjectArray_btSoftBody_Tetra__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	::btSoftBody::Tetra const & tp0 = *(::btSoftBody::Tetra const *)p0;
	o->push_back(tp0);
}
//method: at ::btSoftBody::Tetra const & ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Tetra__at(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::Tetra const & ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Tetra__at0(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSoftBody::Tetra & ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Tetra__at1(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Tetra__size(void *c) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Tetra__capacity(void *c) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Tetra__init(void *c) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Tetra__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Tetra__pop_back(void *c) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Tetra__deallocate(void *c) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Tetra__allocate(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( void *,int,int ) 
void btAlignedObjectArray_btSoftBody_Tetra__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btSoftBody::Tetra & ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Tetra__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: destroy void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Tetra__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int,int,::btSoftBody::Tetra * ) const
void btAlignedObjectArray_btSoftBody_Tetra__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	::btSoftBody::Tetra * tp2 = (::btSoftBody::Tetra *)p2;
	o->copy(p0,p1,tp2);
}
//method: resize void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int,::btSoftBody::Tetra const & ) 
void btAlignedObjectArray_btSoftBody_Tetra__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	::btSoftBody::Tetra const & tp1 = *(::btSoftBody::Tetra const *)p1;
	o->resize(p0,tp1);
}
//method: clear void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Tetra__clear(void *c) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Tetra__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: expand ::btSoftBody::Tetra & ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( ::btSoftBody::Tetra const & ) 
void* btAlignedObjectArray_btSoftBody_Tetra__expand(void *c,void* p0) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	::btSoftBody::Tetra const & tp0 = *(::btSoftBody::Tetra const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Tetra__reserve(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSoftBody::Tetra, 16u> btAlignedObjectArray_btSoftBody_Tetra_->m_allocator
void btAlignedObjectArray_btSoftBody_Tetra__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	::btAlignedAllocator<btSoftBody::Tetra, 16u> & ta = *(::btAlignedAllocator<btSoftBody::Tetra, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSoftBody_Tetra__m_allocator_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSoftBody_Tetra_->m_capacity
void btAlignedObjectArray_btSoftBody_Tetra__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSoftBody_Tetra__m_capacity_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSoftBody::Tetra * btAlignedObjectArray_btSoftBody_Tetra_->m_data
void btAlignedObjectArray_btSoftBody_Tetra__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	::btSoftBody::Tetra * ta = (::btSoftBody::Tetra *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btSoftBody_Tetra__m_data_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btSoftBody_Tetra_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Tetra__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSoftBody_Tetra__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSoftBody_Tetra_->m_size
void btAlignedObjectArray_btSoftBody_Tetra__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSoftBody_Tetra__m_size_get(void *c) {
	::btAlignedObjectArray< btSoftBody::Tetra > *o = (::btAlignedObjectArray< btSoftBody::Tetra >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btSoftBody::ePSolver::_ >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_ePSolver____new() {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSoftBody::ePSolver::_ >),16);
	o = new (mem)::btAlignedObjectArray< btSoftBody::ePSolver::_ >();
	return (void*)o;
}
void btAlignedObjectArray_btSoftBody_ePSolver____free(void *c) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	delete o;
}
//not supported method: push_back void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( ::btSoftBody::ePSolver::_ const & ) 
// error:  - unsupported, void - ok

//not supported method: at ::btSoftBody::ePSolver::_ const & ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at ::btSoftBody::ePSolver::_ const & ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at ::btSoftBody::ePSolver::_ & ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int ) 
// error: int - ok,  - unsupported

//method: size int ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) const
int btAlignedObjectArray_btSoftBody_ePSolver____size(void *c) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) const
int btAlignedObjectArray_btSoftBody_ePSolver____capacity(void *c) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) 
void btAlignedObjectArray_btSoftBody_ePSolver____init(void *c) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_ePSolver____swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) 
void btAlignedObjectArray_btSoftBody_ePSolver____pop_back(void *c) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) 
void btAlignedObjectArray_btSoftBody_ePSolver____deallocate(void *c) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_ePSolver____allocate(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( void *,int,int ) 
void btAlignedObjectArray_btSoftBody_ePSolver____initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//not supported method: expandNonInitializing ::btSoftBody::ePSolver::_ & ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) 
// error:  - unsupported

//method: destroy void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_ePSolver____destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int,int,::btSoftBody::ePSolver::_ * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: resize void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int,::btSoftBody::ePSolver::_ const & ) 
// error: int - ok,  - unsupported, void - ok

//method: clear void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) 
void btAlignedObjectArray_btSoftBody_ePSolver____clear(void *c) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int ) 
int btAlignedObjectArray_btSoftBody_ePSolver____allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//not supported method: expand ::btSoftBody::ePSolver::_ & ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( ::btSoftBody::ePSolver::_ const & ) 
// error:  - unsupported,  - unsupported

//method: reserve void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int ) 
void btAlignedObjectArray_btSoftBody_ePSolver____reserve(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u> btAlignedObjectArray_btSoftBody_ePSolver___->m_allocator
void btAlignedObjectArray_btSoftBody_ePSolver____m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	::btAlignedAllocator<btSoftBody::ePSolver::_, 16u> & ta = *(::btAlignedAllocator<btSoftBody::ePSolver::_, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSoftBody_ePSolver____m_allocator_get(void *c) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSoftBody_ePSolver___->m_capacity
void btAlignedObjectArray_btSoftBody_ePSolver____m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSoftBody_ePSolver____m_capacity_get(void *c) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSoftBody::ePSolver::_ * btAlignedObjectArray_btSoftBody_ePSolver___->m_data
// attribute not supported: //attribute: ::btSoftBody::ePSolver::_ * btAlignedObjectArray_btSoftBody_ePSolver___->m_data
//attribute: bool btAlignedObjectArray_btSoftBody_ePSolver___->m_ownsMemory
void btAlignedObjectArray_btSoftBody_ePSolver____m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSoftBody_ePSolver____m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSoftBody_ePSolver___->m_size
void btAlignedObjectArray_btSoftBody_ePSolver____m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSoftBody_ePSolver____m_size_get(void *c) {
	::btAlignedObjectArray< btSoftBody::ePSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::ePSolver::_ >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btSoftBody::eVSolver::_ >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_eVSolver____new() {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSoftBody::eVSolver::_ >),16);
	o = new (mem)::btAlignedObjectArray< btSoftBody::eVSolver::_ >();
	return (void*)o;
}
void btAlignedObjectArray_btSoftBody_eVSolver____free(void *c) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	delete o;
}
//not supported method: push_back void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( ::btSoftBody::eVSolver::_ const & ) 
// error:  - unsupported, void - ok

//not supported method: at ::btSoftBody::eVSolver::_ const & ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at ::btSoftBody::eVSolver::_ const & ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at ::btSoftBody::eVSolver::_ & ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int ) 
// error: int - ok,  - unsupported

//method: size int ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) const
int btAlignedObjectArray_btSoftBody_eVSolver____size(void *c) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) const
int btAlignedObjectArray_btSoftBody_eVSolver____capacity(void *c) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) 
void btAlignedObjectArray_btSoftBody_eVSolver____init(void *c) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_eVSolver____swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) 
void btAlignedObjectArray_btSoftBody_eVSolver____pop_back(void *c) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) 
void btAlignedObjectArray_btSoftBody_eVSolver____deallocate(void *c) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_eVSolver____allocate(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( void *,int,int ) 
void btAlignedObjectArray_btSoftBody_eVSolver____initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//not supported method: expandNonInitializing ::btSoftBody::eVSolver::_ & ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) 
// error:  - unsupported

//method: destroy void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_eVSolver____destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int,int,::btSoftBody::eVSolver::_ * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: resize void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int,::btSoftBody::eVSolver::_ const & ) 
// error: int - ok,  - unsupported, void - ok

//method: clear void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) 
void btAlignedObjectArray_btSoftBody_eVSolver____clear(void *c) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int ) 
int btAlignedObjectArray_btSoftBody_eVSolver____allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//not supported method: expand ::btSoftBody::eVSolver::_ & ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( ::btSoftBody::eVSolver::_ const & ) 
// error:  - unsupported,  - unsupported

//method: reserve void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int ) 
void btAlignedObjectArray_btSoftBody_eVSolver____reserve(void *c,int p0) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u> btAlignedObjectArray_btSoftBody_eVSolver___->m_allocator
void btAlignedObjectArray_btSoftBody_eVSolver____m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	::btAlignedAllocator<btSoftBody::eVSolver::_, 16u> & ta = *(::btAlignedAllocator<btSoftBody::eVSolver::_, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSoftBody_eVSolver____m_allocator_get(void *c) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSoftBody_eVSolver___->m_capacity
void btAlignedObjectArray_btSoftBody_eVSolver____m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSoftBody_eVSolver____m_capacity_get(void *c) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSoftBody::eVSolver::_ * btAlignedObjectArray_btSoftBody_eVSolver___->m_data
// attribute not supported: //attribute: ::btSoftBody::eVSolver::_ * btAlignedObjectArray_btSoftBody_eVSolver___->m_data
//attribute: bool btAlignedObjectArray_btSoftBody_eVSolver___->m_ownsMemory
void btAlignedObjectArray_btSoftBody_eVSolver____m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSoftBody_eVSolver____m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSoftBody_eVSolver___->m_size
void btAlignedObjectArray_btSoftBody_eVSolver____m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSoftBody_eVSolver____m_size_get(void *c) {
	::btAlignedObjectArray< btSoftBody::eVSolver::_ > *o = (::btAlignedObjectArray< btSoftBody::eVSolver::_ >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btSolverConstraint >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) 
void* btAlignedObjectArray_btSolverConstraint__new() {
	::btAlignedObjectArray< btSolverConstraint > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSolverConstraint >),16);
	o = new (mem)::btAlignedObjectArray< btSolverConstraint >();
	return (void*)o;
}
void btAlignedObjectArray_btSolverConstraint__free(void *c) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btSolverConstraint>::* )( ::btSolverConstraint const & ) 
void btAlignedObjectArray_btSolverConstraint__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	::btSolverConstraint const & tp0 = *(::btSolverConstraint const *)p0;
	o->push_back(tp0);
}
//method: at ::btSolverConstraint const & ( ::btAlignedObjectArray<btSolverConstraint>::* )( int ) const
void* btAlignedObjectArray_btSolverConstraint__at(void *c,int p0) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSolverConstraint const & ( ::btAlignedObjectArray<btSolverConstraint>::* )( int ) const
void* btAlignedObjectArray_btSolverConstraint__at0(void *c,int p0) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btSolverConstraint & ( ::btAlignedObjectArray<btSolverConstraint>::* )( int ) 
void* btAlignedObjectArray_btSolverConstraint__at1(void *c,int p0) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) const
int btAlignedObjectArray_btSolverConstraint__size(void *c) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) const
int btAlignedObjectArray_btSolverConstraint__capacity(void *c) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) 
void btAlignedObjectArray_btSolverConstraint__init(void *c) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btSolverConstraint>::* )( int ) 
void* btAlignedObjectArray_btSolverConstraint__allocate(void *c,int p0) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) 
void btAlignedObjectArray_btSolverConstraint__pop_back(void *c) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) 
void btAlignedObjectArray_btSolverConstraint__deallocate(void *c) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btSolverConstraint>::* )( int,int ) 
void btAlignedObjectArray_btSolverConstraint__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSolverConstraint>::* )( void *,int,int ) 
void btAlignedObjectArray_btSolverConstraint__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btSolverConstraint & ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) 
void* btAlignedObjectArray_btSolverConstraint__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btSolverConstraint>::* )( int,::btSolverConstraint const & ) 
void btAlignedObjectArray_btSolverConstraint__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	::btSolverConstraint const & tp1 = *(::btSolverConstraint const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btSolverConstraint>::* )( int,int ) 
void btAlignedObjectArray_btSolverConstraint__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btSolverConstraint>::* )( int,int,::btSolverConstraint * ) const
void btAlignedObjectArray_btSolverConstraint__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	::btSolverConstraint * tp2 = (::btSolverConstraint *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btSolverConstraint & ( ::btAlignedObjectArray<btSolverConstraint>::* )( ::btSolverConstraint const & ) 
void* btAlignedObjectArray_btSolverConstraint__expand(void *c,void* p0) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	::btSolverConstraint const & tp0 = *(::btSolverConstraint const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) 
void btAlignedObjectArray_btSolverConstraint__clear(void *c) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSolverConstraint>::* )( int ) 
int btAlignedObjectArray_btSolverConstraint__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btSolverConstraint>::* )( int ) 
void btAlignedObjectArray_btSolverConstraint__reserve(void *c,int p0) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSolverConstraint, 16u> btAlignedObjectArray_btSolverConstraint_->m_allocator
void btAlignedObjectArray_btSolverConstraint__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	::btAlignedAllocator<btSolverConstraint, 16u> & ta = *(::btAlignedAllocator<btSolverConstraint, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSolverConstraint__m_allocator_get(void *c) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSolverConstraint_->m_size
void btAlignedObjectArray_btSolverConstraint__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSolverConstraint__m_size_get(void *c) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btSolverConstraint_->m_capacity
void btAlignedObjectArray_btSolverConstraint__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSolverConstraint__m_capacity_get(void *c) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSolverConstraint * btAlignedObjectArray_btSolverConstraint_->m_data
void btAlignedObjectArray_btSolverConstraint__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	::btSolverConstraint * ta = (::btSolverConstraint *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btSolverConstraint__m_data_get(void *c) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btSolverConstraint_->m_ownsMemory
void btAlignedObjectArray_btSolverConstraint__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSolverConstraint__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSolverConstraint > *o = (::btAlignedObjectArray< btSolverConstraint >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btSparseSdf<3>::Cell* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) 
void* btAlignedObjectArray_btSparseSdf_3__Cell_ptr__new() {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btSparseSdf<3>::Cell* >),16);
	o = new (mem)::btAlignedObjectArray< btSparseSdf<3>::Cell* >();
	return (void*)o;
}
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__free(void *c) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	delete o;
}
//not supported method: push_back void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( ::btSparseSdf<3>::Cell * const & ) 
// error:  - unsupported, void - ok

//not supported method: at ::btSparseSdf<3>::Cell * const & ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at ::btSparseSdf<3>::Cell * const & ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at ::btSparseSdf<3>::Cell * & ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int ) 
// error: int - ok,  - unsupported

//method: size int ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) const
int btAlignedObjectArray_btSparseSdf_3__Cell_ptr__size(void *c) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) const
int btAlignedObjectArray_btSparseSdf_3__Cell_ptr__capacity(void *c) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) 
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__init(void *c) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int,int ) 
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) 
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) 
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int ) 
void* btAlignedObjectArray_btSparseSdf_3__Cell_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( void *,int,int ) 
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//not supported method: expandNonInitializing ::btSparseSdf<3>::Cell * & ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) 
// error:  - unsupported

//method: destroy void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int,int ) 
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int,int,::btSparseSdf<3>::Cell * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: resize void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int,::btSparseSdf<3>::Cell * const & ) 
// error: int - ok,  - unsupported, void - ok

//method: clear void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) 
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__clear(void *c) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int ) 
int btAlignedObjectArray_btSparseSdf_3__Cell_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//not supported method: expand ::btSparseSdf<3>::Cell * & ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( ::btSparseSdf<3>::Cell * const & ) 
// error:  - unsupported,  - unsupported

//method: reserve void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int ) 
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u> btAlignedObjectArray_btSparseSdf_3__Cell_ptr_->m_allocator
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u> & ta = *(::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btSparseSdf_3__Cell_ptr_->m_capacity
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btSparseSdf<3>::Cell * * btAlignedObjectArray_btSparseSdf_3__Cell_ptr_->m_data
// attribute not supported: //attribute: ::btSparseSdf<3>::Cell * * btAlignedObjectArray_btSparseSdf_3__Cell_ptr_->m_data
//attribute: bool btAlignedObjectArray_btSparseSdf_3__Cell_ptr_->m_ownsMemory
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btSparseSdf_3__Cell_ptr_->m_size
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btSparseSdf<3>::Cell* > *o = (::btAlignedObjectArray< btSparseSdf<3>::Cell* >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btTransform >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btTransform>::* )(  ) 
void* btAlignedObjectArray_btTransform__new() {
	::btAlignedObjectArray< btTransform > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btTransform >),16);
	o = new (mem)::btAlignedObjectArray< btTransform >();
	return (void*)o;
}
void btAlignedObjectArray_btTransform__free(void *c) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btTransform>::* )( ::btTransform const & ) 
void btAlignedObjectArray_btTransform__push_back(void *c,float* p0) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	o->push_back(tp0);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//method: at ::btTransform const & ( ::btAlignedObjectArray<btTransform>::* )( int ) const
void btAlignedObjectArray_btTransform__at(void *c,int p0,float* ret) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->at(p0);
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: at ::btTransform const & ( ::btAlignedObjectArray<btTransform>::* )( int ) const
void btAlignedObjectArray_btTransform__at0(void *c,int p0,float* ret) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->at(p0);
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: at ::btTransform & ( ::btAlignedObjectArray<btTransform>::* )( int ) 
void btAlignedObjectArray_btTransform__at1(void *c,int p0,float* ret) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->at(p0);
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: size int ( ::btAlignedObjectArray<btTransform>::* )(  ) const
int btAlignedObjectArray_btTransform__size(void *c) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btTransform>::* )(  ) const
int btAlignedObjectArray_btTransform__capacity(void *c) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btTransform>::* )(  ) 
void btAlignedObjectArray_btTransform__init(void *c) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btTransform>::* )( int ) 
void* btAlignedObjectArray_btTransform__allocate(void *c,int p0) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btTransform>::* )(  ) 
void btAlignedObjectArray_btTransform__pop_back(void *c) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btTransform>::* )(  ) 
void btAlignedObjectArray_btTransform__deallocate(void *c) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btTransform>::* )( int,int ) 
void btAlignedObjectArray_btTransform__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btTransform>::* )( void *,int,int ) 
void btAlignedObjectArray_btTransform__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btTransform & ( ::btAlignedObjectArray<btTransform>::* )(  ) 
void btAlignedObjectArray_btTransform__expandNonInitializing(void *c,float* ret) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->expandNonInitializing();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: resize void ( ::btAlignedObjectArray<btTransform>::* )( int,::btTransform const & ) 
void btAlignedObjectArray_btTransform__resize(void *c,int p0,float* p1) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->resize(p0,tp1);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: destroy void ( ::btAlignedObjectArray<btTransform>::* )( int,int ) 
void btAlignedObjectArray_btTransform__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btTransform>::* )( int,int,::btTransform * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: expand ::btTransform & ( ::btAlignedObjectArray<btTransform>::* )( ::btTransform const & ) 
void btAlignedObjectArray_btTransform__expand(void *c,float* p0,float* ret) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->expand(tp0);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: clear void ( ::btAlignedObjectArray<btTransform>::* )(  ) 
void btAlignedObjectArray_btTransform__clear(void *c) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btTransform>::* )( int ) 
int btAlignedObjectArray_btTransform__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btTransform>::* )( int ) 
void btAlignedObjectArray_btTransform__reserve(void *c,int p0) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btTransform, 16u> btAlignedObjectArray_btTransform_->m_allocator
void btAlignedObjectArray_btTransform__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	::btAlignedAllocator<btTransform, 16u> & ta = *(::btAlignedAllocator<btTransform, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btTransform__m_allocator_get(void *c) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btTransform_->m_size
void btAlignedObjectArray_btTransform__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btTransform__m_size_get(void *c) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btTransform_->m_capacity
void btAlignedObjectArray_btTransform__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btTransform__m_capacity_get(void *c) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btTransform * btAlignedObjectArray_btTransform_->m_data
// attribute not supported: //attribute: ::btTransform * btAlignedObjectArray_btTransform_->m_data
//attribute: bool btAlignedObjectArray_btTransform_->m_ownsMemory
void btAlignedObjectArray_btTransform__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btTransform__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btTransform > *o = (::btAlignedObjectArray< btTransform >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btTriangleInfo >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) 
void* btAlignedObjectArray_btTriangleInfo__new() {
	::btAlignedObjectArray< btTriangleInfo > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btTriangleInfo >),16);
	o = new (mem)::btAlignedObjectArray< btTriangleInfo >();
	return (void*)o;
}
void btAlignedObjectArray_btTriangleInfo__free(void *c) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btTriangleInfo>::* )( ::btTriangleInfo const & ) 
void btAlignedObjectArray_btTriangleInfo__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	::btTriangleInfo const & tp0 = *(::btTriangleInfo const *)p0;
	o->push_back(tp0);
}
//method: at ::btTriangleInfo const & ( ::btAlignedObjectArray<btTriangleInfo>::* )( int ) const
void* btAlignedObjectArray_btTriangleInfo__at(void *c,int p0) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btTriangleInfo const & ( ::btAlignedObjectArray<btTriangleInfo>::* )( int ) const
void* btAlignedObjectArray_btTriangleInfo__at0(void *c,int p0) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btTriangleInfo & ( ::btAlignedObjectArray<btTriangleInfo>::* )( int ) 
void* btAlignedObjectArray_btTriangleInfo__at1(void *c,int p0) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) const
int btAlignedObjectArray_btTriangleInfo__size(void *c) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) const
int btAlignedObjectArray_btTriangleInfo__capacity(void *c) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) 
void btAlignedObjectArray_btTriangleInfo__init(void *c) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btTriangleInfo>::* )( int ) 
void* btAlignedObjectArray_btTriangleInfo__allocate(void *c,int p0) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) 
void btAlignedObjectArray_btTriangleInfo__pop_back(void *c) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) 
void btAlignedObjectArray_btTriangleInfo__deallocate(void *c) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btTriangleInfo>::* )( int,int ) 
void btAlignedObjectArray_btTriangleInfo__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btTriangleInfo>::* )( void *,int,int ) 
void btAlignedObjectArray_btTriangleInfo__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btTriangleInfo & ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) 
void* btAlignedObjectArray_btTriangleInfo__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btTriangleInfo>::* )( int,::btTriangleInfo const & ) 
void btAlignedObjectArray_btTriangleInfo__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	::btTriangleInfo const & tp1 = *(::btTriangleInfo const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btTriangleInfo>::* )( int,int ) 
void btAlignedObjectArray_btTriangleInfo__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btTriangleInfo>::* )( int,int,::btTriangleInfo * ) const
void btAlignedObjectArray_btTriangleInfo__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	::btTriangleInfo * tp2 = (::btTriangleInfo *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btTriangleInfo & ( ::btAlignedObjectArray<btTriangleInfo>::* )( ::btTriangleInfo const & ) 
void* btAlignedObjectArray_btTriangleInfo__expand(void *c,void* p0) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	::btTriangleInfo const & tp0 = *(::btTriangleInfo const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) 
void btAlignedObjectArray_btTriangleInfo__clear(void *c) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btTriangleInfo>::* )( int ) 
int btAlignedObjectArray_btTriangleInfo__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btTriangleInfo>::* )( int ) 
void btAlignedObjectArray_btTriangleInfo__reserve(void *c,int p0) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btTriangleInfo, 16u> btAlignedObjectArray_btTriangleInfo_->m_allocator
void btAlignedObjectArray_btTriangleInfo__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	::btAlignedAllocator<btTriangleInfo, 16u> & ta = *(::btAlignedAllocator<btTriangleInfo, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btTriangleInfo__m_allocator_get(void *c) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btTriangleInfo_->m_size
void btAlignedObjectArray_btTriangleInfo__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btTriangleInfo__m_size_get(void *c) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btTriangleInfo_->m_capacity
void btAlignedObjectArray_btTriangleInfo__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btTriangleInfo__m_capacity_get(void *c) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btTriangleInfo * btAlignedObjectArray_btTriangleInfo_->m_data
void btAlignedObjectArray_btTriangleInfo__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	::btTriangleInfo * ta = (::btTriangleInfo *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btTriangleInfo__m_data_get(void *c) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btTriangleInfo_->m_ownsMemory
void btAlignedObjectArray_btTriangleInfo__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btTriangleInfo__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btTriangleInfo > *o = (::btAlignedObjectArray< btTriangleInfo >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btTypedConstraint* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) 
void* btAlignedObjectArray_btTypedConstraint_ptr__new() {
	::btAlignedObjectArray< btTypedConstraint* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btTypedConstraint* >),16);
	o = new (mem)::btAlignedObjectArray< btTypedConstraint* >();
	return (void*)o;
}
void btAlignedObjectArray_btTypedConstraint_ptr__free(void *c) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btTypedConstraint*>::* )( ::btTypedConstraint * const & ) 
void btAlignedObjectArray_btTypedConstraint_ptr__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	::btTypedConstraint * tp0 = (::btTypedConstraint *)p0;
	o->push_back(tp0);
}
//method: at ::btTypedConstraint * const & ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int ) const
void* btAlignedObjectArray_btTypedConstraint_ptr__at(void *c,int p0) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btTypedConstraint * const & ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int ) const
void* btAlignedObjectArray_btTypedConstraint_ptr__at0(void *c,int p0) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: at ::btTypedConstraint * & ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int ) 
void* btAlignedObjectArray_btTypedConstraint_ptr__at1(void *c,int p0) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	void* retVal = (void*) o->at(p0);
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) const
int btAlignedObjectArray_btTypedConstraint_ptr__size(void *c) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) const
int btAlignedObjectArray_btTypedConstraint_ptr__capacity(void *c) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_ptr__init(void *c) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int ) 
void* btAlignedObjectArray_btTypedConstraint_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_ptr__pop_back(void *c) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_ptr__deallocate(void *c) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int,int ) 
void btAlignedObjectArray_btTypedConstraint_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btTypedConstraint*>::* )( void *,int,int ) 
void btAlignedObjectArray_btTypedConstraint_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btTypedConstraint * & ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) 
void* btAlignedObjectArray_btTypedConstraint_ptr__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	void* retVal = (void*) o->expandNonInitializing();
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int,::btTypedConstraint * const & ) 
void btAlignedObjectArray_btTypedConstraint_ptr__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	::btTypedConstraint * tp1 = (::btTypedConstraint *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int,int ) 
void btAlignedObjectArray_btTypedConstraint_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int,int,::btTypedConstraint * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: expand ::btTypedConstraint * & ( ::btAlignedObjectArray<btTypedConstraint*>::* )( ::btTypedConstraint * const & ) 
void* btAlignedObjectArray_btTypedConstraint_ptr__expand(void *c,void* p0) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	::btTypedConstraint * tp0 = (::btTypedConstraint *)p0;
	void* retVal = (void*) o->expand(tp0);
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_ptr__clear(void *c) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int ) 
int btAlignedObjectArray_btTypedConstraint_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int ) 
void btAlignedObjectArray_btTypedConstraint_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btTypedConstraint*, 16u> btAlignedObjectArray_btTypedConstraint_ptr_->m_allocator
void btAlignedObjectArray_btTypedConstraint_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	::btAlignedAllocator<btTypedConstraint*, 16u> & ta = *(::btAlignedAllocator<btTypedConstraint*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btTypedConstraint_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btTypedConstraint_ptr_->m_size
void btAlignedObjectArray_btTypedConstraint_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btTypedConstraint_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btTypedConstraint_ptr_->m_capacity
void btAlignedObjectArray_btTypedConstraint_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btTypedConstraint_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btTypedConstraint * * btAlignedObjectArray_btTypedConstraint_ptr_->m_data
// attribute not supported: //attribute: ::btTypedConstraint * * btAlignedObjectArray_btTypedConstraint_ptr_->m_data
//attribute: bool btAlignedObjectArray_btTypedConstraint_ptr_->m_ownsMemory
void btAlignedObjectArray_btTypedConstraint_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btTypedConstraint_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btTypedConstraint* > *o = (::btAlignedObjectArray< btTypedConstraint* >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) 
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__new() {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >),16);
	o = new (mem)::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >();
	return (void*)o;
}
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__free(void *c) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( ::btTypedConstraint::btConstraintInfo1 const & ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	::btTypedConstraint::btConstraintInfo1 const & tp0 = *(::btTypedConstraint::btConstraintInfo1 const *)p0;
	o->push_back(tp0);
}
//method: at ::btTypedConstraint::btConstraintInfo1 const & ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int ) const
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__at(void *c,int p0) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btTypedConstraint::btConstraintInfo1 const & ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int ) const
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__at0(void *c,int p0) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btTypedConstraint::btConstraintInfo1 & ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int ) 
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__at1(void *c,int p0) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) const
int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__size(void *c) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) const
int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__capacity(void *c) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__init(void *c) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int ) 
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__allocate(void *c,int p0) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__pop_back(void *c) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__deallocate(void *c) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int,int ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( void *,int,int ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btTypedConstraint::btConstraintInfo1 & ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) 
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int,::btTypedConstraint::btConstraintInfo1 const & ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	::btTypedConstraint::btConstraintInfo1 const & tp1 = *(::btTypedConstraint::btConstraintInfo1 const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int,int ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int,int,::btTypedConstraint::btConstraintInfo1 * ) const
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	::btTypedConstraint::btConstraintInfo1 * tp2 = (::btTypedConstraint::btConstraintInfo1 *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btTypedConstraint::btConstraintInfo1 & ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( ::btTypedConstraint::btConstraintInfo1 const & ) 
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__expand(void *c,void* p0) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	::btTypedConstraint::btConstraintInfo1 const & tp0 = *(::btTypedConstraint::btConstraintInfo1 const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__clear(void *c) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int ) 
int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__reserve(void *c,int p0) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u> btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_->m_allocator
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u> & ta = *(::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_allocator_get(void *c) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_->m_size
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_size_get(void *c) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_->m_capacity
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_capacity_get(void *c) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btTypedConstraint::btConstraintInfo1 * btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_->m_data
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	::btTypedConstraint::btConstraintInfo1 * ta = (::btTypedConstraint::btConstraintInfo1 *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_data_get(void *c) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_->m_ownsMemory
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 > *o = (::btAlignedObjectArray< btTypedConstraint::btConstraintInfo1 >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< btVector3 >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btVector3>::* )(  ) 
void* btAlignedObjectArray_btVector3__new() {
	::btAlignedObjectArray< btVector3 > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btVector3 >),16);
	o = new (mem)::btAlignedObjectArray< btVector3 >();
	return (void*)o;
}
void btAlignedObjectArray_btVector3__free(void *c) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btVector3>::* )( ::btVector3 const & ) 
void btAlignedObjectArray_btVector3__push_back(void *c,float* p0) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->push_back(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: at ::btVector3 const & ( ::btAlignedObjectArray<btVector3>::* )( int ) const
void btAlignedObjectArray_btVector3__at(void *c,int p0,float* ret) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->at(p0);
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: at ::btVector3 const & ( ::btAlignedObjectArray<btVector3>::* )( int ) const
void btAlignedObjectArray_btVector3__at0(void *c,int p0,float* ret) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->at(p0);
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: at ::btVector3 & ( ::btAlignedObjectArray<btVector3>::* )( int ) 
void btAlignedObjectArray_btVector3__at1(void *c,int p0,float* ret) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->at(p0);
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: size int ( ::btAlignedObjectArray<btVector3>::* )(  ) const
int btAlignedObjectArray_btVector3__size(void *c) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btVector3>::* )(  ) const
int btAlignedObjectArray_btVector3__capacity(void *c) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btVector3>::* )(  ) 
void btAlignedObjectArray_btVector3__init(void *c) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<btVector3>::* )( int,int ) 
void btAlignedObjectArray_btVector3__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<btVector3>::* )(  ) 
void btAlignedObjectArray_btVector3__pop_back(void *c) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btVector3>::* )(  ) 
void btAlignedObjectArray_btVector3__deallocate(void *c) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<btVector3>::* )( int ) 
void* btAlignedObjectArray_btVector3__allocate(void *c,int p0) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btVector3>::* )( void *,int,int ) 
void btAlignedObjectArray_btVector3__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btVector3 & ( ::btAlignedObjectArray<btVector3>::* )(  ) 
void btAlignedObjectArray_btVector3__expandNonInitializing(void *c,float* ret) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->expandNonInitializing();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: destroy void ( ::btAlignedObjectArray<btVector3>::* )( int,int ) 
void btAlignedObjectArray_btVector3__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<btVector3>::* )( int,int,::btVector3 * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//method: resize void ( ::btAlignedObjectArray<btVector3>::* )( int,::btVector3 const & ) 
void btAlignedObjectArray_btVector3__resize(void *c,int p0,float* p1) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->resize(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: clear void ( ::btAlignedObjectArray<btVector3>::* )(  ) 
void btAlignedObjectArray_btVector3__clear(void *c) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btVector3>::* )( int ) 
int btAlignedObjectArray_btVector3__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: expand ::btVector3 & ( ::btAlignedObjectArray<btVector3>::* )( ::btVector3 const & ) 
void btAlignedObjectArray_btVector3__expand(void *c,float* p0,float* ret) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->expand(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: reserve void ( ::btAlignedObjectArray<btVector3>::* )( int ) 
void btAlignedObjectArray_btVector3__reserve(void *c,int p0) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btVector3, 16u> btAlignedObjectArray_btVector3_->m_allocator
void btAlignedObjectArray_btVector3__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	::btAlignedAllocator<btVector3, 16u> & ta = *(::btAlignedAllocator<btVector3, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btVector3__m_allocator_get(void *c) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btVector3_->m_capacity
void btAlignedObjectArray_btVector3__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btVector3__m_capacity_get(void *c) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btVector3 * btAlignedObjectArray_btVector3_->m_data
// attribute not supported: //attribute: ::btVector3 * btAlignedObjectArray_btVector3_->m_data
//attribute: bool btAlignedObjectArray_btVector3_->m_ownsMemory
void btAlignedObjectArray_btVector3__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btVector3__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_btVector3_->m_size
void btAlignedObjectArray_btVector3__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btVector3__m_size_get(void *c) {
	::btAlignedObjectArray< btVector3 > *o = (::btAlignedObjectArray< btVector3 >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< btWheelInfo >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) 
void* btAlignedObjectArray_btWheelInfo__new() {
	::btAlignedObjectArray< btWheelInfo > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< btWheelInfo >),16);
	o = new (mem)::btAlignedObjectArray< btWheelInfo >();
	return (void*)o;
}
void btAlignedObjectArray_btWheelInfo__free(void *c) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	delete o;
}
//method: push_back void ( ::btAlignedObjectArray<btWheelInfo>::* )( ::btWheelInfo const & ) 
void btAlignedObjectArray_btWheelInfo__push_back(void *c,void* p0) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	::btWheelInfo const & tp0 = *(::btWheelInfo const *)p0;
	o->push_back(tp0);
}
//method: at ::btWheelInfo const & ( ::btAlignedObjectArray<btWheelInfo>::* )( int ) const
void* btAlignedObjectArray_btWheelInfo__at(void *c,int p0) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btWheelInfo const & ( ::btAlignedObjectArray<btWheelInfo>::* )( int ) const
void* btAlignedObjectArray_btWheelInfo__at0(void *c,int p0) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: at ::btWheelInfo & ( ::btAlignedObjectArray<btWheelInfo>::* )( int ) 
void* btAlignedObjectArray_btWheelInfo__at1(void *c,int p0) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	void* retVal = (void*) &(o->at(p0));
	return retVal;
}
//method: size int ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) const
int btAlignedObjectArray_btWheelInfo__size(void *c) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) const
int btAlignedObjectArray_btWheelInfo__capacity(void *c) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) 
void btAlignedObjectArray_btWheelInfo__init(void *c) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<btWheelInfo>::* )( int ) 
void* btAlignedObjectArray_btWheelInfo__allocate(void *c,int p0) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) 
void btAlignedObjectArray_btWheelInfo__pop_back(void *c) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) 
void btAlignedObjectArray_btWheelInfo__deallocate(void *c) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<btWheelInfo>::* )( int,int ) 
void btAlignedObjectArray_btWheelInfo__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<btWheelInfo>::* )( void *,int,int ) 
void btAlignedObjectArray_btWheelInfo__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//method: expandNonInitializing ::btWheelInfo & ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) 
void* btAlignedObjectArray_btWheelInfo__expandNonInitializing(void *c) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	void* retVal = (void*) &(o->expandNonInitializing());
	return retVal;
}
//method: resize void ( ::btAlignedObjectArray<btWheelInfo>::* )( int,::btWheelInfo const & ) 
void btAlignedObjectArray_btWheelInfo__resize(void *c,int p0,void* p1) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	::btWheelInfo const & tp1 = *(::btWheelInfo const *)p1;
	o->resize(p0,tp1);
}
//method: destroy void ( ::btAlignedObjectArray<btWheelInfo>::* )( int,int ) 
void btAlignedObjectArray_btWheelInfo__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	o->destroy(p0,p1);
}
//method: copy void ( ::btAlignedObjectArray<btWheelInfo>::* )( int,int,::btWheelInfo * ) const
void btAlignedObjectArray_btWheelInfo__copy(void *c,int p0,int p1,void* p2) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	::btWheelInfo * tp2 = (::btWheelInfo *)p2;
	o->copy(p0,p1,tp2);
}
//method: expand ::btWheelInfo & ( ::btAlignedObjectArray<btWheelInfo>::* )( ::btWheelInfo const & ) 
void* btAlignedObjectArray_btWheelInfo__expand(void *c,void* p0) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	::btWheelInfo const & tp0 = *(::btWheelInfo const *)p0;
	void* retVal = (void*) &(o->expand(tp0));
	return retVal;
}
//method: clear void ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) 
void btAlignedObjectArray_btWheelInfo__clear(void *c) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<btWheelInfo>::* )( int ) 
int btAlignedObjectArray_btWheelInfo__allocSize(void *c,int p0) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<btWheelInfo>::* )( int ) 
void btAlignedObjectArray_btWheelInfo__reserve(void *c,int p0) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<btWheelInfo, 16u> btAlignedObjectArray_btWheelInfo_->m_allocator
void btAlignedObjectArray_btWheelInfo__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	::btAlignedAllocator<btWheelInfo, 16u> & ta = *(::btAlignedAllocator<btWheelInfo, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_btWheelInfo__m_allocator_get(void *c) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_btWheelInfo_->m_size
void btAlignedObjectArray_btWheelInfo__m_size_set(void *c,int a) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_btWheelInfo__m_size_get(void *c) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_btWheelInfo_->m_capacity
void btAlignedObjectArray_btWheelInfo__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_btWheelInfo__m_capacity_get(void *c) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	return (int)(o->m_capacity);
}

//attribute: ::btWheelInfo * btAlignedObjectArray_btWheelInfo_->m_data
void btAlignedObjectArray_btWheelInfo__m_data_set(void *c,void* a) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	::btWheelInfo * ta = (::btWheelInfo *)a;
	o->m_data = ta;
}
void* btAlignedObjectArray_btWheelInfo__m_data_get(void *c) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	return (void*)(o->m_data);
}

//attribute: bool btAlignedObjectArray_btWheelInfo_->m_ownsMemory
void btAlignedObjectArray_btWheelInfo__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_btWheelInfo__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< btWheelInfo > *o = (::btAlignedObjectArray< btWheelInfo >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< char const* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<char const*>::* )(  ) 
void* btAlignedObjectArray_charconst_ptr__new() {
	::btAlignedObjectArray< char const* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< char const* >),16);
	o = new (mem)::btAlignedObjectArray< char const* >();
	return (void*)o;
}
void btAlignedObjectArray_charconst_ptr__free(void *c) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	delete o;
}
//not supported method: push_back void ( ::btAlignedObjectArray<char const*>::* )( char const * const & ) 
// error:  - unsupported, void - ok

//not supported method: at char const * const & ( ::btAlignedObjectArray<char const*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at char const * const & ( ::btAlignedObjectArray<char const*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at char const * & ( ::btAlignedObjectArray<char const*>::* )( int ) 
// error: int - ok,  - unsupported

//method: size int ( ::btAlignedObjectArray<char const*>::* )(  ) const
int btAlignedObjectArray_charconst_ptr__size(void *c) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<char const*>::* )(  ) const
int btAlignedObjectArray_charconst_ptr__capacity(void *c) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<char const*>::* )(  ) 
void btAlignedObjectArray_charconst_ptr__init(void *c) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<char const*>::* )( int ) 
void* btAlignedObjectArray_charconst_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<char const*>::* )(  ) 
void btAlignedObjectArray_charconst_ptr__pop_back(void *c) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<char const*>::* )(  ) 
void btAlignedObjectArray_charconst_ptr__deallocate(void *c) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<char const*>::* )( int,int ) 
void btAlignedObjectArray_charconst_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<char const*>::* )( void *,int,int ) 
void btAlignedObjectArray_charconst_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//not supported method: expandNonInitializing char const * & ( ::btAlignedObjectArray<char const*>::* )(  ) 
// error:  - unsupported

//not supported method: resize void ( ::btAlignedObjectArray<char const*>::* )( int,char const * const & ) 
// error: int - ok,  - unsupported, void - ok

//method: destroy void ( ::btAlignedObjectArray<char const*>::* )( int,int ) 
void btAlignedObjectArray_charconst_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<char const*>::* )( int,int,char const * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: expand char const * & ( ::btAlignedObjectArray<char const*>::* )( char const * const & ) 
// error:  - unsupported,  - unsupported

//method: clear void ( ::btAlignedObjectArray<char const*>::* )(  ) 
void btAlignedObjectArray_charconst_ptr__clear(void *c) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<char const*>::* )( int ) 
int btAlignedObjectArray_charconst_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<char const*>::* )( int ) 
void btAlignedObjectArray_charconst_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<char const*, 16u> btAlignedObjectArray_charconst_ptr_->m_allocator
void btAlignedObjectArray_charconst_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	::btAlignedAllocator<char const*, 16u> & ta = *(::btAlignedAllocator<char const*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_charconst_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_charconst_ptr_->m_size
void btAlignedObjectArray_charconst_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_charconst_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_charconst_ptr_->m_capacity
void btAlignedObjectArray_charconst_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_charconst_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	return (int)(o->m_capacity);
}

//attribute: char const * * btAlignedObjectArray_charconst_ptr_->m_data
// attribute not supported: //attribute: char const * * btAlignedObjectArray_charconst_ptr_->m_data
//attribute: bool btAlignedObjectArray_charconst_ptr_->m_ownsMemory
void btAlignedObjectArray_charconst_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_charconst_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< char const* > *o = (::btAlignedObjectArray< char const* >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< char* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<char*>::* )(  ) 
void* btAlignedObjectArray_char_ptr__new() {
	::btAlignedObjectArray< char* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< char* >),16);
	o = new (mem)::btAlignedObjectArray< char* >();
	return (void*)o;
}
void btAlignedObjectArray_char_ptr__free(void *c) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	delete o;
}
//not supported method: push_back void ( ::btAlignedObjectArray<char*>::* )( char * const & ) 
// error:  - unsupported, void - ok

//not supported method: at char * const & ( ::btAlignedObjectArray<char*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at char * const & ( ::btAlignedObjectArray<char*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at char * & ( ::btAlignedObjectArray<char*>::* )( int ) 
// error: int - ok,  - unsupported

//method: size int ( ::btAlignedObjectArray<char*>::* )(  ) const
int btAlignedObjectArray_char_ptr__size(void *c) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<char*>::* )(  ) const
int btAlignedObjectArray_char_ptr__capacity(void *c) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<char*>::* )(  ) 
void btAlignedObjectArray_char_ptr__init(void *c) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<char*>::* )( int ) 
void* btAlignedObjectArray_char_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<char*>::* )(  ) 
void btAlignedObjectArray_char_ptr__pop_back(void *c) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<char*>::* )(  ) 
void btAlignedObjectArray_char_ptr__deallocate(void *c) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<char*>::* )( int,int ) 
void btAlignedObjectArray_char_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<char*>::* )( void *,int,int ) 
void btAlignedObjectArray_char_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//not supported method: expandNonInitializing char * & ( ::btAlignedObjectArray<char*>::* )(  ) 
// error:  - unsupported

//not supported method: resize void ( ::btAlignedObjectArray<char*>::* )( int,char * const & ) 
// error: int - ok,  - unsupported, void - ok

//method: destroy void ( ::btAlignedObjectArray<char*>::* )( int,int ) 
void btAlignedObjectArray_char_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<char*>::* )( int,int,char * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: expand char * & ( ::btAlignedObjectArray<char*>::* )( char * const & ) 
// error:  - unsupported,  - unsupported

//method: clear void ( ::btAlignedObjectArray<char*>::* )(  ) 
void btAlignedObjectArray_char_ptr__clear(void *c) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<char*>::* )( int ) 
int btAlignedObjectArray_char_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<char*>::* )( int ) 
void btAlignedObjectArray_char_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<char*, 16u> btAlignedObjectArray_char_ptr_->m_allocator
void btAlignedObjectArray_char_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	::btAlignedAllocator<char*, 16u> & ta = *(::btAlignedAllocator<char*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_char_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_char_ptr_->m_size
void btAlignedObjectArray_char_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_char_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_char_ptr_->m_capacity
void btAlignedObjectArray_char_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_char_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	return (int)(o->m_capacity);
}

//attribute: char * * btAlignedObjectArray_char_ptr_->m_data
// attribute not supported: //attribute: char * * btAlignedObjectArray_char_ptr_->m_data
//attribute: bool btAlignedObjectArray_char_ptr_->m_ownsMemory
void btAlignedObjectArray_char_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_char_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< char* > *o = (::btAlignedObjectArray< char* >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< float >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<float>::* )(  ) 
void* btAlignedObjectArray_float__new() {
	::btAlignedObjectArray< float > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< float >),16);
	o = new (mem)::btAlignedObjectArray< float >();
	return (void*)o;
}
void btAlignedObjectArray_float__free(void *c) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	delete o;
}
//not supported method: push_back void ( ::btAlignedObjectArray<float>::* )( float const & ) 
// error:  - unsupported, void - ok

//not supported method: at float const & ( ::btAlignedObjectArray<float>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at float const & ( ::btAlignedObjectArray<float>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at float & ( ::btAlignedObjectArray<float>::* )( int ) 
// error: int - ok,  - unsupported

//method: size int ( ::btAlignedObjectArray<float>::* )(  ) const
int btAlignedObjectArray_float__size(void *c) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<float>::* )(  ) const
int btAlignedObjectArray_float__capacity(void *c) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<float>::* )(  ) 
void btAlignedObjectArray_float__init(void *c) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<float>::* )( int,int ) 
void btAlignedObjectArray_float__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<float>::* )(  ) 
void btAlignedObjectArray_float__pop_back(void *c) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<float>::* )(  ) 
void btAlignedObjectArray_float__deallocate(void *c) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<float>::* )( int ) 
void* btAlignedObjectArray_float__allocate(void *c,int p0) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<float>::* )( void *,int,int ) 
void btAlignedObjectArray_float__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//not supported method: expandNonInitializing float & ( ::btAlignedObjectArray<float>::* )(  ) 
// error:  - unsupported

//method: destroy void ( ::btAlignedObjectArray<float>::* )( int,int ) 
void btAlignedObjectArray_float__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<float>::* )( int,int,float * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: resize void ( ::btAlignedObjectArray<float>::* )( int,float const & ) 
// error: int - ok,  - unsupported, void - ok

//method: clear void ( ::btAlignedObjectArray<float>::* )(  ) 
void btAlignedObjectArray_float__clear(void *c) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<float>::* )( int ) 
int btAlignedObjectArray_float__allocSize(void *c,int p0) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//not supported method: expand float & ( ::btAlignedObjectArray<float>::* )( float const & ) 
// error:  - unsupported,  - unsupported

//method: reserve void ( ::btAlignedObjectArray<float>::* )( int ) 
void btAlignedObjectArray_float__reserve(void *c,int p0) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<float, 16u> btAlignedObjectArray_float_->m_allocator
void btAlignedObjectArray_float__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	::btAlignedAllocator<float, 16u> & ta = *(::btAlignedAllocator<float, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_float__m_allocator_get(void *c) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_float_->m_capacity
void btAlignedObjectArray_float__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_float__m_capacity_get(void *c) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	return (int)(o->m_capacity);
}

//attribute: float * btAlignedObjectArray_float_->m_data
// attribute not supported: //attribute: float * btAlignedObjectArray_float_->m_data
//attribute: bool btAlignedObjectArray_float_->m_ownsMemory
void btAlignedObjectArray_float__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_float__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_float_->m_size
void btAlignedObjectArray_float__m_size_set(void *c,int a) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_float__m_size_get(void *c) {
	::btAlignedObjectArray< float > *o = (::btAlignedObjectArray< float >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< int >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<int>::* )(  ) 
void* btAlignedObjectArray_int__new() {
	::btAlignedObjectArray< int > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< int >),16);
	o = new (mem)::btAlignedObjectArray< int >();
	return (void*)o;
}
void btAlignedObjectArray_int__free(void *c) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	delete o;
}
//not supported method: push_back void ( ::btAlignedObjectArray<int>::* )( int const & ) 
// error:  - unsupported, void - ok

//not supported method: at int const & ( ::btAlignedObjectArray<int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at int const & ( ::btAlignedObjectArray<int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at int & ( ::btAlignedObjectArray<int>::* )( int ) 
// error: int - ok,  - unsupported

//method: size int ( ::btAlignedObjectArray<int>::* )(  ) const
int btAlignedObjectArray_int__size(void *c) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<int>::* )(  ) const
int btAlignedObjectArray_int__capacity(void *c) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<int>::* )(  ) 
void btAlignedObjectArray_int__init(void *c) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	o->init();
}
//method: swap void ( ::btAlignedObjectArray<int>::* )( int,int ) 
void btAlignedObjectArray_int__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	o->swap(p0,p1);
}
//method: pop_back void ( ::btAlignedObjectArray<int>::* )(  ) 
void btAlignedObjectArray_int__pop_back(void *c) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<int>::* )(  ) 
void btAlignedObjectArray_int__deallocate(void *c) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	o->deallocate();
}
//method: allocate void * ( ::btAlignedObjectArray<int>::* )( int ) 
void* btAlignedObjectArray_int__allocate(void *c,int p0) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<int>::* )( void *,int,int ) 
void btAlignedObjectArray_int__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//not supported method: expandNonInitializing int & ( ::btAlignedObjectArray<int>::* )(  ) 
// error:  - unsupported

//method: destroy void ( ::btAlignedObjectArray<int>::* )( int,int ) 
void btAlignedObjectArray_int__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<int>::* )( int,int,int * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: resize void ( ::btAlignedObjectArray<int>::* )( int,int const & ) 
// error: int - ok,  - unsupported, void - ok

//method: clear void ( ::btAlignedObjectArray<int>::* )(  ) 
void btAlignedObjectArray_int__clear(void *c) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<int>::* )( int ) 
int btAlignedObjectArray_int__allocSize(void *c,int p0) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//not supported method: expand int & ( ::btAlignedObjectArray<int>::* )( int const & ) 
// error:  - unsupported,  - unsupported

//method: reserve void ( ::btAlignedObjectArray<int>::* )( int ) 
void btAlignedObjectArray_int__reserve(void *c,int p0) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<int, 16u> btAlignedObjectArray_int_->m_allocator
void btAlignedObjectArray_int__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	::btAlignedAllocator<int, 16u> & ta = *(::btAlignedAllocator<int, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_int__m_allocator_get(void *c) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_int_->m_capacity
void btAlignedObjectArray_int__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_int__m_capacity_get(void *c) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	return (int)(o->m_capacity);
}

//attribute: int * btAlignedObjectArray_int_->m_data
// attribute not supported: //attribute: int * btAlignedObjectArray_int_->m_data
//attribute: bool btAlignedObjectArray_int_->m_ownsMemory
void btAlignedObjectArray_int__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_int__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	return (int)(o->m_ownsMemory);
}

//attribute: int btAlignedObjectArray_int_->m_size
void btAlignedObjectArray_int__m_size_set(void *c,int a) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_int__m_size_get(void *c) {
	::btAlignedObjectArray< int > *o = (::btAlignedObjectArray< int >*)c;
	return (int)(o->m_size);
}


// ::btAlignedObjectArray< short* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<short*>::* )(  ) 
void* btAlignedObjectArray_short_ptr__new() {
	::btAlignedObjectArray< short* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< short* >),16);
	o = new (mem)::btAlignedObjectArray< short* >();
	return (void*)o;
}
void btAlignedObjectArray_short_ptr__free(void *c) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	delete o;
}
//not supported method: push_back void ( ::btAlignedObjectArray<short*>::* )( short int * const & ) 
// error:  - unsupported, void - ok

//not supported method: at short int * const & ( ::btAlignedObjectArray<short*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at short int * const & ( ::btAlignedObjectArray<short*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at short int * & ( ::btAlignedObjectArray<short*>::* )( int ) 
// error: int - ok,  - unsupported

//method: size int ( ::btAlignedObjectArray<short*>::* )(  ) const
int btAlignedObjectArray_short_ptr__size(void *c) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<short*>::* )(  ) const
int btAlignedObjectArray_short_ptr__capacity(void *c) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<short*>::* )(  ) 
void btAlignedObjectArray_short_ptr__init(void *c) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<short*>::* )( int ) 
void* btAlignedObjectArray_short_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<short*>::* )(  ) 
void btAlignedObjectArray_short_ptr__pop_back(void *c) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<short*>::* )(  ) 
void btAlignedObjectArray_short_ptr__deallocate(void *c) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<short*>::* )( int,int ) 
void btAlignedObjectArray_short_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<short*>::* )( void *,int,int ) 
void btAlignedObjectArray_short_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//not supported method: expandNonInitializing short int * & ( ::btAlignedObjectArray<short*>::* )(  ) 
// error:  - unsupported

//not supported method: resize void ( ::btAlignedObjectArray<short*>::* )( int,short int * const & ) 
// error: int - ok,  - unsupported, void - ok

//method: destroy void ( ::btAlignedObjectArray<short*>::* )( int,int ) 
void btAlignedObjectArray_short_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<short*>::* )( int,int,short int * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: expand short int * & ( ::btAlignedObjectArray<short*>::* )( short int * const & ) 
// error:  - unsupported,  - unsupported

//method: clear void ( ::btAlignedObjectArray<short*>::* )(  ) 
void btAlignedObjectArray_short_ptr__clear(void *c) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<short*>::* )( int ) 
int btAlignedObjectArray_short_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<short*>::* )( int ) 
void btAlignedObjectArray_short_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<short*, 16u> btAlignedObjectArray_short_ptr_->m_allocator
void btAlignedObjectArray_short_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	::btAlignedAllocator<short*, 16u> & ta = *(::btAlignedAllocator<short*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_short_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_short_ptr_->m_size
void btAlignedObjectArray_short_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_short_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_short_ptr_->m_capacity
void btAlignedObjectArray_short_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_short_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	return (int)(o->m_capacity);
}

//attribute: short int * * btAlignedObjectArray_short_ptr_->m_data
// attribute not supported: //attribute: short int * * btAlignedObjectArray_short_ptr_->m_data
//attribute: bool btAlignedObjectArray_short_ptr_->m_ownsMemory
void btAlignedObjectArray_short_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_short_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< short* > *o = (::btAlignedObjectArray< short* >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< short >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<short>::* )(  ) 
void* btAlignedObjectArray_short__new() {
	::btAlignedObjectArray< short > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< short >),16);
	o = new (mem)::btAlignedObjectArray< short >();
	return (void*)o;
}
void btAlignedObjectArray_short__free(void *c) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	delete o;
}
//not supported method: push_back void ( ::btAlignedObjectArray<short>::* )( short int const & ) 
// error:  - unsupported, void - ok

//not supported method: at short int const & ( ::btAlignedObjectArray<short>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at short int const & ( ::btAlignedObjectArray<short>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at short int & ( ::btAlignedObjectArray<short>::* )( int ) 
// error: int - ok,  - unsupported

//method: size int ( ::btAlignedObjectArray<short>::* )(  ) const
int btAlignedObjectArray_short__size(void *c) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<short>::* )(  ) const
int btAlignedObjectArray_short__capacity(void *c) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<short>::* )(  ) 
void btAlignedObjectArray_short__init(void *c) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<short>::* )( int ) 
void* btAlignedObjectArray_short__allocate(void *c,int p0) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<short>::* )(  ) 
void btAlignedObjectArray_short__pop_back(void *c) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<short>::* )(  ) 
void btAlignedObjectArray_short__deallocate(void *c) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<short>::* )( int,int ) 
void btAlignedObjectArray_short__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<short>::* )( void *,int,int ) 
void btAlignedObjectArray_short__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//not supported method: expandNonInitializing short int & ( ::btAlignedObjectArray<short>::* )(  ) 
// error:  - unsupported

//not supported method: resize void ( ::btAlignedObjectArray<short>::* )( int,short int const & ) 
// error: int - ok,  - unsupported, void - ok

//method: destroy void ( ::btAlignedObjectArray<short>::* )( int,int ) 
void btAlignedObjectArray_short__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<short>::* )( int,int,short int * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: expand short int & ( ::btAlignedObjectArray<short>::* )( short int const & ) 
// error:  - unsupported,  - unsupported

//method: clear void ( ::btAlignedObjectArray<short>::* )(  ) 
void btAlignedObjectArray_short__clear(void *c) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<short>::* )( int ) 
int btAlignedObjectArray_short__allocSize(void *c,int p0) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<short>::* )( int ) 
void btAlignedObjectArray_short__reserve(void *c,int p0) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<short, 16u> btAlignedObjectArray_short_->m_allocator
void btAlignedObjectArray_short__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	::btAlignedAllocator<short, 16u> & ta = *(::btAlignedAllocator<short, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_short__m_allocator_get(void *c) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_short_->m_size
void btAlignedObjectArray_short__m_size_set(void *c,int a) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_short__m_size_get(void *c) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_short_->m_capacity
void btAlignedObjectArray_short__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_short__m_capacity_get(void *c) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	return (int)(o->m_capacity);
}

//attribute: short int * btAlignedObjectArray_short_->m_data
// attribute not supported: //attribute: short int * btAlignedObjectArray_short_->m_data
//attribute: bool btAlignedObjectArray_short_->m_ownsMemory
void btAlignedObjectArray_short__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_short__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< short > *o = (::btAlignedObjectArray< short >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< unsigned int >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<unsigned int>::* )(  ) 
void* btAlignedObjectArray_unsignedint__new() {
	::btAlignedObjectArray< unsigned int > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< unsigned int >),16);
	o = new (mem)::btAlignedObjectArray< unsigned int >();
	return (void*)o;
}
void btAlignedObjectArray_unsignedint__free(void *c) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	delete o;
}
//not supported method: push_back void ( ::btAlignedObjectArray<unsigned int>::* )( unsigned int const & ) 
// error:  - unsupported, void - ok

//not supported method: at unsigned int const & ( ::btAlignedObjectArray<unsigned int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at unsigned int const & ( ::btAlignedObjectArray<unsigned int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at unsigned int & ( ::btAlignedObjectArray<unsigned int>::* )( int ) 
// error: int - ok,  - unsupported

//method: size int ( ::btAlignedObjectArray<unsigned int>::* )(  ) const
int btAlignedObjectArray_unsignedint__size(void *c) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<unsigned int>::* )(  ) const
int btAlignedObjectArray_unsignedint__capacity(void *c) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<unsigned int>::* )(  ) 
void btAlignedObjectArray_unsignedint__init(void *c) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<unsigned int>::* )( int ) 
void* btAlignedObjectArray_unsignedint__allocate(void *c,int p0) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<unsigned int>::* )(  ) 
void btAlignedObjectArray_unsignedint__pop_back(void *c) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<unsigned int>::* )(  ) 
void btAlignedObjectArray_unsignedint__deallocate(void *c) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<unsigned int>::* )( int,int ) 
void btAlignedObjectArray_unsignedint__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<unsigned int>::* )( void *,int,int ) 
void btAlignedObjectArray_unsignedint__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//not supported method: expandNonInitializing unsigned int & ( ::btAlignedObjectArray<unsigned int>::* )(  ) 
// error:  - unsupported

//not supported method: resize void ( ::btAlignedObjectArray<unsigned int>::* )( int,unsigned int const & ) 
// error: int - ok,  - unsupported, void - ok

//method: destroy void ( ::btAlignedObjectArray<unsigned int>::* )( int,int ) 
void btAlignedObjectArray_unsignedint__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<unsigned int>::* )( int,int,unsigned int * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: expand unsigned int & ( ::btAlignedObjectArray<unsigned int>::* )( unsigned int const & ) 
// error:  - unsupported,  - unsupported

//method: clear void ( ::btAlignedObjectArray<unsigned int>::* )(  ) 
void btAlignedObjectArray_unsignedint__clear(void *c) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<unsigned int>::* )( int ) 
int btAlignedObjectArray_unsignedint__allocSize(void *c,int p0) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<unsigned int>::* )( int ) 
void btAlignedObjectArray_unsignedint__reserve(void *c,int p0) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<unsigned int, 16u> btAlignedObjectArray_unsignedint_->m_allocator
void btAlignedObjectArray_unsignedint__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	::btAlignedAllocator<unsigned int, 16u> & ta = *(::btAlignedAllocator<unsigned int, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_unsignedint__m_allocator_get(void *c) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_unsignedint_->m_size
void btAlignedObjectArray_unsignedint__m_size_set(void *c,int a) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_unsignedint__m_size_get(void *c) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_unsignedint_->m_capacity
void btAlignedObjectArray_unsignedint__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_unsignedint__m_capacity_get(void *c) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	return (int)(o->m_capacity);
}

//attribute: unsigned int * btAlignedObjectArray_unsignedint_->m_data
// attribute not supported: //attribute: unsigned int * btAlignedObjectArray_unsignedint_->m_data
//attribute: bool btAlignedObjectArray_unsignedint_->m_ownsMemory
void btAlignedObjectArray_unsignedint__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_unsignedint__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< unsigned int > *o = (::btAlignedObjectArray< unsigned int >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< unsigned short >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<unsigned short>::* )(  ) 
void* btAlignedObjectArray_unsignedshort__new() {
	::btAlignedObjectArray< unsigned short > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< unsigned short >),16);
	o = new (mem)::btAlignedObjectArray< unsigned short >();
	return (void*)o;
}
void btAlignedObjectArray_unsignedshort__free(void *c) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	delete o;
}
//not supported method: push_back void ( ::btAlignedObjectArray<unsigned short>::* )( short unsigned int const & ) 
// error:  - unsupported, void - ok

//not supported method: at short unsigned int const & ( ::btAlignedObjectArray<unsigned short>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at short unsigned int const & ( ::btAlignedObjectArray<unsigned short>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at short unsigned int & ( ::btAlignedObjectArray<unsigned short>::* )( int ) 
// error: int - ok,  - unsupported

//method: size int ( ::btAlignedObjectArray<unsigned short>::* )(  ) const
int btAlignedObjectArray_unsignedshort__size(void *c) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<unsigned short>::* )(  ) const
int btAlignedObjectArray_unsignedshort__capacity(void *c) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<unsigned short>::* )(  ) 
void btAlignedObjectArray_unsignedshort__init(void *c) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<unsigned short>::* )( int ) 
void* btAlignedObjectArray_unsignedshort__allocate(void *c,int p0) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<unsigned short>::* )(  ) 
void btAlignedObjectArray_unsignedshort__pop_back(void *c) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<unsigned short>::* )(  ) 
void btAlignedObjectArray_unsignedshort__deallocate(void *c) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<unsigned short>::* )( int,int ) 
void btAlignedObjectArray_unsignedshort__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<unsigned short>::* )( void *,int,int ) 
void btAlignedObjectArray_unsignedshort__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//not supported method: expandNonInitializing short unsigned int & ( ::btAlignedObjectArray<unsigned short>::* )(  ) 
// error:  - unsupported

//not supported method: resize void ( ::btAlignedObjectArray<unsigned short>::* )( int,short unsigned int const & ) 
// error: int - ok,  - unsupported, void - ok

//method: destroy void ( ::btAlignedObjectArray<unsigned short>::* )( int,int ) 
void btAlignedObjectArray_unsignedshort__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<unsigned short>::* )( int,int,short unsigned int * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: expand short unsigned int & ( ::btAlignedObjectArray<unsigned short>::* )( short unsigned int const & ) 
// error:  - unsupported,  - unsupported

//method: clear void ( ::btAlignedObjectArray<unsigned short>::* )(  ) 
void btAlignedObjectArray_unsignedshort__clear(void *c) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<unsigned short>::* )( int ) 
int btAlignedObjectArray_unsignedshort__allocSize(void *c,int p0) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<unsigned short>::* )( int ) 
void btAlignedObjectArray_unsignedshort__reserve(void *c,int p0) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<unsigned short, 16u> btAlignedObjectArray_unsignedshort_->m_allocator
void btAlignedObjectArray_unsignedshort__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	::btAlignedAllocator<unsigned short, 16u> & ta = *(::btAlignedAllocator<unsigned short, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_unsignedshort__m_allocator_get(void *c) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_unsignedshort_->m_size
void btAlignedObjectArray_unsignedshort__m_size_set(void *c,int a) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_unsignedshort__m_size_get(void *c) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_unsignedshort_->m_capacity
void btAlignedObjectArray_unsignedshort__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_unsignedshort__m_capacity_get(void *c) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	return (int)(o->m_capacity);
}

//attribute: short unsigned int * btAlignedObjectArray_unsignedshort_->m_data
// attribute not supported: //attribute: short unsigned int * btAlignedObjectArray_unsignedshort_->m_data
//attribute: bool btAlignedObjectArray_unsignedshort_->m_ownsMemory
void btAlignedObjectArray_unsignedshort__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_unsignedshort__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< unsigned short > *o = (::btAlignedObjectArray< unsigned short >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btAlignedObjectArray< void* >
//constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<void*>::* )(  ) 
void* btAlignedObjectArray_void_ptr__new() {
	::btAlignedObjectArray< void* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAlignedObjectArray< void* >),16);
	o = new (mem)::btAlignedObjectArray< void* >();
	return (void*)o;
}
void btAlignedObjectArray_void_ptr__free(void *c) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	delete o;
}
//not supported method: push_back void ( ::btAlignedObjectArray<void*>::* )( void * const & ) 
// error:  - unsupported, void - ok

//not supported method: at void * const & ( ::btAlignedObjectArray<void*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at void * const & ( ::btAlignedObjectArray<void*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at void * & ( ::btAlignedObjectArray<void*>::* )( int ) 
// error: int - ok,  - unsupported

//method: size int ( ::btAlignedObjectArray<void*>::* )(  ) const
int btAlignedObjectArray_void_ptr__size(void *c) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//method: capacity int ( ::btAlignedObjectArray<void*>::* )(  ) const
int btAlignedObjectArray_void_ptr__capacity(void *c) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	int retVal = (int)o->capacity();
	return retVal;
}
//method: init void ( ::btAlignedObjectArray<void*>::* )(  ) 
void btAlignedObjectArray_void_ptr__init(void *c) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	o->init();
}
//method: allocate void * ( ::btAlignedObjectArray<void*>::* )( int ) 
void* btAlignedObjectArray_void_ptr__allocate(void *c,int p0) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	void* retVal = (void*) o->allocate(p0);
	return retVal;
}
//method: pop_back void ( ::btAlignedObjectArray<void*>::* )(  ) 
void btAlignedObjectArray_void_ptr__pop_back(void *c) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	o->pop_back();
}
//method: deallocate void ( ::btAlignedObjectArray<void*>::* )(  ) 
void btAlignedObjectArray_void_ptr__deallocate(void *c) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	o->deallocate();
}
//method: swap void ( ::btAlignedObjectArray<void*>::* )( int,int ) 
void btAlignedObjectArray_void_ptr__swap(void *c,int p0,int p1) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	o->swap(p0,p1);
}
//method: initializeFromBuffer void ( ::btAlignedObjectArray<void*>::* )( void *,int,int ) 
void btAlignedObjectArray_void_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	void * tp0 = (void *)p0;
	o->initializeFromBuffer(tp0,p1,p2);
}
//not supported method: expandNonInitializing void * & ( ::btAlignedObjectArray<void*>::* )(  ) 
// error:  - unsupported

//not supported method: resize void ( ::btAlignedObjectArray<void*>::* )( int,void * const & ) 
// error: int - ok,  - unsupported, void - ok

//method: destroy void ( ::btAlignedObjectArray<void*>::* )( int,int ) 
void btAlignedObjectArray_void_ptr__destroy(void *c,int p0,int p1) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	o->destroy(p0,p1);
}
//not supported method: copy void ( ::btAlignedObjectArray<void*>::* )( int,int,void * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: expand void * & ( ::btAlignedObjectArray<void*>::* )( void * const & ) 
// error:  - unsupported,  - unsupported

//method: clear void ( ::btAlignedObjectArray<void*>::* )(  ) 
void btAlignedObjectArray_void_ptr__clear(void *c) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	o->clear();
}
//method: allocSize int ( ::btAlignedObjectArray<void*>::* )( int ) 
int btAlignedObjectArray_void_ptr__allocSize(void *c,int p0) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	int retVal = (int)o->allocSize(p0);
	return retVal;
}
//method: reserve void ( ::btAlignedObjectArray<void*>::* )( int ) 
void btAlignedObjectArray_void_ptr__reserve(void *c,int p0) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	o->reserve(p0);
}
//attribute: ::btAlignedAllocator<void*, 16u> btAlignedObjectArray_void_ptr_->m_allocator
void btAlignedObjectArray_void_ptr__m_allocator_set(void *c,void* a) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	::btAlignedAllocator<void*, 16u> & ta = *(::btAlignedAllocator<void*, 16u> *)a;
	o->m_allocator = ta;
}
void* btAlignedObjectArray_void_ptr__m_allocator_get(void *c) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	return (void*)&(o->m_allocator);
}

//attribute: int btAlignedObjectArray_void_ptr_->m_size
void btAlignedObjectArray_void_ptr__m_size_set(void *c,int a) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	o->m_size = a;
}
int btAlignedObjectArray_void_ptr__m_size_get(void *c) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	return (int)(o->m_size);
}

//attribute: int btAlignedObjectArray_void_ptr_->m_capacity
void btAlignedObjectArray_void_ptr__m_capacity_set(void *c,int a) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	o->m_capacity = a;
}
int btAlignedObjectArray_void_ptr__m_capacity_get(void *c) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	return (int)(o->m_capacity);
}

//attribute: void * * btAlignedObjectArray_void_ptr_->m_data
// attribute not supported: //attribute: void * * btAlignedObjectArray_void_ptr_->m_data
//attribute: bool btAlignedObjectArray_void_ptr_->m_ownsMemory
void btAlignedObjectArray_void_ptr__m_ownsMemory_set(void *c,int a) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	o->m_ownsMemory = a;
}
int btAlignedObjectArray_void_ptr__m_ownsMemory_get(void *c) {
	::btAlignedObjectArray< void* > *o = (::btAlignedObjectArray< void* >*)c;
	return (int)(o->m_ownsMemory);
}


// ::btBlock
//constructor: btBlock  ( ::btBlock::* )(  ) 
void* btBlock_new() {
	::btBlock *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btBlock),16);
	o = new (mem)::btBlock();
	return (void*)o;
}
void btBlock_free(void *c) {
	::btBlock *o = (::btBlock*)c;
	delete o;
}
//attribute: ::btBlock * btBlock->previous
void btBlock_previous_set(void *c,void* a) {
	::btBlock *o = (::btBlock*)c;
	::btBlock * ta = (::btBlock *)a;
	o->previous = ta;
}
void* btBlock_previous_get(void *c) {
	::btBlock *o = (::btBlock*)c;
	return (void*)(o->previous);
}

//attribute: unsigned char * btBlock->address
// attribute not supported: //attribute: unsigned char * btBlock->address

// ::btChunk
//constructor: btChunk  ( ::btChunk::* )(  ) 
void* btChunk_new() {
	::btChunk *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btChunk),16);
	o = new (mem)::btChunk();
	return (void*)o;
}
void btChunk_free(void *c) {
	::btChunk *o = (::btChunk*)c;
	delete o;
}
//attribute: int btChunk->m_chunkCode
void btChunk_m_chunkCode_set(void *c,int a) {
	::btChunk *o = (::btChunk*)c;
	o->m_chunkCode = a;
}
int btChunk_m_chunkCode_get(void *c) {
	::btChunk *o = (::btChunk*)c;
	return (int)(o->m_chunkCode);
}

//attribute: int btChunk->m_dna_nr
void btChunk_m_dna_nr_set(void *c,int a) {
	::btChunk *o = (::btChunk*)c;
	o->m_dna_nr = a;
}
int btChunk_m_dna_nr_get(void *c) {
	::btChunk *o = (::btChunk*)c;
	return (int)(o->m_dna_nr);
}

//attribute: int btChunk->m_length
void btChunk_m_length_set(void *c,int a) {
	::btChunk *o = (::btChunk*)c;
	o->m_length = a;
}
int btChunk_m_length_get(void *c) {
	::btChunk *o = (::btChunk*)c;
	return (int)(o->m_length);
}

//attribute: int btChunk->m_number
void btChunk_m_number_set(void *c,int a) {
	::btChunk *o = (::btChunk*)c;
	o->m_number = a;
}
int btChunk_m_number_get(void *c) {
	::btChunk *o = (::btChunk*)c;
	return (int)(o->m_number);
}

//attribute: void * btChunk->m_oldPtr
void btChunk_m_oldPtr_set(void *c,void* a) {
	::btChunk *o = (::btChunk*)c;
	void * ta = (void *)a;
	o->m_oldPtr = ta;
}
void* btChunk_m_oldPtr_get(void *c) {
	::btChunk *o = (::btChunk*)c;
	return (void*)(o->m_oldPtr);
}


// ::btClock
//constructor: btClock  ( ::btClock::* )(  ) 
void* btClock_new() {
	::btClock *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btClock),16);
	o = new (mem)::btClock();
	return (void*)o;
}
void btClock_free(void *c) {
	::btClock *o = (::btClock*)c;
	delete o;
}
//method: reset void ( ::btClock::* )(  ) 
void btClock_reset(void *c) {
	::btClock *o = (::btClock*)c;
	o->reset();
}
//method: getTimeMilliseconds long unsigned int ( ::btClock::* )(  ) 
long unsigned int btClock_getTimeMilliseconds(void *c) {
	::btClock *o = (::btClock*)c;
	long unsigned int retVal = (long unsigned int)o->getTimeMilliseconds();
	return retVal;
}
//method: getTimeMicroseconds long unsigned int ( ::btClock::* )(  ) 
long unsigned int btClock_getTimeMicroseconds(void *c) {
	::btClock *o = (::btClock*)c;
	long unsigned int retVal = (long unsigned int)o->getTimeMicroseconds();
	return retVal;
}
//attribute: ::btClockData * btClock->m_data
// attribute not supported: //attribute: ::btClockData * btClock->m_data

// ::btConvexSeparatingDistanceUtil
//constructor: btConvexSeparatingDistanceUtil  ( ::btConvexSeparatingDistanceUtil::* )( ::btScalar,::btScalar ) 
void* btConvexSeparatingDistanceUtil_new(float p0,float p1) {
	::btConvexSeparatingDistanceUtil *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btConvexSeparatingDistanceUtil),16);
	o = new (mem)::btConvexSeparatingDistanceUtil(p0,p1);
	return (void*)o;
}
void btConvexSeparatingDistanceUtil_free(void *c) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	delete o;
}
//method: updateSeparatingDistance void ( ::btConvexSeparatingDistanceUtil::* )( ::btTransform const &,::btTransform const & ) 
void btConvexSeparatingDistanceUtil_updateSeparatingDistance(void *c,float* p0,float* p1) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->updateSeparatingDistance(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: getConservativeSeparatingDistance ::btScalar ( ::btConvexSeparatingDistanceUtil::* )(  ) 
float btConvexSeparatingDistanceUtil_getConservativeSeparatingDistance(void *c) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	float retVal = (float)o->getConservativeSeparatingDistance();
	return retVal;
}
//method: initSeparatingDistance void ( ::btConvexSeparatingDistanceUtil::* )( ::btVector3 const &,::btScalar,::btTransform const &,::btTransform const & ) 
void btConvexSeparatingDistanceUtil_initSeparatingDistance(void *c,float* p0,float p1,float* p2,float* p3) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	o->initSeparatingDistance(tp0,p1,tp2,tp3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
}
//attribute: ::btQuaternion btConvexSeparatingDistanceUtil->m_ornA
void btConvexSeparatingDistanceUtil_m_ornA_set(void *c,float* a) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	btQuaternion ta(a[0],a[1],a[2],a[3]);
	o->m_ornA = ta;
}
void btConvexSeparatingDistanceUtil_m_ornA_get(void *c,float* a) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	a[0]=(o->m_ornA).getX();a[1]=(o->m_ornA).getY();a[2]=(o->m_ornA).getZ();a[3]=(o->m_ornA).getW();
}

//attribute: ::btQuaternion btConvexSeparatingDistanceUtil->m_ornB
void btConvexSeparatingDistanceUtil_m_ornB_set(void *c,float* a) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	btQuaternion ta(a[0],a[1],a[2],a[3]);
	o->m_ornB = ta;
}
void btConvexSeparatingDistanceUtil_m_ornB_get(void *c,float* a) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	a[0]=(o->m_ornB).getX();a[1]=(o->m_ornB).getY();a[2]=(o->m_ornB).getZ();a[3]=(o->m_ornB).getW();
}

//attribute: ::btVector3 btConvexSeparatingDistanceUtil->m_posA
void btConvexSeparatingDistanceUtil_m_posA_set(void *c,float* a) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_posA = ta;
}
void btConvexSeparatingDistanceUtil_m_posA_get(void *c,float* a) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	a[0]=(o->m_posA).m_floats[0];a[1]=(o->m_posA).m_floats[1];a[2]=(o->m_posA).m_floats[2];
}

//attribute: ::btVector3 btConvexSeparatingDistanceUtil->m_posB
void btConvexSeparatingDistanceUtil_m_posB_set(void *c,float* a) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_posB = ta;
}
void btConvexSeparatingDistanceUtil_m_posB_get(void *c,float* a) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	a[0]=(o->m_posB).m_floats[0];a[1]=(o->m_posB).m_floats[1];a[2]=(o->m_posB).m_floats[2];
}

//attribute: ::btVector3 btConvexSeparatingDistanceUtil->m_separatingNormal
void btConvexSeparatingDistanceUtil_m_separatingNormal_set(void *c,float* a) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_separatingNormal = ta;
}
void btConvexSeparatingDistanceUtil_m_separatingNormal_get(void *c,float* a) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	a[0]=(o->m_separatingNormal).m_floats[0];a[1]=(o->m_separatingNormal).m_floats[1];a[2]=(o->m_separatingNormal).m_floats[2];
}

//attribute: ::btScalar btConvexSeparatingDistanceUtil->m_boundingRadiusA
void btConvexSeparatingDistanceUtil_m_boundingRadiusA_set(void *c,float a) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	o->m_boundingRadiusA = a;
}
float btConvexSeparatingDistanceUtil_m_boundingRadiusA_get(void *c) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	return (float)(o->m_boundingRadiusA);
}

//attribute: ::btScalar btConvexSeparatingDistanceUtil->m_boundingRadiusB
void btConvexSeparatingDistanceUtil_m_boundingRadiusB_set(void *c,float a) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	o->m_boundingRadiusB = a;
}
float btConvexSeparatingDistanceUtil_m_boundingRadiusB_get(void *c) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	return (float)(o->m_boundingRadiusB);
}

//attribute: ::btScalar btConvexSeparatingDistanceUtil->m_separatingDistance
void btConvexSeparatingDistanceUtil_m_separatingDistance_set(void *c,float a) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	o->m_separatingDistance = a;
}
float btConvexSeparatingDistanceUtil_m_separatingDistance_get(void *c) {
	::btConvexSeparatingDistanceUtil *o = (::btConvexSeparatingDistanceUtil*)c;
	return (float)(o->m_separatingDistance);
}


// ::btDefaultMotionState
//constructor: btDefaultMotionState  ( ::btDefaultMotionState::* )( ::btTransform const &,::btTransform const & ) 
void* btDefaultMotionState_new(float* p0,float* p1) {
	::btDefaultMotionState *o = 0;
	 void *mem = 0;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	mem = btAlignedAlloc(sizeof(::btDefaultMotionState),16);
	o = new (mem)::btDefaultMotionState(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	return (void*)o;
}
void btDefaultMotionState_free(void *c) {
	::btDefaultMotionState *o = (::btDefaultMotionState*)c;
	delete o;
}
//method: setWorldTransform void ( ::btDefaultMotionState::* )( ::btTransform const & ) 
void btDefaultMotionState_setWorldTransform(void *c,float* p0) {
	::btDefaultMotionState *o = (::btDefaultMotionState*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	o->setWorldTransform(tp0);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//method: getWorldTransform void ( ::btDefaultMotionState::* )( ::btTransform & ) const
void btDefaultMotionState_getWorldTransform(void *c,float* p0) {
	::btDefaultMotionState *o = (::btDefaultMotionState*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	o->getWorldTransform(tp0);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//attribute: ::btTransform btDefaultMotionState->m_graphicsWorldTrans
void btDefaultMotionState_m_graphicsWorldTrans_set(void *c,float* a) {
	::btDefaultMotionState *o = (::btDefaultMotionState*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_graphicsWorldTrans = ta;
}
void btDefaultMotionState_m_graphicsWorldTrans_get(void *c,float* a) {
	::btDefaultMotionState *o = (::btDefaultMotionState*)c;
	a[0]=(o->m_graphicsWorldTrans).getBasis().getRow(0).m_floats[0];a[1]=(o->m_graphicsWorldTrans).getBasis().getRow(0).m_floats[1];a[2]=(o->m_graphicsWorldTrans).getBasis().getRow(0).m_floats[2];a[3]=(o->m_graphicsWorldTrans).getBasis().getRow(1).m_floats[0];a[4]=(o->m_graphicsWorldTrans).getBasis().getRow(1).m_floats[1];a[5]=(o->m_graphicsWorldTrans).getBasis().getRow(1).m_floats[2];a[6]=(o->m_graphicsWorldTrans).getBasis().getRow(2).m_floats[0];a[7]=(o->m_graphicsWorldTrans).getBasis().getRow(2).m_floats[1];a[8]=(o->m_graphicsWorldTrans).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_graphicsWorldTrans).getOrigin().m_floats[0];a[10]=(o->m_graphicsWorldTrans).getOrigin().m_floats[1];a[11]=(o->m_graphicsWorldTrans).getOrigin().m_floats[2];
}

//attribute: ::btTransform btDefaultMotionState->m_centerOfMassOffset
void btDefaultMotionState_m_centerOfMassOffset_set(void *c,float* a) {
	::btDefaultMotionState *o = (::btDefaultMotionState*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_centerOfMassOffset = ta;
}
void btDefaultMotionState_m_centerOfMassOffset_get(void *c,float* a) {
	::btDefaultMotionState *o = (::btDefaultMotionState*)c;
	a[0]=(o->m_centerOfMassOffset).getBasis().getRow(0).m_floats[0];a[1]=(o->m_centerOfMassOffset).getBasis().getRow(0).m_floats[1];a[2]=(o->m_centerOfMassOffset).getBasis().getRow(0).m_floats[2];a[3]=(o->m_centerOfMassOffset).getBasis().getRow(1).m_floats[0];a[4]=(o->m_centerOfMassOffset).getBasis().getRow(1).m_floats[1];a[5]=(o->m_centerOfMassOffset).getBasis().getRow(1).m_floats[2];a[6]=(o->m_centerOfMassOffset).getBasis().getRow(2).m_floats[0];a[7]=(o->m_centerOfMassOffset).getBasis().getRow(2).m_floats[1];a[8]=(o->m_centerOfMassOffset).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_centerOfMassOffset).getOrigin().m_floats[0];a[10]=(o->m_centerOfMassOffset).getOrigin().m_floats[1];a[11]=(o->m_centerOfMassOffset).getOrigin().m_floats[2];
}

//attribute: ::btTransform btDefaultMotionState->m_startWorldTrans
void btDefaultMotionState_m_startWorldTrans_set(void *c,float* a) {
	::btDefaultMotionState *o = (::btDefaultMotionState*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_startWorldTrans = ta;
}
void btDefaultMotionState_m_startWorldTrans_get(void *c,float* a) {
	::btDefaultMotionState *o = (::btDefaultMotionState*)c;
	a[0]=(o->m_startWorldTrans).getBasis().getRow(0).m_floats[0];a[1]=(o->m_startWorldTrans).getBasis().getRow(0).m_floats[1];a[2]=(o->m_startWorldTrans).getBasis().getRow(0).m_floats[2];a[3]=(o->m_startWorldTrans).getBasis().getRow(1).m_floats[0];a[4]=(o->m_startWorldTrans).getBasis().getRow(1).m_floats[1];a[5]=(o->m_startWorldTrans).getBasis().getRow(1).m_floats[2];a[6]=(o->m_startWorldTrans).getBasis().getRow(2).m_floats[0];a[7]=(o->m_startWorldTrans).getBasis().getRow(2).m_floats[1];a[8]=(o->m_startWorldTrans).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_startWorldTrans).getOrigin().m_floats[0];a[10]=(o->m_startWorldTrans).getOrigin().m_floats[1];a[11]=(o->m_startWorldTrans).getOrigin().m_floats[2];
}

//attribute: void * btDefaultMotionState->m_userPointer
void btDefaultMotionState_m_userPointer_set(void *c,void* a) {
	::btDefaultMotionState *o = (::btDefaultMotionState*)c;
	void * ta = (void *)a;
	o->m_userPointer = ta;
}
void* btDefaultMotionState_m_userPointer_get(void *c) {
	::btDefaultMotionState *o = (::btDefaultMotionState*)c;
	return (void*)(o->m_userPointer);
}


// ::btDefaultSerializer
//constructor: btDefaultSerializer  ( ::btDefaultSerializer::* )( int ) 
void* btDefaultSerializer_new(int p0) {
	::btDefaultSerializer *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btDefaultSerializer),16);
	o = new (mem)::btDefaultSerializer(p0);
	return (void*)o;
}
void btDefaultSerializer_free(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	delete o;
}
//method: finishSerialization void ( ::btDefaultSerializer::* )(  ) 
void btDefaultSerializer_finishSerialization(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	o->finishSerialization();
}
//not supported method: internalAlloc unsigned char * ( ::btDefaultSerializer::* )( ::size_t ) 
// error:  - unsupported,  - unsupported

//not supported method: findNameForPointer char const * ( ::btDefaultSerializer::* )( void const * ) const
// error:  - unsupported, char const * - ok

//not supported method: writeHeader void ( ::btDefaultSerializer::* )( unsigned char * ) const
// error:  - unsupported, void - ok

//method: startSerialization void ( ::btDefaultSerializer::* )(  ) 
void btDefaultSerializer_startSerialization(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	o->startSerialization();
}
//method: getSerializationFlags int ( ::btDefaultSerializer::* )(  ) const
int btDefaultSerializer_getSerializationFlags(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	int retVal = (int)o->getSerializationFlags();
	return retVal;
}
//method: setSerializationFlags void ( ::btDefaultSerializer::* )( int ) 
void btDefaultSerializer_setSerializationFlags(void *c,int p0) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	o->setSerializationFlags(p0);
}
//method: getReverseType int ( ::btDefaultSerializer::* )( char const * ) const
int btDefaultSerializer_getReverseType(void *c,char const * p0) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	int retVal = (int)o->getReverseType(p0);
	return retVal;
}
//method: finalizeChunk void ( ::btDefaultSerializer::* )( ::btChunk *,char const *,int,void * ) 
void btDefaultSerializer_finalizeChunk(void *c,void* p0,char const * p1,int p2,void* p3) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	::btChunk * tp0 = (::btChunk *)p0;
	void * tp3 = (void *)p3;
	o->finalizeChunk(tp0,p1,p2,tp3);
}
//method: initDNA void ( ::btDefaultSerializer::* )( char const *,int ) 
void btDefaultSerializer_initDNA(void *c,char const * p0,int p1) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	o->initDNA(p0,p1);
}
//method: writeDNA void ( ::btDefaultSerializer::* )(  ) 
void btDefaultSerializer_writeDNA(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	o->writeDNA();
}
//not supported method: getBufferPointer unsigned char const * ( ::btDefaultSerializer::* )(  ) const
// error:  - unsupported

//method: getCurrentBufferSize int ( ::btDefaultSerializer::* )(  ) const
int btDefaultSerializer_getCurrentBufferSize(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	int retVal = (int)o->getCurrentBufferSize();
	return retVal;
}
//method: getUniquePointer void * ( ::btDefaultSerializer::* )( void * ) 
void* btDefaultSerializer_getUniquePointer(void *c,void* p0) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	void * tp0 = (void *)p0;
	void* retVal = (void*) o->getUniquePointer(tp0);
	return retVal;
}
//method: serializeName void ( ::btDefaultSerializer::* )( char const * ) 
void btDefaultSerializer_serializeName(void *c,char const * p0) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	o->serializeName(p0);
}
//method: findPointer void * ( ::btDefaultSerializer::* )( void * ) 
void* btDefaultSerializer_findPointer(void *c,void* p0) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	void * tp0 = (void *)p0;
	void* retVal = (void*) o->findPointer(tp0);
	return retVal;
}
//not supported method: registerNameForPointer void ( ::btDefaultSerializer::* )( void const *,char const * ) 
// error:  - unsupported, char const * - ok, void - ok

//not supported method: allocate ::btChunk * ( ::btDefaultSerializer::* )( ::size_t,int ) 
// error:  - unsupported, int - ok, ::btChunk * - ok

//attribute: ::btAlignedObjectArray<char*> btDefaultSerializer->mTypes
void btDefaultSerializer_mTypes_set(void *c,void* a) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	::btAlignedObjectArray<char*> & ta = *(::btAlignedObjectArray<char*> *)a;
	o->mTypes = ta;
}
void* btDefaultSerializer_mTypes_get(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	return (void*)&(o->mTypes);
}

//attribute: ::btAlignedObjectArray<short*> btDefaultSerializer->mStructs
void btDefaultSerializer_mStructs_set(void *c,void* a) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	::btAlignedObjectArray<short*> & ta = *(::btAlignedObjectArray<short*> *)a;
	o->mStructs = ta;
}
void* btDefaultSerializer_mStructs_get(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	return (void*)&(o->mStructs);
}

//attribute: ::btAlignedObjectArray<short> btDefaultSerializer->mTlens
void btDefaultSerializer_mTlens_set(void *c,void* a) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	::btAlignedObjectArray<short> & ta = *(::btAlignedObjectArray<short> *)a;
	o->mTlens = ta;
}
void* btDefaultSerializer_mTlens_get(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	return (void*)&(o->mTlens);
}

//attribute: ::btHashMap<btHashInt, int> btDefaultSerializer->mStructReverse
void btDefaultSerializer_mStructReverse_set(void *c,void* a) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	::btHashMap<btHashInt, int> & ta = *(::btHashMap<btHashInt, int> *)a;
	o->mStructReverse = ta;
}
void* btDefaultSerializer_mStructReverse_get(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	return (void*)&(o->mStructReverse);
}

//attribute: ::btHashMap<btHashString, int> btDefaultSerializer->mTypeLookup
void btDefaultSerializer_mTypeLookup_set(void *c,void* a) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	::btHashMap<btHashString, int> & ta = *(::btHashMap<btHashString, int> *)a;
	o->mTypeLookup = ta;
}
void* btDefaultSerializer_mTypeLookup_get(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	return (void*)&(o->mTypeLookup);
}

//attribute: ::btHashMap<btHashPtr, void*> btDefaultSerializer->m_chunkP
void btDefaultSerializer_m_chunkP_set(void *c,void* a) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	::btHashMap<btHashPtr, void*> & ta = *(::btHashMap<btHashPtr, void*> *)a;
	o->m_chunkP = ta;
}
void* btDefaultSerializer_m_chunkP_get(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	return (void*)&(o->m_chunkP);
}

//attribute: ::btHashMap<btHashPtr, char const*> btDefaultSerializer->m_nameMap
void btDefaultSerializer_m_nameMap_set(void *c,void* a) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	::btHashMap<btHashPtr, char const*> & ta = *(::btHashMap<btHashPtr, char const*> *)a;
	o->m_nameMap = ta;
}
void* btDefaultSerializer_m_nameMap_get(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	return (void*)&(o->m_nameMap);
}

//attribute: ::btHashMap<btHashPtr, btPointerUid> btDefaultSerializer->m_uniquePointers
void btDefaultSerializer_m_uniquePointers_set(void *c,void* a) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	::btHashMap<btHashPtr, btPointerUid> & ta = *(::btHashMap<btHashPtr, btPointerUid> *)a;
	o->m_uniquePointers = ta;
}
void* btDefaultSerializer_m_uniquePointers_get(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	return (void*)&(o->m_uniquePointers);
}

//attribute: int btDefaultSerializer->m_uniqueIdGenerator
void btDefaultSerializer_m_uniqueIdGenerator_set(void *c,int a) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	o->m_uniqueIdGenerator = a;
}
int btDefaultSerializer_m_uniqueIdGenerator_get(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	return (int)(o->m_uniqueIdGenerator);
}

//attribute: int btDefaultSerializer->m_totalSize
void btDefaultSerializer_m_totalSize_set(void *c,int a) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	o->m_totalSize = a;
}
int btDefaultSerializer_m_totalSize_get(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	return (int)(o->m_totalSize);
}

//attribute: unsigned char * btDefaultSerializer->m_buffer
// attribute not supported: //attribute: unsigned char * btDefaultSerializer->m_buffer
//attribute: int btDefaultSerializer->m_currentSize
void btDefaultSerializer_m_currentSize_set(void *c,int a) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	o->m_currentSize = a;
}
int btDefaultSerializer_m_currentSize_get(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	return (int)(o->m_currentSize);
}

//attribute: void * btDefaultSerializer->m_dna
void btDefaultSerializer_m_dna_set(void *c,void* a) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	void * ta = (void *)a;
	o->m_dna = ta;
}
void* btDefaultSerializer_m_dna_get(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	return (void*)(o->m_dna);
}

//attribute: int btDefaultSerializer->m_dnaLength
void btDefaultSerializer_m_dnaLength_set(void *c,int a) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	o->m_dnaLength = a;
}
int btDefaultSerializer_m_dnaLength_get(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	return (int)(o->m_dnaLength);
}

//attribute: int btDefaultSerializer->m_serializationFlags
void btDefaultSerializer_m_serializationFlags_set(void *c,int a) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	o->m_serializationFlags = a;
}
int btDefaultSerializer_m_serializationFlags_get(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	return (int)(o->m_serializationFlags);
}

//attribute: ::btAlignedObjectArray<btChunk*> btDefaultSerializer->m_chunkPtrs
void btDefaultSerializer_m_chunkPtrs_set(void *c,void* a) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	::btAlignedObjectArray<btChunk*> & ta = *(::btAlignedObjectArray<btChunk*> *)a;
	o->m_chunkPtrs = ta;
}
void* btDefaultSerializer_m_chunkPtrs_get(void *c) {
	::btDefaultSerializer *o = (::btDefaultSerializer*)c;
	return (void*)&(o->m_chunkPtrs);
}


// ::btGeometryUtil
//constructor: btGeometryUtil  ( ::btGeometryUtil::* )(  ) 
void* btGeometryUtil_new() {
	::btGeometryUtil *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGeometryUtil),16);
	o = new (mem)::btGeometryUtil();
	return (void*)o;
}
void btGeometryUtil_free(void *c) {
	::btGeometryUtil *o = (::btGeometryUtil*)c;
	delete o;
}
//method: isPointInsidePlanes bool (*)( ::btAlignedObjectArray<btVector3> const &,::btVector3 const &,::btScalar )
int btGeometryUtil_isPointInsidePlanes(void* p0,float* p1,float p2) {
	::btAlignedObjectArray<btVector3> const & tp0 = *(::btAlignedObjectArray<btVector3> const *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	int retVal = (int)::btGeometryUtil::isPointInsidePlanes(tp0,tp1,p2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//method: getVerticesFromPlaneEquations void (*)( ::btAlignedObjectArray<btVector3> const &,::btAlignedObjectArray<btVector3> & )
void btGeometryUtil_getVerticesFromPlaneEquations(void* p0,void* p1) {
	::btAlignedObjectArray<btVector3> const & tp0 = *(::btAlignedObjectArray<btVector3> const *)p0;
	::btAlignedObjectArray<btVector3> & tp1 = *(::btAlignedObjectArray<btVector3> *)p1;
	::btGeometryUtil::getVerticesFromPlaneEquations(tp0,tp1);
}
//method: areVerticesBehindPlane bool (*)( ::btVector3 const &,::btAlignedObjectArray<btVector3> const &,::btScalar )
int btGeometryUtil_areVerticesBehindPlane(float* p0,void* p1,float p2) {
	btVector3 tp0(p0[0],p0[1],p0[2]);
	::btAlignedObjectArray<btVector3> const & tp1 = *(::btAlignedObjectArray<btVector3> const *)p1;
	int retVal = (int)::btGeometryUtil::areVerticesBehindPlane(tp0,tp1,p2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return retVal;
}
//method: getPlaneEquationsFromVertices void (*)( ::btAlignedObjectArray<btVector3> &,::btAlignedObjectArray<btVector3> & )
void btGeometryUtil_getPlaneEquationsFromVertices(void* p0,void* p1) {
	::btAlignedObjectArray<btVector3> & tp0 = *(::btAlignedObjectArray<btVector3> *)p0;
	::btAlignedObjectArray<btVector3> & tp1 = *(::btAlignedObjectArray<btVector3> *)p1;
	::btGeometryUtil::getPlaneEquationsFromVertices(tp0,tp1);
}

// ::btHashInt
//constructor: btHashInt  ( ::btHashInt::* )( int ) 
void* btHashInt_new(int p0) {
	::btHashInt *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btHashInt),16);
	o = new (mem)::btHashInt(p0);
	return (void*)o;
}
void btHashInt_free(void *c) {
	::btHashInt *o = (::btHashInt*)c;
	delete o;
}
//method: getUid1 int ( ::btHashInt::* )(  ) const
int btHashInt_getUid1(void *c) {
	::btHashInt *o = (::btHashInt*)c;
	int retVal = (int)o->getUid1();
	return retVal;
}
//method: getHash unsigned int ( ::btHashInt::* )(  ) const
unsigned int btHashInt_getHash(void *c) {
	::btHashInt *o = (::btHashInt*)c;
	unsigned int retVal = (unsigned int)o->getHash();
	return retVal;
}
//method: setUid1 void ( ::btHashInt::* )( int ) 
void btHashInt_setUid1(void *c,int p0) {
	::btHashInt *o = (::btHashInt*)c;
	o->setUid1(p0);
}
//method: equals bool ( ::btHashInt::* )( ::btHashInt const & ) const
int btHashInt_equals(void *c,void* p0) {
	::btHashInt *o = (::btHashInt*)c;
	::btHashInt const & tp0 = *(::btHashInt const *)p0;
	int retVal = (int)o->equals(tp0);
	return retVal;
}
//attribute: int btHashInt->m_uid
void btHashInt_m_uid_set(void *c,int a) {
	::btHashInt *o = (::btHashInt*)c;
	o->m_uid = a;
}
int btHashInt_m_uid_get(void *c) {
	::btHashInt *o = (::btHashInt*)c;
	return (int)(o->m_uid);
}


// ::btHashMap< btHashInt, btTriangleInfo >
//constructor: btHashMap  ( ::btHashMap<btHashInt, btTriangleInfo>::* )(  ) 
void* btHashMap_btHashInt_btTriangleInfo__new() {
	::btHashMap< btHashInt, btTriangleInfo > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btHashMap< btHashInt, btTriangleInfo >),16);
	o = new (mem)::btHashMap< btHashInt, btTriangleInfo >();
	return (void*)o;
}
void btHashMap_btHashInt_btTriangleInfo__free(void *c) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	delete o;
}
//method: insert void ( ::btHashMap<btHashInt, btTriangleInfo>::* )( ::btHashInt const &,::btTriangleInfo const & ) 
void btHashMap_btHashInt_btTriangleInfo__insert(void *c,void* p0,void* p1) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	::btHashInt const & tp0 = *(::btHashInt const *)p0;
	::btTriangleInfo const & tp1 = *(::btTriangleInfo const *)p1;
	o->insert(tp0,tp1);
}
//method: findIndex int ( ::btHashMap<btHashInt, btTriangleInfo>::* )( ::btHashInt const & ) const
int btHashMap_btHashInt_btTriangleInfo__findIndex(void *c,void* p0) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	::btHashInt const & tp0 = *(::btHashInt const *)p0;
	int retVal = (int)o->findIndex(tp0);
	return retVal;
}
//method: clear void ( ::btHashMap<btHashInt, btTriangleInfo>::* )(  ) 
void btHashMap_btHashInt_btTriangleInfo__clear(void *c) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	o->clear();
}
//method: getAtIndex ::btTriangleInfo const * ( ::btHashMap<btHashInt, btTriangleInfo>::* )( int ) const
void* btHashMap_btHashInt_btTriangleInfo__getAtIndex(void *c,int p0) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	void* retVal = (void*) o->getAtIndex(p0);
	return retVal;
}
//method: getAtIndex ::btTriangleInfo const * ( ::btHashMap<btHashInt, btTriangleInfo>::* )( int ) const
void* btHashMap_btHashInt_btTriangleInfo__getAtIndex0(void *c,int p0) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	void* retVal = (void*) o->getAtIndex(p0);
	return retVal;
}
//method: getAtIndex ::btTriangleInfo * ( ::btHashMap<btHashInt, btTriangleInfo>::* )( int ) 
void* btHashMap_btHashInt_btTriangleInfo__getAtIndex1(void *c,int p0) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	void* retVal = (void*) o->getAtIndex(p0);
	return retVal;
}
//method: growTables void ( ::btHashMap<btHashInt, btTriangleInfo>::* )( ::btHashInt const & ) 
void btHashMap_btHashInt_btTriangleInfo__growTables(void *c,void* p0) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	::btHashInt const & tp0 = *(::btHashInt const *)p0;
	o->growTables(tp0);
}
//method: find ::btTriangleInfo const * ( ::btHashMap<btHashInt, btTriangleInfo>::* )( ::btHashInt const & ) const
void* btHashMap_btHashInt_btTriangleInfo__find(void *c,void* p0) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	::btHashInt const & tp0 = *(::btHashInt const *)p0;
	void* retVal = (void*) o->find(tp0);
	return retVal;
}
//method: find ::btTriangleInfo const * ( ::btHashMap<btHashInt, btTriangleInfo>::* )( ::btHashInt const & ) const
void* btHashMap_btHashInt_btTriangleInfo__find0(void *c,void* p0) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	::btHashInt const & tp0 = *(::btHashInt const *)p0;
	void* retVal = (void*) o->find(tp0);
	return retVal;
}
//method: find ::btTriangleInfo * ( ::btHashMap<btHashInt, btTriangleInfo>::* )( ::btHashInt const & ) 
void* btHashMap_btHashInt_btTriangleInfo__find1(void *c,void* p0) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	::btHashInt const & tp0 = *(::btHashInt const *)p0;
	void* retVal = (void*) o->find(tp0);
	return retVal;
}
//method: size int ( ::btHashMap<btHashInt, btTriangleInfo>::* )(  ) const
int btHashMap_btHashInt_btTriangleInfo__size(void *c) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//attribute: ::btAlignedObjectArray<int> btHashMap_btHashInt_btTriangleInfo_->m_hashTable
void btHashMap_btHashInt_btTriangleInfo__m_hashTable_set(void *c,void* a) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_hashTable = ta;
}
void* btHashMap_btHashInt_btTriangleInfo__m_hashTable_get(void *c) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	return (void*)&(o->m_hashTable);
}

//attribute: ::btAlignedObjectArray<int> btHashMap_btHashInt_btTriangleInfo_->m_next
void btHashMap_btHashInt_btTriangleInfo__m_next_set(void *c,void* a) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_next = ta;
}
void* btHashMap_btHashInt_btTriangleInfo__m_next_get(void *c) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	return (void*)&(o->m_next);
}

//attribute: ::btAlignedObjectArray<btTriangleInfo> btHashMap_btHashInt_btTriangleInfo_->m_valueArray
void btHashMap_btHashInt_btTriangleInfo__m_valueArray_set(void *c,void* a) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	::btAlignedObjectArray<btTriangleInfo> & ta = *(::btAlignedObjectArray<btTriangleInfo> *)a;
	o->m_valueArray = ta;
}
void* btHashMap_btHashInt_btTriangleInfo__m_valueArray_get(void *c) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	return (void*)&(o->m_valueArray);
}

//attribute: ::btAlignedObjectArray<btHashInt> btHashMap_btHashInt_btTriangleInfo_->m_keyArray
void btHashMap_btHashInt_btTriangleInfo__m_keyArray_set(void *c,void* a) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	::btAlignedObjectArray<btHashInt> & ta = *(::btAlignedObjectArray<btHashInt> *)a;
	o->m_keyArray = ta;
}
void* btHashMap_btHashInt_btTriangleInfo__m_keyArray_get(void *c) {
	::btHashMap< btHashInt, btTriangleInfo > *o = (::btHashMap< btHashInt, btTriangleInfo >*)c;
	return (void*)&(o->m_keyArray);
}


// ::btHashMap< btHashInt, int >
//constructor: btHashMap  ( ::btHashMap<btHashInt, int>::* )(  ) 
void* btHashMap_btHashInt_int__new() {
	::btHashMap< btHashInt, int > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btHashMap< btHashInt, int >),16);
	o = new (mem)::btHashMap< btHashInt, int >();
	return (void*)o;
}
void btHashMap_btHashInt_int__free(void *c) {
	::btHashMap< btHashInt, int > *o = (::btHashMap< btHashInt, int >*)c;
	delete o;
}
//not supported method: insert void ( ::btHashMap<btHashInt, int>::* )( ::btHashInt const &,int const & ) 
// error: ::btHashInt const & - ok,  - unsupported, void - ok

//method: findIndex int ( ::btHashMap<btHashInt, int>::* )( ::btHashInt const & ) const
int btHashMap_btHashInt_int__findIndex(void *c,void* p0) {
	::btHashMap< btHashInt, int > *o = (::btHashMap< btHashInt, int >*)c;
	::btHashInt const & tp0 = *(::btHashInt const *)p0;
	int retVal = (int)o->findIndex(tp0);
	return retVal;
}
//method: clear void ( ::btHashMap<btHashInt, int>::* )(  ) 
void btHashMap_btHashInt_int__clear(void *c) {
	::btHashMap< btHashInt, int > *o = (::btHashMap< btHashInt, int >*)c;
	o->clear();
}
//not supported method: getAtIndex int const * ( ::btHashMap<btHashInt, int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex int const * ( ::btHashMap<btHashInt, int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex int * ( ::btHashMap<btHashInt, int>::* )( int ) 
// error: int - ok,  - unsupported

//method: growTables void ( ::btHashMap<btHashInt, int>::* )( ::btHashInt const & ) 
void btHashMap_btHashInt_int__growTables(void *c,void* p0) {
	::btHashMap< btHashInt, int > *o = (::btHashMap< btHashInt, int >*)c;
	::btHashInt const & tp0 = *(::btHashInt const *)p0;
	o->growTables(tp0);
}
//not supported method: find int const * ( ::btHashMap<btHashInt, int>::* )( ::btHashInt const & ) const
// error: ::btHashInt const & - ok,  - unsupported

//not supported method: find int const * ( ::btHashMap<btHashInt, int>::* )( ::btHashInt const & ) const
// error: ::btHashInt const & - ok,  - unsupported

//not supported method: find int * ( ::btHashMap<btHashInt, int>::* )( ::btHashInt const & ) 
// error: ::btHashInt const & - ok,  - unsupported

//method: size int ( ::btHashMap<btHashInt, int>::* )(  ) const
int btHashMap_btHashInt_int__size(void *c) {
	::btHashMap< btHashInt, int > *o = (::btHashMap< btHashInt, int >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//attribute: ::btAlignedObjectArray<int> btHashMap_btHashInt_int_->m_hashTable
void btHashMap_btHashInt_int__m_hashTable_set(void *c,void* a) {
	::btHashMap< btHashInt, int > *o = (::btHashMap< btHashInt, int >*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_hashTable = ta;
}
void* btHashMap_btHashInt_int__m_hashTable_get(void *c) {
	::btHashMap< btHashInt, int > *o = (::btHashMap< btHashInt, int >*)c;
	return (void*)&(o->m_hashTable);
}

//attribute: ::btAlignedObjectArray<btHashInt> btHashMap_btHashInt_int_->m_keyArray
void btHashMap_btHashInt_int__m_keyArray_set(void *c,void* a) {
	::btHashMap< btHashInt, int > *o = (::btHashMap< btHashInt, int >*)c;
	::btAlignedObjectArray<btHashInt> & ta = *(::btAlignedObjectArray<btHashInt> *)a;
	o->m_keyArray = ta;
}
void* btHashMap_btHashInt_int__m_keyArray_get(void *c) {
	::btHashMap< btHashInt, int > *o = (::btHashMap< btHashInt, int >*)c;
	return (void*)&(o->m_keyArray);
}

//attribute: ::btAlignedObjectArray<int> btHashMap_btHashInt_int_->m_next
void btHashMap_btHashInt_int__m_next_set(void *c,void* a) {
	::btHashMap< btHashInt, int > *o = (::btHashMap< btHashInt, int >*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_next = ta;
}
void* btHashMap_btHashInt_int__m_next_get(void *c) {
	::btHashMap< btHashInt, int > *o = (::btHashMap< btHashInt, int >*)c;
	return (void*)&(o->m_next);
}

//attribute: ::btAlignedObjectArray<int> btHashMap_btHashInt_int_->m_valueArray
void btHashMap_btHashInt_int__m_valueArray_set(void *c,void* a) {
	::btHashMap< btHashInt, int > *o = (::btHashMap< btHashInt, int >*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_valueArray = ta;
}
void* btHashMap_btHashInt_int__m_valueArray_get(void *c) {
	::btHashMap< btHashInt, int > *o = (::btHashMap< btHashInt, int >*)c;
	return (void*)&(o->m_valueArray);
}


// ::btHashMap< btHashPtr, btPointerUid >
//constructor: btHashMap  ( ::btHashMap<btHashPtr, btPointerUid>::* )(  ) 
void* btHashMap_btHashPtr_btPointerUid__new() {
	::btHashMap< btHashPtr, btPointerUid > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btHashMap< btHashPtr, btPointerUid >),16);
	o = new (mem)::btHashMap< btHashPtr, btPointerUid >();
	return (void*)o;
}
void btHashMap_btHashPtr_btPointerUid__free(void *c) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	delete o;
}
//method: insert void ( ::btHashMap<btHashPtr, btPointerUid>::* )( ::btHashPtr const &,::btPointerUid const & ) 
void btHashMap_btHashPtr_btPointerUid__insert(void *c,void* p0,void* p1) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	::btHashPtr const & tp0 = *(::btHashPtr const *)p0;
	::btPointerUid const & tp1 = *(::btPointerUid const *)p1;
	o->insert(tp0,tp1);
}
//method: findIndex int ( ::btHashMap<btHashPtr, btPointerUid>::* )( ::btHashPtr const & ) const
int btHashMap_btHashPtr_btPointerUid__findIndex(void *c,void* p0) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	::btHashPtr const & tp0 = *(::btHashPtr const *)p0;
	int retVal = (int)o->findIndex(tp0);
	return retVal;
}
//method: clear void ( ::btHashMap<btHashPtr, btPointerUid>::* )(  ) 
void btHashMap_btHashPtr_btPointerUid__clear(void *c) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	o->clear();
}
//method: getAtIndex ::btPointerUid const * ( ::btHashMap<btHashPtr, btPointerUid>::* )( int ) const
void* btHashMap_btHashPtr_btPointerUid__getAtIndex(void *c,int p0) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	void* retVal = (void*) o->getAtIndex(p0);
	return retVal;
}
//method: getAtIndex ::btPointerUid const * ( ::btHashMap<btHashPtr, btPointerUid>::* )( int ) const
void* btHashMap_btHashPtr_btPointerUid__getAtIndex0(void *c,int p0) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	void* retVal = (void*) o->getAtIndex(p0);
	return retVal;
}
//method: getAtIndex ::btPointerUid * ( ::btHashMap<btHashPtr, btPointerUid>::* )( int ) 
void* btHashMap_btHashPtr_btPointerUid__getAtIndex1(void *c,int p0) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	void* retVal = (void*) o->getAtIndex(p0);
	return retVal;
}
//method: growTables void ( ::btHashMap<btHashPtr, btPointerUid>::* )( ::btHashPtr const & ) 
void btHashMap_btHashPtr_btPointerUid__growTables(void *c,void* p0) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	::btHashPtr const & tp0 = *(::btHashPtr const *)p0;
	o->growTables(tp0);
}
//method: find ::btPointerUid const * ( ::btHashMap<btHashPtr, btPointerUid>::* )( ::btHashPtr const & ) const
void* btHashMap_btHashPtr_btPointerUid__find(void *c,void* p0) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	::btHashPtr const & tp0 = *(::btHashPtr const *)p0;
	void* retVal = (void*) o->find(tp0);
	return retVal;
}
//method: find ::btPointerUid const * ( ::btHashMap<btHashPtr, btPointerUid>::* )( ::btHashPtr const & ) const
void* btHashMap_btHashPtr_btPointerUid__find0(void *c,void* p0) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	::btHashPtr const & tp0 = *(::btHashPtr const *)p0;
	void* retVal = (void*) o->find(tp0);
	return retVal;
}
//method: find ::btPointerUid * ( ::btHashMap<btHashPtr, btPointerUid>::* )( ::btHashPtr const & ) 
void* btHashMap_btHashPtr_btPointerUid__find1(void *c,void* p0) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	::btHashPtr const & tp0 = *(::btHashPtr const *)p0;
	void* retVal = (void*) o->find(tp0);
	return retVal;
}
//method: size int ( ::btHashMap<btHashPtr, btPointerUid>::* )(  ) const
int btHashMap_btHashPtr_btPointerUid__size(void *c) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_btPointerUid_->m_hashTable
void btHashMap_btHashPtr_btPointerUid__m_hashTable_set(void *c,void* a) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_hashTable = ta;
}
void* btHashMap_btHashPtr_btPointerUid__m_hashTable_get(void *c) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	return (void*)&(o->m_hashTable);
}

//attribute: ::btAlignedObjectArray<btHashPtr> btHashMap_btHashPtr_btPointerUid_->m_keyArray
void btHashMap_btHashPtr_btPointerUid__m_keyArray_set(void *c,void* a) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	::btAlignedObjectArray<btHashPtr> & ta = *(::btAlignedObjectArray<btHashPtr> *)a;
	o->m_keyArray = ta;
}
void* btHashMap_btHashPtr_btPointerUid__m_keyArray_get(void *c) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	return (void*)&(o->m_keyArray);
}

//attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_btPointerUid_->m_next
void btHashMap_btHashPtr_btPointerUid__m_next_set(void *c,void* a) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_next = ta;
}
void* btHashMap_btHashPtr_btPointerUid__m_next_get(void *c) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	return (void*)&(o->m_next);
}

//attribute: ::btAlignedObjectArray<btPointerUid> btHashMap_btHashPtr_btPointerUid_->m_valueArray
void btHashMap_btHashPtr_btPointerUid__m_valueArray_set(void *c,void* a) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	::btAlignedObjectArray<btPointerUid> & ta = *(::btAlignedObjectArray<btPointerUid> *)a;
	o->m_valueArray = ta;
}
void* btHashMap_btHashPtr_btPointerUid__m_valueArray_get(void *c) {
	::btHashMap< btHashPtr, btPointerUid > *o = (::btHashMap< btHashPtr, btPointerUid >*)c;
	return (void*)&(o->m_valueArray);
}


// ::btHashMap< btHashPtr, char const* >
//constructor: btHashMap  ( ::btHashMap<btHashPtr, char const*>::* )(  ) 
void* btHashMap_btHashPtr_charconst_ptr__new() {
	::btHashMap< btHashPtr, char const* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btHashMap< btHashPtr, char const* >),16);
	o = new (mem)::btHashMap< btHashPtr, char const* >();
	return (void*)o;
}
void btHashMap_btHashPtr_charconst_ptr__free(void *c) {
	::btHashMap< btHashPtr, char const* > *o = (::btHashMap< btHashPtr, char const* >*)c;
	delete o;
}
//not supported method: insert void ( ::btHashMap<btHashPtr, char const*>::* )( ::btHashPtr const &,char const * const & ) 
// error: ::btHashPtr const & - ok,  - unsupported, void - ok

//method: findIndex int ( ::btHashMap<btHashPtr, char const*>::* )( ::btHashPtr const & ) const
int btHashMap_btHashPtr_charconst_ptr__findIndex(void *c,void* p0) {
	::btHashMap< btHashPtr, char const* > *o = (::btHashMap< btHashPtr, char const* >*)c;
	::btHashPtr const & tp0 = *(::btHashPtr const *)p0;
	int retVal = (int)o->findIndex(tp0);
	return retVal;
}
//method: clear void ( ::btHashMap<btHashPtr, char const*>::* )(  ) 
void btHashMap_btHashPtr_charconst_ptr__clear(void *c) {
	::btHashMap< btHashPtr, char const* > *o = (::btHashMap< btHashPtr, char const* >*)c;
	o->clear();
}
//not supported method: getAtIndex char const * const * ( ::btHashMap<btHashPtr, char const*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex char const * const * ( ::btHashMap<btHashPtr, char const*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex char const * * ( ::btHashMap<btHashPtr, char const*>::* )( int ) 
// error: int - ok,  - unsupported

//method: growTables void ( ::btHashMap<btHashPtr, char const*>::* )( ::btHashPtr const & ) 
void btHashMap_btHashPtr_charconst_ptr__growTables(void *c,void* p0) {
	::btHashMap< btHashPtr, char const* > *o = (::btHashMap< btHashPtr, char const* >*)c;
	::btHashPtr const & tp0 = *(::btHashPtr const *)p0;
	o->growTables(tp0);
}
//not supported method: find char const * const * ( ::btHashMap<btHashPtr, char const*>::* )( ::btHashPtr const & ) const
// error: ::btHashPtr const & - ok,  - unsupported

//not supported method: find char const * const * ( ::btHashMap<btHashPtr, char const*>::* )( ::btHashPtr const & ) const
// error: ::btHashPtr const & - ok,  - unsupported

//not supported method: find char const * * ( ::btHashMap<btHashPtr, char const*>::* )( ::btHashPtr const & ) 
// error: ::btHashPtr const & - ok,  - unsupported

//method: size int ( ::btHashMap<btHashPtr, char const*>::* )(  ) const
int btHashMap_btHashPtr_charconst_ptr__size(void *c) {
	::btHashMap< btHashPtr, char const* > *o = (::btHashMap< btHashPtr, char const* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_charconst_ptr_->m_hashTable
void btHashMap_btHashPtr_charconst_ptr__m_hashTable_set(void *c,void* a) {
	::btHashMap< btHashPtr, char const* > *o = (::btHashMap< btHashPtr, char const* >*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_hashTable = ta;
}
void* btHashMap_btHashPtr_charconst_ptr__m_hashTable_get(void *c) {
	::btHashMap< btHashPtr, char const* > *o = (::btHashMap< btHashPtr, char const* >*)c;
	return (void*)&(o->m_hashTable);
}

//attribute: ::btAlignedObjectArray<btHashPtr> btHashMap_btHashPtr_charconst_ptr_->m_keyArray
void btHashMap_btHashPtr_charconst_ptr__m_keyArray_set(void *c,void* a) {
	::btHashMap< btHashPtr, char const* > *o = (::btHashMap< btHashPtr, char const* >*)c;
	::btAlignedObjectArray<btHashPtr> & ta = *(::btAlignedObjectArray<btHashPtr> *)a;
	o->m_keyArray = ta;
}
void* btHashMap_btHashPtr_charconst_ptr__m_keyArray_get(void *c) {
	::btHashMap< btHashPtr, char const* > *o = (::btHashMap< btHashPtr, char const* >*)c;
	return (void*)&(o->m_keyArray);
}

//attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_charconst_ptr_->m_next
void btHashMap_btHashPtr_charconst_ptr__m_next_set(void *c,void* a) {
	::btHashMap< btHashPtr, char const* > *o = (::btHashMap< btHashPtr, char const* >*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_next = ta;
}
void* btHashMap_btHashPtr_charconst_ptr__m_next_get(void *c) {
	::btHashMap< btHashPtr, char const* > *o = (::btHashMap< btHashPtr, char const* >*)c;
	return (void*)&(o->m_next);
}

//attribute: ::btAlignedObjectArray<char const*> btHashMap_btHashPtr_charconst_ptr_->m_valueArray
void btHashMap_btHashPtr_charconst_ptr__m_valueArray_set(void *c,void* a) {
	::btHashMap< btHashPtr, char const* > *o = (::btHashMap< btHashPtr, char const* >*)c;
	::btAlignedObjectArray<char const*> & ta = *(::btAlignedObjectArray<char const*> *)a;
	o->m_valueArray = ta;
}
void* btHashMap_btHashPtr_charconst_ptr__m_valueArray_get(void *c) {
	::btHashMap< btHashPtr, char const* > *o = (::btHashMap< btHashPtr, char const* >*)c;
	return (void*)&(o->m_valueArray);
}


// ::btHashMap< btHashPtr, void* >
//constructor: btHashMap  ( ::btHashMap<btHashPtr, void*>::* )(  ) 
void* btHashMap_btHashPtr_void_ptr__new() {
	::btHashMap< btHashPtr, void* > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btHashMap< btHashPtr, void* >),16);
	o = new (mem)::btHashMap< btHashPtr, void* >();
	return (void*)o;
}
void btHashMap_btHashPtr_void_ptr__free(void *c) {
	::btHashMap< btHashPtr, void* > *o = (::btHashMap< btHashPtr, void* >*)c;
	delete o;
}
//not supported method: insert void ( ::btHashMap<btHashPtr, void*>::* )( ::btHashPtr const &,void * const & ) 
// error: ::btHashPtr const & - ok,  - unsupported, void - ok

//method: findIndex int ( ::btHashMap<btHashPtr, void*>::* )( ::btHashPtr const & ) const
int btHashMap_btHashPtr_void_ptr__findIndex(void *c,void* p0) {
	::btHashMap< btHashPtr, void* > *o = (::btHashMap< btHashPtr, void* >*)c;
	::btHashPtr const & tp0 = *(::btHashPtr const *)p0;
	int retVal = (int)o->findIndex(tp0);
	return retVal;
}
//method: clear void ( ::btHashMap<btHashPtr, void*>::* )(  ) 
void btHashMap_btHashPtr_void_ptr__clear(void *c) {
	::btHashMap< btHashPtr, void* > *o = (::btHashMap< btHashPtr, void* >*)c;
	o->clear();
}
//not supported method: getAtIndex void * const * ( ::btHashMap<btHashPtr, void*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex void * const * ( ::btHashMap<btHashPtr, void*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex void * * ( ::btHashMap<btHashPtr, void*>::* )( int ) 
// error: int - ok,  - unsupported

//method: growTables void ( ::btHashMap<btHashPtr, void*>::* )( ::btHashPtr const & ) 
void btHashMap_btHashPtr_void_ptr__growTables(void *c,void* p0) {
	::btHashMap< btHashPtr, void* > *o = (::btHashMap< btHashPtr, void* >*)c;
	::btHashPtr const & tp0 = *(::btHashPtr const *)p0;
	o->growTables(tp0);
}
//not supported method: find void * const * ( ::btHashMap<btHashPtr, void*>::* )( ::btHashPtr const & ) const
// error: ::btHashPtr const & - ok,  - unsupported

//not supported method: find void * const * ( ::btHashMap<btHashPtr, void*>::* )( ::btHashPtr const & ) const
// error: ::btHashPtr const & - ok,  - unsupported

//not supported method: find void * * ( ::btHashMap<btHashPtr, void*>::* )( ::btHashPtr const & ) 
// error: ::btHashPtr const & - ok,  - unsupported

//method: size int ( ::btHashMap<btHashPtr, void*>::* )(  ) const
int btHashMap_btHashPtr_void_ptr__size(void *c) {
	::btHashMap< btHashPtr, void* > *o = (::btHashMap< btHashPtr, void* >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_void_ptr_->m_hashTable
void btHashMap_btHashPtr_void_ptr__m_hashTable_set(void *c,void* a) {
	::btHashMap< btHashPtr, void* > *o = (::btHashMap< btHashPtr, void* >*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_hashTable = ta;
}
void* btHashMap_btHashPtr_void_ptr__m_hashTable_get(void *c) {
	::btHashMap< btHashPtr, void* > *o = (::btHashMap< btHashPtr, void* >*)c;
	return (void*)&(o->m_hashTable);
}

//attribute: ::btAlignedObjectArray<btHashPtr> btHashMap_btHashPtr_void_ptr_->m_keyArray
void btHashMap_btHashPtr_void_ptr__m_keyArray_set(void *c,void* a) {
	::btHashMap< btHashPtr, void* > *o = (::btHashMap< btHashPtr, void* >*)c;
	::btAlignedObjectArray<btHashPtr> & ta = *(::btAlignedObjectArray<btHashPtr> *)a;
	o->m_keyArray = ta;
}
void* btHashMap_btHashPtr_void_ptr__m_keyArray_get(void *c) {
	::btHashMap< btHashPtr, void* > *o = (::btHashMap< btHashPtr, void* >*)c;
	return (void*)&(o->m_keyArray);
}

//attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_void_ptr_->m_next
void btHashMap_btHashPtr_void_ptr__m_next_set(void *c,void* a) {
	::btHashMap< btHashPtr, void* > *o = (::btHashMap< btHashPtr, void* >*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_next = ta;
}
void* btHashMap_btHashPtr_void_ptr__m_next_get(void *c) {
	::btHashMap< btHashPtr, void* > *o = (::btHashMap< btHashPtr, void* >*)c;
	return (void*)&(o->m_next);
}

//attribute: ::btAlignedObjectArray<void*> btHashMap_btHashPtr_void_ptr_->m_valueArray
void btHashMap_btHashPtr_void_ptr__m_valueArray_set(void *c,void* a) {
	::btHashMap< btHashPtr, void* > *o = (::btHashMap< btHashPtr, void* >*)c;
	::btAlignedObjectArray<void*> & ta = *(::btAlignedObjectArray<void*> *)a;
	o->m_valueArray = ta;
}
void* btHashMap_btHashPtr_void_ptr__m_valueArray_get(void *c) {
	::btHashMap< btHashPtr, void* > *o = (::btHashMap< btHashPtr, void* >*)c;
	return (void*)&(o->m_valueArray);
}


// ::btHashMap< btHashString, int >
//constructor: btHashMap  ( ::btHashMap<btHashString, int>::* )(  ) 
void* btHashMap_btHashString_int__new() {
	::btHashMap< btHashString, int > *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btHashMap< btHashString, int >),16);
	o = new (mem)::btHashMap< btHashString, int >();
	return (void*)o;
}
void btHashMap_btHashString_int__free(void *c) {
	::btHashMap< btHashString, int > *o = (::btHashMap< btHashString, int >*)c;
	delete o;
}
//not supported method: insert void ( ::btHashMap<btHashString, int>::* )( ::btHashString const &,int const & ) 
// error: ::btHashString const & - ok,  - unsupported, void - ok

//method: findIndex int ( ::btHashMap<btHashString, int>::* )( ::btHashString const & ) const
int btHashMap_btHashString_int__findIndex(void *c,void* p0) {
	::btHashMap< btHashString, int > *o = (::btHashMap< btHashString, int >*)c;
	::btHashString const & tp0 = *(::btHashString const *)p0;
	int retVal = (int)o->findIndex(tp0);
	return retVal;
}
//method: clear void ( ::btHashMap<btHashString, int>::* )(  ) 
void btHashMap_btHashString_int__clear(void *c) {
	::btHashMap< btHashString, int > *o = (::btHashMap< btHashString, int >*)c;
	o->clear();
}
//not supported method: getAtIndex int const * ( ::btHashMap<btHashString, int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex int const * ( ::btHashMap<btHashString, int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex int * ( ::btHashMap<btHashString, int>::* )( int ) 
// error: int - ok,  - unsupported

//method: growTables void ( ::btHashMap<btHashString, int>::* )( ::btHashString const & ) 
void btHashMap_btHashString_int__growTables(void *c,void* p0) {
	::btHashMap< btHashString, int > *o = (::btHashMap< btHashString, int >*)c;
	::btHashString const & tp0 = *(::btHashString const *)p0;
	o->growTables(tp0);
}
//not supported method: find int const * ( ::btHashMap<btHashString, int>::* )( ::btHashString const & ) const
// error: ::btHashString const & - ok,  - unsupported

//not supported method: find int const * ( ::btHashMap<btHashString, int>::* )( ::btHashString const & ) const
// error: ::btHashString const & - ok,  - unsupported

//not supported method: find int * ( ::btHashMap<btHashString, int>::* )( ::btHashString const & ) 
// error: ::btHashString const & - ok,  - unsupported

//method: size int ( ::btHashMap<btHashString, int>::* )(  ) const
int btHashMap_btHashString_int__size(void *c) {
	::btHashMap< btHashString, int > *o = (::btHashMap< btHashString, int >*)c;
	int retVal = (int)o->size();
	return retVal;
}
//attribute: ::btAlignedObjectArray<int> btHashMap_btHashString_int_->m_hashTable
void btHashMap_btHashString_int__m_hashTable_set(void *c,void* a) {
	::btHashMap< btHashString, int > *o = (::btHashMap< btHashString, int >*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_hashTable = ta;
}
void* btHashMap_btHashString_int__m_hashTable_get(void *c) {
	::btHashMap< btHashString, int > *o = (::btHashMap< btHashString, int >*)c;
	return (void*)&(o->m_hashTable);
}

//attribute: ::btAlignedObjectArray<btHashString> btHashMap_btHashString_int_->m_keyArray
void btHashMap_btHashString_int__m_keyArray_set(void *c,void* a) {
	::btHashMap< btHashString, int > *o = (::btHashMap< btHashString, int >*)c;
	::btAlignedObjectArray<btHashString> & ta = *(::btAlignedObjectArray<btHashString> *)a;
	o->m_keyArray = ta;
}
void* btHashMap_btHashString_int__m_keyArray_get(void *c) {
	::btHashMap< btHashString, int > *o = (::btHashMap< btHashString, int >*)c;
	return (void*)&(o->m_keyArray);
}

//attribute: ::btAlignedObjectArray<int> btHashMap_btHashString_int_->m_next
void btHashMap_btHashString_int__m_next_set(void *c,void* a) {
	::btHashMap< btHashString, int > *o = (::btHashMap< btHashString, int >*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_next = ta;
}
void* btHashMap_btHashString_int__m_next_get(void *c) {
	::btHashMap< btHashString, int > *o = (::btHashMap< btHashString, int >*)c;
	return (void*)&(o->m_next);
}

//attribute: ::btAlignedObjectArray<int> btHashMap_btHashString_int_->m_valueArray
void btHashMap_btHashString_int__m_valueArray_set(void *c,void* a) {
	::btHashMap< btHashString, int > *o = (::btHashMap< btHashString, int >*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_valueArray = ta;
}
void* btHashMap_btHashString_int__m_valueArray_get(void *c) {
	::btHashMap< btHashString, int > *o = (::btHashMap< btHashString, int >*)c;
	return (void*)&(o->m_valueArray);
}


// ::btHashPtr
//not supported constructor: btHashPtr  ( ::btHashPtr::* )( void const * ) 
// error:  - unsupported

void btHashPtr_free(void *c) {
	::btHashPtr *o = (::btHashPtr*)c;
	delete o;
}
//method: getHash unsigned int ( ::btHashPtr::* )(  ) const
unsigned int btHashPtr_getHash(void *c) {
	::btHashPtr *o = (::btHashPtr*)c;
	unsigned int retVal = (unsigned int)o->getHash();
	return retVal;
}
//method: equals bool ( ::btHashPtr::* )( ::btHashPtr const & ) const
int btHashPtr_equals(void *c,void* p0) {
	::btHashPtr *o = (::btHashPtr*)c;
	::btHashPtr const & tp0 = *(::btHashPtr const *)p0;
	int retVal = (int)o->equals(tp0);
	return retVal;
}
//not supported method: getPointer void const * ( ::btHashPtr::* )(  ) const
// error:  - unsupported

//attribute: ::btHashPtr btHashPtr->
// attribute not supported: //attribute: ::btHashPtr btHashPtr->

// ::btHashString
//constructor: btHashString  ( ::btHashString::* )( char const * ) 
void* btHashString_new(char const * p0) {
	::btHashString *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btHashString),16);
	o = new (mem)::btHashString(p0);
	return (void*)o;
}
void btHashString_free(void *c) {
	::btHashString *o = (::btHashString*)c;
	delete o;
}
//method: getHash unsigned int ( ::btHashString::* )(  ) const
unsigned int btHashString_getHash(void *c) {
	::btHashString *o = (::btHashString*)c;
	unsigned int retVal = (unsigned int)o->getHash();
	return retVal;
}
//method: equals bool ( ::btHashString::* )( ::btHashString const & ) const
int btHashString_equals(void *c,void* p0) {
	::btHashString *o = (::btHashString*)c;
	::btHashString const & tp0 = *(::btHashString const *)p0;
	int retVal = (int)o->equals(tp0);
	return retVal;
}
//method: portableStringCompare int ( ::btHashString::* )( char const *,char const * ) const
int btHashString_portableStringCompare(void *c,char const * p0,char const * p1) {
	::btHashString *o = (::btHashString*)c;
	int retVal = (int)o->portableStringCompare(p0,p1);
	return retVal;
}
//attribute: unsigned int btHashString->m_hash
void btHashString_m_hash_set(void *c,unsigned int a) {
	::btHashString *o = (::btHashString*)c;
	o->m_hash = a;
}
unsigned int btHashString_m_hash_get(void *c) {
	::btHashString *o = (::btHashString*)c;
	return (unsigned int)(o->m_hash);
}

//attribute: char const * btHashString->m_string
void btHashString_m_string_set(void *c,char const * a) {
	::btHashString *o = (::btHashString*)c;
	o->m_string = a;
}
char const * btHashString_m_string_get(void *c) {
	::btHashString *o = (::btHashString*)c;
	return (char const *)(o->m_string);
}


// ::btIDebugDraw
//method: draw3dText void ( ::btIDebugDraw::* )( ::btVector3 const &,char const * ) 
void btIDebugDraw_draw3dText(void *c,float* p0,char const * p1) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->draw3dText(tp0,p1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: drawBox void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btIDebugDraw_drawBox(void *c,float* p0,float* p1,float* p2) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->drawBox(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: drawBox void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btIDebugDraw_drawBox0(void *c,float* p0,float* p1,float* p2) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->drawBox(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: drawBox void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btTransform const &,::btVector3 const & ) 
void btIDebugDraw_drawBox1(void *c,float* p0,float* p1,float* p2,float* p3) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	o->drawBox(tp0,tp1,tp2,tp3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
}
//method: drawCone void ( ::btIDebugDraw::* )( ::btScalar,::btScalar,int,::btTransform const &,::btVector3 const & ) 
void btIDebugDraw_drawCone(void *c,float p0,float p1,int p2,float* p3,float* p4) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->drawCone(p0,p1,p2,tp3,tp4);
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: drawCapsule void ( ::btIDebugDraw::* )( ::btScalar,::btScalar,int,::btTransform const &,::btVector3 const & ) 
void btIDebugDraw_drawCapsule(void *c,float p0,float p1,int p2,float* p3,float* p4) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->drawCapsule(p0,p1,p2,tp3,tp4);
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: drawArc void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar,::btScalar,::btScalar,::btScalar,::btVector3 const &,bool,::btScalar ) 
void btIDebugDraw_drawArc(void *c,float* p0,float* p1,float* p2,float p3,float p4,float p5,float p6,float* p7,int p8,float p9) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp7(p7[0],p7[1],p7[2]);
	o->drawArc(tp0,tp1,tp2,p3,p4,p5,p6,tp7,p8,p9);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p7[0]=tp7.m_floats[0];p7[1]=tp7.m_floats[1];p7[2]=tp7.m_floats[2];
}
//method: drawCylinder void ( ::btIDebugDraw::* )( ::btScalar,::btScalar,int,::btTransform const &,::btVector3 const & ) 
void btIDebugDraw_drawCylinder(void *c,float p0,float p1,int p2,float* p3,float* p4) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->drawCylinder(p0,p1,p2,tp3,tp4);
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: reportErrorWarning void ( ::btIDebugDraw::* )( char const * ) 
void btIDebugDraw_reportErrorWarning(void *c,char const * p0) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	o->reportErrorWarning(p0);
}
//method: drawTriangle void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
void btIDebugDraw_drawTriangle(void *c,float* p0,float* p1,float* p2,float* p3,float* p4,float* p5,float* p6,float p7) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	btVector3 tp5(p5[0],p5[1],p5[2]);
	btVector3 tp6(p6[0],p6[1],p6[2]);
	o->drawTriangle(tp0,tp1,tp2,tp3,tp4,tp5,tp6,p7);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	p5[0]=tp5.m_floats[0];p5[1]=tp5.m_floats[1];p5[2]=tp5.m_floats[2];
	p6[0]=tp6.m_floats[0];p6[1]=tp6.m_floats[1];p6[2]=tp6.m_floats[2];
}
//method: drawTriangle void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
void btIDebugDraw_drawTriangle0(void *c,float* p0,float* p1,float* p2,float* p3,float* p4,float* p5,float* p6,float p7) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	btVector3 tp5(p5[0],p5[1],p5[2]);
	btVector3 tp6(p6[0],p6[1],p6[2]);
	o->drawTriangle(tp0,tp1,tp2,tp3,tp4,tp5,tp6,p7);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	p5[0]=tp5.m_floats[0];p5[1]=tp5.m_floats[1];p5[2]=tp5.m_floats[2];
	p6[0]=tp6.m_floats[0];p6[1]=tp6.m_floats[1];p6[2]=tp6.m_floats[2];
}
//method: drawTriangle void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
void btIDebugDraw_drawTriangle1(void *c,float* p0,float* p1,float* p2,float* p3,float p4) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	o->drawTriangle(tp0,tp1,tp2,tp3,p4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
}
//method: getDebugMode int ( ::btIDebugDraw::* )(  ) const
int btIDebugDraw_getDebugMode(void *c) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	int retVal = (int)o->getDebugMode();
	return retVal;
}
//method: drawLine void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btIDebugDraw_drawLine(void *c,float* p0,float* p1,float* p2) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->drawLine(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: drawLine void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btIDebugDraw_drawLine0(void *c,float* p0,float* p1,float* p2) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->drawLine(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: drawLine void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btIDebugDraw_drawLine1(void *c,float* p0,float* p1,float* p2,float* p3) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	o->drawLine(tp0,tp1,tp2,tp3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
}
//method: drawTransform void ( ::btIDebugDraw::* )( ::btTransform const &,::btScalar ) 
void btIDebugDraw_drawTransform(void *c,float* p0,float p1) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	o->drawTransform(tp0,p1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//method: drawAabb void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btIDebugDraw_drawAabb(void *c,float* p0,float* p1,float* p2) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->drawAabb(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: drawPlane void ( ::btIDebugDraw::* )( ::btVector3 const &,::btScalar,::btTransform const &,::btVector3 const & ) 
void btIDebugDraw_drawPlane(void *c,float* p0,float p1,float* p2,float* p3) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	o->drawPlane(tp0,p1,tp2,tp3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
}
//method: drawContactPoint void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btScalar,int,::btVector3 const & ) 
void btIDebugDraw_drawContactPoint(void *c,float* p0,float* p1,float p2,int p3,float* p4) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->drawContactPoint(tp0,tp1,p2,p3,tp4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: setDebugMode void ( ::btIDebugDraw::* )( int ) 
void btIDebugDraw_setDebugMode(void *c,int p0) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	o->setDebugMode(p0);
}
//method: drawSpherePatch void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar,::btScalar,::btScalar,::btScalar,::btScalar,::btVector3 const &,::btScalar ) 
void btIDebugDraw_drawSpherePatch(void *c,float* p0,float* p1,float* p2,float p3,float p4,float p5,float p6,float p7,float* p8,float p9) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp8(p8[0],p8[1],p8[2]);
	o->drawSpherePatch(tp0,tp1,tp2,p3,p4,p5,p6,p7,tp8,p9);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p8[0]=tp8.m_floats[0];p8[1]=tp8.m_floats[1];p8[2]=tp8.m_floats[2];
}
//method: drawSphere void ( ::btIDebugDraw::* )( ::btScalar,::btTransform const &,::btVector3 const & ) 
void btIDebugDraw_drawSphere(void *c,float p0,float* p1,float* p2) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->drawSphere(p0,tp1,tp2);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: drawSphere void ( ::btIDebugDraw::* )( ::btScalar,::btTransform const &,::btVector3 const & ) 
void btIDebugDraw_drawSphere0(void *c,float p0,float* p1,float* p2) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->drawSphere(p0,tp1,tp2);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: drawSphere void ( ::btIDebugDraw::* )( ::btVector3 const &,::btScalar,::btVector3 const & ) 
void btIDebugDraw_drawSphere1(void *c,float* p0,float p1,float* p2) {
	::btIDebugDraw *o = (::btIDebugDraw*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->drawSphere(tp0,p1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}

// ::btMatrix3x3DoubleData
//constructor: btMatrix3x3DoubleData  ( ::btMatrix3x3DoubleData::* )(  ) 
void* btMatrix3x3DoubleData_new() {
	::btMatrix3x3DoubleData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btMatrix3x3DoubleData),16);
	o = new (mem)::btMatrix3x3DoubleData();
	return (void*)o;
}
void btMatrix3x3DoubleData_free(void *c) {
	::btMatrix3x3DoubleData *o = (::btMatrix3x3DoubleData*)c;
	delete o;
}
//attribute: ::btVector3DoubleData[3] btMatrix3x3DoubleData->m_el
// attribute not supported: //attribute: ::btVector3DoubleData[3] btMatrix3x3DoubleData->m_el

// ::btMatrix3x3FloatData
//constructor: btMatrix3x3FloatData  ( ::btMatrix3x3FloatData::* )(  ) 
void* btMatrix3x3FloatData_new() {
	::btMatrix3x3FloatData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btMatrix3x3FloatData),16);
	o = new (mem)::btMatrix3x3FloatData();
	return (void*)o;
}
void btMatrix3x3FloatData_free(void *c) {
	::btMatrix3x3FloatData *o = (::btMatrix3x3FloatData*)c;
	delete o;
}
//attribute: ::btVector3FloatData[3] btMatrix3x3FloatData->m_el
// attribute not supported: //attribute: ::btVector3FloatData[3] btMatrix3x3FloatData->m_el

// ::btMotionState
//method: setWorldTransform void ( ::btMotionState::* )( ::btTransform const & ) 
void btMotionState_setWorldTransform(void *c,float* p0) {
	::btMotionState *o = (::btMotionState*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	o->setWorldTransform(tp0);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//method: getWorldTransform void ( ::btMotionState::* )( ::btTransform & ) const
void btMotionState_getWorldTransform(void *c,float* p0) {
	::btMotionState *o = (::btMotionState*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	o->getWorldTransform(tp0);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}

// ::btPointerUid
//constructor: btPointerUid  ( ::btPointerUid::* )(  ) 
void* btPointerUid_new() {
	::btPointerUid *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btPointerUid),16);
	o = new (mem)::btPointerUid();
	return (void*)o;
}
void btPointerUid_free(void *c) {
	::btPointerUid *o = (::btPointerUid*)c;
	delete o;
}
//attribute: ::btPointerUid btPointerUid->
// attribute not supported: //attribute: ::btPointerUid btPointerUid->

// ::btQuadWord
//constructor: btQuadWord  ( ::btQuadWord::* )(  ) 
void* btQuadWord_new0() {
	::btQuadWord *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btQuadWord),16);
	o = new (mem)::btQuadWord();
	return (void*)o;
}
//constructor: btQuadWord  ( ::btQuadWord::* )( ::btScalar const &,::btScalar const &,::btScalar const & ) 
void* btQuadWord_new1(float p0,float p1,float p2) {
	::btQuadWord *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btQuadWord),16);
	o = new (mem)::btQuadWord(p0,p1,p2);
	return (void*)o;
}
//constructor: btQuadWord  ( ::btQuadWord::* )( ::btScalar const &,::btScalar const &,::btScalar const &,::btScalar const & ) 
void* btQuadWord_new2(float p0,float p1,float p2,float p3) {
	::btQuadWord *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btQuadWord),16);
	o = new (mem)::btQuadWord(p0,p1,p2,p3);
	return (void*)o;
}
void btQuadWord_free(void *c) {
	::btQuadWord *o = (::btQuadWord*)c;
	delete o;
}
//method: setMin void ( ::btQuadWord::* )( ::btQuadWord const & ) 
void btQuadWord_setMin(void *c,void* p0) {
	::btQuadWord *o = (::btQuadWord*)c;
	::btQuadWord const & tp0 = *(::btQuadWord const *)p0;
	o->setMin(tp0);
}
//method: setValue void ( ::btQuadWord::* )( ::btScalar const &,::btScalar const &,::btScalar const & ) 
void btQuadWord_setValue(void *c,float p0,float p1,float p2) {
	::btQuadWord *o = (::btQuadWord*)c;
	o->setValue(p0,p1,p2);
}
//method: setValue void ( ::btQuadWord::* )( ::btScalar const &,::btScalar const &,::btScalar const & ) 
void btQuadWord_setValue0(void *c,float p0,float p1,float p2) {
	::btQuadWord *o = (::btQuadWord*)c;
	o->setValue(p0,p1,p2);
}
//method: setValue void ( ::btQuadWord::* )( ::btScalar const &,::btScalar const &,::btScalar const &,::btScalar const & ) 
void btQuadWord_setValue1(void *c,float p0,float p1,float p2,float p3) {
	::btQuadWord *o = (::btQuadWord*)c;
	o->setValue(p0,p1,p2,p3);
}
//method: setMax void ( ::btQuadWord::* )( ::btQuadWord const & ) 
void btQuadWord_setMax(void *c,void* p0) {
	::btQuadWord *o = (::btQuadWord*)c;
	::btQuadWord const & tp0 = *(::btQuadWord const *)p0;
	o->setMax(tp0);
}
//method: getX ::btScalar const & ( ::btQuadWord::* )(  ) const
float btQuadWord_getX(void *c) {
	::btQuadWord *o = (::btQuadWord*)c;
	float retVal = (float)o->getX();
	return retVal;
}
//method: getY ::btScalar const & ( ::btQuadWord::* )(  ) const
float btQuadWord_getY(void *c) {
	::btQuadWord *o = (::btQuadWord*)c;
	float retVal = (float)o->getY();
	return retVal;
}
//method: getZ ::btScalar const & ( ::btQuadWord::* )(  ) const
float btQuadWord_getZ(void *c) {
	::btQuadWord *o = (::btQuadWord*)c;
	float retVal = (float)o->getZ();
	return retVal;
}
//method: setW void ( ::btQuadWord::* )( ::btScalar ) 
void btQuadWord_setW(void *c,float p0) {
	::btQuadWord *o = (::btQuadWord*)c;
	o->setW(p0);
}
//method: w ::btScalar const & ( ::btQuadWord::* )(  ) const
float btQuadWord_w(void *c) {
	::btQuadWord *o = (::btQuadWord*)c;
	float retVal = (float)o->w();
	return retVal;
}
//method: y ::btScalar const & ( ::btQuadWord::* )(  ) const
float btQuadWord_y(void *c) {
	::btQuadWord *o = (::btQuadWord*)c;
	float retVal = (float)o->y();
	return retVal;
}
//method: x ::btScalar const & ( ::btQuadWord::* )(  ) const
float btQuadWord_x(void *c) {
	::btQuadWord *o = (::btQuadWord*)c;
	float retVal = (float)o->x();
	return retVal;
}
//method: z ::btScalar const & ( ::btQuadWord::* )(  ) const
float btQuadWord_z(void *c) {
	::btQuadWord *o = (::btQuadWord*)c;
	float retVal = (float)o->z();
	return retVal;
}
//method: setX void ( ::btQuadWord::* )( ::btScalar ) 
void btQuadWord_setX(void *c,float p0) {
	::btQuadWord *o = (::btQuadWord*)c;
	o->setX(p0);
}
//method: setY void ( ::btQuadWord::* )( ::btScalar ) 
void btQuadWord_setY(void *c,float p0) {
	::btQuadWord *o = (::btQuadWord*)c;
	o->setY(p0);
}
//method: setZ void ( ::btQuadWord::* )( ::btScalar ) 
void btQuadWord_setZ(void *c,float p0) {
	::btQuadWord *o = (::btQuadWord*)c;
	o->setZ(p0);
}
//attribute: ::btScalar[4] btQuadWord->m_floats
// attribute not supported: //attribute: ::btScalar[4] btQuadWord->m_floats

// ::btSerializer
//method: setSerializationFlags void ( ::btSerializer::* )( int ) 
void btSerializer_setSerializationFlags(void *c,int p0) {
	::btSerializer *o = (::btSerializer*)c;
	o->setSerializationFlags(p0);
}
//method: getCurrentBufferSize int ( ::btSerializer::* )(  ) const
int btSerializer_getCurrentBufferSize(void *c) {
	::btSerializer *o = (::btSerializer*)c;
	int retVal = (int)o->getCurrentBufferSize();
	return retVal;
}
//method: startSerialization void ( ::btSerializer::* )(  ) 
void btSerializer_startSerialization(void *c) {
	::btSerializer *o = (::btSerializer*)c;
	o->startSerialization();
}
//method: getSerializationFlags int ( ::btSerializer::* )(  ) const
int btSerializer_getSerializationFlags(void *c) {
	::btSerializer *o = (::btSerializer*)c;
	int retVal = (int)o->getSerializationFlags();
	return retVal;
}
//method: finishSerialization void ( ::btSerializer::* )(  ) 
void btSerializer_finishSerialization(void *c) {
	::btSerializer *o = (::btSerializer*)c;
	o->finishSerialization();
}
//method: getUniquePointer void * ( ::btSerializer::* )( void * ) 
void* btSerializer_getUniquePointer(void *c,void* p0) {
	::btSerializer *o = (::btSerializer*)c;
	void * tp0 = (void *)p0;
	void* retVal = (void*) o->getUniquePointer(tp0);
	return retVal;
}
//not supported method: allocate ::btChunk * ( ::btSerializer::* )( ::size_t,int ) 
// error:  - unsupported, int - ok, ::btChunk * - ok

//not supported method: findNameForPointer char const * ( ::btSerializer::* )( void const * ) const
// error:  - unsupported, char const * - ok

//method: finalizeChunk void ( ::btSerializer::* )( ::btChunk *,char const *,int,void * ) 
void btSerializer_finalizeChunk(void *c,void* p0,char const * p1,int p2,void* p3) {
	::btSerializer *o = (::btSerializer*)c;
	::btChunk * tp0 = (::btChunk *)p0;
	void * tp3 = (void *)p3;
	o->finalizeChunk(tp0,p1,p2,tp3);
}
//method: serializeName void ( ::btSerializer::* )( char const * ) 
void btSerializer_serializeName(void *c,char const * p0) {
	::btSerializer *o = (::btSerializer*)c;
	o->serializeName(p0);
}
//method: findPointer void * ( ::btSerializer::* )( void * ) 
void* btSerializer_findPointer(void *c,void* p0) {
	::btSerializer *o = (::btSerializer*)c;
	void * tp0 = (void *)p0;
	void* retVal = (void*) o->findPointer(tp0);
	return retVal;
}
//not supported method: registerNameForPointer void ( ::btSerializer::* )( void const *,char const * ) 
// error:  - unsupported, char const * - ok, void - ok

//not supported method: getBufferPointer unsigned char const * ( ::btSerializer::* )(  ) const
// error:  - unsupported


// ::btStackAlloc
//constructor: btStackAlloc  ( ::btStackAlloc::* )( unsigned int ) 
void* btStackAlloc_new(unsigned int p0) {
	::btStackAlloc *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btStackAlloc),16);
	o = new (mem)::btStackAlloc(p0);
	return (void*)o;
}
void btStackAlloc_free(void *c) {
	::btStackAlloc *o = (::btStackAlloc*)c;
	delete o;
}
//method: create void ( ::btStackAlloc::* )( unsigned int ) 
void btStackAlloc_create(void *c,unsigned int p0) {
	::btStackAlloc *o = (::btStackAlloc*)c;
	o->create(p0);
}
//method: ctor void ( ::btStackAlloc::* )(  ) 
void btStackAlloc_ctor(void *c) {
	::btStackAlloc *o = (::btStackAlloc*)c;
	o->ctor();
}
//not supported method: allocate unsigned char * ( ::btStackAlloc::* )( unsigned int ) 
// error: unsigned int - ok,  - unsupported

//method: destroy void ( ::btStackAlloc::* )(  ) 
void btStackAlloc_destroy(void *c) {
	::btStackAlloc *o = (::btStackAlloc*)c;
	o->destroy();
}
//method: beginBlock ::btBlock * ( ::btStackAlloc::* )(  ) 
void* btStackAlloc_beginBlock(void *c) {
	::btStackAlloc *o = (::btStackAlloc*)c;
	void* retVal = (void*) o->beginBlock();
	return retVal;
}
//method: getAvailableMemory int ( ::btStackAlloc::* )(  ) const
int btStackAlloc_getAvailableMemory(void *c) {
	::btStackAlloc *o = (::btStackAlloc*)c;
	int retVal = (int)o->getAvailableMemory();
	return retVal;
}
//method: endBlock void ( ::btStackAlloc::* )( ::btBlock * ) 
void btStackAlloc_endBlock(void *c,void* p0) {
	::btStackAlloc *o = (::btStackAlloc*)c;
	::btBlock * tp0 = (::btBlock *)p0;
	o->endBlock(tp0);
}
//attribute: unsigned char * btStackAlloc->data
// attribute not supported: //attribute: unsigned char * btStackAlloc->data
//attribute: unsigned int btStackAlloc->totalsize
void btStackAlloc_totalsize_set(void *c,unsigned int a) {
	::btStackAlloc *o = (::btStackAlloc*)c;
	o->totalsize = a;
}
unsigned int btStackAlloc_totalsize_get(void *c) {
	::btStackAlloc *o = (::btStackAlloc*)c;
	return (unsigned int)(o->totalsize);
}

//attribute: unsigned int btStackAlloc->usedsize
void btStackAlloc_usedsize_set(void *c,unsigned int a) {
	::btStackAlloc *o = (::btStackAlloc*)c;
	o->usedsize = a;
}
unsigned int btStackAlloc_usedsize_get(void *c) {
	::btStackAlloc *o = (::btStackAlloc*)c;
	return (unsigned int)(o->usedsize);
}

//attribute: ::btBlock * btStackAlloc->current
void btStackAlloc_current_set(void *c,void* a) {
	::btStackAlloc *o = (::btStackAlloc*)c;
	::btBlock * ta = (::btBlock *)a;
	o->current = ta;
}
void* btStackAlloc_current_get(void *c) {
	::btStackAlloc *o = (::btStackAlloc*)c;
	return (void*)(o->current);
}

//attribute: bool btStackAlloc->ischild
void btStackAlloc_ischild_set(void *c,int a) {
	::btStackAlloc *o = (::btStackAlloc*)c;
	o->ischild = a;
}
int btStackAlloc_ischild_get(void *c) {
	::btStackAlloc *o = (::btStackAlloc*)c;
	return (int)(o->ischild);
}


// ::btTransformDoubleData
//constructor: btTransformDoubleData  ( ::btTransformDoubleData::* )(  ) 
void* btTransformDoubleData_new() {
	::btTransformDoubleData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTransformDoubleData),16);
	o = new (mem)::btTransformDoubleData();
	return (void*)o;
}
void btTransformDoubleData_free(void *c) {
	::btTransformDoubleData *o = (::btTransformDoubleData*)c;
	delete o;
}
//attribute: ::btMatrix3x3DoubleData btTransformDoubleData->m_basis
void btTransformDoubleData_m_basis_set(void *c,void* a) {
	::btTransformDoubleData *o = (::btTransformDoubleData*)c;
	::btMatrix3x3DoubleData & ta = *(::btMatrix3x3DoubleData *)a;
	o->m_basis = ta;
}
void* btTransformDoubleData_m_basis_get(void *c) {
	::btTransformDoubleData *o = (::btTransformDoubleData*)c;
	return (void*)&(o->m_basis);
}

//attribute: ::btVector3DoubleData btTransformDoubleData->m_origin
void btTransformDoubleData_m_origin_set(void *c,void* a) {
	::btTransformDoubleData *o = (::btTransformDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_origin = ta;
}
void* btTransformDoubleData_m_origin_get(void *c) {
	::btTransformDoubleData *o = (::btTransformDoubleData*)c;
	return (void*)&(o->m_origin);
}


// ::btTransformFloatData
//constructor: btTransformFloatData  ( ::btTransformFloatData::* )(  ) 
void* btTransformFloatData_new() {
	::btTransformFloatData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTransformFloatData),16);
	o = new (mem)::btTransformFloatData();
	return (void*)o;
}
void btTransformFloatData_free(void *c) {
	::btTransformFloatData *o = (::btTransformFloatData*)c;
	delete o;
}
//attribute: ::btMatrix3x3FloatData btTransformFloatData->m_basis
void btTransformFloatData_m_basis_set(void *c,void* a) {
	::btTransformFloatData *o = (::btTransformFloatData*)c;
	::btMatrix3x3FloatData & ta = *(::btMatrix3x3FloatData *)a;
	o->m_basis = ta;
}
void* btTransformFloatData_m_basis_get(void *c) {
	::btTransformFloatData *o = (::btTransformFloatData*)c;
	return (void*)&(o->m_basis);
}

//attribute: ::btVector3FloatData btTransformFloatData->m_origin
void btTransformFloatData_m_origin_set(void *c,void* a) {
	::btTransformFloatData *o = (::btTransformFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_origin = ta;
}
void* btTransformFloatData_m_origin_get(void *c) {
	::btTransformFloatData *o = (::btTransformFloatData*)c;
	return (void*)&(o->m_origin);
}


// ::btTransformUtil
//constructor: btTransformUtil  ( ::btTransformUtil::* )(  ) 
void* btTransformUtil_new() {
	::btTransformUtil *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTransformUtil),16);
	o = new (mem)::btTransformUtil();
	return (void*)o;
}
void btTransformUtil_free(void *c) {
	::btTransformUtil *o = (::btTransformUtil*)c;
	delete o;
}
//not supported method: calculateDiffAxisAngle void (*)( ::btTransform const &,::btTransform const &,::btVector3 &,::btScalar & )
// error: ::btTransform const & - ok, ::btTransform const & - ok, ::btVector3 & - ok,  - unsupported, void - ok

//method: calculateVelocity void (*)( ::btTransform const &,::btTransform const &,::btScalar,::btVector3 &,::btVector3 & )
void btTransformUtil_calculateVelocity(float* p0,float* p1,float p2,float* p3,float* p4) {
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	::btTransformUtil::calculateVelocity(tp0,tp1,p2,tp3,tp4);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: integrateTransform void (*)( ::btTransform const &,::btVector3 const &,::btVector3 const &,::btScalar,::btTransform & )
void btTransformUtil_integrateTransform(float* p0,float* p1,float* p2,float p3,float* p4) {
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btMatrix3x3 mtp4(p4[0],p4[1],p4[2],p4[3],p4[4],p4[5],p4[6],p4[7],p4[8]);
	btVector3 vtp4(p4[9],p4[10],p4[11]);
	btTransform tp4(mtp4,vtp4);
	::btTransformUtil::integrateTransform(tp0,tp1,tp2,p3,tp4);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p4[0]=tp4.getBasis().getRow(0).m_floats[0];p4[1]=tp4.getBasis().getRow(0).m_floats[1];p4[2]=tp4.getBasis().getRow(0).m_floats[2];p4[3]=tp4.getBasis().getRow(1).m_floats[0];p4[4]=tp4.getBasis().getRow(1).m_floats[1];p4[5]=tp4.getBasis().getRow(1).m_floats[2];p4[6]=tp4.getBasis().getRow(2).m_floats[0];p4[7]=tp4.getBasis().getRow(2).m_floats[1];p4[8]=tp4.getBasis().getRow(2).m_floats[2];
	p4[9]=tp4.getOrigin().m_floats[0];p4[10]=tp4.getOrigin().m_floats[1];p4[11]=tp4.getOrigin().m_floats[2];
}
//method: calculateVelocityQuaternion void (*)( ::btVector3 const &,::btVector3 const &,::btQuaternion const &,::btQuaternion const &,::btScalar,::btVector3 &,::btVector3 & )
void btTransformUtil_calculateVelocityQuaternion(float* p0,float* p1,float* p2,float* p3,float p4,float* p5,float* p6) {
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btQuaternion tp2(p2[0],p2[1],p2[2],p2[3]);
	btQuaternion tp3(p3[0],p3[1],p3[2],p3[3]);
	btVector3 tp5(p5[0],p5[1],p5[2]);
	btVector3 tp6(p6[0],p6[1],p6[2]);
	::btTransformUtil::calculateVelocityQuaternion(tp0,tp1,tp2,tp3,p4,tp5,tp6);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.getX();p2[1]=tp2.getY();p2[2]=tp2.getZ();p2[3]=tp2.getW();
	p3[0]=tp3.getX();p3[1]=tp3.getY();p3[2]=tp3.getZ();p3[3]=tp3.getW();
	p5[0]=tp5.m_floats[0];p5[1]=tp5.m_floats[1];p5[2]=tp5.m_floats[2];
	p6[0]=tp6.m_floats[0];p6[1]=tp6.m_floats[1];p6[2]=tp6.m_floats[2];
}
//not supported method: calculateDiffAxisAngleQuaternion void (*)( ::btQuaternion const &,::btQuaternion const &,::btVector3 &,::btScalar & )
// error: ::btQuaternion const & - ok, ::btQuaternion const & - ok, ::btVector3 & - ok,  - unsupported, void - ok


// ::btTypedObject
//constructor: btTypedObject  ( ::btTypedObject::* )( int ) 
void* btTypedObject_new(int p0) {
	::btTypedObject *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTypedObject),16);
	o = new (mem)::btTypedObject(p0);
	return (void*)o;
}
void btTypedObject_free(void *c) {
	::btTypedObject *o = (::btTypedObject*)c;
	delete o;
}
//method: getObjectType int ( ::btTypedObject::* )(  ) const
int btTypedObject_getObjectType(void *c) {
	::btTypedObject *o = (::btTypedObject*)c;
	int retVal = (int)o->getObjectType();
	return retVal;
}
//attribute: int btTypedObject->m_objectType
void btTypedObject_m_objectType_set(void *c,int a) {
	::btTypedObject *o = (::btTypedObject*)c;
	o->m_objectType = a;
}
int btTypedObject_m_objectType_get(void *c) {
	::btTypedObject *o = (::btTypedObject*)c;
	return (int)(o->m_objectType);
}


// ::btVector3DoubleData
//constructor: btVector3DoubleData  ( ::btVector3DoubleData::* )(  ) 
void* btVector3DoubleData_new() {
	::btVector3DoubleData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btVector3DoubleData),16);
	o = new (mem)::btVector3DoubleData();
	return (void*)o;
}
void btVector3DoubleData_free(void *c) {
	::btVector3DoubleData *o = (::btVector3DoubleData*)c;
	delete o;
}
//attribute: double[4] btVector3DoubleData->m_floats
// attribute not supported: //attribute: double[4] btVector3DoubleData->m_floats

// ::btVector3FloatData
//constructor: btVector3FloatData  ( ::btVector3FloatData::* )(  ) 
void* btVector3FloatData_new() {
	::btVector3FloatData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btVector3FloatData),16);
	o = new (mem)::btVector3FloatData();
	return (void*)o;
}
void btVector3FloatData_free(void *c) {
	::btVector3FloatData *o = (::btVector3FloatData*)c;
	delete o;
}
//attribute: float[4] btVector3FloatData->m_floats
// attribute not supported: //attribute: float[4] btVector3FloatData->m_floats

// ::btAngularLimit
//constructor: btAngularLimit  ( ::btAngularLimit::* )(  ) 
void* btAngularLimit_new() {
	::btAngularLimit *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAngularLimit),16);
	o = new (mem)::btAngularLimit();
	return (void*)o;
}
void btAngularLimit_free(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	delete o;
}
//method: getCorrection ::btScalar ( ::btAngularLimit::* )(  ) const
float btAngularLimit_getCorrection(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	float retVal = (float)o->getCorrection();
	return retVal;
}
//method: set void ( ::btAngularLimit::* )( ::btScalar,::btScalar,::btScalar,::btScalar,::btScalar ) 
void btAngularLimit_set(void *c,float p0,float p1,float p2,float p3,float p4) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	o->set(p0,p1,p2,p3,p4);
}
//method: getError ::btScalar ( ::btAngularLimit::* )(  ) const
float btAngularLimit_getError(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	float retVal = (float)o->getError();
	return retVal;
}
//not supported method: fit void ( ::btAngularLimit::* )( ::btScalar & ) const
// error:  - unsupported, void - ok

//method: isLimit bool ( ::btAngularLimit::* )(  ) const
int btAngularLimit_isLimit(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	int retVal = (int)o->isLimit();
	return retVal;
}
//method: getSign ::btScalar ( ::btAngularLimit::* )(  ) const
float btAngularLimit_getSign(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	float retVal = (float)o->getSign();
	return retVal;
}
//method: getBiasFactor ::btScalar ( ::btAngularLimit::* )(  ) const
float btAngularLimit_getBiasFactor(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	float retVal = (float)o->getBiasFactor();
	return retVal;
}
//method: getSoftness ::btScalar ( ::btAngularLimit::* )(  ) const
float btAngularLimit_getSoftness(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	float retVal = (float)o->getSoftness();
	return retVal;
}
//method: getHigh ::btScalar ( ::btAngularLimit::* )(  ) const
float btAngularLimit_getHigh(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	float retVal = (float)o->getHigh();
	return retVal;
}
//not supported method: test void ( ::btAngularLimit::* )( ::btScalar const ) 
// error:  - unsupported, void - ok

//method: getHalfRange ::btScalar ( ::btAngularLimit::* )(  ) const
float btAngularLimit_getHalfRange(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	float retVal = (float)o->getHalfRange();
	return retVal;
}
//method: getLow ::btScalar ( ::btAngularLimit::* )(  ) const
float btAngularLimit_getLow(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	float retVal = (float)o->getLow();
	return retVal;
}
//method: getRelaxationFactor ::btScalar ( ::btAngularLimit::* )(  ) const
float btAngularLimit_getRelaxationFactor(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	float retVal = (float)o->getRelaxationFactor();
	return retVal;
}
//attribute: ::btScalar btAngularLimit->m_center
void btAngularLimit_m_center_set(void *c,float a) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	o->m_center = a;
}
float btAngularLimit_m_center_get(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	return (float)(o->m_center);
}

//attribute: ::btScalar btAngularLimit->m_halfRange
void btAngularLimit_m_halfRange_set(void *c,float a) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	o->m_halfRange = a;
}
float btAngularLimit_m_halfRange_get(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	return (float)(o->m_halfRange);
}

//attribute: ::btScalar btAngularLimit->m_softness
void btAngularLimit_m_softness_set(void *c,float a) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	o->m_softness = a;
}
float btAngularLimit_m_softness_get(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	return (float)(o->m_softness);
}

//attribute: ::btScalar btAngularLimit->m_biasFactor
void btAngularLimit_m_biasFactor_set(void *c,float a) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	o->m_biasFactor = a;
}
float btAngularLimit_m_biasFactor_get(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	return (float)(o->m_biasFactor);
}

//attribute: ::btScalar btAngularLimit->m_relaxationFactor
void btAngularLimit_m_relaxationFactor_set(void *c,float a) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	o->m_relaxationFactor = a;
}
float btAngularLimit_m_relaxationFactor_get(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	return (float)(o->m_relaxationFactor);
}

//attribute: ::btScalar btAngularLimit->m_correction
void btAngularLimit_m_correction_set(void *c,float a) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	o->m_correction = a;
}
float btAngularLimit_m_correction_get(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	return (float)(o->m_correction);
}

//attribute: ::btScalar btAngularLimit->m_sign
void btAngularLimit_m_sign_set(void *c,float a) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	o->m_sign = a;
}
float btAngularLimit_m_sign_get(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	return (float)(o->m_sign);
}

//attribute: bool btAngularLimit->m_solveLimit
void btAngularLimit_m_solveLimit_set(void *c,int a) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	o->m_solveLimit = a;
}
int btAngularLimit_m_solveLimit_get(void *c) {
	::btAngularLimit *o = (::btAngularLimit*)c;
	return (int)(o->m_solveLimit);
}


// ::btConeTwistConstraint
//constructor: btConeTwistConstraint  ( ::btConeTwistConstraint::* )( ::btRigidBody &,::btRigidBody &,::btTransform const &,::btTransform const & ) 
void* btConeTwistConstraint_new0(void* p0,void* p1,float* p2,float* p3) {
	::btConeTwistConstraint *o = 0;
	 void *mem = 0;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	mem = btAlignedAlloc(sizeof(::btConeTwistConstraint),16);
	o = new (mem)::btConeTwistConstraint(tp0,tp1,tp2,tp3);
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
	return (void*)o;
}
//constructor: btConeTwistConstraint  ( ::btConeTwistConstraint::* )( ::btRigidBody &,::btTransform const & ) 
void* btConeTwistConstraint_new1(void* p0,float* p1) {
	::btConeTwistConstraint *o = 0;
	 void *mem = 0;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	mem = btAlignedAlloc(sizeof(::btConeTwistConstraint),16);
	o = new (mem)::btConeTwistConstraint(tp0,tp1);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	return (void*)o;
}
void btConeTwistConstraint_free(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	delete o;
}
//method: getRigidBodyB ::btRigidBody const & ( ::btConeTwistConstraint::* )(  ) const
void* btConeTwistConstraint_getRigidBodyB(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyB());
	return retVal;
}
//method: buildJacobian void ( ::btConeTwistConstraint::* )(  ) 
void btConeTwistConstraint_buildJacobian(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->buildJacobian();
}
//method: getRigidBodyA ::btRigidBody const & ( ::btConeTwistConstraint::* )(  ) const
void* btConeTwistConstraint_getRigidBodyA(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyA());
	return retVal;
}
//method: adjustSwingAxisToUseEllipseNormal void ( ::btConeTwistConstraint::* )( ::btVector3 & ) const
void btConeTwistConstraint_adjustSwingAxisToUseEllipseNormal(void *c,float* p0) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->adjustSwingAxisToUseEllipseNormal(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: isPastSwingLimit bool ( ::btConeTwistConstraint::* )(  ) 
int btConeTwistConstraint_isPastSwingLimit(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	int retVal = (int)o->isPastSwingLimit();
	return retVal;
}
//method: getFrameOffsetA ::btTransform const & ( ::btConeTwistConstraint::* )(  ) const
void btConeTwistConstraint_getFrameOffsetA(void *c,float* ret) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetA();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getFrameOffsetB ::btTransform const & ( ::btConeTwistConstraint::* )(  ) const
void btConeTwistConstraint_getFrameOffsetB(void *c,float* ret) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetB();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getInfo2NonVirtual void ( ::btConeTwistConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,::btTransform const &,::btTransform const &,::btMatrix3x3 const &,::btMatrix3x3 const & ) 
void btConeTwistConstraint_getInfo2NonVirtual(void *c,void* p0,float* p1,float* p2,float* p3,float* p4) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btMatrix3x3 tp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btMatrix3x3 tp4(p4[0],p4[1],p4[2],p4[3],p4[4],p4[5],p4[6],p4[7],p4[8]);
	o->getInfo2NonVirtual(tp0,tp1,tp2,tp3,tp4);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.getRow(0).m_floats[0];p3[1]=tp3.getRow(0).m_floats[1];p3[2]=tp3.getRow(0).m_floats[2];p3[3]=tp3.getRow(1).m_floats[0];p3[4]=tp3.getRow(1).m_floats[1];p3[5]=tp3.getRow(1).m_floats[2];p3[6]=tp3.getRow(2).m_floats[0];p3[7]=tp3.getRow(2).m_floats[1];p3[8]=tp3.getRow(2).m_floats[2];
	p4[0]=tp4.getRow(0).m_floats[0];p4[1]=tp4.getRow(0).m_floats[1];p4[2]=tp4.getRow(0).m_floats[2];p4[3]=tp4.getRow(1).m_floats[0];p4[4]=tp4.getRow(1).m_floats[1];p4[5]=tp4.getRow(1).m_floats[2];p4[6]=tp4.getRow(2).m_floats[0];p4[7]=tp4.getRow(2).m_floats[1];p4[8]=tp4.getRow(2).m_floats[2];
}
//method: getSwingSpan1 ::btScalar ( ::btConeTwistConstraint::* )(  ) 
float btConeTwistConstraint_getSwingSpan1(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	float retVal = (float)o->getSwingSpan1();
	return retVal;
}
//method: calcAngleInfo2 void ( ::btConeTwistConstraint::* )( ::btTransform const &,::btTransform const &,::btMatrix3x3 const &,::btMatrix3x3 const & ) 
void btConeTwistConstraint_calcAngleInfo2(void *c,float* p0,float* p1,float* p2,float* p3) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btMatrix3x3 tp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btMatrix3x3 tp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	o->calcAngleInfo2(tp0,tp1,tp2,tp3);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.getRow(0).m_floats[0];p2[1]=tp2.getRow(0).m_floats[1];p2[2]=tp2.getRow(0).m_floats[2];p2[3]=tp2.getRow(1).m_floats[0];p2[4]=tp2.getRow(1).m_floats[1];p2[5]=tp2.getRow(1).m_floats[2];p2[6]=tp2.getRow(2).m_floats[0];p2[7]=tp2.getRow(2).m_floats[1];p2[8]=tp2.getRow(2).m_floats[2];
	p3[0]=tp3.getRow(0).m_floats[0];p3[1]=tp3.getRow(0).m_floats[1];p3[2]=tp3.getRow(0).m_floats[2];p3[3]=tp3.getRow(1).m_floats[0];p3[4]=tp3.getRow(1).m_floats[1];p3[5]=tp3.getRow(1).m_floats[2];p3[6]=tp3.getRow(2).m_floats[0];p3[7]=tp3.getRow(2).m_floats[1];p3[8]=tp3.getRow(2).m_floats[2];
}
//not supported method: computeConeLimitInfo void ( ::btConeTwistConstraint::* )( ::btQuaternion const &,::btScalar &,::btVector3 &,::btScalar & ) 
// error: ::btQuaternion const & - ok,  - unsupported, ::btVector3 & - ok,  - unsupported, void - ok

//method: getParam ::btScalar ( ::btConeTwistConstraint::* )( int,int ) const
float btConeTwistConstraint_getParam(void *c,int p0,int p1) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	float retVal = (float)o->getParam(p0,p1);
	return retVal;
}
//method: setDamping void ( ::btConeTwistConstraint::* )( ::btScalar ) 
void btConeTwistConstraint_setDamping(void *c,float p0) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->setDamping(p0);
}
//method: getInfo1 void ( ::btConeTwistConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btConeTwistConstraint_getInfo1(void *c,void* p0) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	::btTypedConstraint::btConstraintInfo1 * tp0 = (::btTypedConstraint::btConstraintInfo1 *)p0;
	o->getInfo1(tp0);
}
//method: getInfo2 void ( ::btConeTwistConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void btConeTwistConstraint_getInfo2(void *c,void* p0) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	o->getInfo2(tp0);
}
//method: setParam void ( ::btConeTwistConstraint::* )( int,::btScalar,int ) 
void btConeTwistConstraint_setParam(void *c,int p0,float p1,int p2) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->setParam(p0,p1,p2);
}
//method: calculateSerializeBufferSize int ( ::btConeTwistConstraint::* )(  ) const
int btConeTwistConstraint_calculateSerializeBufferSize(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//not supported method: computeTwistLimitInfo void ( ::btConeTwistConstraint::* )( ::btQuaternion const &,::btScalar &,::btVector3 & ) 
// error: ::btQuaternion const & - ok,  - unsupported, ::btVector3 & - ok, void - ok

//method: init void ( ::btConeTwistConstraint::* )(  ) 
void btConeTwistConstraint_init(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->init();
}
//method: getTwistAngle ::btScalar ( ::btConeTwistConstraint::* )(  ) 
float btConeTwistConstraint_getTwistAngle(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	float retVal = (float)o->getTwistAngle();
	return retVal;
}
//method: setMaxMotorImpulseNormalized void ( ::btConeTwistConstraint::* )( ::btScalar ) 
void btConeTwistConstraint_setMaxMotorImpulseNormalized(void *c,float p0) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->setMaxMotorImpulseNormalized(p0);
}
//method: getSolveTwistLimit int ( ::btConeTwistConstraint::* )(  ) 
int btConeTwistConstraint_getSolveTwistLimit(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	int retVal = (int)o->getSolveTwistLimit();
	return retVal;
}
//method: enableMotor void ( ::btConeTwistConstraint::* )( bool ) 
void btConeTwistConstraint_enableMotor(void *c,int p0) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->enableMotor(p0);
}
//method: getBFrame ::btTransform const & ( ::btConeTwistConstraint::* )(  ) 
void btConeTwistConstraint_getBFrame(void *c,float* ret) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getBFrame();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getInfo1NonVirtual void ( ::btConeTwistConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btConeTwistConstraint_getInfo1NonVirtual(void *c,void* p0) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	::btTypedConstraint::btConstraintInfo1 * tp0 = (::btTypedConstraint::btConstraintInfo1 *)p0;
	o->getInfo1NonVirtual(tp0);
}
//method: serialize char const * ( ::btConeTwistConstraint::* )( void *,::btSerializer * ) const
char const * btConeTwistConstraint_serialize(void *c,void* p0,void* p1) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: getFixThresh ::btScalar ( ::btConeTwistConstraint::* )(  ) 
float btConeTwistConstraint_getFixThresh(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	float retVal = (float)o->getFixThresh();
	return retVal;
}
//method: getSolveSwingLimit int ( ::btConeTwistConstraint::* )(  ) 
int btConeTwistConstraint_getSolveSwingLimit(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	int retVal = (int)o->getSolveSwingLimit();
	return retVal;
}
//method: getSwingSpan2 ::btScalar ( ::btConeTwistConstraint::* )(  ) 
float btConeTwistConstraint_getSwingSpan2(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	float retVal = (float)o->getSwingSpan2();
	return retVal;
}
//method: setAngularOnly void ( ::btConeTwistConstraint::* )( bool ) 
void btConeTwistConstraint_setAngularOnly(void *c,int p0) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->setAngularOnly(p0);
}
//method: setFrames void ( ::btConeTwistConstraint::* )( ::btTransform const &,::btTransform const & ) 
void btConeTwistConstraint_setFrames(void *c,float* p0,float* p1) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->setFrames(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: setLimit void ( ::btConeTwistConstraint::* )( int,::btScalar ) 
void btConeTwistConstraint_setLimit(void *c,int p0,float p1) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->setLimit(p0,p1);
}
//method: setLimit void ( ::btConeTwistConstraint::* )( int,::btScalar ) 
void btConeTwistConstraint_setLimit0(void *c,int p0,float p1) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->setLimit(p0,p1);
}
//method: setLimit void ( ::btConeTwistConstraint::* )( ::btScalar,::btScalar,::btScalar,::btScalar,::btScalar,::btScalar ) 
void btConeTwistConstraint_setLimit1(void *c,float p0,float p1,float p2,float p3,float p4,float p5) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->setLimit(p0,p1,p2,p3,p4,p5);
}
//method: getTwistLimitSign ::btScalar ( ::btConeTwistConstraint::* )(  ) 
float btConeTwistConstraint_getTwistLimitSign(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	float retVal = (float)o->getTwistLimitSign();
	return retVal;
}
//method: setMaxMotorImpulse void ( ::btConeTwistConstraint::* )( ::btScalar ) 
void btConeTwistConstraint_setMaxMotorImpulse(void *c,float p0) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->setMaxMotorImpulse(p0);
}
//method: calcAngleInfo void ( ::btConeTwistConstraint::* )(  ) 
void btConeTwistConstraint_calcAngleInfo(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->calcAngleInfo();
}
//method: setMotorTarget void ( ::btConeTwistConstraint::* )( ::btQuaternion const & ) 
void btConeTwistConstraint_setMotorTarget(void *c,float* p0) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btQuaternion tp0(p0[0],p0[1],p0[2],p0[3]);
	o->setMotorTarget(tp0);
	p0[0]=tp0.getX();p0[1]=tp0.getY();p0[2]=tp0.getZ();p0[3]=tp0.getW();
}
//method: setFixThresh void ( ::btConeTwistConstraint::* )( ::btScalar ) 
void btConeTwistConstraint_setFixThresh(void *c,float p0) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->setFixThresh(p0);
}
//method: setMotorTargetInConstraintSpace void ( ::btConeTwistConstraint::* )( ::btQuaternion const & ) 
void btConeTwistConstraint_setMotorTargetInConstraintSpace(void *c,float* p0) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btQuaternion tp0(p0[0],p0[1],p0[2],p0[3]);
	o->setMotorTargetInConstraintSpace(tp0);
	p0[0]=tp0.getX();p0[1]=tp0.getY();p0[2]=tp0.getZ();p0[3]=tp0.getW();
}
//method: solveConstraintObsolete void ( ::btConeTwistConstraint::* )( ::btRigidBody &,::btRigidBody &,::btScalar ) 
void btConeTwistConstraint_solveConstraintObsolete(void *c,void* p0,void* p1,float p2) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	o->solveConstraintObsolete(tp0,tp1,p2);
}
//method: GetPointForAngle ::btVector3 ( ::btConeTwistConstraint::* )( ::btScalar,::btScalar ) const
void btConeTwistConstraint_GetPointForAngle(void *c,float p0,float p1,float* ret) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->GetPointForAngle(p0,p1);
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: updateRHS void ( ::btConeTwistConstraint::* )( ::btScalar ) 
void btConeTwistConstraint_updateRHS(void *c,float p0) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->updateRHS(p0);
}
//method: getTwistSpan ::btScalar ( ::btConeTwistConstraint::* )(  ) 
float btConeTwistConstraint_getTwistSpan(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	float retVal = (float)o->getTwistSpan();
	return retVal;
}
//method: getAFrame ::btTransform const & ( ::btConeTwistConstraint::* )(  ) 
void btConeTwistConstraint_getAFrame(void *c,float* ret) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getAFrame();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//attribute: ::btJacobianEntry[3] btConeTwistConstraint->m_jac
// attribute not supported: //attribute: ::btJacobianEntry[3] btConeTwistConstraint->m_jac
//attribute: ::btTransform btConeTwistConstraint->m_rbAFrame
void btConeTwistConstraint_m_rbAFrame_set(void *c,float* a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_rbAFrame = ta;
}
void btConeTwistConstraint_m_rbAFrame_get(void *c,float* a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	a[0]=(o->m_rbAFrame).getBasis().getRow(0).m_floats[0];a[1]=(o->m_rbAFrame).getBasis().getRow(0).m_floats[1];a[2]=(o->m_rbAFrame).getBasis().getRow(0).m_floats[2];a[3]=(o->m_rbAFrame).getBasis().getRow(1).m_floats[0];a[4]=(o->m_rbAFrame).getBasis().getRow(1).m_floats[1];a[5]=(o->m_rbAFrame).getBasis().getRow(1).m_floats[2];a[6]=(o->m_rbAFrame).getBasis().getRow(2).m_floats[0];a[7]=(o->m_rbAFrame).getBasis().getRow(2).m_floats[1];a[8]=(o->m_rbAFrame).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_rbAFrame).getOrigin().m_floats[0];a[10]=(o->m_rbAFrame).getOrigin().m_floats[1];a[11]=(o->m_rbAFrame).getOrigin().m_floats[2];
}

//attribute: ::btTransform btConeTwistConstraint->m_rbBFrame
void btConeTwistConstraint_m_rbBFrame_set(void *c,float* a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_rbBFrame = ta;
}
void btConeTwistConstraint_m_rbBFrame_get(void *c,float* a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	a[0]=(o->m_rbBFrame).getBasis().getRow(0).m_floats[0];a[1]=(o->m_rbBFrame).getBasis().getRow(0).m_floats[1];a[2]=(o->m_rbBFrame).getBasis().getRow(0).m_floats[2];a[3]=(o->m_rbBFrame).getBasis().getRow(1).m_floats[0];a[4]=(o->m_rbBFrame).getBasis().getRow(1).m_floats[1];a[5]=(o->m_rbBFrame).getBasis().getRow(1).m_floats[2];a[6]=(o->m_rbBFrame).getBasis().getRow(2).m_floats[0];a[7]=(o->m_rbBFrame).getBasis().getRow(2).m_floats[1];a[8]=(o->m_rbBFrame).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_rbBFrame).getOrigin().m_floats[0];a[10]=(o->m_rbBFrame).getOrigin().m_floats[1];a[11]=(o->m_rbBFrame).getOrigin().m_floats[2];
}

//attribute: ::btScalar btConeTwistConstraint->m_limitSoftness
void btConeTwistConstraint_m_limitSoftness_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_limitSoftness = a;
}
float btConeTwistConstraint_m_limitSoftness_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_limitSoftness);
}

//attribute: ::btScalar btConeTwistConstraint->m_biasFactor
void btConeTwistConstraint_m_biasFactor_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_biasFactor = a;
}
float btConeTwistConstraint_m_biasFactor_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_biasFactor);
}

//attribute: ::btScalar btConeTwistConstraint->m_relaxationFactor
void btConeTwistConstraint_m_relaxationFactor_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_relaxationFactor = a;
}
float btConeTwistConstraint_m_relaxationFactor_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_relaxationFactor);
}

//attribute: ::btScalar btConeTwistConstraint->m_damping
void btConeTwistConstraint_m_damping_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_damping = a;
}
float btConeTwistConstraint_m_damping_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_damping);
}

//attribute: ::btScalar btConeTwistConstraint->m_swingSpan1
void btConeTwistConstraint_m_swingSpan1_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_swingSpan1 = a;
}
float btConeTwistConstraint_m_swingSpan1_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_swingSpan1);
}

//attribute: ::btScalar btConeTwistConstraint->m_swingSpan2
void btConeTwistConstraint_m_swingSpan2_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_swingSpan2 = a;
}
float btConeTwistConstraint_m_swingSpan2_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_swingSpan2);
}

//attribute: ::btScalar btConeTwistConstraint->m_twistSpan
void btConeTwistConstraint_m_twistSpan_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_twistSpan = a;
}
float btConeTwistConstraint_m_twistSpan_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_twistSpan);
}

//attribute: ::btScalar btConeTwistConstraint->m_fixThresh
void btConeTwistConstraint_m_fixThresh_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_fixThresh = a;
}
float btConeTwistConstraint_m_fixThresh_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_fixThresh);
}

//attribute: ::btVector3 btConeTwistConstraint->m_swingAxis
void btConeTwistConstraint_m_swingAxis_set(void *c,float* a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_swingAxis = ta;
}
void btConeTwistConstraint_m_swingAxis_get(void *c,float* a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	a[0]=(o->m_swingAxis).m_floats[0];a[1]=(o->m_swingAxis).m_floats[1];a[2]=(o->m_swingAxis).m_floats[2];
}

//attribute: ::btVector3 btConeTwistConstraint->m_twistAxis
void btConeTwistConstraint_m_twistAxis_set(void *c,float* a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_twistAxis = ta;
}
void btConeTwistConstraint_m_twistAxis_get(void *c,float* a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	a[0]=(o->m_twistAxis).m_floats[0];a[1]=(o->m_twistAxis).m_floats[1];a[2]=(o->m_twistAxis).m_floats[2];
}

//attribute: ::btScalar btConeTwistConstraint->m_kSwing
void btConeTwistConstraint_m_kSwing_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_kSwing = a;
}
float btConeTwistConstraint_m_kSwing_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_kSwing);
}

//attribute: ::btScalar btConeTwistConstraint->m_kTwist
void btConeTwistConstraint_m_kTwist_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_kTwist = a;
}
float btConeTwistConstraint_m_kTwist_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_kTwist);
}

//attribute: ::btScalar btConeTwistConstraint->m_twistLimitSign
void btConeTwistConstraint_m_twistLimitSign_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_twistLimitSign = a;
}
float btConeTwistConstraint_m_twistLimitSign_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_twistLimitSign);
}

//attribute: ::btScalar btConeTwistConstraint->m_swingCorrection
void btConeTwistConstraint_m_swingCorrection_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_swingCorrection = a;
}
float btConeTwistConstraint_m_swingCorrection_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_swingCorrection);
}

//attribute: ::btScalar btConeTwistConstraint->m_twistCorrection
void btConeTwistConstraint_m_twistCorrection_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_twistCorrection = a;
}
float btConeTwistConstraint_m_twistCorrection_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_twistCorrection);
}

//attribute: ::btScalar btConeTwistConstraint->m_twistAngle
void btConeTwistConstraint_m_twistAngle_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_twistAngle = a;
}
float btConeTwistConstraint_m_twistAngle_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_twistAngle);
}

//attribute: ::btScalar btConeTwistConstraint->m_accSwingLimitImpulse
void btConeTwistConstraint_m_accSwingLimitImpulse_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_accSwingLimitImpulse = a;
}
float btConeTwistConstraint_m_accSwingLimitImpulse_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_accSwingLimitImpulse);
}

//attribute: ::btScalar btConeTwistConstraint->m_accTwistLimitImpulse
void btConeTwistConstraint_m_accTwistLimitImpulse_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_accTwistLimitImpulse = a;
}
float btConeTwistConstraint_m_accTwistLimitImpulse_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_accTwistLimitImpulse);
}

//attribute: bool btConeTwistConstraint->m_angularOnly
void btConeTwistConstraint_m_angularOnly_set(void *c,int a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_angularOnly = a;
}
int btConeTwistConstraint_m_angularOnly_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (int)(o->m_angularOnly);
}

//attribute: bool btConeTwistConstraint->m_solveTwistLimit
void btConeTwistConstraint_m_solveTwistLimit_set(void *c,int a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_solveTwistLimit = a;
}
int btConeTwistConstraint_m_solveTwistLimit_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (int)(o->m_solveTwistLimit);
}

//attribute: bool btConeTwistConstraint->m_solveSwingLimit
void btConeTwistConstraint_m_solveSwingLimit_set(void *c,int a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_solveSwingLimit = a;
}
int btConeTwistConstraint_m_solveSwingLimit_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (int)(o->m_solveSwingLimit);
}

//attribute: bool btConeTwistConstraint->m_useSolveConstraintObsolete
void btConeTwistConstraint_m_useSolveConstraintObsolete_set(void *c,int a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_useSolveConstraintObsolete = a;
}
int btConeTwistConstraint_m_useSolveConstraintObsolete_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (int)(o->m_useSolveConstraintObsolete);
}

//attribute: ::btScalar btConeTwistConstraint->m_swingLimitRatio
void btConeTwistConstraint_m_swingLimitRatio_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_swingLimitRatio = a;
}
float btConeTwistConstraint_m_swingLimitRatio_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_swingLimitRatio);
}

//attribute: ::btScalar btConeTwistConstraint->m_twistLimitRatio
void btConeTwistConstraint_m_twistLimitRatio_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_twistLimitRatio = a;
}
float btConeTwistConstraint_m_twistLimitRatio_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_twistLimitRatio);
}

//attribute: ::btVector3 btConeTwistConstraint->m_twistAxisA
void btConeTwistConstraint_m_twistAxisA_set(void *c,float* a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_twistAxisA = ta;
}
void btConeTwistConstraint_m_twistAxisA_get(void *c,float* a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	a[0]=(o->m_twistAxisA).m_floats[0];a[1]=(o->m_twistAxisA).m_floats[1];a[2]=(o->m_twistAxisA).m_floats[2];
}

//attribute: bool btConeTwistConstraint->m_bMotorEnabled
void btConeTwistConstraint_m_bMotorEnabled_set(void *c,int a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_bMotorEnabled = a;
}
int btConeTwistConstraint_m_bMotorEnabled_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (int)(o->m_bMotorEnabled);
}

//attribute: bool btConeTwistConstraint->m_bNormalizedMotorStrength
void btConeTwistConstraint_m_bNormalizedMotorStrength_set(void *c,int a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_bNormalizedMotorStrength = a;
}
int btConeTwistConstraint_m_bNormalizedMotorStrength_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (int)(o->m_bNormalizedMotorStrength);
}

//attribute: ::btQuaternion btConeTwistConstraint->m_qTarget
void btConeTwistConstraint_m_qTarget_set(void *c,float* a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btQuaternion ta(a[0],a[1],a[2],a[3]);
	o->m_qTarget = ta;
}
void btConeTwistConstraint_m_qTarget_get(void *c,float* a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	a[0]=(o->m_qTarget).getX();a[1]=(o->m_qTarget).getY();a[2]=(o->m_qTarget).getZ();a[3]=(o->m_qTarget).getW();
}

//attribute: ::btScalar btConeTwistConstraint->m_maxMotorImpulse
void btConeTwistConstraint_m_maxMotorImpulse_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_maxMotorImpulse = a;
}
float btConeTwistConstraint_m_maxMotorImpulse_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_maxMotorImpulse);
}

//attribute: ::btVector3 btConeTwistConstraint->m_accMotorImpulse
void btConeTwistConstraint_m_accMotorImpulse_set(void *c,float* a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_accMotorImpulse = ta;
}
void btConeTwistConstraint_m_accMotorImpulse_get(void *c,float* a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	a[0]=(o->m_accMotorImpulse).m_floats[0];a[1]=(o->m_accMotorImpulse).m_floats[1];a[2]=(o->m_accMotorImpulse).m_floats[2];
}

//attribute: int btConeTwistConstraint->m_flags
void btConeTwistConstraint_m_flags_set(void *c,int a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_flags = a;
}
int btConeTwistConstraint_m_flags_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (int)(o->m_flags);
}

//attribute: ::btScalar btConeTwistConstraint->m_linCFM
void btConeTwistConstraint_m_linCFM_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_linCFM = a;
}
float btConeTwistConstraint_m_linCFM_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_linCFM);
}

//attribute: ::btScalar btConeTwistConstraint->m_linERP
void btConeTwistConstraint_m_linERP_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_linERP = a;
}
float btConeTwistConstraint_m_linERP_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_linERP);
}

//attribute: ::btScalar btConeTwistConstraint->m_angCFM
void btConeTwistConstraint_m_angCFM_set(void *c,float a) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	o->m_angCFM = a;
}
float btConeTwistConstraint_m_angCFM_get(void *c) {
	::btConeTwistConstraint *o = (::btConeTwistConstraint*)c;
	return (float)(o->m_angCFM);
}


// ::btConeTwistConstraintData
//constructor: btConeTwistConstraintData  ( ::btConeTwistConstraintData::* )(  ) 
void* btConeTwistConstraintData_new() {
	::btConeTwistConstraintData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btConeTwistConstraintData),16);
	o = new (mem)::btConeTwistConstraintData();
	return (void*)o;
}
void btConeTwistConstraintData_free(void *c) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	delete o;
}
//attribute: ::btTypedConstraintData btConeTwistConstraintData->m_typeConstraintData
void btConeTwistConstraintData_m_typeConstraintData_set(void *c,void* a) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	::btTypedConstraintData & ta = *(::btTypedConstraintData *)a;
	o->m_typeConstraintData = ta;
}
void* btConeTwistConstraintData_m_typeConstraintData_get(void *c) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	return (void*)&(o->m_typeConstraintData);
}

//attribute: ::btTransformFloatData btConeTwistConstraintData->m_rbAFrame
void btConeTwistConstraintData_m_rbAFrame_set(void *c,void* a) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	::btTransformFloatData & ta = *(::btTransformFloatData *)a;
	o->m_rbAFrame = ta;
}
void* btConeTwistConstraintData_m_rbAFrame_get(void *c) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	return (void*)&(o->m_rbAFrame);
}

//attribute: ::btTransformFloatData btConeTwistConstraintData->m_rbBFrame
void btConeTwistConstraintData_m_rbBFrame_set(void *c,void* a) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	::btTransformFloatData & ta = *(::btTransformFloatData *)a;
	o->m_rbBFrame = ta;
}
void* btConeTwistConstraintData_m_rbBFrame_get(void *c) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	return (void*)&(o->m_rbBFrame);
}

//attribute: float btConeTwistConstraintData->m_swingSpan1
void btConeTwistConstraintData_m_swingSpan1_set(void *c,float a) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	o->m_swingSpan1 = a;
}
float btConeTwistConstraintData_m_swingSpan1_get(void *c) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	return (float)(o->m_swingSpan1);
}

//attribute: float btConeTwistConstraintData->m_swingSpan2
void btConeTwistConstraintData_m_swingSpan2_set(void *c,float a) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	o->m_swingSpan2 = a;
}
float btConeTwistConstraintData_m_swingSpan2_get(void *c) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	return (float)(o->m_swingSpan2);
}

//attribute: float btConeTwistConstraintData->m_twistSpan
void btConeTwistConstraintData_m_twistSpan_set(void *c,float a) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	o->m_twistSpan = a;
}
float btConeTwistConstraintData_m_twistSpan_get(void *c) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	return (float)(o->m_twistSpan);
}

//attribute: float btConeTwistConstraintData->m_limitSoftness
void btConeTwistConstraintData_m_limitSoftness_set(void *c,float a) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	o->m_limitSoftness = a;
}
float btConeTwistConstraintData_m_limitSoftness_get(void *c) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	return (float)(o->m_limitSoftness);
}

//attribute: float btConeTwistConstraintData->m_biasFactor
void btConeTwistConstraintData_m_biasFactor_set(void *c,float a) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	o->m_biasFactor = a;
}
float btConeTwistConstraintData_m_biasFactor_get(void *c) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	return (float)(o->m_biasFactor);
}

//attribute: float btConeTwistConstraintData->m_relaxationFactor
void btConeTwistConstraintData_m_relaxationFactor_set(void *c,float a) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	o->m_relaxationFactor = a;
}
float btConeTwistConstraintData_m_relaxationFactor_get(void *c) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	return (float)(o->m_relaxationFactor);
}

//attribute: float btConeTwistConstraintData->m_damping
void btConeTwistConstraintData_m_damping_set(void *c,float a) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	o->m_damping = a;
}
float btConeTwistConstraintData_m_damping_get(void *c) {
	::btConeTwistConstraintData *o = (::btConeTwistConstraintData*)c;
	return (float)(o->m_damping);
}

//attribute: char[4] btConeTwistConstraintData->m_pad
// attribute not supported: //attribute: char[4] btConeTwistConstraintData->m_pad

// ::btTypedConstraint::btConstraintInfo1
//constructor: btConstraintInfo1  ( ::btTypedConstraint::btConstraintInfo1::* )(  ) 
void* btTypedConstraint_btConstraintInfo1_new() {
	::btTypedConstraint::btConstraintInfo1 *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTypedConstraint::btConstraintInfo1),16);
	o = new (mem)::btTypedConstraint::btConstraintInfo1();
	return (void*)o;
}
void btTypedConstraint_btConstraintInfo1_free(void *c) {
	::btTypedConstraint::btConstraintInfo1 *o = (::btTypedConstraint::btConstraintInfo1*)c;
	delete o;
}
//attribute: int btTypedConstraint_btConstraintInfo1->m_numConstraintRows
void btTypedConstraint_btConstraintInfo1_m_numConstraintRows_set(void *c,int a) {
	::btTypedConstraint::btConstraintInfo1 *o = (::btTypedConstraint::btConstraintInfo1*)c;
	o->m_numConstraintRows = a;
}
int btTypedConstraint_btConstraintInfo1_m_numConstraintRows_get(void *c) {
	::btTypedConstraint::btConstraintInfo1 *o = (::btTypedConstraint::btConstraintInfo1*)c;
	return (int)(o->m_numConstraintRows);
}

//attribute: int btTypedConstraint_btConstraintInfo1->nub
void btTypedConstraint_btConstraintInfo1_nub_set(void *c,int a) {
	::btTypedConstraint::btConstraintInfo1 *o = (::btTypedConstraint::btConstraintInfo1*)c;
	o->nub = a;
}
int btTypedConstraint_btConstraintInfo1_nub_get(void *c) {
	::btTypedConstraint::btConstraintInfo1 *o = (::btTypedConstraint::btConstraintInfo1*)c;
	return (int)(o->nub);
}


// ::btTypedConstraint::btConstraintInfo2
//constructor: btConstraintInfo2  ( ::btTypedConstraint::btConstraintInfo2::* )(  ) 
void* btTypedConstraint_btConstraintInfo2_new() {
	::btTypedConstraint::btConstraintInfo2 *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTypedConstraint::btConstraintInfo2),16);
	o = new (mem)::btTypedConstraint::btConstraintInfo2();
	return (void*)o;
}
void btTypedConstraint_btConstraintInfo2_free(void *c) {
	::btTypedConstraint::btConstraintInfo2 *o = (::btTypedConstraint::btConstraintInfo2*)c;
	delete o;
}
//attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->cfm
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->cfm
//attribute: ::btScalar btTypedConstraint_btConstraintInfo2->erp
void btTypedConstraint_btConstraintInfo2_erp_set(void *c,float a) {
	::btTypedConstraint::btConstraintInfo2 *o = (::btTypedConstraint::btConstraintInfo2*)c;
	o->erp = a;
}
float btTypedConstraint_btConstraintInfo2_erp_get(void *c) {
	::btTypedConstraint::btConstraintInfo2 *o = (::btTypedConstraint::btConstraintInfo2*)c;
	return (float)(o->erp);
}

//attribute: int * btTypedConstraint_btConstraintInfo2->findex
// attribute not supported: //attribute: int * btTypedConstraint_btConstraintInfo2->findex
//attribute: ::btScalar btTypedConstraint_btConstraintInfo2->fps
void btTypedConstraint_btConstraintInfo2_fps_set(void *c,float a) {
	::btTypedConstraint::btConstraintInfo2 *o = (::btTypedConstraint::btConstraintInfo2*)c;
	o->fps = a;
}
float btTypedConstraint_btConstraintInfo2_fps_get(void *c) {
	::btTypedConstraint::btConstraintInfo2 *o = (::btTypedConstraint::btConstraintInfo2*)c;
	return (float)(o->fps);
}

//attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_J1angularAxis
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_J1angularAxis
//attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_J1linearAxis
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_J1linearAxis
//attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_J2angularAxis
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_J2angularAxis
//attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_J2linearAxis
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_J2linearAxis
//attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_constraintError
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_constraintError
//attribute: ::btScalar btTypedConstraint_btConstraintInfo2->m_damping
void btTypedConstraint_btConstraintInfo2_m_damping_set(void *c,float a) {
	::btTypedConstraint::btConstraintInfo2 *o = (::btTypedConstraint::btConstraintInfo2*)c;
	o->m_damping = a;
}
float btTypedConstraint_btConstraintInfo2_m_damping_get(void *c) {
	::btTypedConstraint::btConstraintInfo2 *o = (::btTypedConstraint::btConstraintInfo2*)c;
	return (float)(o->m_damping);
}

//attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_lowerLimit
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_lowerLimit
//attribute: int btTypedConstraint_btConstraintInfo2->m_numIterations
void btTypedConstraint_btConstraintInfo2_m_numIterations_set(void *c,int a) {
	::btTypedConstraint::btConstraintInfo2 *o = (::btTypedConstraint::btConstraintInfo2*)c;
	o->m_numIterations = a;
}
int btTypedConstraint_btConstraintInfo2_m_numIterations_get(void *c) {
	::btTypedConstraint::btConstraintInfo2 *o = (::btTypedConstraint::btConstraintInfo2*)c;
	return (int)(o->m_numIterations);
}

//attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_upperLimit
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_upperLimit
//attribute: int btTypedConstraint_btConstraintInfo2->rowskip
void btTypedConstraint_btConstraintInfo2_rowskip_set(void *c,int a) {
	::btTypedConstraint::btConstraintInfo2 *o = (::btTypedConstraint::btConstraintInfo2*)c;
	o->rowskip = a;
}
int btTypedConstraint_btConstraintInfo2_rowskip_get(void *c) {
	::btTypedConstraint::btConstraintInfo2 *o = (::btTypedConstraint::btConstraintInfo2*)c;
	return (int)(o->rowskip);
}


// ::btConstraintSetting
//constructor: btConstraintSetting  ( ::btConstraintSetting::* )(  ) 
void* btConstraintSetting_new() {
	::btConstraintSetting *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btConstraintSetting),16);
	o = new (mem)::btConstraintSetting();
	return (void*)o;
}
void btConstraintSetting_free(void *c) {
	::btConstraintSetting *o = (::btConstraintSetting*)c;
	delete o;
}
//attribute: ::btScalar btConstraintSetting->m_tau
void btConstraintSetting_m_tau_set(void *c,float a) {
	::btConstraintSetting *o = (::btConstraintSetting*)c;
	o->m_tau = a;
}
float btConstraintSetting_m_tau_get(void *c) {
	::btConstraintSetting *o = (::btConstraintSetting*)c;
	return (float)(o->m_tau);
}

//attribute: ::btScalar btConstraintSetting->m_damping
void btConstraintSetting_m_damping_set(void *c,float a) {
	::btConstraintSetting *o = (::btConstraintSetting*)c;
	o->m_damping = a;
}
float btConstraintSetting_m_damping_get(void *c) {
	::btConstraintSetting *o = (::btConstraintSetting*)c;
	return (float)(o->m_damping);
}

//attribute: ::btScalar btConstraintSetting->m_impulseClamp
void btConstraintSetting_m_impulseClamp_set(void *c,float a) {
	::btConstraintSetting *o = (::btConstraintSetting*)c;
	o->m_impulseClamp = a;
}
float btConstraintSetting_m_impulseClamp_get(void *c) {
	::btConstraintSetting *o = (::btConstraintSetting*)c;
	return (float)(o->m_impulseClamp);
}


// ::btConstraintSolver
//method: reset void ( ::btConstraintSolver::* )(  ) 
void btConstraintSolver_reset(void *c) {
	::btConstraintSolver *o = (::btConstraintSolver*)c;
	o->reset();
}
//method: allSolved void ( ::btConstraintSolver::* )( ::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc * ) 
void btConstraintSolver_allSolved(void *c,void* p0,void* p1,void* p2) {
	::btConstraintSolver *o = (::btConstraintSolver*)c;
	::btContactSolverInfo const & tp0 = *(::btContactSolverInfo const *)p0;
	::btIDebugDraw * tp1 = (::btIDebugDraw *)p1;
	::btStackAlloc * tp2 = (::btStackAlloc *)p2;
	o->allSolved(tp0,tp1,tp2);
}
//not supported method: solveGroup ::btScalar ( ::btConstraintSolver::* )( ::btCollisionObject * *,int,::btPersistentManifold * *,int,::btTypedConstraint * *,int,::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc *,::btDispatcher * ) 
// error:  - unsupported, int - ok,  - unsupported, int - ok,  - unsupported, int - ok, ::btContactSolverInfo const & - ok, ::btIDebugDraw * - ok, ::btStackAlloc * - ok, ::btDispatcher * - ok, ::btScalar - ok

//method: prepareSolve void ( ::btConstraintSolver::* )( int,int ) 
void btConstraintSolver_prepareSolve(void *c,int p0,int p1) {
	::btConstraintSolver *o = (::btConstraintSolver*)c;
	o->prepareSolve(p0,p1);
}

// ::btContactConstraint
//method: getInfo1 void ( ::btContactConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btContactConstraint_getInfo1(void *c,void* p0) {
	::btContactConstraint *o = (::btContactConstraint*)c;
	::btTypedConstraint::btConstraintInfo1 * tp0 = (::btTypedConstraint::btConstraintInfo1 *)p0;
	o->getInfo1(tp0);
}
//method: setContactManifold void ( ::btContactConstraint::* )( ::btPersistentManifold * ) 
void btContactConstraint_setContactManifold(void *c,void* p0) {
	::btContactConstraint *o = (::btContactConstraint*)c;
	::btPersistentManifold * tp0 = (::btPersistentManifold *)p0;
	o->setContactManifold(tp0);
}
//method: buildJacobian void ( ::btContactConstraint::* )(  ) 
void btContactConstraint_buildJacobian(void *c) {
	::btContactConstraint *o = (::btContactConstraint*)c;
	o->buildJacobian();
}
//method: getInfo2 void ( ::btContactConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void btContactConstraint_getInfo2(void *c,void* p0) {
	::btContactConstraint *o = (::btContactConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	o->getInfo2(tp0);
}
//method: getContactManifold ::btPersistentManifold * ( ::btContactConstraint::* )(  ) 
void* btContactConstraint_getContactManifold(void *c) {
	::btContactConstraint *o = (::btContactConstraint*)c;
	void* retVal = (void*) o->getContactManifold();
	return retVal;
}
//method: getContactManifold ::btPersistentManifold * ( ::btContactConstraint::* )(  ) 
void* btContactConstraint_getContactManifold0(void *c) {
	::btContactConstraint *o = (::btContactConstraint*)c;
	void* retVal = (void*) o->getContactManifold();
	return retVal;
}
//method: getContactManifold ::btPersistentManifold const * ( ::btContactConstraint::* )(  ) const
void* btContactConstraint_getContactManifold1(void *c) {
	::btContactConstraint *o = (::btContactConstraint*)c;
	void* retVal = (void*) o->getContactManifold();
	return retVal;
}
//attribute: ::btPersistentManifold btContactConstraint->m_contactManifold
void btContactConstraint_m_contactManifold_set(void *c,void* a) {
	::btContactConstraint *o = (::btContactConstraint*)c;
	::btPersistentManifold & ta = *(::btPersistentManifold *)a;
	o->m_contactManifold = ta;
}
void* btContactConstraint_m_contactManifold_get(void *c) {
	::btContactConstraint *o = (::btContactConstraint*)c;
	return (void*)&(o->m_contactManifold);
}


// ::btContactSolverInfo
//constructor: btContactSolverInfo  ( ::btContactSolverInfo::* )(  ) 
void* btContactSolverInfo_new() {
	::btContactSolverInfo *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btContactSolverInfo),16);
	o = new (mem)::btContactSolverInfo();
	return (void*)o;
}
void btContactSolverInfo_free(void *c) {
	::btContactSolverInfo *o = (::btContactSolverInfo*)c;
	delete o;
}

// ::btContactSolverInfoData
//constructor: btContactSolverInfoData  ( ::btContactSolverInfoData::* )(  ) 
void* btContactSolverInfoData_new() {
	::btContactSolverInfoData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btContactSolverInfoData),16);
	o = new (mem)::btContactSolverInfoData();
	return (void*)o;
}
void btContactSolverInfoData_free(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	delete o;
}
//attribute: ::btScalar btContactSolverInfoData->m_tau
void btContactSolverInfoData_m_tau_set(void *c,float a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_tau = a;
}
float btContactSolverInfoData_m_tau_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (float)(o->m_tau);
}

//attribute: ::btScalar btContactSolverInfoData->m_damping
void btContactSolverInfoData_m_damping_set(void *c,float a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_damping = a;
}
float btContactSolverInfoData_m_damping_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (float)(o->m_damping);
}

//attribute: ::btScalar btContactSolverInfoData->m_friction
void btContactSolverInfoData_m_friction_set(void *c,float a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_friction = a;
}
float btContactSolverInfoData_m_friction_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (float)(o->m_friction);
}

//attribute: ::btScalar btContactSolverInfoData->m_timeStep
void btContactSolverInfoData_m_timeStep_set(void *c,float a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_timeStep = a;
}
float btContactSolverInfoData_m_timeStep_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (float)(o->m_timeStep);
}

//attribute: ::btScalar btContactSolverInfoData->m_restitution
void btContactSolverInfoData_m_restitution_set(void *c,float a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_restitution = a;
}
float btContactSolverInfoData_m_restitution_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (float)(o->m_restitution);
}

//attribute: int btContactSolverInfoData->m_numIterations
void btContactSolverInfoData_m_numIterations_set(void *c,int a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_numIterations = a;
}
int btContactSolverInfoData_m_numIterations_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (int)(o->m_numIterations);
}

//attribute: ::btScalar btContactSolverInfoData->m_maxErrorReduction
void btContactSolverInfoData_m_maxErrorReduction_set(void *c,float a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_maxErrorReduction = a;
}
float btContactSolverInfoData_m_maxErrorReduction_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (float)(o->m_maxErrorReduction);
}

//attribute: ::btScalar btContactSolverInfoData->m_sor
void btContactSolverInfoData_m_sor_set(void *c,float a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_sor = a;
}
float btContactSolverInfoData_m_sor_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (float)(o->m_sor);
}

//attribute: ::btScalar btContactSolverInfoData->m_erp
void btContactSolverInfoData_m_erp_set(void *c,float a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_erp = a;
}
float btContactSolverInfoData_m_erp_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (float)(o->m_erp);
}

//attribute: ::btScalar btContactSolverInfoData->m_erp2
void btContactSolverInfoData_m_erp2_set(void *c,float a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_erp2 = a;
}
float btContactSolverInfoData_m_erp2_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (float)(o->m_erp2);
}

//attribute: ::btScalar btContactSolverInfoData->m_globalCfm
void btContactSolverInfoData_m_globalCfm_set(void *c,float a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_globalCfm = a;
}
float btContactSolverInfoData_m_globalCfm_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (float)(o->m_globalCfm);
}

//attribute: int btContactSolverInfoData->m_splitImpulse
void btContactSolverInfoData_m_splitImpulse_set(void *c,int a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_splitImpulse = a;
}
int btContactSolverInfoData_m_splitImpulse_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (int)(o->m_splitImpulse);
}

//attribute: ::btScalar btContactSolverInfoData->m_splitImpulsePenetrationThreshold
void btContactSolverInfoData_m_splitImpulsePenetrationThreshold_set(void *c,float a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_splitImpulsePenetrationThreshold = a;
}
float btContactSolverInfoData_m_splitImpulsePenetrationThreshold_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (float)(o->m_splitImpulsePenetrationThreshold);
}

//attribute: ::btScalar btContactSolverInfoData->m_linearSlop
void btContactSolverInfoData_m_linearSlop_set(void *c,float a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_linearSlop = a;
}
float btContactSolverInfoData_m_linearSlop_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (float)(o->m_linearSlop);
}

//attribute: ::btScalar btContactSolverInfoData->m_warmstartingFactor
void btContactSolverInfoData_m_warmstartingFactor_set(void *c,float a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_warmstartingFactor = a;
}
float btContactSolverInfoData_m_warmstartingFactor_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (float)(o->m_warmstartingFactor);
}

//attribute: int btContactSolverInfoData->m_solverMode
void btContactSolverInfoData_m_solverMode_set(void *c,int a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_solverMode = a;
}
int btContactSolverInfoData_m_solverMode_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (int)(o->m_solverMode);
}

//attribute: int btContactSolverInfoData->m_restingContactRestitutionThreshold
void btContactSolverInfoData_m_restingContactRestitutionThreshold_set(void *c,int a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_restingContactRestitutionThreshold = a;
}
int btContactSolverInfoData_m_restingContactRestitutionThreshold_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (int)(o->m_restingContactRestitutionThreshold);
}

//attribute: int btContactSolverInfoData->m_minimumSolverBatchSize
void btContactSolverInfoData_m_minimumSolverBatchSize_set(void *c,int a) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	o->m_minimumSolverBatchSize = a;
}
int btContactSolverInfoData_m_minimumSolverBatchSize_get(void *c) {
	::btContactSolverInfoData *o = (::btContactSolverInfoData*)c;
	return (int)(o->m_minimumSolverBatchSize);
}


// ::btGeneric6DofConstraint
//constructor: btGeneric6DofConstraint  ( ::btGeneric6DofConstraint::* )( ::btRigidBody &,::btRigidBody &,::btTransform const &,::btTransform const &,bool ) 
void* btGeneric6DofConstraint_new0(void* p0,void* p1,float* p2,float* p3,int p4) {
	::btGeneric6DofConstraint *o = 0;
	 void *mem = 0;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	mem = btAlignedAlloc(sizeof(::btGeneric6DofConstraint),16);
	o = new (mem)::btGeneric6DofConstraint(tp0,tp1,tp2,tp3,p4);
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
	return (void*)o;
}
//constructor: btGeneric6DofConstraint  ( ::btGeneric6DofConstraint::* )( ::btRigidBody &,::btTransform const &,bool ) 
void* btGeneric6DofConstraint_new1(void* p0,float* p1,int p2) {
	::btGeneric6DofConstraint *o = 0;
	 void *mem = 0;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	mem = btAlignedAlloc(sizeof(::btGeneric6DofConstraint),16);
	o = new (mem)::btGeneric6DofConstraint(tp0,tp1,p2);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	return (void*)o;
}
void btGeneric6DofConstraint_free(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	delete o;
}
//method: buildJacobian void ( ::btGeneric6DofConstraint::* )(  ) 
void btGeneric6DofConstraint_buildJacobian(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->buildJacobian();
}
//method: setParam void ( ::btGeneric6DofConstraint::* )( int,::btScalar,int ) 
void btGeneric6DofConstraint_setParam(void *c,int p0,float p1,int p2) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->setParam(p0,p1,p2);
}
//method: getInfo1NonVirtual void ( ::btGeneric6DofConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btGeneric6DofConstraint_getInfo1NonVirtual(void *c,void* p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	::btTypedConstraint::btConstraintInfo1 * tp0 = (::btTypedConstraint::btConstraintInfo1 *)p0;
	o->getInfo1NonVirtual(tp0);
}
//method: getFrameOffsetA ::btTransform const & ( ::btGeneric6DofConstraint::* )(  ) const
void btGeneric6DofConstraint_getFrameOffsetA(void *c,float* ret) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetA();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getFrameOffsetA ::btTransform const & ( ::btGeneric6DofConstraint::* )(  ) const
void btGeneric6DofConstraint_getFrameOffsetA0(void *c,float* ret) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetA();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getFrameOffsetA ::btTransform & ( ::btGeneric6DofConstraint::* )(  ) 
void btGeneric6DofConstraint_getFrameOffsetA1(void *c,float* ret) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetA();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getRelativePivotPosition ::btScalar ( ::btGeneric6DofConstraint::* )( int ) const
float btGeneric6DofConstraint_getRelativePivotPosition(void *c,int p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	float retVal = (float)o->getRelativePivotPosition(p0);
	return retVal;
}
//method: calculateAngleInfo void ( ::btGeneric6DofConstraint::* )(  ) 
void btGeneric6DofConstraint_calculateAngleInfo(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->calculateAngleInfo();
}
//method: getInfo2NonVirtual void ( ::btGeneric6DofConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btGeneric6DofConstraint_getInfo2NonVirtual(void *c,void* p0,float* p1,float* p2,float* p3,float* p4,float* p5,float* p6) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	btVector3 tp5(p5[0],p5[1],p5[2]);
	btVector3 tp6(p6[0],p6[1],p6[2]);
	o->getInfo2NonVirtual(tp0,tp1,tp2,tp3,tp4,tp5,tp6);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	p5[0]=tp5.m_floats[0];p5[1]=tp5.m_floats[1];p5[2]=tp5.m_floats[2];
	p6[0]=tp6.m_floats[0];p6[1]=tp6.m_floats[1];p6[2]=tp6.m_floats[2];
}
//method: setAngularLimits int ( ::btGeneric6DofConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,int,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
int btGeneric6DofConstraint_setAngularLimits(void *c,void* p0,int p1,float* p2,float* p3,float* p4,float* p5,float* p6,float* p7) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	btVector3 tp5(p5[0],p5[1],p5[2]);
	btVector3 tp6(p6[0],p6[1],p6[2]);
	btVector3 tp7(p7[0],p7[1],p7[2]);
	int retVal = (int)o->setAngularLimits(tp0,p1,tp2,tp3,tp4,tp5,tp6,tp7);
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	p5[0]=tp5.m_floats[0];p5[1]=tp5.m_floats[1];p5[2]=tp5.m_floats[2];
	p6[0]=tp6.m_floats[0];p6[1]=tp6.m_floats[1];p6[2]=tp6.m_floats[2];
	p7[0]=tp7.m_floats[0];p7[1]=tp7.m_floats[1];p7[2]=tp7.m_floats[2];
	return retVal;
}
//method: getParam ::btScalar ( ::btGeneric6DofConstraint::* )( int,int ) const
float btGeneric6DofConstraint_getParam(void *c,int p0,int p1) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	float retVal = (float)o->getParam(p0,p1);
	return retVal;
}
//method: getInfo1 void ( ::btGeneric6DofConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btGeneric6DofConstraint_getInfo1(void *c,void* p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	::btTypedConstraint::btConstraintInfo1 * tp0 = (::btTypedConstraint::btConstraintInfo1 *)p0;
	o->getInfo1(tp0);
}
//method: getInfo2 void ( ::btGeneric6DofConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void btGeneric6DofConstraint_getInfo2(void *c,void* p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	o->getInfo2(tp0);
}
//method: calcAnchorPos void ( ::btGeneric6DofConstraint::* )(  ) 
void btGeneric6DofConstraint_calcAnchorPos(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->calcAnchorPos();
}
//method: getAngularLowerLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 & ) 
void btGeneric6DofConstraint_getAngularLowerLimit(void *c,float* p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->getAngularLowerLimit(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: calculateSerializeBufferSize int ( ::btGeneric6DofConstraint::* )(  ) const
int btGeneric6DofConstraint_calculateSerializeBufferSize(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: getAxis ::btVector3 ( ::btGeneric6DofConstraint::* )( int ) const
void btGeneric6DofConstraint_getAxis(void *c,int p0,float* ret) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAxis(p0);
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getLinearUpperLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 & ) 
void btGeneric6DofConstraint_getLinearUpperLimit(void *c,float* p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->getLinearUpperLimit(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: setUseFrameOffset void ( ::btGeneric6DofConstraint::* )( bool ) 
void btGeneric6DofConstraint_setUseFrameOffset(void *c,int p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->setUseFrameOffset(p0);
}
//method: isLimited bool ( ::btGeneric6DofConstraint::* )( int ) 
int btGeneric6DofConstraint_isLimited(void *c,int p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	int retVal = (int)o->isLimited(p0);
	return retVal;
}
//method: getRotationalLimitMotor ::btRotationalLimitMotor * ( ::btGeneric6DofConstraint::* )( int ) 
void* btGeneric6DofConstraint_getRotationalLimitMotor(void *c,int p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	void* retVal = (void*) o->getRotationalLimitMotor(p0);
	return retVal;
}
//method: buildAngularJacobian void ( ::btGeneric6DofConstraint::* )( ::btJacobianEntry &,::btVector3 const & ) 
void btGeneric6DofConstraint_buildAngularJacobian(void *c,void* p0,float* p1) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	::btJacobianEntry & tp0 = *(::btJacobianEntry *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->buildAngularJacobian(tp0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getFrameOffsetB ::btTransform const & ( ::btGeneric6DofConstraint::* )(  ) const
void btGeneric6DofConstraint_getFrameOffsetB(void *c,float* ret) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetB();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getFrameOffsetB ::btTransform const & ( ::btGeneric6DofConstraint::* )(  ) const
void btGeneric6DofConstraint_getFrameOffsetB0(void *c,float* ret) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetB();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getFrameOffsetB ::btTransform & ( ::btGeneric6DofConstraint::* )(  ) 
void btGeneric6DofConstraint_getFrameOffsetB1(void *c,float* ret) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetB();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: setLinearLowerLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 const & ) 
void btGeneric6DofConstraint_setLinearLowerLimit(void *c,float* p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLinearLowerLimit(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getLinearLowerLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 & ) 
void btGeneric6DofConstraint_getLinearLowerLimit(void *c,float* p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->getLinearLowerLimit(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: buildLinearJacobian void ( ::btGeneric6DofConstraint::* )( ::btJacobianEntry &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btGeneric6DofConstraint_buildLinearJacobian(void *c,void* p0,float* p1,float* p2,float* p3) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	::btJacobianEntry & tp0 = *(::btJacobianEntry *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	o->buildLinearJacobian(tp0,tp1,tp2,tp3);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
}
//method: getUseFrameOffset bool ( ::btGeneric6DofConstraint::* )(  ) 
int btGeneric6DofConstraint_getUseFrameOffset(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	int retVal = (int)o->getUseFrameOffset();
	return retVal;
}
//method: getCalculatedTransformB ::btTransform const & ( ::btGeneric6DofConstraint::* )(  ) const
void btGeneric6DofConstraint_getCalculatedTransformB(void *c,float* ret) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getCalculatedTransformB();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: calculateTransforms void ( ::btGeneric6DofConstraint::* )( ::btTransform const &,::btTransform const & ) 
void btGeneric6DofConstraint_calculateTransforms(void *c,float* p0,float* p1) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->calculateTransforms(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: calculateTransforms void ( ::btGeneric6DofConstraint::* )( ::btTransform const &,::btTransform const & ) 
void btGeneric6DofConstraint_calculateTransforms0(void *c,float* p0,float* p1) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->calculateTransforms(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: calculateTransforms void ( ::btGeneric6DofConstraint::* )(  ) 
void btGeneric6DofConstraint_calculateTransforms1(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->calculateTransforms();
}
//method: get_limit_motor_info2 int ( ::btGeneric6DofConstraint::* )( ::btRotationalLimitMotor *,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btTypedConstraint::btConstraintInfo2 *,int,::btVector3 &,int,int ) 
int btGeneric6DofConstraint_get_limit_motor_info2(void *c,void* p0,float* p1,float* p2,float* p3,float* p4,float* p5,float* p6,void* p7,int p8,float* p9,int p10,int p11) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	::btRotationalLimitMotor * tp0 = (::btRotationalLimitMotor *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	btVector3 tp5(p5[0],p5[1],p5[2]);
	btVector3 tp6(p6[0],p6[1],p6[2]);
	::btTypedConstraint::btConstraintInfo2 * tp7 = (::btTypedConstraint::btConstraintInfo2 *)p7;
	btVector3 tp9(p9[0],p9[1],p9[2]);
	int retVal = (int)o->get_limit_motor_info2(tp0,tp1,tp2,tp3,tp4,tp5,tp6,tp7,p8,tp9,p10,p11);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	p5[0]=tp5.m_floats[0];p5[1]=tp5.m_floats[1];p5[2]=tp5.m_floats[2];
	p6[0]=tp6.m_floats[0];p6[1]=tp6.m_floats[1];p6[2]=tp6.m_floats[2];
	p9[0]=tp9.m_floats[0];p9[1]=tp9.m_floats[1];p9[2]=tp9.m_floats[2];
	return retVal;
}
//method: getCalculatedTransformA ::btTransform const & ( ::btGeneric6DofConstraint::* )(  ) const
void btGeneric6DofConstraint_getCalculatedTransformA(void *c,float* ret) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getCalculatedTransformA();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: serialize char const * ( ::btGeneric6DofConstraint::* )( void *,::btSerializer * ) const
char const * btGeneric6DofConstraint_serialize(void *c,void* p0,void* p1) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: setLimit void ( ::btGeneric6DofConstraint::* )( int,::btScalar,::btScalar ) 
void btGeneric6DofConstraint_setLimit(void *c,int p0,float p1,float p2) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->setLimit(p0,p1,p2);
}
//method: getTranslationalLimitMotor ::btTranslationalLimitMotor * ( ::btGeneric6DofConstraint::* )(  ) 
void* btGeneric6DofConstraint_getTranslationalLimitMotor(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	void* retVal = (void*) o->getTranslationalLimitMotor();
	return retVal;
}
//method: setLinearLimits int ( ::btGeneric6DofConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,int,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
int btGeneric6DofConstraint_setLinearLimits(void *c,void* p0,int p1,float* p2,float* p3,float* p4,float* p5,float* p6,float* p7) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	btVector3 tp5(p5[0],p5[1],p5[2]);
	btVector3 tp6(p6[0],p6[1],p6[2]);
	btVector3 tp7(p7[0],p7[1],p7[2]);
	int retVal = (int)o->setLinearLimits(tp0,p1,tp2,tp3,tp4,tp5,tp6,tp7);
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	p5[0]=tp5.m_floats[0];p5[1]=tp5.m_floats[1];p5[2]=tp5.m_floats[2];
	p6[0]=tp6.m_floats[0];p6[1]=tp6.m_floats[1];p6[2]=tp6.m_floats[2];
	p7[0]=tp7.m_floats[0];p7[1]=tp7.m_floats[1];p7[2]=tp7.m_floats[2];
	return retVal;
}
//method: getAngle ::btScalar ( ::btGeneric6DofConstraint::* )( int ) const
float btGeneric6DofConstraint_getAngle(void *c,int p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	float retVal = (float)o->getAngle(p0);
	return retVal;
}
//method: updateRHS void ( ::btGeneric6DofConstraint::* )( ::btScalar ) 
void btGeneric6DofConstraint_updateRHS(void *c,float p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->updateRHS(p0);
}
//method: getAngularUpperLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 & ) 
void btGeneric6DofConstraint_getAngularUpperLimit(void *c,float* p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->getAngularUpperLimit(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: setAngularLowerLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 const & ) 
void btGeneric6DofConstraint_setAngularLowerLimit(void *c,float* p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setAngularLowerLimit(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: calculateLinearInfo void ( ::btGeneric6DofConstraint::* )(  ) 
void btGeneric6DofConstraint_calculateLinearInfo(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->calculateLinearInfo();
}
//method: setFrames void ( ::btGeneric6DofConstraint::* )( ::btTransform const &,::btTransform const & ) 
void btGeneric6DofConstraint_setFrames(void *c,float* p0,float* p1) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->setFrames(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: setLinearUpperLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 const & ) 
void btGeneric6DofConstraint_setLinearUpperLimit(void *c,float* p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLinearUpperLimit(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: setAngularUpperLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 const & ) 
void btGeneric6DofConstraint_setAngularUpperLimit(void *c,float* p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setAngularUpperLimit(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: setAxis void ( ::btGeneric6DofConstraint::* )( ::btVector3 const &,::btVector3 const & ) 
void btGeneric6DofConstraint_setAxis(void *c,float* p0,float* p1) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->setAxis(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: testAngularLimitMotor bool ( ::btGeneric6DofConstraint::* )( int ) 
int btGeneric6DofConstraint_testAngularLimitMotor(void *c,int p0) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	int retVal = (int)o->testAngularLimitMotor(p0);
	return retVal;
}
//attribute: ::btTransform btGeneric6DofConstraint->m_frameInA
void btGeneric6DofConstraint_m_frameInA_set(void *c,float* a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_frameInA = ta;
}
void btGeneric6DofConstraint_m_frameInA_get(void *c,float* a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	a[0]=(o->m_frameInA).getBasis().getRow(0).m_floats[0];a[1]=(o->m_frameInA).getBasis().getRow(0).m_floats[1];a[2]=(o->m_frameInA).getBasis().getRow(0).m_floats[2];a[3]=(o->m_frameInA).getBasis().getRow(1).m_floats[0];a[4]=(o->m_frameInA).getBasis().getRow(1).m_floats[1];a[5]=(o->m_frameInA).getBasis().getRow(1).m_floats[2];a[6]=(o->m_frameInA).getBasis().getRow(2).m_floats[0];a[7]=(o->m_frameInA).getBasis().getRow(2).m_floats[1];a[8]=(o->m_frameInA).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_frameInA).getOrigin().m_floats[0];a[10]=(o->m_frameInA).getOrigin().m_floats[1];a[11]=(o->m_frameInA).getOrigin().m_floats[2];
}

//attribute: ::btTransform btGeneric6DofConstraint->m_frameInB
void btGeneric6DofConstraint_m_frameInB_set(void *c,float* a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_frameInB = ta;
}
void btGeneric6DofConstraint_m_frameInB_get(void *c,float* a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	a[0]=(o->m_frameInB).getBasis().getRow(0).m_floats[0];a[1]=(o->m_frameInB).getBasis().getRow(0).m_floats[1];a[2]=(o->m_frameInB).getBasis().getRow(0).m_floats[2];a[3]=(o->m_frameInB).getBasis().getRow(1).m_floats[0];a[4]=(o->m_frameInB).getBasis().getRow(1).m_floats[1];a[5]=(o->m_frameInB).getBasis().getRow(1).m_floats[2];a[6]=(o->m_frameInB).getBasis().getRow(2).m_floats[0];a[7]=(o->m_frameInB).getBasis().getRow(2).m_floats[1];a[8]=(o->m_frameInB).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_frameInB).getOrigin().m_floats[0];a[10]=(o->m_frameInB).getOrigin().m_floats[1];a[11]=(o->m_frameInB).getOrigin().m_floats[2];
}

//attribute: ::btJacobianEntry[3] btGeneric6DofConstraint->m_jacLinear
// attribute not supported: //attribute: ::btJacobianEntry[3] btGeneric6DofConstraint->m_jacLinear
//attribute: ::btJacobianEntry[3] btGeneric6DofConstraint->m_jacAng
// attribute not supported: //attribute: ::btJacobianEntry[3] btGeneric6DofConstraint->m_jacAng
//attribute: ::btTranslationalLimitMotor btGeneric6DofConstraint->m_linearLimits
void btGeneric6DofConstraint_m_linearLimits_set(void *c,void* a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	::btTranslationalLimitMotor & ta = *(::btTranslationalLimitMotor *)a;
	o->m_linearLimits = ta;
}
void* btGeneric6DofConstraint_m_linearLimits_get(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	return (void*)&(o->m_linearLimits);
}

//attribute: ::btRotationalLimitMotor[3] btGeneric6DofConstraint->m_angularLimits
// attribute not supported: //attribute: ::btRotationalLimitMotor[3] btGeneric6DofConstraint->m_angularLimits
//attribute: ::btScalar btGeneric6DofConstraint->m_timeStep
void btGeneric6DofConstraint_m_timeStep_set(void *c,float a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->m_timeStep = a;
}
float btGeneric6DofConstraint_m_timeStep_get(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	return (float)(o->m_timeStep);
}

//attribute: ::btTransform btGeneric6DofConstraint->m_calculatedTransformA
void btGeneric6DofConstraint_m_calculatedTransformA_set(void *c,float* a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_calculatedTransformA = ta;
}
void btGeneric6DofConstraint_m_calculatedTransformA_get(void *c,float* a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	a[0]=(o->m_calculatedTransformA).getBasis().getRow(0).m_floats[0];a[1]=(o->m_calculatedTransformA).getBasis().getRow(0).m_floats[1];a[2]=(o->m_calculatedTransformA).getBasis().getRow(0).m_floats[2];a[3]=(o->m_calculatedTransformA).getBasis().getRow(1).m_floats[0];a[4]=(o->m_calculatedTransformA).getBasis().getRow(1).m_floats[1];a[5]=(o->m_calculatedTransformA).getBasis().getRow(1).m_floats[2];a[6]=(o->m_calculatedTransformA).getBasis().getRow(2).m_floats[0];a[7]=(o->m_calculatedTransformA).getBasis().getRow(2).m_floats[1];a[8]=(o->m_calculatedTransformA).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_calculatedTransformA).getOrigin().m_floats[0];a[10]=(o->m_calculatedTransformA).getOrigin().m_floats[1];a[11]=(o->m_calculatedTransformA).getOrigin().m_floats[2];
}

//attribute: ::btTransform btGeneric6DofConstraint->m_calculatedTransformB
void btGeneric6DofConstraint_m_calculatedTransformB_set(void *c,float* a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_calculatedTransformB = ta;
}
void btGeneric6DofConstraint_m_calculatedTransformB_get(void *c,float* a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	a[0]=(o->m_calculatedTransformB).getBasis().getRow(0).m_floats[0];a[1]=(o->m_calculatedTransformB).getBasis().getRow(0).m_floats[1];a[2]=(o->m_calculatedTransformB).getBasis().getRow(0).m_floats[2];a[3]=(o->m_calculatedTransformB).getBasis().getRow(1).m_floats[0];a[4]=(o->m_calculatedTransformB).getBasis().getRow(1).m_floats[1];a[5]=(o->m_calculatedTransformB).getBasis().getRow(1).m_floats[2];a[6]=(o->m_calculatedTransformB).getBasis().getRow(2).m_floats[0];a[7]=(o->m_calculatedTransformB).getBasis().getRow(2).m_floats[1];a[8]=(o->m_calculatedTransformB).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_calculatedTransformB).getOrigin().m_floats[0];a[10]=(o->m_calculatedTransformB).getOrigin().m_floats[1];a[11]=(o->m_calculatedTransformB).getOrigin().m_floats[2];
}

//attribute: ::btVector3 btGeneric6DofConstraint->m_calculatedAxisAngleDiff
void btGeneric6DofConstraint_m_calculatedAxisAngleDiff_set(void *c,float* a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_calculatedAxisAngleDiff = ta;
}
void btGeneric6DofConstraint_m_calculatedAxisAngleDiff_get(void *c,float* a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	a[0]=(o->m_calculatedAxisAngleDiff).m_floats[0];a[1]=(o->m_calculatedAxisAngleDiff).m_floats[1];a[2]=(o->m_calculatedAxisAngleDiff).m_floats[2];
}

//attribute: ::btVector3[3] btGeneric6DofConstraint->m_calculatedAxis
// attribute not supported: //attribute: ::btVector3[3] btGeneric6DofConstraint->m_calculatedAxis
//attribute: ::btVector3 btGeneric6DofConstraint->m_calculatedLinearDiff
void btGeneric6DofConstraint_m_calculatedLinearDiff_set(void *c,float* a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_calculatedLinearDiff = ta;
}
void btGeneric6DofConstraint_m_calculatedLinearDiff_get(void *c,float* a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	a[0]=(o->m_calculatedLinearDiff).m_floats[0];a[1]=(o->m_calculatedLinearDiff).m_floats[1];a[2]=(o->m_calculatedLinearDiff).m_floats[2];
}

//attribute: ::btScalar btGeneric6DofConstraint->m_factA
void btGeneric6DofConstraint_m_factA_set(void *c,float a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->m_factA = a;
}
float btGeneric6DofConstraint_m_factA_get(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	return (float)(o->m_factA);
}

//attribute: ::btScalar btGeneric6DofConstraint->m_factB
void btGeneric6DofConstraint_m_factB_set(void *c,float a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->m_factB = a;
}
float btGeneric6DofConstraint_m_factB_get(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	return (float)(o->m_factB);
}

//attribute: bool btGeneric6DofConstraint->m_hasStaticBody
void btGeneric6DofConstraint_m_hasStaticBody_set(void *c,int a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->m_hasStaticBody = a;
}
int btGeneric6DofConstraint_m_hasStaticBody_get(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	return (int)(o->m_hasStaticBody);
}

//attribute: ::btVector3 btGeneric6DofConstraint->m_AnchorPos
void btGeneric6DofConstraint_m_AnchorPos_set(void *c,float* a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_AnchorPos = ta;
}
void btGeneric6DofConstraint_m_AnchorPos_get(void *c,float* a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	a[0]=(o->m_AnchorPos).m_floats[0];a[1]=(o->m_AnchorPos).m_floats[1];a[2]=(o->m_AnchorPos).m_floats[2];
}

//attribute: bool btGeneric6DofConstraint->m_useLinearReferenceFrameA
void btGeneric6DofConstraint_m_useLinearReferenceFrameA_set(void *c,int a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->m_useLinearReferenceFrameA = a;
}
int btGeneric6DofConstraint_m_useLinearReferenceFrameA_get(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	return (int)(o->m_useLinearReferenceFrameA);
}

//attribute: bool btGeneric6DofConstraint->m_useOffsetForConstraintFrame
void btGeneric6DofConstraint_m_useOffsetForConstraintFrame_set(void *c,int a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->m_useOffsetForConstraintFrame = a;
}
int btGeneric6DofConstraint_m_useOffsetForConstraintFrame_get(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	return (int)(o->m_useOffsetForConstraintFrame);
}

//attribute: int btGeneric6DofConstraint->m_flags
void btGeneric6DofConstraint_m_flags_set(void *c,int a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->m_flags = a;
}
int btGeneric6DofConstraint_m_flags_get(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	return (int)(o->m_flags);
}

//attribute: bool btGeneric6DofConstraint->m_useSolveConstraintObsolete
void btGeneric6DofConstraint_m_useSolveConstraintObsolete_set(void *c,int a) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	o->m_useSolveConstraintObsolete = a;
}
int btGeneric6DofConstraint_m_useSolveConstraintObsolete_get(void *c) {
	::btGeneric6DofConstraint *o = (::btGeneric6DofConstraint*)c;
	return (int)(o->m_useSolveConstraintObsolete);
}


// ::btGeneric6DofConstraintData
//constructor: btGeneric6DofConstraintData  ( ::btGeneric6DofConstraintData::* )(  ) 
void* btGeneric6DofConstraintData_new() {
	::btGeneric6DofConstraintData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGeneric6DofConstraintData),16);
	o = new (mem)::btGeneric6DofConstraintData();
	return (void*)o;
}
void btGeneric6DofConstraintData_free(void *c) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	delete o;
}
//attribute: ::btTypedConstraintData btGeneric6DofConstraintData->m_typeConstraintData
void btGeneric6DofConstraintData_m_typeConstraintData_set(void *c,void* a) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	::btTypedConstraintData & ta = *(::btTypedConstraintData *)a;
	o->m_typeConstraintData = ta;
}
void* btGeneric6DofConstraintData_m_typeConstraintData_get(void *c) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	return (void*)&(o->m_typeConstraintData);
}

//attribute: ::btTransformFloatData btGeneric6DofConstraintData->m_rbAFrame
void btGeneric6DofConstraintData_m_rbAFrame_set(void *c,void* a) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	::btTransformFloatData & ta = *(::btTransformFloatData *)a;
	o->m_rbAFrame = ta;
}
void* btGeneric6DofConstraintData_m_rbAFrame_get(void *c) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	return (void*)&(o->m_rbAFrame);
}

//attribute: ::btTransformFloatData btGeneric6DofConstraintData->m_rbBFrame
void btGeneric6DofConstraintData_m_rbBFrame_set(void *c,void* a) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	::btTransformFloatData & ta = *(::btTransformFloatData *)a;
	o->m_rbBFrame = ta;
}
void* btGeneric6DofConstraintData_m_rbBFrame_get(void *c) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	return (void*)&(o->m_rbBFrame);
}

//attribute: ::btVector3FloatData btGeneric6DofConstraintData->m_linearUpperLimit
void btGeneric6DofConstraintData_m_linearUpperLimit_set(void *c,void* a) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_linearUpperLimit = ta;
}
void* btGeneric6DofConstraintData_m_linearUpperLimit_get(void *c) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	return (void*)&(o->m_linearUpperLimit);
}

//attribute: ::btVector3FloatData btGeneric6DofConstraintData->m_linearLowerLimit
void btGeneric6DofConstraintData_m_linearLowerLimit_set(void *c,void* a) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_linearLowerLimit = ta;
}
void* btGeneric6DofConstraintData_m_linearLowerLimit_get(void *c) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	return (void*)&(o->m_linearLowerLimit);
}

//attribute: ::btVector3FloatData btGeneric6DofConstraintData->m_angularUpperLimit
void btGeneric6DofConstraintData_m_angularUpperLimit_set(void *c,void* a) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_angularUpperLimit = ta;
}
void* btGeneric6DofConstraintData_m_angularUpperLimit_get(void *c) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	return (void*)&(o->m_angularUpperLimit);
}

//attribute: ::btVector3FloatData btGeneric6DofConstraintData->m_angularLowerLimit
void btGeneric6DofConstraintData_m_angularLowerLimit_set(void *c,void* a) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_angularLowerLimit = ta;
}
void* btGeneric6DofConstraintData_m_angularLowerLimit_get(void *c) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	return (void*)&(o->m_angularLowerLimit);
}

//attribute: int btGeneric6DofConstraintData->m_useLinearReferenceFrameA
void btGeneric6DofConstraintData_m_useLinearReferenceFrameA_set(void *c,int a) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	o->m_useLinearReferenceFrameA = a;
}
int btGeneric6DofConstraintData_m_useLinearReferenceFrameA_get(void *c) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	return (int)(o->m_useLinearReferenceFrameA);
}

//attribute: int btGeneric6DofConstraintData->m_useOffsetForConstraintFrame
void btGeneric6DofConstraintData_m_useOffsetForConstraintFrame_set(void *c,int a) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	o->m_useOffsetForConstraintFrame = a;
}
int btGeneric6DofConstraintData_m_useOffsetForConstraintFrame_get(void *c) {
	::btGeneric6DofConstraintData *o = (::btGeneric6DofConstraintData*)c;
	return (int)(o->m_useOffsetForConstraintFrame);
}


// ::btGeneric6DofSpringConstraint
//constructor: btGeneric6DofSpringConstraint  ( ::btGeneric6DofSpringConstraint::* )( ::btRigidBody &,::btRigidBody &,::btTransform const &,::btTransform const &,bool ) 
void* btGeneric6DofSpringConstraint_new(void* p0,void* p1,float* p2,float* p3,int p4) {
	::btGeneric6DofSpringConstraint *o = 0;
	 void *mem = 0;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	mem = btAlignedAlloc(sizeof(::btGeneric6DofSpringConstraint),16);
	o = new (mem)::btGeneric6DofSpringConstraint(tp0,tp1,tp2,tp3,p4);
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
	return (void*)o;
}
void btGeneric6DofSpringConstraint_free(void *c) {
	::btGeneric6DofSpringConstraint *o = (::btGeneric6DofSpringConstraint*)c;
	delete o;
}
//method: calculateSerializeBufferSize int ( ::btGeneric6DofSpringConstraint::* )(  ) const
int btGeneric6DofSpringConstraint_calculateSerializeBufferSize(void *c) {
	::btGeneric6DofSpringConstraint *o = (::btGeneric6DofSpringConstraint*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: setEquilibriumPoint void ( ::btGeneric6DofSpringConstraint::* )(  ) 
void btGeneric6DofSpringConstraint_setEquilibriumPoint(void *c) {
	::btGeneric6DofSpringConstraint *o = (::btGeneric6DofSpringConstraint*)c;
	o->setEquilibriumPoint();
}
//method: setEquilibriumPoint void ( ::btGeneric6DofSpringConstraint::* )(  ) 
void btGeneric6DofSpringConstraint_setEquilibriumPoint0(void *c) {
	::btGeneric6DofSpringConstraint *o = (::btGeneric6DofSpringConstraint*)c;
	o->setEquilibriumPoint();
}
//method: setEquilibriumPoint void ( ::btGeneric6DofSpringConstraint::* )( int ) 
void btGeneric6DofSpringConstraint_setEquilibriumPoint1(void *c,int p0) {
	::btGeneric6DofSpringConstraint *o = (::btGeneric6DofSpringConstraint*)c;
	o->setEquilibriumPoint(p0);
}
//method: setEquilibriumPoint void ( ::btGeneric6DofSpringConstraint::* )( int,::btScalar ) 
void btGeneric6DofSpringConstraint_setEquilibriumPoint2(void *c,int p0,float p1) {
	::btGeneric6DofSpringConstraint *o = (::btGeneric6DofSpringConstraint*)c;
	o->setEquilibriumPoint(p0,p1);
}
//method: serialize char const * ( ::btGeneric6DofSpringConstraint::* )( void *,::btSerializer * ) const
char const * btGeneric6DofSpringConstraint_serialize(void *c,void* p0,void* p1) {
	::btGeneric6DofSpringConstraint *o = (::btGeneric6DofSpringConstraint*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: enableSpring void ( ::btGeneric6DofSpringConstraint::* )( int,bool ) 
void btGeneric6DofSpringConstraint_enableSpring(void *c,int p0,int p1) {
	::btGeneric6DofSpringConstraint *o = (::btGeneric6DofSpringConstraint*)c;
	o->enableSpring(p0,p1);
}
//method: setStiffness void ( ::btGeneric6DofSpringConstraint::* )( int,::btScalar ) 
void btGeneric6DofSpringConstraint_setStiffness(void *c,int p0,float p1) {
	::btGeneric6DofSpringConstraint *o = (::btGeneric6DofSpringConstraint*)c;
	o->setStiffness(p0,p1);
}
//method: setDamping void ( ::btGeneric6DofSpringConstraint::* )( int,::btScalar ) 
void btGeneric6DofSpringConstraint_setDamping(void *c,int p0,float p1) {
	::btGeneric6DofSpringConstraint *o = (::btGeneric6DofSpringConstraint*)c;
	o->setDamping(p0,p1);
}
//method: getInfo2 void ( ::btGeneric6DofSpringConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void btGeneric6DofSpringConstraint_getInfo2(void *c,void* p0) {
	::btGeneric6DofSpringConstraint *o = (::btGeneric6DofSpringConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	o->getInfo2(tp0);
}
//method: internalUpdateSprings void ( ::btGeneric6DofSpringConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void btGeneric6DofSpringConstraint_internalUpdateSprings(void *c,void* p0) {
	::btGeneric6DofSpringConstraint *o = (::btGeneric6DofSpringConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	o->internalUpdateSprings(tp0);
}
//method: setAxis void ( ::btGeneric6DofSpringConstraint::* )( ::btVector3 const &,::btVector3 const & ) 
void btGeneric6DofSpringConstraint_setAxis(void *c,float* p0,float* p1) {
	::btGeneric6DofSpringConstraint *o = (::btGeneric6DofSpringConstraint*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->setAxis(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//attribute: bool[6] btGeneric6DofSpringConstraint->m_springEnabled
// attribute not supported: //attribute: bool[6] btGeneric6DofSpringConstraint->m_springEnabled
//attribute: ::btScalar[6] btGeneric6DofSpringConstraint->m_equilibriumPoint
// attribute not supported: //attribute: ::btScalar[6] btGeneric6DofSpringConstraint->m_equilibriumPoint
//attribute: ::btScalar[6] btGeneric6DofSpringConstraint->m_springStiffness
// attribute not supported: //attribute: ::btScalar[6] btGeneric6DofSpringConstraint->m_springStiffness
//attribute: ::btScalar[6] btGeneric6DofSpringConstraint->m_springDamping
// attribute not supported: //attribute: ::btScalar[6] btGeneric6DofSpringConstraint->m_springDamping

// ::btGeneric6DofSpringConstraintData
//constructor: btGeneric6DofSpringConstraintData  ( ::btGeneric6DofSpringConstraintData::* )(  ) 
void* btGeneric6DofSpringConstraintData_new() {
	::btGeneric6DofSpringConstraintData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGeneric6DofSpringConstraintData),16);
	o = new (mem)::btGeneric6DofSpringConstraintData();
	return (void*)o;
}
void btGeneric6DofSpringConstraintData_free(void *c) {
	::btGeneric6DofSpringConstraintData *o = (::btGeneric6DofSpringConstraintData*)c;
	delete o;
}
//attribute: ::btGeneric6DofConstraintData btGeneric6DofSpringConstraintData->m_6dofData
void btGeneric6DofSpringConstraintData_m_6dofData_set(void *c,void* a) {
	::btGeneric6DofSpringConstraintData *o = (::btGeneric6DofSpringConstraintData*)c;
	::btGeneric6DofConstraintData & ta = *(::btGeneric6DofConstraintData *)a;
	o->m_6dofData = ta;
}
void* btGeneric6DofSpringConstraintData_m_6dofData_get(void *c) {
	::btGeneric6DofSpringConstraintData *o = (::btGeneric6DofSpringConstraintData*)c;
	return (void*)&(o->m_6dofData);
}

//attribute: int[6] btGeneric6DofSpringConstraintData->m_springEnabled
// attribute not supported: //attribute: int[6] btGeneric6DofSpringConstraintData->m_springEnabled
//attribute: float[6] btGeneric6DofSpringConstraintData->m_equilibriumPoint
// attribute not supported: //attribute: float[6] btGeneric6DofSpringConstraintData->m_equilibriumPoint
//attribute: float[6] btGeneric6DofSpringConstraintData->m_springStiffness
// attribute not supported: //attribute: float[6] btGeneric6DofSpringConstraintData->m_springStiffness
//attribute: float[6] btGeneric6DofSpringConstraintData->m_springDamping
// attribute not supported: //attribute: float[6] btGeneric6DofSpringConstraintData->m_springDamping

// ::btHinge2Constraint
//constructor: btHinge2Constraint  ( ::btHinge2Constraint::* )( ::btRigidBody &,::btRigidBody &,::btVector3 &,::btVector3 &,::btVector3 & ) 
void* btHinge2Constraint_new(void* p0,void* p1,float* p2,float* p3,float* p4) {
	::btHinge2Constraint *o = 0;
	 void *mem = 0;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	mem = btAlignedAlloc(sizeof(::btHinge2Constraint),16);
	o = new (mem)::btHinge2Constraint(tp0,tp1,tp2,tp3,tp4);
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	return (void*)o;
}
void btHinge2Constraint_free(void *c) {
	::btHinge2Constraint *o = (::btHinge2Constraint*)c;
	delete o;
}
//method: setLowerLimit void ( ::btHinge2Constraint::* )( ::btScalar ) 
void btHinge2Constraint_setLowerLimit(void *c,float p0) {
	::btHinge2Constraint *o = (::btHinge2Constraint*)c;
	o->setLowerLimit(p0);
}
//method: getAnchor2 ::btVector3 const & ( ::btHinge2Constraint::* )(  ) 
void btHinge2Constraint_getAnchor2(void *c,float* ret) {
	::btHinge2Constraint *o = (::btHinge2Constraint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAnchor2();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getAxis1 ::btVector3 const & ( ::btHinge2Constraint::* )(  ) 
void btHinge2Constraint_getAxis1(void *c,float* ret) {
	::btHinge2Constraint *o = (::btHinge2Constraint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAxis1();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getAnchor ::btVector3 const & ( ::btHinge2Constraint::* )(  ) 
void btHinge2Constraint_getAnchor(void *c,float* ret) {
	::btHinge2Constraint *o = (::btHinge2Constraint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAnchor();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getAxis2 ::btVector3 const & ( ::btHinge2Constraint::* )(  ) 
void btHinge2Constraint_getAxis2(void *c,float* ret) {
	::btHinge2Constraint *o = (::btHinge2Constraint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAxis2();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: setUpperLimit void ( ::btHinge2Constraint::* )( ::btScalar ) 
void btHinge2Constraint_setUpperLimit(void *c,float p0) {
	::btHinge2Constraint *o = (::btHinge2Constraint*)c;
	o->setUpperLimit(p0);
}
//method: getAngle2 ::btScalar ( ::btHinge2Constraint::* )(  ) 
float btHinge2Constraint_getAngle2(void *c) {
	::btHinge2Constraint *o = (::btHinge2Constraint*)c;
	float retVal = (float)o->getAngle2();
	return retVal;
}
//method: getAngle1 ::btScalar ( ::btHinge2Constraint::* )(  ) 
float btHinge2Constraint_getAngle1(void *c) {
	::btHinge2Constraint *o = (::btHinge2Constraint*)c;
	float retVal = (float)o->getAngle1();
	return retVal;
}
//attribute: ::btVector3 btHinge2Constraint->m_anchor
void btHinge2Constraint_m_anchor_set(void *c,float* a) {
	::btHinge2Constraint *o = (::btHinge2Constraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_anchor = ta;
}
void btHinge2Constraint_m_anchor_get(void *c,float* a) {
	::btHinge2Constraint *o = (::btHinge2Constraint*)c;
	a[0]=(o->m_anchor).m_floats[0];a[1]=(o->m_anchor).m_floats[1];a[2]=(o->m_anchor).m_floats[2];
}

//attribute: ::btVector3 btHinge2Constraint->m_axis1
void btHinge2Constraint_m_axis1_set(void *c,float* a) {
	::btHinge2Constraint *o = (::btHinge2Constraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_axis1 = ta;
}
void btHinge2Constraint_m_axis1_get(void *c,float* a) {
	::btHinge2Constraint *o = (::btHinge2Constraint*)c;
	a[0]=(o->m_axis1).m_floats[0];a[1]=(o->m_axis1).m_floats[1];a[2]=(o->m_axis1).m_floats[2];
}

//attribute: ::btVector3 btHinge2Constraint->m_axis2
void btHinge2Constraint_m_axis2_set(void *c,float* a) {
	::btHinge2Constraint *o = (::btHinge2Constraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_axis2 = ta;
}
void btHinge2Constraint_m_axis2_get(void *c,float* a) {
	::btHinge2Constraint *o = (::btHinge2Constraint*)c;
	a[0]=(o->m_axis2).m_floats[0];a[1]=(o->m_axis2).m_floats[1];a[2]=(o->m_axis2).m_floats[2];
}


// ::btHingeConstraint
//constructor: btHingeConstraint  ( ::btHingeConstraint::* )( ::btRigidBody &,::btRigidBody &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,bool ) 
void* btHingeConstraint_new0(void* p0,void* p1,float* p2,float* p3,float* p4,float* p5,int p6) {
	::btHingeConstraint *o = 0;
	 void *mem = 0;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	btVector3 tp5(p5[0],p5[1],p5[2]);
	mem = btAlignedAlloc(sizeof(::btHingeConstraint),16);
	o = new (mem)::btHingeConstraint(tp0,tp1,tp2,tp3,tp4,tp5,p6);
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	p5[0]=tp5.m_floats[0];p5[1]=tp5.m_floats[1];p5[2]=tp5.m_floats[2];
	return (void*)o;
}
//constructor: btHingeConstraint  ( ::btHingeConstraint::* )( ::btRigidBody &,::btVector3 const &,::btVector3 const &,bool ) 
void* btHingeConstraint_new1(void* p0,float* p1,float* p2,int p3) {
	::btHingeConstraint *o = 0;
	 void *mem = 0;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	mem = btAlignedAlloc(sizeof(::btHingeConstraint),16);
	o = new (mem)::btHingeConstraint(tp0,tp1,tp2,p3);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	return (void*)o;
}
//constructor: btHingeConstraint  ( ::btHingeConstraint::* )( ::btRigidBody &,::btRigidBody &,::btTransform const &,::btTransform const &,bool ) 
void* btHingeConstraint_new2(void* p0,void* p1,float* p2,float* p3,int p4) {
	::btHingeConstraint *o = 0;
	 void *mem = 0;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	mem = btAlignedAlloc(sizeof(::btHingeConstraint),16);
	o = new (mem)::btHingeConstraint(tp0,tp1,tp2,tp3,p4);
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
	return (void*)o;
}
//constructor: btHingeConstraint  ( ::btHingeConstraint::* )( ::btRigidBody &,::btTransform const &,bool ) 
void* btHingeConstraint_new3(void* p0,float* p1,int p2) {
	::btHingeConstraint *o = 0;
	 void *mem = 0;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	mem = btAlignedAlloc(sizeof(::btHingeConstraint),16);
	o = new (mem)::btHingeConstraint(tp0,tp1,p2);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	return (void*)o;
}
void btHingeConstraint_free(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	delete o;
}
//method: getRigidBodyB ::btRigidBody const & ( ::btHingeConstraint::* )(  ) const
void* btHingeConstraint_getRigidBodyB(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyB());
	return retVal;
}
//method: getRigidBodyB ::btRigidBody const & ( ::btHingeConstraint::* )(  ) const
void* btHingeConstraint_getRigidBodyB0(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyB());
	return retVal;
}
//method: getRigidBodyB ::btRigidBody & ( ::btHingeConstraint::* )(  ) 
void* btHingeConstraint_getRigidBodyB1(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyB());
	return retVal;
}
//method: getInfo2NonVirtual void ( ::btHingeConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const & ) 
void btHingeConstraint_getInfo2NonVirtual(void *c,void* p0,float* p1,float* p2,float* p3,float* p4) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->getInfo2NonVirtual(tp0,tp1,tp2,tp3,tp4);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: getRigidBodyA ::btRigidBody const & ( ::btHingeConstraint::* )(  ) const
void* btHingeConstraint_getRigidBodyA(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyA());
	return retVal;
}
//method: getRigidBodyA ::btRigidBody const & ( ::btHingeConstraint::* )(  ) const
void* btHingeConstraint_getRigidBodyA0(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyA());
	return retVal;
}
//method: getRigidBodyA ::btRigidBody & ( ::btHingeConstraint::* )(  ) 
void* btHingeConstraint_getRigidBodyA1(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyA());
	return retVal;
}
//method: getMotorTargetVelosity ::btScalar ( ::btHingeConstraint::* )(  ) 
float btHingeConstraint_getMotorTargetVelosity(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	float retVal = (float)o->getMotorTargetVelosity();
	return retVal;
}
//method: getFrameOffsetA ::btTransform & ( ::btHingeConstraint::* )(  ) 
void btHingeConstraint_getFrameOffsetA(void *c,float* ret) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetA();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getFrameOffsetB ::btTransform & ( ::btHingeConstraint::* )(  ) 
void btHingeConstraint_getFrameOffsetB(void *c,float* ret) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetB();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: buildJacobian void ( ::btHingeConstraint::* )(  ) 
void btHingeConstraint_buildJacobian(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->buildJacobian();
}
//method: setMaxMotorImpulse void ( ::btHingeConstraint::* )( ::btScalar ) 
void btHingeConstraint_setMaxMotorImpulse(void *c,float p0) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->setMaxMotorImpulse(p0);
}
//method: getHingeAngle ::btScalar ( ::btHingeConstraint::* )(  ) 
float btHingeConstraint_getHingeAngle(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	float retVal = (float)o->getHingeAngle();
	return retVal;
}
//method: getHingeAngle ::btScalar ( ::btHingeConstraint::* )(  ) 
float btHingeConstraint_getHingeAngle0(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	float retVal = (float)o->getHingeAngle();
	return retVal;
}
//method: getHingeAngle ::btScalar ( ::btHingeConstraint::* )( ::btTransform const &,::btTransform const & ) 
float btHingeConstraint_getHingeAngle1(void *c,float* p0,float* p1) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	float retVal = (float)o->getHingeAngle(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	return retVal;
}
//method: testLimit void ( ::btHingeConstraint::* )( ::btTransform const &,::btTransform const & ) 
void btHingeConstraint_testLimit(void *c,float* p0,float* p1) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->testLimit(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: getInfo1 void ( ::btHingeConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btHingeConstraint_getInfo1(void *c,void* p0) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	::btTypedConstraint::btConstraintInfo1 * tp0 = (::btTypedConstraint::btConstraintInfo1 *)p0;
	o->getInfo1(tp0);
}
//method: getInfo2Internal void ( ::btHingeConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const & ) 
void btHingeConstraint_getInfo2Internal(void *c,void* p0,float* p1,float* p2,float* p3,float* p4) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->getInfo2Internal(tp0,tp1,tp2,tp3,tp4);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: getInfo2 void ( ::btHingeConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void btHingeConstraint_getInfo2(void *c,void* p0) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	o->getInfo2(tp0);
}
//method: getUpperLimit ::btScalar ( ::btHingeConstraint::* )(  ) const
float btHingeConstraint_getUpperLimit(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	float retVal = (float)o->getUpperLimit();
	return retVal;
}
//method: enableAngularMotor void ( ::btHingeConstraint::* )( bool,::btScalar,::btScalar ) 
void btHingeConstraint_enableAngularMotor(void *c,int p0,float p1,float p2) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->enableAngularMotor(p0,p1,p2);
}
//method: getLimitSign ::btScalar ( ::btHingeConstraint::* )(  ) 
float btHingeConstraint_getLimitSign(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	float retVal = (float)o->getLimitSign();
	return retVal;
}
//method: calculateSerializeBufferSize int ( ::btHingeConstraint::* )(  ) const
int btHingeConstraint_calculateSerializeBufferSize(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: getMaxMotorImpulse ::btScalar ( ::btHingeConstraint::* )(  ) 
float btHingeConstraint_getMaxMotorImpulse(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	float retVal = (float)o->getMaxMotorImpulse();
	return retVal;
}
//method: getLowerLimit ::btScalar ( ::btHingeConstraint::* )(  ) const
float btHingeConstraint_getLowerLimit(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	float retVal = (float)o->getLowerLimit();
	return retVal;
}
//method: setParam void ( ::btHingeConstraint::* )( int,::btScalar,int ) 
void btHingeConstraint_setParam(void *c,int p0,float p1,int p2) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->setParam(p0,p1,p2);
}
//method: setUseFrameOffset void ( ::btHingeConstraint::* )( bool ) 
void btHingeConstraint_setUseFrameOffset(void *c,int p0) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->setUseFrameOffset(p0);
}
//method: getEnableAngularMotor bool ( ::btHingeConstraint::* )(  ) 
int btHingeConstraint_getEnableAngularMotor(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	int retVal = (int)o->getEnableAngularMotor();
	return retVal;
}
//method: enableMotor void ( ::btHingeConstraint::* )( bool ) 
void btHingeConstraint_enableMotor(void *c,int p0) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->enableMotor(p0);
}
//method: getBFrame ::btTransform const & ( ::btHingeConstraint::* )(  ) const
void btHingeConstraint_getBFrame(void *c,float* ret) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getBFrame();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getBFrame ::btTransform const & ( ::btHingeConstraint::* )(  ) const
void btHingeConstraint_getBFrame0(void *c,float* ret) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getBFrame();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getBFrame ::btTransform & ( ::btHingeConstraint::* )(  ) 
void btHingeConstraint_getBFrame1(void *c,float* ret) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getBFrame();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getInfo1NonVirtual void ( ::btHingeConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btHingeConstraint_getInfo1NonVirtual(void *c,void* p0) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	::btTypedConstraint::btConstraintInfo1 * tp0 = (::btTypedConstraint::btConstraintInfo1 *)p0;
	o->getInfo1NonVirtual(tp0);
}
//method: getInfo2InternalUsingFrameOffset void ( ::btHingeConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const & ) 
void btHingeConstraint_getInfo2InternalUsingFrameOffset(void *c,void* p0,float* p1,float* p2,float* p3,float* p4) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->getInfo2InternalUsingFrameOffset(tp0,tp1,tp2,tp3,tp4);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: serialize char const * ( ::btHingeConstraint::* )( void *,::btSerializer * ) const
char const * btHingeConstraint_serialize(void *c,void* p0,void* p1) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: getUseFrameOffset bool ( ::btHingeConstraint::* )(  ) 
int btHingeConstraint_getUseFrameOffset(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	int retVal = (int)o->getUseFrameOffset();
	return retVal;
}
//method: setAngularOnly void ( ::btHingeConstraint::* )( bool ) 
void btHingeConstraint_setAngularOnly(void *c,int p0) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->setAngularOnly(p0);
}
//method: getParam ::btScalar ( ::btHingeConstraint::* )( int,int ) const
float btHingeConstraint_getParam(void *c,int p0,int p1) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	float retVal = (float)o->getParam(p0,p1);
	return retVal;
}
//method: setLimit void ( ::btHingeConstraint::* )( ::btScalar,::btScalar,::btScalar,::btScalar,::btScalar ) 
void btHingeConstraint_setLimit(void *c,float p0,float p1,float p2,float p3,float p4) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->setLimit(p0,p1,p2,p3,p4);
}
//method: getSolveLimit int ( ::btHingeConstraint::* )(  ) 
int btHingeConstraint_getSolveLimit(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	int retVal = (int)o->getSolveLimit();
	return retVal;
}
//method: updateRHS void ( ::btHingeConstraint::* )( ::btScalar ) 
void btHingeConstraint_updateRHS(void *c,float p0) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->updateRHS(p0);
}
//method: setMotorTarget void ( ::btHingeConstraint::* )( ::btQuaternion const &,::btScalar ) 
void btHingeConstraint_setMotorTarget(void *c,float* p0,float p1) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btQuaternion tp0(p0[0],p0[1],p0[2],p0[3]);
	o->setMotorTarget(tp0,p1);
	p0[0]=tp0.getX();p0[1]=tp0.getY();p0[2]=tp0.getZ();p0[3]=tp0.getW();
}
//method: setMotorTarget void ( ::btHingeConstraint::* )( ::btQuaternion const &,::btScalar ) 
void btHingeConstraint_setMotorTarget0(void *c,float* p0,float p1) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btQuaternion tp0(p0[0],p0[1],p0[2],p0[3]);
	o->setMotorTarget(tp0,p1);
	p0[0]=tp0.getX();p0[1]=tp0.getY();p0[2]=tp0.getZ();p0[3]=tp0.getW();
}
//method: setMotorTarget void ( ::btHingeConstraint::* )( ::btScalar,::btScalar ) 
void btHingeConstraint_setMotorTarget1(void *c,float p0,float p1) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->setMotorTarget(p0,p1);
}
//method: getAngularOnly bool ( ::btHingeConstraint::* )(  ) 
int btHingeConstraint_getAngularOnly(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	int retVal = (int)o->getAngularOnly();
	return retVal;
}
//method: setFrames void ( ::btHingeConstraint::* )( ::btTransform const &,::btTransform const & ) 
void btHingeConstraint_setFrames(void *c,float* p0,float* p1) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->setFrames(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: setAxis void ( ::btHingeConstraint::* )( ::btVector3 & ) 
void btHingeConstraint_setAxis(void *c,float* p0) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setAxis(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getAFrame ::btTransform const & ( ::btHingeConstraint::* )(  ) const
void btHingeConstraint_getAFrame(void *c,float* ret) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getAFrame();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getAFrame ::btTransform const & ( ::btHingeConstraint::* )(  ) const
void btHingeConstraint_getAFrame0(void *c,float* ret) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getAFrame();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getAFrame ::btTransform & ( ::btHingeConstraint::* )(  ) 
void btHingeConstraint_getAFrame1(void *c,float* ret) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getAFrame();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//attribute: ::btJacobianEntry[3] btHingeConstraint->m_jac
// attribute not supported: //attribute: ::btJacobianEntry[3] btHingeConstraint->m_jac
//attribute: ::btJacobianEntry[3] btHingeConstraint->m_jacAng
// attribute not supported: //attribute: ::btJacobianEntry[3] btHingeConstraint->m_jacAng
//attribute: ::btTransform btHingeConstraint->m_rbAFrame
void btHingeConstraint_m_rbAFrame_set(void *c,float* a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_rbAFrame = ta;
}
void btHingeConstraint_m_rbAFrame_get(void *c,float* a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	a[0]=(o->m_rbAFrame).getBasis().getRow(0).m_floats[0];a[1]=(o->m_rbAFrame).getBasis().getRow(0).m_floats[1];a[2]=(o->m_rbAFrame).getBasis().getRow(0).m_floats[2];a[3]=(o->m_rbAFrame).getBasis().getRow(1).m_floats[0];a[4]=(o->m_rbAFrame).getBasis().getRow(1).m_floats[1];a[5]=(o->m_rbAFrame).getBasis().getRow(1).m_floats[2];a[6]=(o->m_rbAFrame).getBasis().getRow(2).m_floats[0];a[7]=(o->m_rbAFrame).getBasis().getRow(2).m_floats[1];a[8]=(o->m_rbAFrame).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_rbAFrame).getOrigin().m_floats[0];a[10]=(o->m_rbAFrame).getOrigin().m_floats[1];a[11]=(o->m_rbAFrame).getOrigin().m_floats[2];
}

//attribute: ::btTransform btHingeConstraint->m_rbBFrame
void btHingeConstraint_m_rbBFrame_set(void *c,float* a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_rbBFrame = ta;
}
void btHingeConstraint_m_rbBFrame_get(void *c,float* a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	a[0]=(o->m_rbBFrame).getBasis().getRow(0).m_floats[0];a[1]=(o->m_rbBFrame).getBasis().getRow(0).m_floats[1];a[2]=(o->m_rbBFrame).getBasis().getRow(0).m_floats[2];a[3]=(o->m_rbBFrame).getBasis().getRow(1).m_floats[0];a[4]=(o->m_rbBFrame).getBasis().getRow(1).m_floats[1];a[5]=(o->m_rbBFrame).getBasis().getRow(1).m_floats[2];a[6]=(o->m_rbBFrame).getBasis().getRow(2).m_floats[0];a[7]=(o->m_rbBFrame).getBasis().getRow(2).m_floats[1];a[8]=(o->m_rbBFrame).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_rbBFrame).getOrigin().m_floats[0];a[10]=(o->m_rbBFrame).getOrigin().m_floats[1];a[11]=(o->m_rbBFrame).getOrigin().m_floats[2];
}

//attribute: ::btScalar btHingeConstraint->m_motorTargetVelocity
void btHingeConstraint_m_motorTargetVelocity_set(void *c,float a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_motorTargetVelocity = a;
}
float btHingeConstraint_m_motorTargetVelocity_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (float)(o->m_motorTargetVelocity);
}

//attribute: ::btScalar btHingeConstraint->m_maxMotorImpulse
void btHingeConstraint_m_maxMotorImpulse_set(void *c,float a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_maxMotorImpulse = a;
}
float btHingeConstraint_m_maxMotorImpulse_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (float)(o->m_maxMotorImpulse);
}

//attribute: ::btAngularLimit btHingeConstraint->m_limit
void btHingeConstraint_m_limit_set(void *c,void* a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	::btAngularLimit & ta = *(::btAngularLimit *)a;
	o->m_limit = ta;
}
void* btHingeConstraint_m_limit_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (void*)&(o->m_limit);
}

//attribute: ::btScalar btHingeConstraint->m_kHinge
void btHingeConstraint_m_kHinge_set(void *c,float a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_kHinge = a;
}
float btHingeConstraint_m_kHinge_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (float)(o->m_kHinge);
}

//attribute: ::btScalar btHingeConstraint->m_accLimitImpulse
void btHingeConstraint_m_accLimitImpulse_set(void *c,float a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_accLimitImpulse = a;
}
float btHingeConstraint_m_accLimitImpulse_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (float)(o->m_accLimitImpulse);
}

//attribute: ::btScalar btHingeConstraint->m_hingeAngle
void btHingeConstraint_m_hingeAngle_set(void *c,float a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_hingeAngle = a;
}
float btHingeConstraint_m_hingeAngle_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (float)(o->m_hingeAngle);
}

//attribute: ::btScalar btHingeConstraint->m_referenceSign
void btHingeConstraint_m_referenceSign_set(void *c,float a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_referenceSign = a;
}
float btHingeConstraint_m_referenceSign_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (float)(o->m_referenceSign);
}

//attribute: bool btHingeConstraint->m_angularOnly
void btHingeConstraint_m_angularOnly_set(void *c,int a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_angularOnly = a;
}
int btHingeConstraint_m_angularOnly_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (int)(o->m_angularOnly);
}

//attribute: bool btHingeConstraint->m_enableAngularMotor
void btHingeConstraint_m_enableAngularMotor_set(void *c,int a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_enableAngularMotor = a;
}
int btHingeConstraint_m_enableAngularMotor_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (int)(o->m_enableAngularMotor);
}

//attribute: bool btHingeConstraint->m_useSolveConstraintObsolete
void btHingeConstraint_m_useSolveConstraintObsolete_set(void *c,int a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_useSolveConstraintObsolete = a;
}
int btHingeConstraint_m_useSolveConstraintObsolete_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (int)(o->m_useSolveConstraintObsolete);
}

//attribute: bool btHingeConstraint->m_useOffsetForConstraintFrame
void btHingeConstraint_m_useOffsetForConstraintFrame_set(void *c,int a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_useOffsetForConstraintFrame = a;
}
int btHingeConstraint_m_useOffsetForConstraintFrame_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (int)(o->m_useOffsetForConstraintFrame);
}

//attribute: bool btHingeConstraint->m_useReferenceFrameA
void btHingeConstraint_m_useReferenceFrameA_set(void *c,int a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_useReferenceFrameA = a;
}
int btHingeConstraint_m_useReferenceFrameA_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (int)(o->m_useReferenceFrameA);
}

//attribute: ::btScalar btHingeConstraint->m_accMotorImpulse
void btHingeConstraint_m_accMotorImpulse_set(void *c,float a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_accMotorImpulse = a;
}
float btHingeConstraint_m_accMotorImpulse_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (float)(o->m_accMotorImpulse);
}

//attribute: int btHingeConstraint->m_flags
void btHingeConstraint_m_flags_set(void *c,int a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_flags = a;
}
int btHingeConstraint_m_flags_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (int)(o->m_flags);
}

//attribute: ::btScalar btHingeConstraint->m_normalCFM
void btHingeConstraint_m_normalCFM_set(void *c,float a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_normalCFM = a;
}
float btHingeConstraint_m_normalCFM_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (float)(o->m_normalCFM);
}

//attribute: ::btScalar btHingeConstraint->m_stopCFM
void btHingeConstraint_m_stopCFM_set(void *c,float a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_stopCFM = a;
}
float btHingeConstraint_m_stopCFM_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (float)(o->m_stopCFM);
}

//attribute: ::btScalar btHingeConstraint->m_stopERP
void btHingeConstraint_m_stopERP_set(void *c,float a) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	o->m_stopERP = a;
}
float btHingeConstraint_m_stopERP_get(void *c) {
	::btHingeConstraint *o = (::btHingeConstraint*)c;
	return (float)(o->m_stopERP);
}


// ::btHingeConstraintDoubleData
//constructor: btHingeConstraintDoubleData  ( ::btHingeConstraintDoubleData::* )(  ) 
void* btHingeConstraintDoubleData_new() {
	::btHingeConstraintDoubleData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btHingeConstraintDoubleData),16);
	o = new (mem)::btHingeConstraintDoubleData();
	return (void*)o;
}
void btHingeConstraintDoubleData_free(void *c) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	delete o;
}
//attribute: ::btTypedConstraintData btHingeConstraintDoubleData->m_typeConstraintData
void btHingeConstraintDoubleData_m_typeConstraintData_set(void *c,void* a) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	::btTypedConstraintData & ta = *(::btTypedConstraintData *)a;
	o->m_typeConstraintData = ta;
}
void* btHingeConstraintDoubleData_m_typeConstraintData_get(void *c) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	return (void*)&(o->m_typeConstraintData);
}

//attribute: ::btTransformDoubleData btHingeConstraintDoubleData->m_rbAFrame
void btHingeConstraintDoubleData_m_rbAFrame_set(void *c,void* a) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	::btTransformDoubleData & ta = *(::btTransformDoubleData *)a;
	o->m_rbAFrame = ta;
}
void* btHingeConstraintDoubleData_m_rbAFrame_get(void *c) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	return (void*)&(o->m_rbAFrame);
}

//attribute: ::btTransformDoubleData btHingeConstraintDoubleData->m_rbBFrame
void btHingeConstraintDoubleData_m_rbBFrame_set(void *c,void* a) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	::btTransformDoubleData & ta = *(::btTransformDoubleData *)a;
	o->m_rbBFrame = ta;
}
void* btHingeConstraintDoubleData_m_rbBFrame_get(void *c) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	return (void*)&(o->m_rbBFrame);
}

//attribute: int btHingeConstraintDoubleData->m_useReferenceFrameA
void btHingeConstraintDoubleData_m_useReferenceFrameA_set(void *c,int a) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	o->m_useReferenceFrameA = a;
}
int btHingeConstraintDoubleData_m_useReferenceFrameA_get(void *c) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	return (int)(o->m_useReferenceFrameA);
}

//attribute: int btHingeConstraintDoubleData->m_angularOnly
void btHingeConstraintDoubleData_m_angularOnly_set(void *c,int a) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	o->m_angularOnly = a;
}
int btHingeConstraintDoubleData_m_angularOnly_get(void *c) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	return (int)(o->m_angularOnly);
}

//attribute: int btHingeConstraintDoubleData->m_enableAngularMotor
void btHingeConstraintDoubleData_m_enableAngularMotor_set(void *c,int a) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	o->m_enableAngularMotor = a;
}
int btHingeConstraintDoubleData_m_enableAngularMotor_get(void *c) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	return (int)(o->m_enableAngularMotor);
}

//attribute: float btHingeConstraintDoubleData->m_motorTargetVelocity
void btHingeConstraintDoubleData_m_motorTargetVelocity_set(void *c,float a) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	o->m_motorTargetVelocity = a;
}
float btHingeConstraintDoubleData_m_motorTargetVelocity_get(void *c) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	return (float)(o->m_motorTargetVelocity);
}

//attribute: float btHingeConstraintDoubleData->m_maxMotorImpulse
void btHingeConstraintDoubleData_m_maxMotorImpulse_set(void *c,float a) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	o->m_maxMotorImpulse = a;
}
float btHingeConstraintDoubleData_m_maxMotorImpulse_get(void *c) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	return (float)(o->m_maxMotorImpulse);
}

//attribute: float btHingeConstraintDoubleData->m_lowerLimit
void btHingeConstraintDoubleData_m_lowerLimit_set(void *c,float a) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	o->m_lowerLimit = a;
}
float btHingeConstraintDoubleData_m_lowerLimit_get(void *c) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	return (float)(o->m_lowerLimit);
}

//attribute: float btHingeConstraintDoubleData->m_upperLimit
void btHingeConstraintDoubleData_m_upperLimit_set(void *c,float a) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	o->m_upperLimit = a;
}
float btHingeConstraintDoubleData_m_upperLimit_get(void *c) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	return (float)(o->m_upperLimit);
}

//attribute: float btHingeConstraintDoubleData->m_limitSoftness
void btHingeConstraintDoubleData_m_limitSoftness_set(void *c,float a) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	o->m_limitSoftness = a;
}
float btHingeConstraintDoubleData_m_limitSoftness_get(void *c) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	return (float)(o->m_limitSoftness);
}

//attribute: float btHingeConstraintDoubleData->m_biasFactor
void btHingeConstraintDoubleData_m_biasFactor_set(void *c,float a) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	o->m_biasFactor = a;
}
float btHingeConstraintDoubleData_m_biasFactor_get(void *c) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	return (float)(o->m_biasFactor);
}

//attribute: float btHingeConstraintDoubleData->m_relaxationFactor
void btHingeConstraintDoubleData_m_relaxationFactor_set(void *c,float a) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	o->m_relaxationFactor = a;
}
float btHingeConstraintDoubleData_m_relaxationFactor_get(void *c) {
	::btHingeConstraintDoubleData *o = (::btHingeConstraintDoubleData*)c;
	return (float)(o->m_relaxationFactor);
}


// ::btHingeConstraintFloatData
//constructor: btHingeConstraintFloatData  ( ::btHingeConstraintFloatData::* )(  ) 
void* btHingeConstraintFloatData_new() {
	::btHingeConstraintFloatData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btHingeConstraintFloatData),16);
	o = new (mem)::btHingeConstraintFloatData();
	return (void*)o;
}
void btHingeConstraintFloatData_free(void *c) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	delete o;
}
//attribute: ::btTypedConstraintData btHingeConstraintFloatData->m_typeConstraintData
void btHingeConstraintFloatData_m_typeConstraintData_set(void *c,void* a) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	::btTypedConstraintData & ta = *(::btTypedConstraintData *)a;
	o->m_typeConstraintData = ta;
}
void* btHingeConstraintFloatData_m_typeConstraintData_get(void *c) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	return (void*)&(o->m_typeConstraintData);
}

//attribute: ::btTransformFloatData btHingeConstraintFloatData->m_rbAFrame
void btHingeConstraintFloatData_m_rbAFrame_set(void *c,void* a) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	::btTransformFloatData & ta = *(::btTransformFloatData *)a;
	o->m_rbAFrame = ta;
}
void* btHingeConstraintFloatData_m_rbAFrame_get(void *c) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	return (void*)&(o->m_rbAFrame);
}

//attribute: ::btTransformFloatData btHingeConstraintFloatData->m_rbBFrame
void btHingeConstraintFloatData_m_rbBFrame_set(void *c,void* a) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	::btTransformFloatData & ta = *(::btTransformFloatData *)a;
	o->m_rbBFrame = ta;
}
void* btHingeConstraintFloatData_m_rbBFrame_get(void *c) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	return (void*)&(o->m_rbBFrame);
}

//attribute: int btHingeConstraintFloatData->m_useReferenceFrameA
void btHingeConstraintFloatData_m_useReferenceFrameA_set(void *c,int a) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	o->m_useReferenceFrameA = a;
}
int btHingeConstraintFloatData_m_useReferenceFrameA_get(void *c) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	return (int)(o->m_useReferenceFrameA);
}

//attribute: int btHingeConstraintFloatData->m_angularOnly
void btHingeConstraintFloatData_m_angularOnly_set(void *c,int a) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	o->m_angularOnly = a;
}
int btHingeConstraintFloatData_m_angularOnly_get(void *c) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	return (int)(o->m_angularOnly);
}

//attribute: int btHingeConstraintFloatData->m_enableAngularMotor
void btHingeConstraintFloatData_m_enableAngularMotor_set(void *c,int a) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	o->m_enableAngularMotor = a;
}
int btHingeConstraintFloatData_m_enableAngularMotor_get(void *c) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	return (int)(o->m_enableAngularMotor);
}

//attribute: float btHingeConstraintFloatData->m_motorTargetVelocity
void btHingeConstraintFloatData_m_motorTargetVelocity_set(void *c,float a) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	o->m_motorTargetVelocity = a;
}
float btHingeConstraintFloatData_m_motorTargetVelocity_get(void *c) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	return (float)(o->m_motorTargetVelocity);
}

//attribute: float btHingeConstraintFloatData->m_maxMotorImpulse
void btHingeConstraintFloatData_m_maxMotorImpulse_set(void *c,float a) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	o->m_maxMotorImpulse = a;
}
float btHingeConstraintFloatData_m_maxMotorImpulse_get(void *c) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	return (float)(o->m_maxMotorImpulse);
}

//attribute: float btHingeConstraintFloatData->m_lowerLimit
void btHingeConstraintFloatData_m_lowerLimit_set(void *c,float a) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	o->m_lowerLimit = a;
}
float btHingeConstraintFloatData_m_lowerLimit_get(void *c) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	return (float)(o->m_lowerLimit);
}

//attribute: float btHingeConstraintFloatData->m_upperLimit
void btHingeConstraintFloatData_m_upperLimit_set(void *c,float a) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	o->m_upperLimit = a;
}
float btHingeConstraintFloatData_m_upperLimit_get(void *c) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	return (float)(o->m_upperLimit);
}

//attribute: float btHingeConstraintFloatData->m_limitSoftness
void btHingeConstraintFloatData_m_limitSoftness_set(void *c,float a) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	o->m_limitSoftness = a;
}
float btHingeConstraintFloatData_m_limitSoftness_get(void *c) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	return (float)(o->m_limitSoftness);
}

//attribute: float btHingeConstraintFloatData->m_biasFactor
void btHingeConstraintFloatData_m_biasFactor_set(void *c,float a) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	o->m_biasFactor = a;
}
float btHingeConstraintFloatData_m_biasFactor_get(void *c) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	return (float)(o->m_biasFactor);
}

//attribute: float btHingeConstraintFloatData->m_relaxationFactor
void btHingeConstraintFloatData_m_relaxationFactor_set(void *c,float a) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	o->m_relaxationFactor = a;
}
float btHingeConstraintFloatData_m_relaxationFactor_get(void *c) {
	::btHingeConstraintFloatData *o = (::btHingeConstraintFloatData*)c;
	return (float)(o->m_relaxationFactor);
}


// ::btJacobianEntry
//constructor: btJacobianEntry  ( ::btJacobianEntry::* )(  ) 
void* btJacobianEntry_new0() {
	::btJacobianEntry *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btJacobianEntry),16);
	o = new (mem)::btJacobianEntry();
	return (void*)o;
}
//not supported constructor: btJacobianEntry  ( ::btJacobianEntry::* )( ::btMatrix3x3 const &,::btMatrix3x3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar const,::btVector3 const &,::btScalar const ) 
// error: ::btMatrix3x3 const & - ok, ::btMatrix3x3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported, ::btVector3 const & - ok,  - unsupported

//constructor: btJacobianEntry  ( ::btJacobianEntry::* )( ::btVector3 const &,::btMatrix3x3 const &,::btMatrix3x3 const &,::btVector3 const &,::btVector3 const & ) 
void* btJacobianEntry_new2(float* p0,float* p1,float* p2,float* p3,float* p4) {
	::btJacobianEntry *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btMatrix3x3 tp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btMatrix3x3 tp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	mem = btAlignedAlloc(sizeof(::btJacobianEntry),16);
	o = new (mem)::btJacobianEntry(tp0,tp1,tp2,tp3,tp4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.getRow(0).m_floats[0];p1[1]=tp1.getRow(0).m_floats[1];p1[2]=tp1.getRow(0).m_floats[2];p1[3]=tp1.getRow(1).m_floats[0];p1[4]=tp1.getRow(1).m_floats[1];p1[5]=tp1.getRow(1).m_floats[2];p1[6]=tp1.getRow(2).m_floats[0];p1[7]=tp1.getRow(2).m_floats[1];p1[8]=tp1.getRow(2).m_floats[2];
	p2[0]=tp2.getRow(0).m_floats[0];p2[1]=tp2.getRow(0).m_floats[1];p2[2]=tp2.getRow(0).m_floats[2];p2[3]=tp2.getRow(1).m_floats[0];p2[4]=tp2.getRow(1).m_floats[1];p2[5]=tp2.getRow(1).m_floats[2];p2[6]=tp2.getRow(2).m_floats[0];p2[7]=tp2.getRow(2).m_floats[1];p2[8]=tp2.getRow(2).m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	return (void*)o;
}
//constructor: btJacobianEntry  ( ::btJacobianEntry::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void* btJacobianEntry_new3(float* p0,float* p1,float* p2,float* p3) {
	::btJacobianEntry *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	mem = btAlignedAlloc(sizeof(::btJacobianEntry),16);
	o = new (mem)::btJacobianEntry(tp0,tp1,tp2,tp3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	return (void*)o;
}
//not supported constructor: btJacobianEntry  ( ::btJacobianEntry::* )( ::btMatrix3x3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar const ) 
// error: ::btMatrix3x3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported

void btJacobianEntry_free(void *c) {
	::btJacobianEntry *o = (::btJacobianEntry*)c;
	delete o;
}
//method: getDiagonal ::btScalar ( ::btJacobianEntry::* )(  ) const
float btJacobianEntry_getDiagonal(void *c) {
	::btJacobianEntry *o = (::btJacobianEntry*)c;
	float retVal = (float)o->getDiagonal();
	return retVal;
}
//method: getRelativeVelocity ::btScalar ( ::btJacobianEntry::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
float btJacobianEntry_getRelativeVelocity(void *c,float* p0,float* p1,float* p2,float* p3) {
	::btJacobianEntry *o = (::btJacobianEntry*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	float retVal = (float)o->getRelativeVelocity(tp0,tp1,tp2,tp3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	return retVal;
}
//not supported method: getNonDiagonal ::btScalar ( ::btJacobianEntry::* )( ::btJacobianEntry const &,::btScalar const ) const
// error: ::btJacobianEntry const & - ok,  - unsupported, ::btScalar - ok

//not supported method: getNonDiagonal ::btScalar ( ::btJacobianEntry::* )( ::btJacobianEntry const &,::btScalar const ) const
// error: ::btJacobianEntry const & - ok,  - unsupported, ::btScalar - ok

//not supported method: getNonDiagonal ::btScalar ( ::btJacobianEntry::* )( ::btJacobianEntry const &,::btScalar const,::btScalar const ) const
// error: ::btJacobianEntry const & - ok,  - unsupported,  - unsupported, ::btScalar - ok

//attribute: ::btVector3 btJacobianEntry->m_0MinvJt
void btJacobianEntry_m_0MinvJt_set(void *c,float* a) {
	::btJacobianEntry *o = (::btJacobianEntry*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_0MinvJt = ta;
}
void btJacobianEntry_m_0MinvJt_get(void *c,float* a) {
	::btJacobianEntry *o = (::btJacobianEntry*)c;
	a[0]=(o->m_0MinvJt).m_floats[0];a[1]=(o->m_0MinvJt).m_floats[1];a[2]=(o->m_0MinvJt).m_floats[2];
}

//attribute: ::btVector3 btJacobianEntry->m_1MinvJt
void btJacobianEntry_m_1MinvJt_set(void *c,float* a) {
	::btJacobianEntry *o = (::btJacobianEntry*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_1MinvJt = ta;
}
void btJacobianEntry_m_1MinvJt_get(void *c,float* a) {
	::btJacobianEntry *o = (::btJacobianEntry*)c;
	a[0]=(o->m_1MinvJt).m_floats[0];a[1]=(o->m_1MinvJt).m_floats[1];a[2]=(o->m_1MinvJt).m_floats[2];
}

//attribute: ::btScalar btJacobianEntry->m_Adiag
void btJacobianEntry_m_Adiag_set(void *c,float a) {
	::btJacobianEntry *o = (::btJacobianEntry*)c;
	o->m_Adiag = a;
}
float btJacobianEntry_m_Adiag_get(void *c) {
	::btJacobianEntry *o = (::btJacobianEntry*)c;
	return (float)(o->m_Adiag);
}

//attribute: ::btVector3 btJacobianEntry->m_aJ
void btJacobianEntry_m_aJ_set(void *c,float* a) {
	::btJacobianEntry *o = (::btJacobianEntry*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_aJ = ta;
}
void btJacobianEntry_m_aJ_get(void *c,float* a) {
	::btJacobianEntry *o = (::btJacobianEntry*)c;
	a[0]=(o->m_aJ).m_floats[0];a[1]=(o->m_aJ).m_floats[1];a[2]=(o->m_aJ).m_floats[2];
}

//attribute: ::btVector3 btJacobianEntry->m_bJ
void btJacobianEntry_m_bJ_set(void *c,float* a) {
	::btJacobianEntry *o = (::btJacobianEntry*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_bJ = ta;
}
void btJacobianEntry_m_bJ_get(void *c,float* a) {
	::btJacobianEntry *o = (::btJacobianEntry*)c;
	a[0]=(o->m_bJ).m_floats[0];a[1]=(o->m_bJ).m_floats[1];a[2]=(o->m_bJ).m_floats[2];
}

//attribute: ::btVector3 btJacobianEntry->m_linearJointAxis
void btJacobianEntry_m_linearJointAxis_set(void *c,float* a) {
	::btJacobianEntry *o = (::btJacobianEntry*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_linearJointAxis = ta;
}
void btJacobianEntry_m_linearJointAxis_get(void *c,float* a) {
	::btJacobianEntry *o = (::btJacobianEntry*)c;
	a[0]=(o->m_linearJointAxis).m_floats[0];a[1]=(o->m_linearJointAxis).m_floats[1];a[2]=(o->m_linearJointAxis).m_floats[2];
}


// ::btPoint2PointConstraint
//constructor: btPoint2PointConstraint  ( ::btPoint2PointConstraint::* )( ::btRigidBody &,::btRigidBody &,::btVector3 const &,::btVector3 const & ) 
void* btPoint2PointConstraint_new0(void* p0,void* p1,float* p2,float* p3) {
	::btPoint2PointConstraint *o = 0;
	 void *mem = 0;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	mem = btAlignedAlloc(sizeof(::btPoint2PointConstraint),16);
	o = new (mem)::btPoint2PointConstraint(tp0,tp1,tp2,tp3);
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	return (void*)o;
}
//constructor: btPoint2PointConstraint  ( ::btPoint2PointConstraint::* )( ::btRigidBody &,::btVector3 const & ) 
void* btPoint2PointConstraint_new1(void* p0,float* p1) {
	::btPoint2PointConstraint *o = 0;
	 void *mem = 0;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	mem = btAlignedAlloc(sizeof(::btPoint2PointConstraint),16);
	o = new (mem)::btPoint2PointConstraint(tp0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return (void*)o;
}
void btPoint2PointConstraint_free(void *c) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	delete o;
}
//method: getInfo1NonVirtual void ( ::btPoint2PointConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btPoint2PointConstraint_getInfo1NonVirtual(void *c,void* p0) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	::btTypedConstraint::btConstraintInfo1 * tp0 = (::btTypedConstraint::btConstraintInfo1 *)p0;
	o->getInfo1NonVirtual(tp0);
}
//method: getInfo2NonVirtual void ( ::btPoint2PointConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,::btTransform const &,::btTransform const & ) 
void btPoint2PointConstraint_getInfo2NonVirtual(void *c,void* p0,float* p1,float* p2) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	o->getInfo2NonVirtual(tp0,tp1,tp2);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
}
//method: setParam void ( ::btPoint2PointConstraint::* )( int,::btScalar,int ) 
void btPoint2PointConstraint_setParam(void *c,int p0,float p1,int p2) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	o->setParam(p0,p1,p2);
}
//method: getPivotInA ::btVector3 const & ( ::btPoint2PointConstraint::* )(  ) const
void btPoint2PointConstraint_getPivotInA(void *c,float* ret) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getPivotInA();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getPivotInB ::btVector3 const & ( ::btPoint2PointConstraint::* )(  ) const
void btPoint2PointConstraint_getPivotInB(void *c,float* ret) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getPivotInB();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: updateRHS void ( ::btPoint2PointConstraint::* )( ::btScalar ) 
void btPoint2PointConstraint_updateRHS(void *c,float p0) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	o->updateRHS(p0);
}
//method: serialize char const * ( ::btPoint2PointConstraint::* )( void *,::btSerializer * ) const
char const * btPoint2PointConstraint_serialize(void *c,void* p0,void* p1) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: buildJacobian void ( ::btPoint2PointConstraint::* )(  ) 
void btPoint2PointConstraint_buildJacobian(void *c) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	o->buildJacobian();
}
//method: calculateSerializeBufferSize int ( ::btPoint2PointConstraint::* )(  ) const
int btPoint2PointConstraint_calculateSerializeBufferSize(void *c) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: getParam ::btScalar ( ::btPoint2PointConstraint::* )( int,int ) const
float btPoint2PointConstraint_getParam(void *c,int p0,int p1) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	float retVal = (float)o->getParam(p0,p1);
	return retVal;
}
//method: getInfo1 void ( ::btPoint2PointConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btPoint2PointConstraint_getInfo1(void *c,void* p0) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	::btTypedConstraint::btConstraintInfo1 * tp0 = (::btTypedConstraint::btConstraintInfo1 *)p0;
	o->getInfo1(tp0);
}
//method: getInfo2 void ( ::btPoint2PointConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void btPoint2PointConstraint_getInfo2(void *c,void* p0) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	o->getInfo2(tp0);
}
//method: setPivotA void ( ::btPoint2PointConstraint::* )( ::btVector3 const & ) 
void btPoint2PointConstraint_setPivotA(void *c,float* p0) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setPivotA(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: setPivotB void ( ::btPoint2PointConstraint::* )( ::btVector3 const & ) 
void btPoint2PointConstraint_setPivotB(void *c,float* p0) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setPivotB(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//attribute: ::btJacobianEntry[3] btPoint2PointConstraint->m_jac
// attribute not supported: //attribute: ::btJacobianEntry[3] btPoint2PointConstraint->m_jac
//attribute: ::btVector3 btPoint2PointConstraint->m_pivotInA
void btPoint2PointConstraint_m_pivotInA_set(void *c,float* a) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_pivotInA = ta;
}
void btPoint2PointConstraint_m_pivotInA_get(void *c,float* a) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	a[0]=(o->m_pivotInA).m_floats[0];a[1]=(o->m_pivotInA).m_floats[1];a[2]=(o->m_pivotInA).m_floats[2];
}

//attribute: ::btVector3 btPoint2PointConstraint->m_pivotInB
void btPoint2PointConstraint_m_pivotInB_set(void *c,float* a) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_pivotInB = ta;
}
void btPoint2PointConstraint_m_pivotInB_get(void *c,float* a) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	a[0]=(o->m_pivotInB).m_floats[0];a[1]=(o->m_pivotInB).m_floats[1];a[2]=(o->m_pivotInB).m_floats[2];
}

//attribute: int btPoint2PointConstraint->m_flags
void btPoint2PointConstraint_m_flags_set(void *c,int a) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	o->m_flags = a;
}
int btPoint2PointConstraint_m_flags_get(void *c) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	return (int)(o->m_flags);
}

//attribute: ::btScalar btPoint2PointConstraint->m_erp
void btPoint2PointConstraint_m_erp_set(void *c,float a) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	o->m_erp = a;
}
float btPoint2PointConstraint_m_erp_get(void *c) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	return (float)(o->m_erp);
}

//attribute: ::btScalar btPoint2PointConstraint->m_cfm
void btPoint2PointConstraint_m_cfm_set(void *c,float a) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	o->m_cfm = a;
}
float btPoint2PointConstraint_m_cfm_get(void *c) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	return (float)(o->m_cfm);
}

//attribute: bool btPoint2PointConstraint->m_useSolveConstraintObsolete
void btPoint2PointConstraint_m_useSolveConstraintObsolete_set(void *c,int a) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	o->m_useSolveConstraintObsolete = a;
}
int btPoint2PointConstraint_m_useSolveConstraintObsolete_get(void *c) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	return (int)(o->m_useSolveConstraintObsolete);
}

//attribute: ::btConstraintSetting btPoint2PointConstraint->m_setting
void btPoint2PointConstraint_m_setting_set(void *c,void* a) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	::btConstraintSetting & ta = *(::btConstraintSetting *)a;
	o->m_setting = ta;
}
void* btPoint2PointConstraint_m_setting_get(void *c) {
	::btPoint2PointConstraint *o = (::btPoint2PointConstraint*)c;
	return (void*)&(o->m_setting);
}


// ::btPoint2PointConstraintDoubleData
//constructor: btPoint2PointConstraintDoubleData  ( ::btPoint2PointConstraintDoubleData::* )(  ) 
void* btPoint2PointConstraintDoubleData_new() {
	::btPoint2PointConstraintDoubleData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btPoint2PointConstraintDoubleData),16);
	o = new (mem)::btPoint2PointConstraintDoubleData();
	return (void*)o;
}
void btPoint2PointConstraintDoubleData_free(void *c) {
	::btPoint2PointConstraintDoubleData *o = (::btPoint2PointConstraintDoubleData*)c;
	delete o;
}
//attribute: ::btTypedConstraintData btPoint2PointConstraintDoubleData->m_typeConstraintData
void btPoint2PointConstraintDoubleData_m_typeConstraintData_set(void *c,void* a) {
	::btPoint2PointConstraintDoubleData *o = (::btPoint2PointConstraintDoubleData*)c;
	::btTypedConstraintData & ta = *(::btTypedConstraintData *)a;
	o->m_typeConstraintData = ta;
}
void* btPoint2PointConstraintDoubleData_m_typeConstraintData_get(void *c) {
	::btPoint2PointConstraintDoubleData *o = (::btPoint2PointConstraintDoubleData*)c;
	return (void*)&(o->m_typeConstraintData);
}

//attribute: ::btVector3DoubleData btPoint2PointConstraintDoubleData->m_pivotInA
void btPoint2PointConstraintDoubleData_m_pivotInA_set(void *c,void* a) {
	::btPoint2PointConstraintDoubleData *o = (::btPoint2PointConstraintDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_pivotInA = ta;
}
void* btPoint2PointConstraintDoubleData_m_pivotInA_get(void *c) {
	::btPoint2PointConstraintDoubleData *o = (::btPoint2PointConstraintDoubleData*)c;
	return (void*)&(o->m_pivotInA);
}

//attribute: ::btVector3DoubleData btPoint2PointConstraintDoubleData->m_pivotInB
void btPoint2PointConstraintDoubleData_m_pivotInB_set(void *c,void* a) {
	::btPoint2PointConstraintDoubleData *o = (::btPoint2PointConstraintDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_pivotInB = ta;
}
void* btPoint2PointConstraintDoubleData_m_pivotInB_get(void *c) {
	::btPoint2PointConstraintDoubleData *o = (::btPoint2PointConstraintDoubleData*)c;
	return (void*)&(o->m_pivotInB);
}


// ::btPoint2PointConstraintFloatData
//constructor: btPoint2PointConstraintFloatData  ( ::btPoint2PointConstraintFloatData::* )(  ) 
void* btPoint2PointConstraintFloatData_new() {
	::btPoint2PointConstraintFloatData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btPoint2PointConstraintFloatData),16);
	o = new (mem)::btPoint2PointConstraintFloatData();
	return (void*)o;
}
void btPoint2PointConstraintFloatData_free(void *c) {
	::btPoint2PointConstraintFloatData *o = (::btPoint2PointConstraintFloatData*)c;
	delete o;
}
//attribute: ::btTypedConstraintData btPoint2PointConstraintFloatData->m_typeConstraintData
void btPoint2PointConstraintFloatData_m_typeConstraintData_set(void *c,void* a) {
	::btPoint2PointConstraintFloatData *o = (::btPoint2PointConstraintFloatData*)c;
	::btTypedConstraintData & ta = *(::btTypedConstraintData *)a;
	o->m_typeConstraintData = ta;
}
void* btPoint2PointConstraintFloatData_m_typeConstraintData_get(void *c) {
	::btPoint2PointConstraintFloatData *o = (::btPoint2PointConstraintFloatData*)c;
	return (void*)&(o->m_typeConstraintData);
}

//attribute: ::btVector3FloatData btPoint2PointConstraintFloatData->m_pivotInA
void btPoint2PointConstraintFloatData_m_pivotInA_set(void *c,void* a) {
	::btPoint2PointConstraintFloatData *o = (::btPoint2PointConstraintFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_pivotInA = ta;
}
void* btPoint2PointConstraintFloatData_m_pivotInA_get(void *c) {
	::btPoint2PointConstraintFloatData *o = (::btPoint2PointConstraintFloatData*)c;
	return (void*)&(o->m_pivotInA);
}

//attribute: ::btVector3FloatData btPoint2PointConstraintFloatData->m_pivotInB
void btPoint2PointConstraintFloatData_m_pivotInB_set(void *c,void* a) {
	::btPoint2PointConstraintFloatData *o = (::btPoint2PointConstraintFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_pivotInB = ta;
}
void* btPoint2PointConstraintFloatData_m_pivotInB_get(void *c) {
	::btPoint2PointConstraintFloatData *o = (::btPoint2PointConstraintFloatData*)c;
	return (void*)&(o->m_pivotInB);
}


// ::btRotationalLimitMotor
//constructor: btRotationalLimitMotor  ( ::btRotationalLimitMotor::* )(  ) 
void* btRotationalLimitMotor_new() {
	::btRotationalLimitMotor *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btRotationalLimitMotor),16);
	o = new (mem)::btRotationalLimitMotor();
	return (void*)o;
}
void btRotationalLimitMotor_free(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	delete o;
}
//method: testLimitValue int ( ::btRotationalLimitMotor::* )( ::btScalar ) 
int btRotationalLimitMotor_testLimitValue(void *c,float p0) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	int retVal = (int)o->testLimitValue(p0);
	return retVal;
}
//method: solveAngularLimits ::btScalar ( ::btRotationalLimitMotor::* )( ::btScalar,::btVector3 &,::btScalar,::btRigidBody *,::btRigidBody * ) 
float btRotationalLimitMotor_solveAngularLimits(void *c,float p0,float* p1,float p2,void* p3,void* p4) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btRigidBody * tp3 = (::btRigidBody *)p3;
	::btRigidBody * tp4 = (::btRigidBody *)p4;
	float retVal = (float)o->solveAngularLimits(p0,tp1,p2,tp3,tp4);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//method: needApplyTorques bool ( ::btRotationalLimitMotor::* )(  ) 
int btRotationalLimitMotor_needApplyTorques(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	int retVal = (int)o->needApplyTorques();
	return retVal;
}
//method: isLimited bool ( ::btRotationalLimitMotor::* )(  ) 
int btRotationalLimitMotor_isLimited(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	int retVal = (int)o->isLimited();
	return retVal;
}
//attribute: ::btScalar btRotationalLimitMotor->m_accumulatedImpulse
void btRotationalLimitMotor_m_accumulatedImpulse_set(void *c,float a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_accumulatedImpulse = a;
}
float btRotationalLimitMotor_m_accumulatedImpulse_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (float)(o->m_accumulatedImpulse);
}

//attribute: ::btScalar btRotationalLimitMotor->m_bounce
void btRotationalLimitMotor_m_bounce_set(void *c,float a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_bounce = a;
}
float btRotationalLimitMotor_m_bounce_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (float)(o->m_bounce);
}

//attribute: int btRotationalLimitMotor->m_currentLimit
void btRotationalLimitMotor_m_currentLimit_set(void *c,int a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_currentLimit = a;
}
int btRotationalLimitMotor_m_currentLimit_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (int)(o->m_currentLimit);
}

//attribute: ::btScalar btRotationalLimitMotor->m_currentLimitError
void btRotationalLimitMotor_m_currentLimitError_set(void *c,float a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_currentLimitError = a;
}
float btRotationalLimitMotor_m_currentLimitError_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (float)(o->m_currentLimitError);
}

//attribute: ::btScalar btRotationalLimitMotor->m_currentPosition
void btRotationalLimitMotor_m_currentPosition_set(void *c,float a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_currentPosition = a;
}
float btRotationalLimitMotor_m_currentPosition_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (float)(o->m_currentPosition);
}

//attribute: ::btScalar btRotationalLimitMotor->m_damping
void btRotationalLimitMotor_m_damping_set(void *c,float a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_damping = a;
}
float btRotationalLimitMotor_m_damping_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (float)(o->m_damping);
}

//attribute: bool btRotationalLimitMotor->m_enableMotor
void btRotationalLimitMotor_m_enableMotor_set(void *c,int a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_enableMotor = a;
}
int btRotationalLimitMotor_m_enableMotor_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (int)(o->m_enableMotor);
}

//attribute: ::btScalar btRotationalLimitMotor->m_hiLimit
void btRotationalLimitMotor_m_hiLimit_set(void *c,float a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_hiLimit = a;
}
float btRotationalLimitMotor_m_hiLimit_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (float)(o->m_hiLimit);
}

//attribute: ::btScalar btRotationalLimitMotor->m_limitSoftness
void btRotationalLimitMotor_m_limitSoftness_set(void *c,float a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_limitSoftness = a;
}
float btRotationalLimitMotor_m_limitSoftness_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (float)(o->m_limitSoftness);
}

//attribute: ::btScalar btRotationalLimitMotor->m_loLimit
void btRotationalLimitMotor_m_loLimit_set(void *c,float a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_loLimit = a;
}
float btRotationalLimitMotor_m_loLimit_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (float)(o->m_loLimit);
}

//attribute: ::btScalar btRotationalLimitMotor->m_maxLimitForce
void btRotationalLimitMotor_m_maxLimitForce_set(void *c,float a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_maxLimitForce = a;
}
float btRotationalLimitMotor_m_maxLimitForce_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (float)(o->m_maxLimitForce);
}

//attribute: ::btScalar btRotationalLimitMotor->m_maxMotorForce
void btRotationalLimitMotor_m_maxMotorForce_set(void *c,float a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_maxMotorForce = a;
}
float btRotationalLimitMotor_m_maxMotorForce_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (float)(o->m_maxMotorForce);
}

//attribute: ::btScalar btRotationalLimitMotor->m_normalCFM
void btRotationalLimitMotor_m_normalCFM_set(void *c,float a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_normalCFM = a;
}
float btRotationalLimitMotor_m_normalCFM_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (float)(o->m_normalCFM);
}

//attribute: ::btScalar btRotationalLimitMotor->m_stopCFM
void btRotationalLimitMotor_m_stopCFM_set(void *c,float a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_stopCFM = a;
}
float btRotationalLimitMotor_m_stopCFM_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (float)(o->m_stopCFM);
}

//attribute: ::btScalar btRotationalLimitMotor->m_stopERP
void btRotationalLimitMotor_m_stopERP_set(void *c,float a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_stopERP = a;
}
float btRotationalLimitMotor_m_stopERP_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (float)(o->m_stopERP);
}

//attribute: ::btScalar btRotationalLimitMotor->m_targetVelocity
void btRotationalLimitMotor_m_targetVelocity_set(void *c,float a) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	o->m_targetVelocity = a;
}
float btRotationalLimitMotor_m_targetVelocity_get(void *c) {
	::btRotationalLimitMotor *o = (::btRotationalLimitMotor*)c;
	return (float)(o->m_targetVelocity);
}


// ::btSequentialImpulseConstraintSolver
//constructor: btSequentialImpulseConstraintSolver  ( ::btSequentialImpulseConstraintSolver::* )(  ) 
void* btSequentialImpulseConstraintSolver_new() {
	::btSequentialImpulseConstraintSolver *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSequentialImpulseConstraintSolver),16);
	o = new (mem)::btSequentialImpulseConstraintSolver();
	return (void*)o;
}
void btSequentialImpulseConstraintSolver_free(void *c) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	delete o;
}
//method: convertContact void ( ::btSequentialImpulseConstraintSolver::* )( ::btPersistentManifold *,::btContactSolverInfo const & ) 
void btSequentialImpulseConstraintSolver_convertContact(void *c,void* p0,void* p1) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btPersistentManifold * tp0 = (::btPersistentManifold *)p0;
	::btContactSolverInfo const & tp1 = *(::btContactSolverInfo const *)p1;
	o->convertContact(tp0,tp1);
}
//method: setRandSeed void ( ::btSequentialImpulseConstraintSolver::* )( long unsigned int ) 
void btSequentialImpulseConstraintSolver_setRandSeed(void *c,long unsigned int p0) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	o->setRandSeed(p0);
}
//not supported method: solveGroupCacheFriendlyIterations ::btScalar ( ::btSequentialImpulseConstraintSolver::* )( ::btCollisionObject * *,int,::btPersistentManifold * *,int,::btTypedConstraint * *,int,::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc * ) 
// error:  - unsupported, int - ok,  - unsupported, int - ok,  - unsupported, int - ok, ::btContactSolverInfo const & - ok, ::btIDebugDraw * - ok, ::btStackAlloc * - ok, ::btScalar - ok

//not supported method: solveSingleIteration ::btScalar ( ::btSequentialImpulseConstraintSolver::* )( int,::btCollisionObject * *,int,::btPersistentManifold * *,int,::btTypedConstraint * *,int,::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc * ) 
// error: int - ok,  - unsupported, int - ok,  - unsupported, int - ok,  - unsupported, int - ok, ::btContactSolverInfo const & - ok, ::btIDebugDraw * - ok, ::btStackAlloc * - ok, ::btScalar - ok

//not supported method: solveGroupCacheFriendlyFinish ::btScalar ( ::btSequentialImpulseConstraintSolver::* )( ::btCollisionObject * *,int,::btPersistentManifold * *,int,::btTypedConstraint * *,int,::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc * ) 
// error:  - unsupported, int - ok,  - unsupported, int - ok,  - unsupported, int - ok, ::btContactSolverInfo const & - ok, ::btIDebugDraw * - ok, ::btStackAlloc * - ok, ::btScalar - ok

//method: getFixedBody ::btRigidBody & (*)(  )
void* btSequentialImpulseConstraintSolver_getFixedBody() {
	void* retVal = (void*) &(::btSequentialImpulseConstraintSolver::getFixedBody());
	return retVal;
}
//method: resolveSingleConstraintRowLowerLimitSIMD void ( ::btSequentialImpulseConstraintSolver::* )( ::btRigidBody &,::btRigidBody &,::btSolverConstraint const & ) 
void btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimitSIMD(void *c,void* p0,void* p1,void* p2) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	::btSolverConstraint const & tp2 = *(::btSolverConstraint const *)p2;
	o->resolveSingleConstraintRowLowerLimitSIMD(tp0,tp1,tp2);
}
//not supported method: solveGroupCacheFriendlySplitImpulseIterations void ( ::btSequentialImpulseConstraintSolver::* )( ::btCollisionObject * *,int,::btPersistentManifold * *,int,::btTypedConstraint * *,int,::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc * ) 
// error:  - unsupported, int - ok,  - unsupported, int - ok,  - unsupported, int - ok, ::btContactSolverInfo const & - ok, ::btIDebugDraw * - ok, ::btStackAlloc * - ok, void - ok

//not supported method: solveGroupCacheFriendlySetup ::btScalar ( ::btSequentialImpulseConstraintSolver::* )( ::btCollisionObject * *,int,::btPersistentManifold * *,int,::btTypedConstraint * *,int,::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc * ) 
// error:  - unsupported, int - ok,  - unsupported, int - ok,  - unsupported, int - ok, ::btContactSolverInfo const & - ok, ::btIDebugDraw * - ok, ::btStackAlloc * - ok, ::btScalar - ok

//not supported method: setupContactConstraint void ( ::btSequentialImpulseConstraintSolver::* )( ::btSolverConstraint &,::btCollisionObject *,::btCollisionObject *,::btManifoldPoint &,::btContactSolverInfo const &,::btVector3 &,::btScalar &,::btScalar &,::btVector3 &,::btVector3 & ) 
// error: ::btSolverConstraint & - ok, ::btCollisionObject * - ok, ::btCollisionObject * - ok, ::btManifoldPoint & - ok, ::btContactSolverInfo const & - ok, ::btVector3 & - ok,  - unsupported,  - unsupported, ::btVector3 & - ok, ::btVector3 & - ok, void - ok

//method: btRand2 long unsigned int ( ::btSequentialImpulseConstraintSolver::* )(  ) 
long unsigned int btSequentialImpulseConstraintSolver_btRand2(void *c) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	long unsigned int retVal = (long unsigned int)o->btRand2();
	return retVal;
}
//method: setFrictionConstraintImpulse void ( ::btSequentialImpulseConstraintSolver::* )( ::btSolverConstraint &,::btRigidBody *,::btRigidBody *,::btManifoldPoint &,::btContactSolverInfo const & ) 
void btSequentialImpulseConstraintSolver_setFrictionConstraintImpulse(void *c,void* p0,void* p1,void* p2,void* p3,void* p4) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btSolverConstraint & tp0 = *(::btSolverConstraint *)p0;
	::btRigidBody * tp1 = (::btRigidBody *)p1;
	::btRigidBody * tp2 = (::btRigidBody *)p2;
	::btManifoldPoint & tp3 = *(::btManifoldPoint *)p3;
	::btContactSolverInfo const & tp4 = *(::btContactSolverInfo const *)p4;
	o->setFrictionConstraintImpulse(tp0,tp1,tp2,tp3,tp4);
}
//method: getOrInitSolverBody int ( ::btSequentialImpulseConstraintSolver::* )( ::btCollisionObject & ) 
int btSequentialImpulseConstraintSolver_getOrInitSolverBody(void *c,void* p0) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btCollisionObject & tp0 = *(::btCollisionObject *)p0;
	int retVal = (int)o->getOrInitSolverBody(tp0);
	return retVal;
}
//method: resolveSingleConstraintRowGenericSIMD void ( ::btSequentialImpulseConstraintSolver::* )( ::btRigidBody &,::btRigidBody &,::btSolverConstraint const & ) 
void btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGenericSIMD(void *c,void* p0,void* p1,void* p2) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	::btSolverConstraint const & tp2 = *(::btSolverConstraint const *)p2;
	o->resolveSingleConstraintRowGenericSIMD(tp0,tp1,tp2);
}
//method: btRandInt2 int ( ::btSequentialImpulseConstraintSolver::* )( int ) 
int btSequentialImpulseConstraintSolver_btRandInt2(void *c,int p0) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	int retVal = (int)o->btRandInt2(p0);
	return retVal;
}
//method: resolveSingleConstraintRowLowerLimit void ( ::btSequentialImpulseConstraintSolver::* )( ::btRigidBody &,::btRigidBody &,::btSolverConstraint const & ) 
void btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimit(void *c,void* p0,void* p1,void* p2) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	::btSolverConstraint const & tp2 = *(::btSolverConstraint const *)p2;
	o->resolveSingleConstraintRowLowerLimit(tp0,tp1,tp2);
}
//method: reset void ( ::btSequentialImpulseConstraintSolver::* )(  ) 
void btSequentialImpulseConstraintSolver_reset(void *c) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	o->reset();
}
//method: resolveSplitPenetrationImpulseCacheFriendly void ( ::btSequentialImpulseConstraintSolver::* )( ::btRigidBody &,::btRigidBody &,::btSolverConstraint const & ) 
void btSequentialImpulseConstraintSolver_resolveSplitPenetrationImpulseCacheFriendly(void *c,void* p0,void* p1,void* p2) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	::btSolverConstraint const & tp2 = *(::btSolverConstraint const *)p2;
	o->resolveSplitPenetrationImpulseCacheFriendly(tp0,tp1,tp2);
}
//method: setupFrictionConstraint void ( ::btSequentialImpulseConstraintSolver::* )( ::btSolverConstraint &,::btVector3 const &,::btRigidBody *,::btRigidBody *,::btManifoldPoint &,::btVector3 const &,::btVector3 const &,::btCollisionObject *,::btCollisionObject *,::btScalar,::btScalar,::btScalar ) 
void btSequentialImpulseConstraintSolver_setupFrictionConstraint(void *c,void* p0,float* p1,void* p2,void* p3,void* p4,float* p5,float* p6,void* p7,void* p8,float p9,float p10,float p11) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btSolverConstraint & tp0 = *(::btSolverConstraint *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btRigidBody * tp2 = (::btRigidBody *)p2;
	::btRigidBody * tp3 = (::btRigidBody *)p3;
	::btManifoldPoint & tp4 = *(::btManifoldPoint *)p4;
	btVector3 tp5(p5[0],p5[1],p5[2]);
	btVector3 tp6(p6[0],p6[1],p6[2]);
	::btCollisionObject * tp7 = (::btCollisionObject *)p7;
	::btCollisionObject * tp8 = (::btCollisionObject *)p8;
	o->setupFrictionConstraint(tp0,tp1,tp2,tp3,tp4,tp5,tp6,tp7,tp8,p9,p10,p11);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p5[0]=tp5.m_floats[0];p5[1]=tp5.m_floats[1];p5[2]=tp5.m_floats[2];
	p6[0]=tp6.m_floats[0];p6[1]=tp6.m_floats[1];p6[2]=tp6.m_floats[2];
}
//method: getRandSeed long unsigned int ( ::btSequentialImpulseConstraintSolver::* )(  ) const
long unsigned int btSequentialImpulseConstraintSolver_getRandSeed(void *c) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	long unsigned int retVal = (long unsigned int)o->getRandSeed();
	return retVal;
}
//method: addFrictionConstraint ::btSolverConstraint & ( ::btSequentialImpulseConstraintSolver::* )( ::btVector3 const &,::btRigidBody *,::btRigidBody *,int,::btManifoldPoint &,::btVector3 const &,::btVector3 const &,::btCollisionObject *,::btCollisionObject *,::btScalar,::btScalar,::btScalar ) 
void* btSequentialImpulseConstraintSolver_addFrictionConstraint(void *c,float* p0,void* p1,void* p2,int p3,void* p4,float* p5,float* p6,void* p7,void* p8,float p9,float p10,float p11) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	::btRigidBody * tp1 = (::btRigidBody *)p1;
	::btRigidBody * tp2 = (::btRigidBody *)p2;
	::btManifoldPoint & tp4 = *(::btManifoldPoint *)p4;
	btVector3 tp5(p5[0],p5[1],p5[2]);
	btVector3 tp6(p6[0],p6[1],p6[2]);
	::btCollisionObject * tp7 = (::btCollisionObject *)p7;
	::btCollisionObject * tp8 = (::btCollisionObject *)p8;
	void* retVal = (void*) &(o->addFrictionConstraint(tp0,tp1,tp2,p3,tp4,tp5,tp6,tp7,tp8,p9,p10,p11));
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p5[0]=tp5.m_floats[0];p5[1]=tp5.m_floats[1];p5[2]=tp5.m_floats[2];
	p6[0]=tp6.m_floats[0];p6[1]=tp6.m_floats[1];p6[2]=tp6.m_floats[2];
	return retVal;
}
//method: restitutionCurve ::btScalar ( ::btSequentialImpulseConstraintSolver::* )( ::btScalar,::btScalar ) 
float btSequentialImpulseConstraintSolver_restitutionCurve(void *c,float p0,float p1) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	float retVal = (float)o->restitutionCurve(p0,p1);
	return retVal;
}
//not supported method: solveGroup ::btScalar ( ::btSequentialImpulseConstraintSolver::* )( ::btCollisionObject * *,int,::btPersistentManifold * *,int,::btTypedConstraint * *,int,::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc *,::btDispatcher * ) 
// error:  - unsupported, int - ok,  - unsupported, int - ok,  - unsupported, int - ok, ::btContactSolverInfo const & - ok, ::btIDebugDraw * - ok, ::btStackAlloc * - ok, ::btDispatcher * - ok, ::btScalar - ok

//method: resolveSingleConstraintRowGeneric void ( ::btSequentialImpulseConstraintSolver::* )( ::btRigidBody &,::btRigidBody &,::btSolverConstraint const & ) 
void btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGeneric(void *c,void* p0,void* p1,void* p2) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	::btSolverConstraint const & tp2 = *(::btSolverConstraint const *)p2;
	o->resolveSingleConstraintRowGeneric(tp0,tp1,tp2);
}
//method: resolveSplitPenetrationSIMD void ( ::btSequentialImpulseConstraintSolver::* )( ::btRigidBody &,::btRigidBody &,::btSolverConstraint const & ) 
void btSequentialImpulseConstraintSolver_resolveSplitPenetrationSIMD(void *c,void* p0,void* p1,void* p2) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	::btSolverConstraint const & tp2 = *(::btSolverConstraint const *)p2;
	o->resolveSplitPenetrationSIMD(tp0,tp1,tp2);
}
//attribute: ::btConstraintArray btSequentialImpulseConstraintSolver->m_tmpSolverContactConstraintPool
void btSequentialImpulseConstraintSolver_m_tmpSolverContactConstraintPool_set(void *c,void* a) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btConstraintArray & ta = *(::btAlignedObjectArray<btSolverConstraint> *)a;
	o->m_tmpSolverContactConstraintPool = ta;
}
void* btSequentialImpulseConstraintSolver_m_tmpSolverContactConstraintPool_get(void *c) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	return (void*)&(o->m_tmpSolverContactConstraintPool);
}

//attribute: ::btConstraintArray btSequentialImpulseConstraintSolver->m_tmpSolverNonContactConstraintPool
void btSequentialImpulseConstraintSolver_m_tmpSolverNonContactConstraintPool_set(void *c,void* a) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btConstraintArray & ta = *(::btAlignedObjectArray<btSolverConstraint> *)a;
	o->m_tmpSolverNonContactConstraintPool = ta;
}
void* btSequentialImpulseConstraintSolver_m_tmpSolverNonContactConstraintPool_get(void *c) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	return (void*)&(o->m_tmpSolverNonContactConstraintPool);
}

//attribute: ::btConstraintArray btSequentialImpulseConstraintSolver->m_tmpSolverContactFrictionConstraintPool
void btSequentialImpulseConstraintSolver_m_tmpSolverContactFrictionConstraintPool_set(void *c,void* a) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btConstraintArray & ta = *(::btAlignedObjectArray<btSolverConstraint> *)a;
	o->m_tmpSolverContactFrictionConstraintPool = ta;
}
void* btSequentialImpulseConstraintSolver_m_tmpSolverContactFrictionConstraintPool_get(void *c) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	return (void*)&(o->m_tmpSolverContactFrictionConstraintPool);
}

//attribute: ::btAlignedObjectArray<int> btSequentialImpulseConstraintSolver->m_orderTmpConstraintPool
void btSequentialImpulseConstraintSolver_m_orderTmpConstraintPool_set(void *c,void* a) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_orderTmpConstraintPool = ta;
}
void* btSequentialImpulseConstraintSolver_m_orderTmpConstraintPool_get(void *c) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	return (void*)&(o->m_orderTmpConstraintPool);
}

//attribute: ::btAlignedObjectArray<int> btSequentialImpulseConstraintSolver->m_orderFrictionConstraintPool
void btSequentialImpulseConstraintSolver_m_orderFrictionConstraintPool_set(void *c,void* a) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_orderFrictionConstraintPool = ta;
}
void* btSequentialImpulseConstraintSolver_m_orderFrictionConstraintPool_get(void *c) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	return (void*)&(o->m_orderFrictionConstraintPool);
}

//attribute: ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1> btSequentialImpulseConstraintSolver->m_tmpConstraintSizesPool
void btSequentialImpulseConstraintSolver_m_tmpConstraintSizesPool_set(void *c,void* a) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1> & ta = *(::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1> *)a;
	o->m_tmpConstraintSizesPool = ta;
}
void* btSequentialImpulseConstraintSolver_m_tmpConstraintSizesPool_get(void *c) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	return (void*)&(o->m_tmpConstraintSizesPool);
}

//attribute: long unsigned int btSequentialImpulseConstraintSolver->m_btSeed2
void btSequentialImpulseConstraintSolver_m_btSeed2_set(void *c,long unsigned int a) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	o->m_btSeed2 = a;
}
long unsigned int btSequentialImpulseConstraintSolver_m_btSeed2_get(void *c) {
	::btSequentialImpulseConstraintSolver *o = (::btSequentialImpulseConstraintSolver*)c;
	return (long unsigned int)(o->m_btSeed2);
}


// ::btSliderConstraint
//constructor: btSliderConstraint  ( ::btSliderConstraint::* )( ::btRigidBody &,::btRigidBody &,::btTransform const &,::btTransform const &,bool ) 
void* btSliderConstraint_new0(void* p0,void* p1,float* p2,float* p3,int p4) {
	::btSliderConstraint *o = 0;
	 void *mem = 0;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	mem = btAlignedAlloc(sizeof(::btSliderConstraint),16);
	o = new (mem)::btSliderConstraint(tp0,tp1,tp2,tp3,p4);
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
	return (void*)o;
}
//constructor: btSliderConstraint  ( ::btSliderConstraint::* )( ::btRigidBody &,::btTransform const &,bool ) 
void* btSliderConstraint_new1(void* p0,float* p1,int p2) {
	::btSliderConstraint *o = 0;
	 void *mem = 0;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	mem = btAlignedAlloc(sizeof(::btSliderConstraint),16);
	o = new (mem)::btSliderConstraint(tp0,tp1,p2);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	return (void*)o;
}
void btSliderConstraint_free(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	delete o;
}
//method: getRigidBodyB ::btRigidBody const & ( ::btSliderConstraint::* )(  ) const
void* btSliderConstraint_getRigidBodyB(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyB());
	return retVal;
}
//method: getRigidBodyA ::btRigidBody const & ( ::btSliderConstraint::* )(  ) const
void* btSliderConstraint_getRigidBodyA(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyA());
	return retVal;
}
//method: getAngDepth ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getAngDepth(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getAngDepth();
	return retVal;
}
//method: getTargetAngMotorVelocity ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getTargetAngMotorVelocity(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getTargetAngMotorVelocity();
	return retVal;
}
//method: getAngularPos ::btScalar ( ::btSliderConstraint::* )(  ) const
float btSliderConstraint_getAngularPos(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getAngularPos();
	return retVal;
}
//method: setRestitutionLimAng void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setRestitutionLimAng(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setRestitutionLimAng(p0);
}
//method: getParam ::btScalar ( ::btSliderConstraint::* )( int,int ) const
float btSliderConstraint_getParam(void *c,int p0,int p1) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getParam(p0,p1);
	return retVal;
}
//method: getInfo1 void ( ::btSliderConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btSliderConstraint_getInfo1(void *c,void* p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	::btTypedConstraint::btConstraintInfo1 * tp0 = (::btTypedConstraint::btConstraintInfo1 *)p0;
	o->getInfo1(tp0);
}
//method: getInfo2 void ( ::btSliderConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void btSliderConstraint_getInfo2(void *c,void* p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	o->getInfo2(tp0);
}
//method: getPoweredLinMotor bool ( ::btSliderConstraint::* )(  ) 
int btSliderConstraint_getPoweredLinMotor(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	int retVal = (int)o->getPoweredLinMotor();
	return retVal;
}
//method: setUseFrameOffset void ( ::btSliderConstraint::* )( bool ) 
void btSliderConstraint_setUseFrameOffset(void *c,int p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setUseFrameOffset(p0);
}
//method: setSoftnessLimLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setSoftnessLimLin(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setSoftnessLimLin(p0);
}
//method: getAncorInA ::btVector3 ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_getAncorInA(void *c,float* ret) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAncorInA();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getAncorInB ::btVector3 ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_getAncorInB(void *c,float* ret) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAncorInB();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: setDampingDirAng void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setDampingDirAng(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setDampingDirAng(p0);
}
//method: getSolveLinLimit bool ( ::btSliderConstraint::* )(  ) 
int btSliderConstraint_getSolveLinLimit(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	int retVal = (int)o->getSolveLinLimit();
	return retVal;
}
//method: getUseFrameOffset bool ( ::btSliderConstraint::* )(  ) 
int btSliderConstraint_getUseFrameOffset(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	int retVal = (int)o->getUseFrameOffset();
	return retVal;
}
//method: getMaxAngMotorForce ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getMaxAngMotorForce(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getMaxAngMotorForce();
	return retVal;
}
//method: setRestitutionDirAng void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setRestitutionDirAng(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setRestitutionDirAng(p0);
}
//method: getMaxLinMotorForce ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getMaxLinMotorForce(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getMaxLinMotorForce();
	return retVal;
}
//method: setDampingOrthoLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setDampingOrthoLin(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setDampingOrthoLin(p0);
}
//method: getSolveAngLimit bool ( ::btSliderConstraint::* )(  ) 
int btSliderConstraint_getSolveAngLimit(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	int retVal = (int)o->getSolveAngLimit();
	return retVal;
}
//method: setPoweredAngMotor void ( ::btSliderConstraint::* )( bool ) 
void btSliderConstraint_setPoweredAngMotor(void *c,int p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setPoweredAngMotor(p0);
}
//method: getLinearPos ::btScalar ( ::btSliderConstraint::* )(  ) const
float btSliderConstraint_getLinearPos(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getLinearPos();
	return retVal;
}
//method: getCalculatedTransformB ::btTransform const & ( ::btSliderConstraint::* )(  ) const
void btSliderConstraint_getCalculatedTransformB(void *c,float* ret) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getCalculatedTransformB();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getCalculatedTransformA ::btTransform const & ( ::btSliderConstraint::* )(  ) const
void btSliderConstraint_getCalculatedTransformA(void *c,float* ret) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getCalculatedTransformA();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: testAngLimits void ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_testAngLimits(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->testAngLimits();
}
//method: setDampingDirLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setDampingDirLin(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setDampingDirLin(p0);
}
//method: getUpperAngLimit ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getUpperAngLimit(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getUpperAngLimit();
	return retVal;
}
//method: setUpperAngLimit void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setUpperAngLimit(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setUpperAngLimit(p0);
}
//method: getRestitutionLimAng ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getRestitutionLimAng(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getRestitutionLimAng();
	return retVal;
}
//method: getSoftnessOrthoLin ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getSoftnessOrthoLin(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getSoftnessOrthoLin();
	return retVal;
}
//method: setLowerLinLimit void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setLowerLinLimit(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setLowerLinLimit(p0);
}
//method: getRestitutionDirLin ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getRestitutionDirLin(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getRestitutionDirLin();
	return retVal;
}
//method: getInfo1NonVirtual void ( ::btSliderConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btSliderConstraint_getInfo1NonVirtual(void *c,void* p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	::btTypedConstraint::btConstraintInfo1 * tp0 = (::btTypedConstraint::btConstraintInfo1 *)p0;
	o->getInfo1NonVirtual(tp0);
}
//method: setRestitutionLimLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setRestitutionLimLin(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setRestitutionLimLin(p0);
}
//method: setTargetLinMotorVelocity void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setTargetLinMotorVelocity(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setTargetLinMotorVelocity(p0);
}
//method: getUpperLinLimit ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getUpperLinLimit(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getUpperLinLimit();
	return retVal;
}
//method: setMaxLinMotorForce void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setMaxLinMotorForce(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setMaxLinMotorForce(p0);
}
//method: getLowerAngLimit ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getLowerAngLimit(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getLowerAngLimit();
	return retVal;
}
//method: setSoftnessDirLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setSoftnessDirLin(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setSoftnessDirLin(p0);
}
//method: initParams void ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_initParams(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->initParams();
}
//method: getInfo2NonVirtual void ( ::btSliderConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const &,::btScalar,::btScalar ) 
void btSliderConstraint_getInfo2NonVirtual(void *c,void* p0,float* p1,float* p2,float* p3,float* p4,float p5,float p6) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->getInfo2NonVirtual(tp0,tp1,tp2,tp3,tp4,p5,p6);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: getFrameOffsetA ::btTransform const & ( ::btSliderConstraint::* )(  ) const
void btSliderConstraint_getFrameOffsetA(void *c,float* ret) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetA();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getFrameOffsetA ::btTransform const & ( ::btSliderConstraint::* )(  ) const
void btSliderConstraint_getFrameOffsetA0(void *c,float* ret) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetA();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getFrameOffsetA ::btTransform & ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_getFrameOffsetA1(void *c,float* ret) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetA();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getFrameOffsetB ::btTransform const & ( ::btSliderConstraint::* )(  ) const
void btSliderConstraint_getFrameOffsetB(void *c,float* ret) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetB();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getFrameOffsetB ::btTransform const & ( ::btSliderConstraint::* )(  ) const
void btSliderConstraint_getFrameOffsetB0(void *c,float* ret) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetB();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getFrameOffsetB ::btTransform & ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_getFrameOffsetB1(void *c,float* ret) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getFrameOffsetB();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getDampingDirAng ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getDampingDirAng(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getDampingDirAng();
	return retVal;
}
//method: getRestitutionLimLin ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getRestitutionLimLin(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getRestitutionLimLin();
	return retVal;
}
//method: getSoftnessOrthoAng ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getSoftnessOrthoAng(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getSoftnessOrthoAng();
	return retVal;
}
//method: setSoftnessOrthoLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setSoftnessOrthoLin(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setSoftnessOrthoLin(p0);
}
//method: setSoftnessLimAng void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setSoftnessLimAng(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setSoftnessLimAng(p0);
}
//method: getDampingDirLin ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getDampingDirLin(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getDampingDirLin();
	return retVal;
}
//method: getSoftnessLimLin ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getSoftnessLimLin(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getSoftnessLimLin();
	return retVal;
}
//method: setPoweredLinMotor void ( ::btSliderConstraint::* )( bool ) 
void btSliderConstraint_setPoweredLinMotor(void *c,int p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setPoweredLinMotor(p0);
}
//method: calculateTransforms void ( ::btSliderConstraint::* )( ::btTransform const &,::btTransform const & ) 
void btSliderConstraint_calculateTransforms(void *c,float* p0,float* p1) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->calculateTransforms(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: getLinDepth ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getLinDepth(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getLinDepth();
	return retVal;
}
//method: serialize char const * ( ::btSliderConstraint::* )( void *,::btSerializer * ) const
char const * btSliderConstraint_serialize(void *c,void* p0,void* p1) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: getDampingLimLin ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getDampingLimLin(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getDampingLimLin();
	return retVal;
}
//method: getRestitutionDirAng ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getRestitutionDirAng(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getRestitutionDirAng();
	return retVal;
}
//method: setParam void ( ::btSliderConstraint::* )( int,::btScalar,int ) 
void btSliderConstraint_setParam(void *c,int p0,float p1,int p2) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setParam(p0,p1,p2);
}
//method: getDampingLimAng ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getDampingLimAng(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getDampingLimAng();
	return retVal;
}
//method: setRestitutionOrthoLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setRestitutionOrthoLin(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setRestitutionOrthoLin(p0);
}
//method: setRestitutionDirLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setRestitutionDirLin(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setRestitutionDirLin(p0);
}
//method: setDampingLimAng void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setDampingLimAng(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setDampingLimAng(p0);
}
//method: setSoftnessDirAng void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setSoftnessDirAng(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setSoftnessDirAng(p0);
}
//method: setUpperLinLimit void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setUpperLinLimit(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setUpperLinLimit(p0);
}
//method: calculateSerializeBufferSize int ( ::btSliderConstraint::* )(  ) const
int btSliderConstraint_calculateSerializeBufferSize(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: setTargetAngMotorVelocity void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setTargetAngMotorVelocity(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setTargetAngMotorVelocity(p0);
}
//method: getSoftnessDirAng ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getSoftnessDirAng(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getSoftnessDirAng();
	return retVal;
}
//method: setMaxAngMotorForce void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setMaxAngMotorForce(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setMaxAngMotorForce(p0);
}
//method: setLowerAngLimit void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setLowerAngLimit(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setLowerAngLimit(p0);
}
//method: getPoweredAngMotor bool ( ::btSliderConstraint::* )(  ) 
int btSliderConstraint_getPoweredAngMotor(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	int retVal = (int)o->getPoweredAngMotor();
	return retVal;
}
//method: getDampingOrthoAng ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getDampingOrthoAng(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getDampingOrthoAng();
	return retVal;
}
//method: getRestitutionOrthoLin ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getRestitutionOrthoLin(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getRestitutionOrthoLin();
	return retVal;
}
//method: getTargetLinMotorVelocity ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getTargetLinMotorVelocity(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getTargetLinMotorVelocity();
	return retVal;
}
//method: testLinLimits void ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_testLinLimits(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->testLinLimits();
}
//method: getLowerLinLimit ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getLowerLinLimit(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getLowerLinLimit();
	return retVal;
}
//method: setDampingOrthoAng void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setDampingOrthoAng(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setDampingOrthoAng(p0);
}
//method: setRestitutionOrthoAng void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setRestitutionOrthoAng(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setRestitutionOrthoAng(p0);
}
//method: getRestitutionOrthoAng ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getRestitutionOrthoAng(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getRestitutionOrthoAng();
	return retVal;
}
//method: getDampingOrthoLin ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getDampingOrthoLin(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getDampingOrthoLin();
	return retVal;
}
//method: getSoftnessLimAng ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getSoftnessLimAng(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getSoftnessLimAng();
	return retVal;
}
//method: setSoftnessOrthoAng void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setSoftnessOrthoAng(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setSoftnessOrthoAng(p0);
}
//method: setDampingLimLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setDampingLimLin(void *c,float p0) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->setDampingLimLin(p0);
}
//method: setFrames void ( ::btSliderConstraint::* )( ::btTransform const &,::btTransform const & ) 
void btSliderConstraint_setFrames(void *c,float* p0,float* p1) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->setFrames(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: getSoftnessDirLin ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getSoftnessDirLin(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	float retVal = (float)o->getSoftnessDirLin();
	return retVal;
}
//method: getUseLinearReferenceFrameA bool ( ::btSliderConstraint::* )(  ) 
int btSliderConstraint_getUseLinearReferenceFrameA(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	int retVal = (int)o->getUseLinearReferenceFrameA();
	return retVal;
}
//attribute: bool btSliderConstraint->m_useSolveConstraintObsolete
void btSliderConstraint_m_useSolveConstraintObsolete_set(void *c,int a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_useSolveConstraintObsolete = a;
}
int btSliderConstraint_m_useSolveConstraintObsolete_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (int)(o->m_useSolveConstraintObsolete);
}

//attribute: bool btSliderConstraint->m_useOffsetForConstraintFrame
void btSliderConstraint_m_useOffsetForConstraintFrame_set(void *c,int a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_useOffsetForConstraintFrame = a;
}
int btSliderConstraint_m_useOffsetForConstraintFrame_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (int)(o->m_useOffsetForConstraintFrame);
}

//attribute: ::btTransform btSliderConstraint->m_frameInA
void btSliderConstraint_m_frameInA_set(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_frameInA = ta;
}
void btSliderConstraint_m_frameInA_get(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	a[0]=(o->m_frameInA).getBasis().getRow(0).m_floats[0];a[1]=(o->m_frameInA).getBasis().getRow(0).m_floats[1];a[2]=(o->m_frameInA).getBasis().getRow(0).m_floats[2];a[3]=(o->m_frameInA).getBasis().getRow(1).m_floats[0];a[4]=(o->m_frameInA).getBasis().getRow(1).m_floats[1];a[5]=(o->m_frameInA).getBasis().getRow(1).m_floats[2];a[6]=(o->m_frameInA).getBasis().getRow(2).m_floats[0];a[7]=(o->m_frameInA).getBasis().getRow(2).m_floats[1];a[8]=(o->m_frameInA).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_frameInA).getOrigin().m_floats[0];a[10]=(o->m_frameInA).getOrigin().m_floats[1];a[11]=(o->m_frameInA).getOrigin().m_floats[2];
}

//attribute: ::btTransform btSliderConstraint->m_frameInB
void btSliderConstraint_m_frameInB_set(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_frameInB = ta;
}
void btSliderConstraint_m_frameInB_get(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	a[0]=(o->m_frameInB).getBasis().getRow(0).m_floats[0];a[1]=(o->m_frameInB).getBasis().getRow(0).m_floats[1];a[2]=(o->m_frameInB).getBasis().getRow(0).m_floats[2];a[3]=(o->m_frameInB).getBasis().getRow(1).m_floats[0];a[4]=(o->m_frameInB).getBasis().getRow(1).m_floats[1];a[5]=(o->m_frameInB).getBasis().getRow(1).m_floats[2];a[6]=(o->m_frameInB).getBasis().getRow(2).m_floats[0];a[7]=(o->m_frameInB).getBasis().getRow(2).m_floats[1];a[8]=(o->m_frameInB).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_frameInB).getOrigin().m_floats[0];a[10]=(o->m_frameInB).getOrigin().m_floats[1];a[11]=(o->m_frameInB).getOrigin().m_floats[2];
}

//attribute: bool btSliderConstraint->m_useLinearReferenceFrameA
void btSliderConstraint_m_useLinearReferenceFrameA_set(void *c,int a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_useLinearReferenceFrameA = a;
}
int btSliderConstraint_m_useLinearReferenceFrameA_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (int)(o->m_useLinearReferenceFrameA);
}

//attribute: ::btScalar btSliderConstraint->m_lowerLinLimit
void btSliderConstraint_m_lowerLinLimit_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_lowerLinLimit = a;
}
float btSliderConstraint_m_lowerLinLimit_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_lowerLinLimit);
}

//attribute: ::btScalar btSliderConstraint->m_upperLinLimit
void btSliderConstraint_m_upperLinLimit_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_upperLinLimit = a;
}
float btSliderConstraint_m_upperLinLimit_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_upperLinLimit);
}

//attribute: ::btScalar btSliderConstraint->m_lowerAngLimit
void btSliderConstraint_m_lowerAngLimit_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_lowerAngLimit = a;
}
float btSliderConstraint_m_lowerAngLimit_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_lowerAngLimit);
}

//attribute: ::btScalar btSliderConstraint->m_upperAngLimit
void btSliderConstraint_m_upperAngLimit_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_upperAngLimit = a;
}
float btSliderConstraint_m_upperAngLimit_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_upperAngLimit);
}

//attribute: ::btScalar btSliderConstraint->m_softnessDirLin
void btSliderConstraint_m_softnessDirLin_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_softnessDirLin = a;
}
float btSliderConstraint_m_softnessDirLin_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_softnessDirLin);
}

//attribute: ::btScalar btSliderConstraint->m_restitutionDirLin
void btSliderConstraint_m_restitutionDirLin_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_restitutionDirLin = a;
}
float btSliderConstraint_m_restitutionDirLin_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_restitutionDirLin);
}

//attribute: ::btScalar btSliderConstraint->m_dampingDirLin
void btSliderConstraint_m_dampingDirLin_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_dampingDirLin = a;
}
float btSliderConstraint_m_dampingDirLin_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_dampingDirLin);
}

//attribute: ::btScalar btSliderConstraint->m_cfmDirLin
void btSliderConstraint_m_cfmDirLin_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_cfmDirLin = a;
}
float btSliderConstraint_m_cfmDirLin_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_cfmDirLin);
}

//attribute: ::btScalar btSliderConstraint->m_softnessDirAng
void btSliderConstraint_m_softnessDirAng_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_softnessDirAng = a;
}
float btSliderConstraint_m_softnessDirAng_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_softnessDirAng);
}

//attribute: ::btScalar btSliderConstraint->m_restitutionDirAng
void btSliderConstraint_m_restitutionDirAng_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_restitutionDirAng = a;
}
float btSliderConstraint_m_restitutionDirAng_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_restitutionDirAng);
}

//attribute: ::btScalar btSliderConstraint->m_dampingDirAng
void btSliderConstraint_m_dampingDirAng_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_dampingDirAng = a;
}
float btSliderConstraint_m_dampingDirAng_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_dampingDirAng);
}

//attribute: ::btScalar btSliderConstraint->m_cfmDirAng
void btSliderConstraint_m_cfmDirAng_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_cfmDirAng = a;
}
float btSliderConstraint_m_cfmDirAng_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_cfmDirAng);
}

//attribute: ::btScalar btSliderConstraint->m_softnessLimLin
void btSliderConstraint_m_softnessLimLin_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_softnessLimLin = a;
}
float btSliderConstraint_m_softnessLimLin_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_softnessLimLin);
}

//attribute: ::btScalar btSliderConstraint->m_restitutionLimLin
void btSliderConstraint_m_restitutionLimLin_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_restitutionLimLin = a;
}
float btSliderConstraint_m_restitutionLimLin_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_restitutionLimLin);
}

//attribute: ::btScalar btSliderConstraint->m_dampingLimLin
void btSliderConstraint_m_dampingLimLin_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_dampingLimLin = a;
}
float btSliderConstraint_m_dampingLimLin_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_dampingLimLin);
}

//attribute: ::btScalar btSliderConstraint->m_cfmLimLin
void btSliderConstraint_m_cfmLimLin_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_cfmLimLin = a;
}
float btSliderConstraint_m_cfmLimLin_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_cfmLimLin);
}

//attribute: ::btScalar btSliderConstraint->m_softnessLimAng
void btSliderConstraint_m_softnessLimAng_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_softnessLimAng = a;
}
float btSliderConstraint_m_softnessLimAng_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_softnessLimAng);
}

//attribute: ::btScalar btSliderConstraint->m_restitutionLimAng
void btSliderConstraint_m_restitutionLimAng_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_restitutionLimAng = a;
}
float btSliderConstraint_m_restitutionLimAng_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_restitutionLimAng);
}

//attribute: ::btScalar btSliderConstraint->m_dampingLimAng
void btSliderConstraint_m_dampingLimAng_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_dampingLimAng = a;
}
float btSliderConstraint_m_dampingLimAng_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_dampingLimAng);
}

//attribute: ::btScalar btSliderConstraint->m_cfmLimAng
void btSliderConstraint_m_cfmLimAng_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_cfmLimAng = a;
}
float btSliderConstraint_m_cfmLimAng_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_cfmLimAng);
}

//attribute: ::btScalar btSliderConstraint->m_softnessOrthoLin
void btSliderConstraint_m_softnessOrthoLin_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_softnessOrthoLin = a;
}
float btSliderConstraint_m_softnessOrthoLin_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_softnessOrthoLin);
}

//attribute: ::btScalar btSliderConstraint->m_restitutionOrthoLin
void btSliderConstraint_m_restitutionOrthoLin_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_restitutionOrthoLin = a;
}
float btSliderConstraint_m_restitutionOrthoLin_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_restitutionOrthoLin);
}

//attribute: ::btScalar btSliderConstraint->m_dampingOrthoLin
void btSliderConstraint_m_dampingOrthoLin_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_dampingOrthoLin = a;
}
float btSliderConstraint_m_dampingOrthoLin_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_dampingOrthoLin);
}

//attribute: ::btScalar btSliderConstraint->m_cfmOrthoLin
void btSliderConstraint_m_cfmOrthoLin_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_cfmOrthoLin = a;
}
float btSliderConstraint_m_cfmOrthoLin_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_cfmOrthoLin);
}

//attribute: ::btScalar btSliderConstraint->m_softnessOrthoAng
void btSliderConstraint_m_softnessOrthoAng_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_softnessOrthoAng = a;
}
float btSliderConstraint_m_softnessOrthoAng_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_softnessOrthoAng);
}

//attribute: ::btScalar btSliderConstraint->m_restitutionOrthoAng
void btSliderConstraint_m_restitutionOrthoAng_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_restitutionOrthoAng = a;
}
float btSliderConstraint_m_restitutionOrthoAng_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_restitutionOrthoAng);
}

//attribute: ::btScalar btSliderConstraint->m_dampingOrthoAng
void btSliderConstraint_m_dampingOrthoAng_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_dampingOrthoAng = a;
}
float btSliderConstraint_m_dampingOrthoAng_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_dampingOrthoAng);
}

//attribute: ::btScalar btSliderConstraint->m_cfmOrthoAng
void btSliderConstraint_m_cfmOrthoAng_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_cfmOrthoAng = a;
}
float btSliderConstraint_m_cfmOrthoAng_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_cfmOrthoAng);
}

//attribute: bool btSliderConstraint->m_solveLinLim
void btSliderConstraint_m_solveLinLim_set(void *c,int a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_solveLinLim = a;
}
int btSliderConstraint_m_solveLinLim_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (int)(o->m_solveLinLim);
}

//attribute: bool btSliderConstraint->m_solveAngLim
void btSliderConstraint_m_solveAngLim_set(void *c,int a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_solveAngLim = a;
}
int btSliderConstraint_m_solveAngLim_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (int)(o->m_solveAngLim);
}

//attribute: int btSliderConstraint->m_flags
void btSliderConstraint_m_flags_set(void *c,int a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_flags = a;
}
int btSliderConstraint_m_flags_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (int)(o->m_flags);
}

//attribute: ::btJacobianEntry[3] btSliderConstraint->m_jacLin
// attribute not supported: //attribute: ::btJacobianEntry[3] btSliderConstraint->m_jacLin
//attribute: ::btScalar[3] btSliderConstraint->m_jacLinDiagABInv
// attribute not supported: //attribute: ::btScalar[3] btSliderConstraint->m_jacLinDiagABInv
//attribute: ::btJacobianEntry[3] btSliderConstraint->m_jacAng
// attribute not supported: //attribute: ::btJacobianEntry[3] btSliderConstraint->m_jacAng
//attribute: ::btScalar btSliderConstraint->m_timeStep
void btSliderConstraint_m_timeStep_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_timeStep = a;
}
float btSliderConstraint_m_timeStep_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_timeStep);
}

//attribute: ::btTransform btSliderConstraint->m_calculatedTransformA
void btSliderConstraint_m_calculatedTransformA_set(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_calculatedTransformA = ta;
}
void btSliderConstraint_m_calculatedTransformA_get(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	a[0]=(o->m_calculatedTransformA).getBasis().getRow(0).m_floats[0];a[1]=(o->m_calculatedTransformA).getBasis().getRow(0).m_floats[1];a[2]=(o->m_calculatedTransformA).getBasis().getRow(0).m_floats[2];a[3]=(o->m_calculatedTransformA).getBasis().getRow(1).m_floats[0];a[4]=(o->m_calculatedTransformA).getBasis().getRow(1).m_floats[1];a[5]=(o->m_calculatedTransformA).getBasis().getRow(1).m_floats[2];a[6]=(o->m_calculatedTransformA).getBasis().getRow(2).m_floats[0];a[7]=(o->m_calculatedTransformA).getBasis().getRow(2).m_floats[1];a[8]=(o->m_calculatedTransformA).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_calculatedTransformA).getOrigin().m_floats[0];a[10]=(o->m_calculatedTransformA).getOrigin().m_floats[1];a[11]=(o->m_calculatedTransformA).getOrigin().m_floats[2];
}

//attribute: ::btTransform btSliderConstraint->m_calculatedTransformB
void btSliderConstraint_m_calculatedTransformB_set(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_calculatedTransformB = ta;
}
void btSliderConstraint_m_calculatedTransformB_get(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	a[0]=(o->m_calculatedTransformB).getBasis().getRow(0).m_floats[0];a[1]=(o->m_calculatedTransformB).getBasis().getRow(0).m_floats[1];a[2]=(o->m_calculatedTransformB).getBasis().getRow(0).m_floats[2];a[3]=(o->m_calculatedTransformB).getBasis().getRow(1).m_floats[0];a[4]=(o->m_calculatedTransformB).getBasis().getRow(1).m_floats[1];a[5]=(o->m_calculatedTransformB).getBasis().getRow(1).m_floats[2];a[6]=(o->m_calculatedTransformB).getBasis().getRow(2).m_floats[0];a[7]=(o->m_calculatedTransformB).getBasis().getRow(2).m_floats[1];a[8]=(o->m_calculatedTransformB).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_calculatedTransformB).getOrigin().m_floats[0];a[10]=(o->m_calculatedTransformB).getOrigin().m_floats[1];a[11]=(o->m_calculatedTransformB).getOrigin().m_floats[2];
}

//attribute: ::btVector3 btSliderConstraint->m_sliderAxis
void btSliderConstraint_m_sliderAxis_set(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_sliderAxis = ta;
}
void btSliderConstraint_m_sliderAxis_get(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	a[0]=(o->m_sliderAxis).m_floats[0];a[1]=(o->m_sliderAxis).m_floats[1];a[2]=(o->m_sliderAxis).m_floats[2];
}

//attribute: ::btVector3 btSliderConstraint->m_realPivotAInW
void btSliderConstraint_m_realPivotAInW_set(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_realPivotAInW = ta;
}
void btSliderConstraint_m_realPivotAInW_get(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	a[0]=(o->m_realPivotAInW).m_floats[0];a[1]=(o->m_realPivotAInW).m_floats[1];a[2]=(o->m_realPivotAInW).m_floats[2];
}

//attribute: ::btVector3 btSliderConstraint->m_realPivotBInW
void btSliderConstraint_m_realPivotBInW_set(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_realPivotBInW = ta;
}
void btSliderConstraint_m_realPivotBInW_get(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	a[0]=(o->m_realPivotBInW).m_floats[0];a[1]=(o->m_realPivotBInW).m_floats[1];a[2]=(o->m_realPivotBInW).m_floats[2];
}

//attribute: ::btVector3 btSliderConstraint->m_projPivotInW
void btSliderConstraint_m_projPivotInW_set(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_projPivotInW = ta;
}
void btSliderConstraint_m_projPivotInW_get(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	a[0]=(o->m_projPivotInW).m_floats[0];a[1]=(o->m_projPivotInW).m_floats[1];a[2]=(o->m_projPivotInW).m_floats[2];
}

//attribute: ::btVector3 btSliderConstraint->m_delta
void btSliderConstraint_m_delta_set(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_delta = ta;
}
void btSliderConstraint_m_delta_get(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	a[0]=(o->m_delta).m_floats[0];a[1]=(o->m_delta).m_floats[1];a[2]=(o->m_delta).m_floats[2];
}

//attribute: ::btVector3 btSliderConstraint->m_depth
void btSliderConstraint_m_depth_set(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_depth = ta;
}
void btSliderConstraint_m_depth_get(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	a[0]=(o->m_depth).m_floats[0];a[1]=(o->m_depth).m_floats[1];a[2]=(o->m_depth).m_floats[2];
}

//attribute: ::btVector3 btSliderConstraint->m_relPosA
void btSliderConstraint_m_relPosA_set(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_relPosA = ta;
}
void btSliderConstraint_m_relPosA_get(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	a[0]=(o->m_relPosA).m_floats[0];a[1]=(o->m_relPosA).m_floats[1];a[2]=(o->m_relPosA).m_floats[2];
}

//attribute: ::btVector3 btSliderConstraint->m_relPosB
void btSliderConstraint_m_relPosB_set(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_relPosB = ta;
}
void btSliderConstraint_m_relPosB_get(void *c,float* a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	a[0]=(o->m_relPosB).m_floats[0];a[1]=(o->m_relPosB).m_floats[1];a[2]=(o->m_relPosB).m_floats[2];
}

//attribute: ::btScalar btSliderConstraint->m_linPos
void btSliderConstraint_m_linPos_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_linPos = a;
}
float btSliderConstraint_m_linPos_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_linPos);
}

//attribute: ::btScalar btSliderConstraint->m_angPos
void btSliderConstraint_m_angPos_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_angPos = a;
}
float btSliderConstraint_m_angPos_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_angPos);
}

//attribute: ::btScalar btSliderConstraint->m_angDepth
void btSliderConstraint_m_angDepth_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_angDepth = a;
}
float btSliderConstraint_m_angDepth_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_angDepth);
}

//attribute: ::btScalar btSliderConstraint->m_kAngle
void btSliderConstraint_m_kAngle_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_kAngle = a;
}
float btSliderConstraint_m_kAngle_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_kAngle);
}

//attribute: bool btSliderConstraint->m_poweredLinMotor
void btSliderConstraint_m_poweredLinMotor_set(void *c,int a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_poweredLinMotor = a;
}
int btSliderConstraint_m_poweredLinMotor_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (int)(o->m_poweredLinMotor);
}

//attribute: ::btScalar btSliderConstraint->m_targetLinMotorVelocity
void btSliderConstraint_m_targetLinMotorVelocity_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_targetLinMotorVelocity = a;
}
float btSliderConstraint_m_targetLinMotorVelocity_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_targetLinMotorVelocity);
}

//attribute: ::btScalar btSliderConstraint->m_maxLinMotorForce
void btSliderConstraint_m_maxLinMotorForce_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_maxLinMotorForce = a;
}
float btSliderConstraint_m_maxLinMotorForce_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_maxLinMotorForce);
}

//attribute: ::btScalar btSliderConstraint->m_accumulatedLinMotorImpulse
void btSliderConstraint_m_accumulatedLinMotorImpulse_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_accumulatedLinMotorImpulse = a;
}
float btSliderConstraint_m_accumulatedLinMotorImpulse_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_accumulatedLinMotorImpulse);
}

//attribute: bool btSliderConstraint->m_poweredAngMotor
void btSliderConstraint_m_poweredAngMotor_set(void *c,int a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_poweredAngMotor = a;
}
int btSliderConstraint_m_poweredAngMotor_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (int)(o->m_poweredAngMotor);
}

//attribute: ::btScalar btSliderConstraint->m_targetAngMotorVelocity
void btSliderConstraint_m_targetAngMotorVelocity_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_targetAngMotorVelocity = a;
}
float btSliderConstraint_m_targetAngMotorVelocity_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_targetAngMotorVelocity);
}

//attribute: ::btScalar btSliderConstraint->m_maxAngMotorForce
void btSliderConstraint_m_maxAngMotorForce_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_maxAngMotorForce = a;
}
float btSliderConstraint_m_maxAngMotorForce_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_maxAngMotorForce);
}

//attribute: ::btScalar btSliderConstraint->m_accumulatedAngMotorImpulse
void btSliderConstraint_m_accumulatedAngMotorImpulse_set(void *c,float a) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	o->m_accumulatedAngMotorImpulse = a;
}
float btSliderConstraint_m_accumulatedAngMotorImpulse_get(void *c) {
	::btSliderConstraint *o = (::btSliderConstraint*)c;
	return (float)(o->m_accumulatedAngMotorImpulse);
}


// ::btSliderConstraintData
//constructor: btSliderConstraintData  ( ::btSliderConstraintData::* )(  ) 
void* btSliderConstraintData_new() {
	::btSliderConstraintData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSliderConstraintData),16);
	o = new (mem)::btSliderConstraintData();
	return (void*)o;
}
void btSliderConstraintData_free(void *c) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	delete o;
}
//attribute: ::btTypedConstraintData btSliderConstraintData->m_typeConstraintData
void btSliderConstraintData_m_typeConstraintData_set(void *c,void* a) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	::btTypedConstraintData & ta = *(::btTypedConstraintData *)a;
	o->m_typeConstraintData = ta;
}
void* btSliderConstraintData_m_typeConstraintData_get(void *c) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	return (void*)&(o->m_typeConstraintData);
}

//attribute: ::btTransformFloatData btSliderConstraintData->m_rbAFrame
void btSliderConstraintData_m_rbAFrame_set(void *c,void* a) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	::btTransformFloatData & ta = *(::btTransformFloatData *)a;
	o->m_rbAFrame = ta;
}
void* btSliderConstraintData_m_rbAFrame_get(void *c) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	return (void*)&(o->m_rbAFrame);
}

//attribute: ::btTransformFloatData btSliderConstraintData->m_rbBFrame
void btSliderConstraintData_m_rbBFrame_set(void *c,void* a) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	::btTransformFloatData & ta = *(::btTransformFloatData *)a;
	o->m_rbBFrame = ta;
}
void* btSliderConstraintData_m_rbBFrame_get(void *c) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	return (void*)&(o->m_rbBFrame);
}

//attribute: float btSliderConstraintData->m_linearUpperLimit
void btSliderConstraintData_m_linearUpperLimit_set(void *c,float a) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	o->m_linearUpperLimit = a;
}
float btSliderConstraintData_m_linearUpperLimit_get(void *c) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	return (float)(o->m_linearUpperLimit);
}

//attribute: float btSliderConstraintData->m_linearLowerLimit
void btSliderConstraintData_m_linearLowerLimit_set(void *c,float a) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	o->m_linearLowerLimit = a;
}
float btSliderConstraintData_m_linearLowerLimit_get(void *c) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	return (float)(o->m_linearLowerLimit);
}

//attribute: float btSliderConstraintData->m_angularUpperLimit
void btSliderConstraintData_m_angularUpperLimit_set(void *c,float a) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	o->m_angularUpperLimit = a;
}
float btSliderConstraintData_m_angularUpperLimit_get(void *c) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	return (float)(o->m_angularUpperLimit);
}

//attribute: float btSliderConstraintData->m_angularLowerLimit
void btSliderConstraintData_m_angularLowerLimit_set(void *c,float a) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	o->m_angularLowerLimit = a;
}
float btSliderConstraintData_m_angularLowerLimit_get(void *c) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	return (float)(o->m_angularLowerLimit);
}

//attribute: int btSliderConstraintData->m_useLinearReferenceFrameA
void btSliderConstraintData_m_useLinearReferenceFrameA_set(void *c,int a) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	o->m_useLinearReferenceFrameA = a;
}
int btSliderConstraintData_m_useLinearReferenceFrameA_get(void *c) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	return (int)(o->m_useLinearReferenceFrameA);
}

//attribute: int btSliderConstraintData->m_useOffsetForConstraintFrame
void btSliderConstraintData_m_useOffsetForConstraintFrame_set(void *c,int a) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	o->m_useOffsetForConstraintFrame = a;
}
int btSliderConstraintData_m_useOffsetForConstraintFrame_get(void *c) {
	::btSliderConstraintData *o = (::btSliderConstraintData*)c;
	return (int)(o->m_useOffsetForConstraintFrame);
}


// ::btSolverBodyObsolete
//constructor: btSolverBodyObsolete  ( ::btSolverBodyObsolete::* )(  ) 
void* btSolverBodyObsolete_new() {
	::btSolverBodyObsolete *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSolverBodyObsolete),16);
	o = new (mem)::btSolverBodyObsolete();
	return (void*)o;
}
void btSolverBodyObsolete_free(void *c) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	delete o;
}
//not supported method: applyImpulse void ( ::btSolverBodyObsolete::* )( ::btVector3 const &,::btVector3 const &,::btScalar const ) 
// error: ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported, void - ok

//method: getAngularVelocity void ( ::btSolverBodyObsolete::* )( ::btVector3 & ) const
void btSolverBodyObsolete_getAngularVelocity(void *c,float* p0) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->getAngularVelocity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: writebackVelocity void ( ::btSolverBodyObsolete::* )(  ) 
void btSolverBodyObsolete_writebackVelocity(void *c) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	o->writebackVelocity();
}
//method: writebackVelocity void ( ::btSolverBodyObsolete::* )(  ) 
void btSolverBodyObsolete_writebackVelocity0(void *c) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	o->writebackVelocity();
}
//method: writebackVelocity void ( ::btSolverBodyObsolete::* )( ::btScalar ) 
void btSolverBodyObsolete_writebackVelocity1(void *c,float p0) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	o->writebackVelocity(p0);
}
//method: internalApplyPushImpulse void ( ::btSolverBodyObsolete::* )( ::btVector3 const &,::btVector3 const &,::btScalar ) 
void btSolverBodyObsolete_internalApplyPushImpulse(void *c,float* p0,float* p1,float p2) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->internalApplyPushImpulse(tp0,tp1,p2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getVelocityInLocalPointObsolete void ( ::btSolverBodyObsolete::* )( ::btVector3 const &,::btVector3 & ) const
void btSolverBodyObsolete_getVelocityInLocalPointObsolete(void *c,float* p0,float* p1) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getVelocityInLocalPointObsolete(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//attribute: ::btVector3 btSolverBodyObsolete->m_deltaLinearVelocity
void btSolverBodyObsolete_m_deltaLinearVelocity_set(void *c,float* a) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_deltaLinearVelocity = ta;
}
void btSolverBodyObsolete_m_deltaLinearVelocity_get(void *c,float* a) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	a[0]=(o->m_deltaLinearVelocity).m_floats[0];a[1]=(o->m_deltaLinearVelocity).m_floats[1];a[2]=(o->m_deltaLinearVelocity).m_floats[2];
}

//attribute: ::btVector3 btSolverBodyObsolete->m_deltaAngularVelocity
void btSolverBodyObsolete_m_deltaAngularVelocity_set(void *c,float* a) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_deltaAngularVelocity = ta;
}
void btSolverBodyObsolete_m_deltaAngularVelocity_get(void *c,float* a) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	a[0]=(o->m_deltaAngularVelocity).m_floats[0];a[1]=(o->m_deltaAngularVelocity).m_floats[1];a[2]=(o->m_deltaAngularVelocity).m_floats[2];
}

//attribute: ::btVector3 btSolverBodyObsolete->m_angularFactor
void btSolverBodyObsolete_m_angularFactor_set(void *c,float* a) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_angularFactor = ta;
}
void btSolverBodyObsolete_m_angularFactor_get(void *c,float* a) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	a[0]=(o->m_angularFactor).m_floats[0];a[1]=(o->m_angularFactor).m_floats[1];a[2]=(o->m_angularFactor).m_floats[2];
}

//attribute: ::btVector3 btSolverBodyObsolete->m_invMass
void btSolverBodyObsolete_m_invMass_set(void *c,float* a) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_invMass = ta;
}
void btSolverBodyObsolete_m_invMass_get(void *c,float* a) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	a[0]=(o->m_invMass).m_floats[0];a[1]=(o->m_invMass).m_floats[1];a[2]=(o->m_invMass).m_floats[2];
}

//attribute: ::btRigidBody * btSolverBodyObsolete->m_originalBody
void btSolverBodyObsolete_m_originalBody_set(void *c,void* a) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	::btRigidBody * ta = (::btRigidBody *)a;
	o->m_originalBody = ta;
}
void* btSolverBodyObsolete_m_originalBody_get(void *c) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	return (void*)(o->m_originalBody);
}

//attribute: ::btVector3 btSolverBodyObsolete->m_pushVelocity
void btSolverBodyObsolete_m_pushVelocity_set(void *c,float* a) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_pushVelocity = ta;
}
void btSolverBodyObsolete_m_pushVelocity_get(void *c,float* a) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	a[0]=(o->m_pushVelocity).m_floats[0];a[1]=(o->m_pushVelocity).m_floats[1];a[2]=(o->m_pushVelocity).m_floats[2];
}

//attribute: ::btVector3 btSolverBodyObsolete->m_turnVelocity
void btSolverBodyObsolete_m_turnVelocity_set(void *c,float* a) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_turnVelocity = ta;
}
void btSolverBodyObsolete_m_turnVelocity_get(void *c,float* a) {
	::btSolverBodyObsolete *o = (::btSolverBodyObsolete*)c;
	a[0]=(o->m_turnVelocity).m_floats[0];a[1]=(o->m_turnVelocity).m_floats[1];a[2]=(o->m_turnVelocity).m_floats[2];
}


// ::btSolverConstraint
//constructor: btSolverConstraint  ( ::btSolverConstraint::* )(  ) 
void* btSolverConstraint_new() {
	::btSolverConstraint *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSolverConstraint),16);
	o = new (mem)::btSolverConstraint();
	return (void*)o;
}
void btSolverConstraint_free(void *c) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	delete o;
}
//attribute: ::btSolverConstraint btSolverConstraint->
// attribute not supported: //attribute: ::btSolverConstraint btSolverConstraint->
//attribute: ::btSolverConstraint btSolverConstraint->
// attribute not supported: //attribute: ::btSolverConstraint btSolverConstraint->
//attribute: ::btSolverConstraint btSolverConstraint->
// attribute not supported: //attribute: ::btSolverConstraint btSolverConstraint->
//attribute: ::btSolverConstraint btSolverConstraint->
// attribute not supported: //attribute: ::btSolverConstraint btSolverConstraint->
//attribute: ::btSolverConstraint btSolverConstraint->
// attribute not supported: //attribute: ::btSolverConstraint btSolverConstraint->
//attribute: ::btVector3 btSolverConstraint->m_angularComponentA
void btSolverConstraint_m_angularComponentA_set(void *c,float* a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_angularComponentA = ta;
}
void btSolverConstraint_m_angularComponentA_get(void *c,float* a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	a[0]=(o->m_angularComponentA).m_floats[0];a[1]=(o->m_angularComponentA).m_floats[1];a[2]=(o->m_angularComponentA).m_floats[2];
}

//attribute: ::btVector3 btSolverConstraint->m_angularComponentB
void btSolverConstraint_m_angularComponentB_set(void *c,float* a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_angularComponentB = ta;
}
void btSolverConstraint_m_angularComponentB_get(void *c,float* a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	a[0]=(o->m_angularComponentB).m_floats[0];a[1]=(o->m_angularComponentB).m_floats[1];a[2]=(o->m_angularComponentB).m_floats[2];
}

//attribute: ::btScalar btSolverConstraint->m_appliedImpulse
void btSolverConstraint_m_appliedImpulse_set(void *c,float a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	o->m_appliedImpulse = a;
}
float btSolverConstraint_m_appliedImpulse_get(void *c) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	return (float)(o->m_appliedImpulse);
}

//attribute: ::btScalar btSolverConstraint->m_appliedPushImpulse
void btSolverConstraint_m_appliedPushImpulse_set(void *c,float a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	o->m_appliedPushImpulse = a;
}
float btSolverConstraint_m_appliedPushImpulse_get(void *c) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	return (float)(o->m_appliedPushImpulse);
}

//attribute: ::btScalar btSolverConstraint->m_cfm
void btSolverConstraint_m_cfm_set(void *c,float a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	o->m_cfm = a;
}
float btSolverConstraint_m_cfm_get(void *c) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	return (float)(o->m_cfm);
}

//attribute: ::btVector3 btSolverConstraint->m_contactNormal
void btSolverConstraint_m_contactNormal_set(void *c,float* a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_contactNormal = ta;
}
void btSolverConstraint_m_contactNormal_get(void *c,float* a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	a[0]=(o->m_contactNormal).m_floats[0];a[1]=(o->m_contactNormal).m_floats[1];a[2]=(o->m_contactNormal).m_floats[2];
}

//attribute: ::btScalar btSolverConstraint->m_friction
void btSolverConstraint_m_friction_set(void *c,float a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	o->m_friction = a;
}
float btSolverConstraint_m_friction_get(void *c) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	return (float)(o->m_friction);
}

//attribute: ::btScalar btSolverConstraint->m_jacDiagABInv
void btSolverConstraint_m_jacDiagABInv_set(void *c,float a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	o->m_jacDiagABInv = a;
}
float btSolverConstraint_m_jacDiagABInv_get(void *c) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	return (float)(o->m_jacDiagABInv);
}

//attribute: ::btScalar btSolverConstraint->m_lowerLimit
void btSolverConstraint_m_lowerLimit_set(void *c,float a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	o->m_lowerLimit = a;
}
float btSolverConstraint_m_lowerLimit_get(void *c) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	return (float)(o->m_lowerLimit);
}

//attribute: ::btVector3 btSolverConstraint->m_relpos1CrossNormal
void btSolverConstraint_m_relpos1CrossNormal_set(void *c,float* a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_relpos1CrossNormal = ta;
}
void btSolverConstraint_m_relpos1CrossNormal_get(void *c,float* a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	a[0]=(o->m_relpos1CrossNormal).m_floats[0];a[1]=(o->m_relpos1CrossNormal).m_floats[1];a[2]=(o->m_relpos1CrossNormal).m_floats[2];
}

//attribute: ::btVector3 btSolverConstraint->m_relpos2CrossNormal
void btSolverConstraint_m_relpos2CrossNormal_set(void *c,float* a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_relpos2CrossNormal = ta;
}
void btSolverConstraint_m_relpos2CrossNormal_get(void *c,float* a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	a[0]=(o->m_relpos2CrossNormal).m_floats[0];a[1]=(o->m_relpos2CrossNormal).m_floats[1];a[2]=(o->m_relpos2CrossNormal).m_floats[2];
}

//attribute: ::btScalar btSolverConstraint->m_rhs
void btSolverConstraint_m_rhs_set(void *c,float a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	o->m_rhs = a;
}
float btSolverConstraint_m_rhs_get(void *c) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	return (float)(o->m_rhs);
}

//attribute: ::btScalar btSolverConstraint->m_rhsPenetration
void btSolverConstraint_m_rhsPenetration_set(void *c,float a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	o->m_rhsPenetration = a;
}
float btSolverConstraint_m_rhsPenetration_get(void *c) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	return (float)(o->m_rhsPenetration);
}

//attribute: ::btScalar btSolverConstraint->m_upperLimit
void btSolverConstraint_m_upperLimit_set(void *c,float a) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	o->m_upperLimit = a;
}
float btSolverConstraint_m_upperLimit_get(void *c) {
	::btSolverConstraint *o = (::btSolverConstraint*)c;
	return (float)(o->m_upperLimit);
}


// ::btTranslationalLimitMotor
//constructor: btTranslationalLimitMotor  ( ::btTranslationalLimitMotor::* )(  ) 
void* btTranslationalLimitMotor_new() {
	::btTranslationalLimitMotor *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTranslationalLimitMotor),16);
	o = new (mem)::btTranslationalLimitMotor();
	return (void*)o;
}
void btTranslationalLimitMotor_free(void *c) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	delete o;
}
//method: testLimitValue int ( ::btTranslationalLimitMotor::* )( int,::btScalar ) 
int btTranslationalLimitMotor_testLimitValue(void *c,int p0,float p1) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	int retVal = (int)o->testLimitValue(p0,p1);
	return retVal;
}
//method: needApplyForce bool ( ::btTranslationalLimitMotor::* )( int ) 
int btTranslationalLimitMotor_needApplyForce(void *c,int p0) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	int retVal = (int)o->needApplyForce(p0);
	return retVal;
}
//method: solveLinearAxis ::btScalar ( ::btTranslationalLimitMotor::* )( ::btScalar,::btScalar,::btRigidBody &,::btVector3 const &,::btRigidBody &,::btVector3 const &,int,::btVector3 const &,::btVector3 const & ) 
float btTranslationalLimitMotor_solveLinearAxis(void *c,float p0,float p1,void* p2,float* p3,void* p4,float* p5,int p6,float* p7,float* p8) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	::btRigidBody & tp2 = *(::btRigidBody *)p2;
	btVector3 tp3(p3[0],p3[1],p3[2]);
	::btRigidBody & tp4 = *(::btRigidBody *)p4;
	btVector3 tp5(p5[0],p5[1],p5[2]);
	btVector3 tp7(p7[0],p7[1],p7[2]);
	btVector3 tp8(p8[0],p8[1],p8[2]);
	float retVal = (float)o->solveLinearAxis(p0,p1,tp2,tp3,tp4,tp5,p6,tp7,tp8);
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p5[0]=tp5.m_floats[0];p5[1]=tp5.m_floats[1];p5[2]=tp5.m_floats[2];
	p7[0]=tp7.m_floats[0];p7[1]=tp7.m_floats[1];p7[2]=tp7.m_floats[2];
	p8[0]=tp8.m_floats[0];p8[1]=tp8.m_floats[1];p8[2]=tp8.m_floats[2];
	return retVal;
}
//method: isLimited bool ( ::btTranslationalLimitMotor::* )( int ) 
int btTranslationalLimitMotor_isLimited(void *c,int p0) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	int retVal = (int)o->isLimited(p0);
	return retVal;
}
//attribute: ::btVector3 btTranslationalLimitMotor->m_accumulatedImpulse
void btTranslationalLimitMotor_m_accumulatedImpulse_set(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_accumulatedImpulse = ta;
}
void btTranslationalLimitMotor_m_accumulatedImpulse_get(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	a[0]=(o->m_accumulatedImpulse).m_floats[0];a[1]=(o->m_accumulatedImpulse).m_floats[1];a[2]=(o->m_accumulatedImpulse).m_floats[2];
}

//attribute: int[3] btTranslationalLimitMotor->m_currentLimit
// attribute not supported: //attribute: int[3] btTranslationalLimitMotor->m_currentLimit
//attribute: ::btVector3 btTranslationalLimitMotor->m_currentLimitError
void btTranslationalLimitMotor_m_currentLimitError_set(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_currentLimitError = ta;
}
void btTranslationalLimitMotor_m_currentLimitError_get(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	a[0]=(o->m_currentLimitError).m_floats[0];a[1]=(o->m_currentLimitError).m_floats[1];a[2]=(o->m_currentLimitError).m_floats[2];
}

//attribute: ::btVector3 btTranslationalLimitMotor->m_currentLinearDiff
void btTranslationalLimitMotor_m_currentLinearDiff_set(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_currentLinearDiff = ta;
}
void btTranslationalLimitMotor_m_currentLinearDiff_get(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	a[0]=(o->m_currentLinearDiff).m_floats[0];a[1]=(o->m_currentLinearDiff).m_floats[1];a[2]=(o->m_currentLinearDiff).m_floats[2];
}

//attribute: ::btScalar btTranslationalLimitMotor->m_damping
void btTranslationalLimitMotor_m_damping_set(void *c,float a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	o->m_damping = a;
}
float btTranslationalLimitMotor_m_damping_get(void *c) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	return (float)(o->m_damping);
}

//attribute: bool[3] btTranslationalLimitMotor->m_enableMotor
// attribute not supported: //attribute: bool[3] btTranslationalLimitMotor->m_enableMotor
//attribute: ::btScalar btTranslationalLimitMotor->m_limitSoftness
void btTranslationalLimitMotor_m_limitSoftness_set(void *c,float a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	o->m_limitSoftness = a;
}
float btTranslationalLimitMotor_m_limitSoftness_get(void *c) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	return (float)(o->m_limitSoftness);
}

//attribute: ::btVector3 btTranslationalLimitMotor->m_lowerLimit
void btTranslationalLimitMotor_m_lowerLimit_set(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_lowerLimit = ta;
}
void btTranslationalLimitMotor_m_lowerLimit_get(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	a[0]=(o->m_lowerLimit).m_floats[0];a[1]=(o->m_lowerLimit).m_floats[1];a[2]=(o->m_lowerLimit).m_floats[2];
}

//attribute: ::btVector3 btTranslationalLimitMotor->m_maxMotorForce
void btTranslationalLimitMotor_m_maxMotorForce_set(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_maxMotorForce = ta;
}
void btTranslationalLimitMotor_m_maxMotorForce_get(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	a[0]=(o->m_maxMotorForce).m_floats[0];a[1]=(o->m_maxMotorForce).m_floats[1];a[2]=(o->m_maxMotorForce).m_floats[2];
}

//attribute: ::btVector3 btTranslationalLimitMotor->m_normalCFM
void btTranslationalLimitMotor_m_normalCFM_set(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_normalCFM = ta;
}
void btTranslationalLimitMotor_m_normalCFM_get(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	a[0]=(o->m_normalCFM).m_floats[0];a[1]=(o->m_normalCFM).m_floats[1];a[2]=(o->m_normalCFM).m_floats[2];
}

//attribute: ::btScalar btTranslationalLimitMotor->m_restitution
void btTranslationalLimitMotor_m_restitution_set(void *c,float a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	o->m_restitution = a;
}
float btTranslationalLimitMotor_m_restitution_get(void *c) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	return (float)(o->m_restitution);
}

//attribute: ::btVector3 btTranslationalLimitMotor->m_stopCFM
void btTranslationalLimitMotor_m_stopCFM_set(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_stopCFM = ta;
}
void btTranslationalLimitMotor_m_stopCFM_get(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	a[0]=(o->m_stopCFM).m_floats[0];a[1]=(o->m_stopCFM).m_floats[1];a[2]=(o->m_stopCFM).m_floats[2];
}

//attribute: ::btVector3 btTranslationalLimitMotor->m_stopERP
void btTranslationalLimitMotor_m_stopERP_set(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_stopERP = ta;
}
void btTranslationalLimitMotor_m_stopERP_get(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	a[0]=(o->m_stopERP).m_floats[0];a[1]=(o->m_stopERP).m_floats[1];a[2]=(o->m_stopERP).m_floats[2];
}

//attribute: ::btVector3 btTranslationalLimitMotor->m_targetVelocity
void btTranslationalLimitMotor_m_targetVelocity_set(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_targetVelocity = ta;
}
void btTranslationalLimitMotor_m_targetVelocity_get(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	a[0]=(o->m_targetVelocity).m_floats[0];a[1]=(o->m_targetVelocity).m_floats[1];a[2]=(o->m_targetVelocity).m_floats[2];
}

//attribute: ::btVector3 btTranslationalLimitMotor->m_upperLimit
void btTranslationalLimitMotor_m_upperLimit_set(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_upperLimit = ta;
}
void btTranslationalLimitMotor_m_upperLimit_get(void *c,float* a) {
	::btTranslationalLimitMotor *o = (::btTranslationalLimitMotor*)c;
	a[0]=(o->m_upperLimit).m_floats[0];a[1]=(o->m_upperLimit).m_floats[1];a[2]=(o->m_upperLimit).m_floats[2];
}


// ::btTypedConstraint
//method: getRigidBodyB ::btRigidBody const & ( ::btTypedConstraint::* )(  ) const
void* btTypedConstraint_getRigidBodyB(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyB());
	return retVal;
}
//method: getRigidBodyB ::btRigidBody const & ( ::btTypedConstraint::* )(  ) const
void* btTypedConstraint_getRigidBodyB0(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyB());
	return retVal;
}
//method: getRigidBodyB ::btRigidBody & ( ::btTypedConstraint::* )(  ) 
void* btTypedConstraint_getRigidBodyB1(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyB());
	return retVal;
}
//method: buildJacobian void ( ::btTypedConstraint::* )(  ) 
void btTypedConstraint_buildJacobian(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	o->buildJacobian();
}
//method: getRigidBodyA ::btRigidBody const & ( ::btTypedConstraint::* )(  ) const
void* btTypedConstraint_getRigidBodyA(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyA());
	return retVal;
}
//method: getRigidBodyA ::btRigidBody const & ( ::btTypedConstraint::* )(  ) const
void* btTypedConstraint_getRigidBodyA0(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyA());
	return retVal;
}
//method: getRigidBodyA ::btRigidBody & ( ::btTypedConstraint::* )(  ) 
void* btTypedConstraint_getRigidBodyA1(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	void* retVal = (void*) &(o->getRigidBodyA());
	return retVal;
}
//method: serialize char const * ( ::btTypedConstraint::* )( void *,::btSerializer * ) const
char const * btTypedConstraint_serialize(void *c,void* p0,void* p1) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: enableFeedback void ( ::btTypedConstraint::* )( bool ) 
void btTypedConstraint_enableFeedback(void *c,int p0) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	o->enableFeedback(p0);
}
//method: getUserConstraintId int ( ::btTypedConstraint::* )(  ) const
int btTypedConstraint_getUserConstraintId(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	int retVal = (int)o->getUserConstraintId();
	return retVal;
}
//method: setParam void ( ::btTypedConstraint::* )( int,::btScalar,int ) 
void btTypedConstraint_setParam(void *c,int p0,float p1,int p2) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	o->setParam(p0,p1,p2);
}
//method: getParam ::btScalar ( ::btTypedConstraint::* )( int,int ) const
float btTypedConstraint_getParam(void *c,int p0,int p1) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	float retVal = (float)o->getParam(p0,p1);
	return retVal;
}
//method: getInfo1 void ( ::btTypedConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btTypedConstraint_getInfo1(void *c,void* p0) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	::btTypedConstraint::btConstraintInfo1 * tp0 = (::btTypedConstraint::btConstraintInfo1 *)p0;
	o->getInfo1(tp0);
}
//method: getInfo2 void ( ::btTypedConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void btTypedConstraint_getInfo2(void *c,void* p0) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	::btTypedConstraint::btConstraintInfo2 * tp0 = (::btTypedConstraint::btConstraintInfo2 *)p0;
	o->getInfo2(tp0);
}
//method: setBreakingImpulseThreshold void ( ::btTypedConstraint::* )( ::btScalar ) 
void btTypedConstraint_setBreakingImpulseThreshold(void *c,float p0) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	o->setBreakingImpulseThreshold(p0);
}
//method: getFixedBody ::btRigidBody & (*)(  )
void* btTypedConstraint_getFixedBody() {
	void* retVal = (void*) &(::btTypedConstraint::getFixedBody());
	return retVal;
}
//method: calculateSerializeBufferSize int ( ::btTypedConstraint::* )(  ) const
int btTypedConstraint_calculateSerializeBufferSize(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: isEnabled bool ( ::btTypedConstraint::* )(  ) const
int btTypedConstraint_isEnabled(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	int retVal = (int)o->isEnabled();
	return retVal;
}
//method: setUserConstraintId void ( ::btTypedConstraint::* )( int ) 
void btTypedConstraint_setUserConstraintId(void *c,int p0) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	o->setUserConstraintId(p0);
}
//not supported method: getConstraintType ::btTypedConstraintType ( ::btTypedConstraint::* )(  ) const
// error:  - unsupported

//method: getMotorFactor ::btScalar ( ::btTypedConstraint::* )( ::btScalar,::btScalar,::btScalar,::btScalar,::btScalar ) 
float btTypedConstraint_getMotorFactor(void *c,float p0,float p1,float p2,float p3,float p4) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	float retVal = (float)o->getMotorFactor(p0,p1,p2,p3,p4);
	return retVal;
}
//method: getDbgDrawSize ::btScalar ( ::btTypedConstraint::* )(  ) 
float btTypedConstraint_getDbgDrawSize(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	float retVal = (float)o->getDbgDrawSize();
	return retVal;
}
//method: internalSetAppliedImpulse void ( ::btTypedConstraint::* )( ::btScalar ) 
void btTypedConstraint_internalSetAppliedImpulse(void *c,float p0) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	o->internalSetAppliedImpulse(p0);
}
//method: needsFeedback bool ( ::btTypedConstraint::* )(  ) const
int btTypedConstraint_needsFeedback(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	int retVal = (int)o->needsFeedback();
	return retVal;
}
//method: getUserConstraintPtr void * ( ::btTypedConstraint::* )(  ) 
void* btTypedConstraint_getUserConstraintPtr(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	void* retVal = (void*) o->getUserConstraintPtr();
	return retVal;
}
//method: setEnabled void ( ::btTypedConstraint::* )( bool ) 
void btTypedConstraint_setEnabled(void *c,int p0) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	o->setEnabled(p0);
}
//method: getUid int ( ::btTypedConstraint::* )(  ) const
int btTypedConstraint_getUid(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	int retVal = (int)o->getUid();
	return retVal;
}
//method: setDbgDrawSize void ( ::btTypedConstraint::* )( ::btScalar ) 
void btTypedConstraint_setDbgDrawSize(void *c,float p0) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	o->setDbgDrawSize(p0);
}
//method: setUserConstraintType void ( ::btTypedConstraint::* )( int ) 
void btTypedConstraint_setUserConstraintType(void *c,int p0) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	o->setUserConstraintType(p0);
}
//method: internalGetAppliedImpulse ::btScalar ( ::btTypedConstraint::* )(  ) 
float btTypedConstraint_internalGetAppliedImpulse(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	float retVal = (float)o->internalGetAppliedImpulse();
	return retVal;
}
//method: setupSolverConstraint void ( ::btTypedConstraint::* )( ::btConstraintArray &,int,int,::btScalar ) 
void btTypedConstraint_setupSolverConstraint(void *c,void* p0,int p1,int p2,float p3) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	::btConstraintArray & tp0 = *(::btAlignedObjectArray<btSolverConstraint> *)p0;
	o->setupSolverConstraint(tp0,p1,p2,p3);
}
//method: getBreakingImpulseThreshold ::btScalar ( ::btTypedConstraint::* )(  ) const
float btTypedConstraint_getBreakingImpulseThreshold(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	float retVal = (float)o->getBreakingImpulseThreshold();
	return retVal;
}
//method: getUserConstraintType int ( ::btTypedConstraint::* )(  ) const
int btTypedConstraint_getUserConstraintType(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	int retVal = (int)o->getUserConstraintType();
	return retVal;
}
//method: solveConstraintObsolete void ( ::btTypedConstraint::* )( ::btRigidBody &,::btRigidBody &,::btScalar ) 
void btTypedConstraint_solveConstraintObsolete(void *c,void* p0,void* p1,float p2) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	o->solveConstraintObsolete(tp0,tp1,p2);
}
//method: getAppliedImpulse ::btScalar ( ::btTypedConstraint::* )(  ) const
float btTypedConstraint_getAppliedImpulse(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	float retVal = (float)o->getAppliedImpulse();
	return retVal;
}
//method: setUserConstraintPtr void ( ::btTypedConstraint::* )( void * ) 
void btTypedConstraint_setUserConstraintPtr(void *c,void* p0) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	void * tp0 = (void *)p0;
	o->setUserConstraintPtr(tp0);
}
//attribute: ::btTypedConstraint btTypedConstraint->
// attribute not supported: //attribute: ::btTypedConstraint btTypedConstraint->
//attribute: ::btScalar btTypedConstraint->m_appliedImpulse
void btTypedConstraint_m_appliedImpulse_set(void *c,float a) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	o->m_appliedImpulse = a;
}
float btTypedConstraint_m_appliedImpulse_get(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	return (float)(o->m_appliedImpulse);
}

//attribute: ::btScalar btTypedConstraint->m_breakingImpulseThreshold
void btTypedConstraint_m_breakingImpulseThreshold_set(void *c,float a) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	o->m_breakingImpulseThreshold = a;
}
float btTypedConstraint_m_breakingImpulseThreshold_get(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	return (float)(o->m_breakingImpulseThreshold);
}

//attribute: ::btScalar btTypedConstraint->m_dbgDrawSize
void btTypedConstraint_m_dbgDrawSize_set(void *c,float a) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	o->m_dbgDrawSize = a;
}
float btTypedConstraint_m_dbgDrawSize_get(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	return (float)(o->m_dbgDrawSize);
}

//attribute: bool btTypedConstraint->m_isEnabled
void btTypedConstraint_m_isEnabled_set(void *c,int a) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	o->m_isEnabled = a;
}
int btTypedConstraint_m_isEnabled_get(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	return (int)(o->m_isEnabled);
}

//attribute: bool btTypedConstraint->m_needsFeedback
void btTypedConstraint_m_needsFeedback_set(void *c,int a) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	o->m_needsFeedback = a;
}
int btTypedConstraint_m_needsFeedback_get(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	return (int)(o->m_needsFeedback);
}

//attribute: ::btRigidBody & btTypedConstraint->m_rbA
void btTypedConstraint_m_rbA_set(void *c,void* a) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	::btRigidBody & ta = *(::btRigidBody *)a;
	o->m_rbA = ta;
}
void* btTypedConstraint_m_rbA_get(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	return (void*)&(o->m_rbA);
}

//attribute: ::btRigidBody & btTypedConstraint->m_rbB
void btTypedConstraint_m_rbB_set(void *c,void* a) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	::btRigidBody & ta = *(::btRigidBody *)a;
	o->m_rbB = ta;
}
void* btTypedConstraint_m_rbB_get(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	return (void*)&(o->m_rbB);
}

//attribute: int btTypedConstraint->m_userConstraintType
void btTypedConstraint_m_userConstraintType_set(void *c,int a) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	o->m_userConstraintType = a;
}
int btTypedConstraint_m_userConstraintType_get(void *c) {
	::btTypedConstraint *o = (::btTypedConstraint*)c;
	return (int)(o->m_userConstraintType);
}


// ::btTypedConstraintData
//constructor: btTypedConstraintData  ( ::btTypedConstraintData::* )(  ) 
void* btTypedConstraintData_new() {
	::btTypedConstraintData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTypedConstraintData),16);
	o = new (mem)::btTypedConstraintData();
	return (void*)o;
}
void btTypedConstraintData_free(void *c) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	delete o;
}
//attribute: float btTypedConstraintData->m_appliedImpulse
void btTypedConstraintData_m_appliedImpulse_set(void *c,float a) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	o->m_appliedImpulse = a;
}
float btTypedConstraintData_m_appliedImpulse_get(void *c) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	return (float)(o->m_appliedImpulse);
}

//attribute: float btTypedConstraintData->m_dbgDrawSize
void btTypedConstraintData_m_dbgDrawSize_set(void *c,float a) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	o->m_dbgDrawSize = a;
}
float btTypedConstraintData_m_dbgDrawSize_get(void *c) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	return (float)(o->m_dbgDrawSize);
}

//attribute: int btTypedConstraintData->m_disableCollisionsBetweenLinkedBodies
void btTypedConstraintData_m_disableCollisionsBetweenLinkedBodies_set(void *c,int a) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	o->m_disableCollisionsBetweenLinkedBodies = a;
}
int btTypedConstraintData_m_disableCollisionsBetweenLinkedBodies_get(void *c) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	return (int)(o->m_disableCollisionsBetweenLinkedBodies);
}

//attribute: char * btTypedConstraintData->m_name
void btTypedConstraintData_m_name_set(void *c,char * a) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	o->m_name = a;
}
char * btTypedConstraintData_m_name_get(void *c) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	return (char *)(o->m_name);
}

//attribute: int btTypedConstraintData->m_needsFeedback
void btTypedConstraintData_m_needsFeedback_set(void *c,int a) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	o->m_needsFeedback = a;
}
int btTypedConstraintData_m_needsFeedback_get(void *c) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	return (int)(o->m_needsFeedback);
}

//attribute: int btTypedConstraintData->m_objectType
void btTypedConstraintData_m_objectType_set(void *c,int a) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	o->m_objectType = a;
}
int btTypedConstraintData_m_objectType_get(void *c) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	return (int)(o->m_objectType);
}

//attribute: char[4] btTypedConstraintData->m_pad4
// attribute not supported: //attribute: char[4] btTypedConstraintData->m_pad4
//attribute: ::btRigidBodyFloatData * btTypedConstraintData->m_rbA
void btTypedConstraintData_m_rbA_set(void *c,void* a) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	::btRigidBodyFloatData * ta = (::btRigidBodyFloatData *)a;
	o->m_rbA = ta;
}
void* btTypedConstraintData_m_rbA_get(void *c) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	return (void*)(o->m_rbA);
}

//attribute: ::btRigidBodyFloatData * btTypedConstraintData->m_rbB
void btTypedConstraintData_m_rbB_set(void *c,void* a) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	::btRigidBodyFloatData * ta = (::btRigidBodyFloatData *)a;
	o->m_rbB = ta;
}
void* btTypedConstraintData_m_rbB_get(void *c) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	return (void*)(o->m_rbB);
}

//attribute: int btTypedConstraintData->m_userConstraintId
void btTypedConstraintData_m_userConstraintId_set(void *c,int a) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	o->m_userConstraintId = a;
}
int btTypedConstraintData_m_userConstraintId_get(void *c) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	return (int)(o->m_userConstraintId);
}

//attribute: int btTypedConstraintData->m_userConstraintType
void btTypedConstraintData_m_userConstraintType_set(void *c,int a) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	o->m_userConstraintType = a;
}
int btTypedConstraintData_m_userConstraintType_get(void *c) {
	::btTypedConstraintData *o = (::btTypedConstraintData*)c;
	return (int)(o->m_userConstraintType);
}


// ::btUniversalConstraint
//constructor: btUniversalConstraint  ( ::btUniversalConstraint::* )( ::btRigidBody &,::btRigidBody &,::btVector3 &,::btVector3 &,::btVector3 & ) 
void* btUniversalConstraint_new(void* p0,void* p1,float* p2,float* p3,float* p4) {
	::btUniversalConstraint *o = 0;
	 void *mem = 0;
	::btRigidBody & tp0 = *(::btRigidBody *)p0;
	::btRigidBody & tp1 = *(::btRigidBody *)p1;
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	mem = btAlignedAlloc(sizeof(::btUniversalConstraint),16);
	o = new (mem)::btUniversalConstraint(tp0,tp1,tp2,tp3,tp4);
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	return (void*)o;
}
void btUniversalConstraint_free(void *c) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	delete o;
}
//method: setLowerLimit void ( ::btUniversalConstraint::* )( ::btScalar,::btScalar ) 
void btUniversalConstraint_setLowerLimit(void *c,float p0,float p1) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	o->setLowerLimit(p0,p1);
}
//method: getAnchor2 ::btVector3 const & ( ::btUniversalConstraint::* )(  ) 
void btUniversalConstraint_getAnchor2(void *c,float* ret) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAnchor2();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: setAxis void ( ::btUniversalConstraint::* )( ::btVector3 const &,::btVector3 const & ) 
void btUniversalConstraint_setAxis(void *c,float* p0,float* p1) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->setAxis(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getAxis1 ::btVector3 const & ( ::btUniversalConstraint::* )(  ) 
void btUniversalConstraint_getAxis1(void *c,float* ret) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAxis1();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getAnchor ::btVector3 const & ( ::btUniversalConstraint::* )(  ) 
void btUniversalConstraint_getAnchor(void *c,float* ret) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAnchor();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getAxis2 ::btVector3 const & ( ::btUniversalConstraint::* )(  ) 
void btUniversalConstraint_getAxis2(void *c,float* ret) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAxis2();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: setUpperLimit void ( ::btUniversalConstraint::* )( ::btScalar,::btScalar ) 
void btUniversalConstraint_setUpperLimit(void *c,float p0,float p1) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	o->setUpperLimit(p0,p1);
}
//method: getAngle2 ::btScalar ( ::btUniversalConstraint::* )(  ) 
float btUniversalConstraint_getAngle2(void *c) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	float retVal = (float)o->getAngle2();
	return retVal;
}
//method: getAngle1 ::btScalar ( ::btUniversalConstraint::* )(  ) 
float btUniversalConstraint_getAngle1(void *c) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	float retVal = (float)o->getAngle1();
	return retVal;
}
//attribute: ::btVector3 btUniversalConstraint->m_anchor
void btUniversalConstraint_m_anchor_set(void *c,float* a) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_anchor = ta;
}
void btUniversalConstraint_m_anchor_get(void *c,float* a) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	a[0]=(o->m_anchor).m_floats[0];a[1]=(o->m_anchor).m_floats[1];a[2]=(o->m_anchor).m_floats[2];
}

//attribute: ::btVector3 btUniversalConstraint->m_axis1
void btUniversalConstraint_m_axis1_set(void *c,float* a) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_axis1 = ta;
}
void btUniversalConstraint_m_axis1_get(void *c,float* a) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	a[0]=(o->m_axis1).m_floats[0];a[1]=(o->m_axis1).m_floats[1];a[2]=(o->m_axis1).m_floats[2];
}

//attribute: ::btVector3 btUniversalConstraint->m_axis2
void btUniversalConstraint_m_axis2_set(void *c,float* a) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_axis2 = ta;
}
void btUniversalConstraint_m_axis2_get(void *c,float* a) {
	::btUniversalConstraint *o = (::btUniversalConstraint*)c;
	a[0]=(o->m_axis2).m_floats[0];a[1]=(o->m_axis2).m_floats[1];a[2]=(o->m_axis2).m_floats[2];
}


// ::btActionInterface
//method: getFixedBody ::btRigidBody & (*)(  )
void* btActionInterface_getFixedBody() {
	void* retVal = (void*) &(::btActionInterface::getFixedBody());
	return retVal;
}
//method: updateAction void ( ::btActionInterface::* )( ::btCollisionWorld *,::btScalar ) 
void btActionInterface_updateAction(void *c,void* p0,float p1) {
	::btActionInterface *o = (::btActionInterface*)c;
	::btCollisionWorld * tp0 = (::btCollisionWorld *)p0;
	o->updateAction(tp0,p1);
}
//method: debugDraw void ( ::btActionInterface::* )( ::btIDebugDraw * ) 
void btActionInterface_debugDraw(void *c,void* p0) {
	::btActionInterface *o = (::btActionInterface*)c;
	::btIDebugDraw * tp0 = (::btIDebugDraw *)p0;
	o->debugDraw(tp0);
}

// ::btDiscreteDynamicsWorld
//constructor: btDiscreteDynamicsWorld  ( ::btDiscreteDynamicsWorld::* )( ::btDispatcher *,::btBroadphaseInterface *,::btConstraintSolver *,::btCollisionConfiguration * ) 
void* btDiscreteDynamicsWorld_new(void* p0,void* p1,void* p2,void* p3) {
	::btDiscreteDynamicsWorld *o = 0;
	 void *mem = 0;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	::btBroadphaseInterface * tp1 = (::btBroadphaseInterface *)p1;
	::btConstraintSolver * tp2 = (::btConstraintSolver *)p2;
	::btCollisionConfiguration * tp3 = (::btCollisionConfiguration *)p3;
	mem = btAlignedAlloc(sizeof(::btDiscreteDynamicsWorld),16);
	o = new (mem)::btDiscreteDynamicsWorld(tp0,tp1,tp2,tp3);
	return (void*)o;
}
void btDiscreteDynamicsWorld_free(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	delete o;
}
//method: setGravity void ( ::btDiscreteDynamicsWorld::* )( ::btVector3 const & ) 
void btDiscreteDynamicsWorld_setGravity(void *c,float* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setGravity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: addAction void ( ::btDiscreteDynamicsWorld::* )( ::btActionInterface * ) 
void btDiscreteDynamicsWorld_addAction(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	o->addAction(tp0);
}
//method: applyGravity void ( ::btDiscreteDynamicsWorld::* )(  ) 
void btDiscreteDynamicsWorld_applyGravity(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->applyGravity();
}
//method: serialize void ( ::btDiscreteDynamicsWorld::* )( ::btSerializer * ) 
void btDiscreteDynamicsWorld_serialize(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btSerializer * tp0 = (::btSerializer *)p0;
	o->serialize(tp0);
}
//method: getCollisionWorld ::btCollisionWorld * ( ::btDiscreteDynamicsWorld::* )(  ) 
void* btDiscreteDynamicsWorld_getCollisionWorld(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	void* retVal = (void*) o->getCollisionWorld();
	return retVal;
}
//method: addRigidBody void ( ::btDiscreteDynamicsWorld::* )( ::btRigidBody * ) 
void btDiscreteDynamicsWorld_addRigidBody(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btRigidBody * tp0 = (::btRigidBody *)p0;
	o->addRigidBody(tp0);
}
//method: addRigidBody void ( ::btDiscreteDynamicsWorld::* )( ::btRigidBody * ) 
void btDiscreteDynamicsWorld_addRigidBody0(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btRigidBody * tp0 = (::btRigidBody *)p0;
	o->addRigidBody(tp0);
}
//method: addRigidBody void ( ::btDiscreteDynamicsWorld::* )( ::btRigidBody *,short int,short int ) 
void btDiscreteDynamicsWorld_addRigidBody1(void *c,void* p0,short int p1,short int p2) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btRigidBody * tp0 = (::btRigidBody *)p0;
	o->addRigidBody(tp0,p1,p2);
}
//method: clearForces void ( ::btDiscreteDynamicsWorld::* )(  ) 
void btDiscreteDynamicsWorld_clearForces(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->clearForces();
}
//method: removeVehicle void ( ::btDiscreteDynamicsWorld::* )( ::btActionInterface * ) 
void btDiscreteDynamicsWorld_removeVehicle(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	o->removeVehicle(tp0);
}
//method: serializeRigidBodies void ( ::btDiscreteDynamicsWorld::* )( ::btSerializer * ) 
void btDiscreteDynamicsWorld_serializeRigidBodies(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btSerializer * tp0 = (::btSerializer *)p0;
	o->serializeRigidBodies(tp0);
}
//method: internalSingleStepSimulation void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
void btDiscreteDynamicsWorld_internalSingleStepSimulation(void *c,float p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->internalSingleStepSimulation(p0);
}
//method: getSynchronizeAllMotionStates bool ( ::btDiscreteDynamicsWorld::* )(  ) const
int btDiscreteDynamicsWorld_getSynchronizeAllMotionStates(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	int retVal = (int)o->getSynchronizeAllMotionStates();
	return retVal;
}
//method: setNumTasks void ( ::btDiscreteDynamicsWorld::* )( int ) 
void btDiscreteDynamicsWorld_setNumTasks(void *c,int p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->setNumTasks(p0);
}
//method: setSynchronizeAllMotionStates void ( ::btDiscreteDynamicsWorld::* )( bool ) 
void btDiscreteDynamicsWorld_setSynchronizeAllMotionStates(void *c,int p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->setSynchronizeAllMotionStates(p0);
}
//method: predictUnconstraintMotion void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
void btDiscreteDynamicsWorld_predictUnconstraintMotion(void *c,float p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->predictUnconstraintMotion(p0);
}
//method: removeConstraint void ( ::btDiscreteDynamicsWorld::* )( ::btTypedConstraint * ) 
void btDiscreteDynamicsWorld_removeConstraint(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btTypedConstraint * tp0 = (::btTypedConstraint *)p0;
	o->removeConstraint(tp0);
}
//method: getNumConstraints int ( ::btDiscreteDynamicsWorld::* )(  ) const
int btDiscreteDynamicsWorld_getNumConstraints(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	int retVal = (int)o->getNumConstraints();
	return retVal;
}
//method: addCollisionObject void ( ::btDiscreteDynamicsWorld::* )( ::btCollisionObject *,short int,short int ) 
void btDiscreteDynamicsWorld_addCollisionObject(void *c,void* p0,short int p1,short int p2) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	o->addCollisionObject(tp0,p1,p2);
}
//method: removeRigidBody void ( ::btDiscreteDynamicsWorld::* )( ::btRigidBody * ) 
void btDiscreteDynamicsWorld_removeRigidBody(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btRigidBody * tp0 = (::btRigidBody *)p0;
	o->removeRigidBody(tp0);
}
//method: integrateTransforms void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
void btDiscreteDynamicsWorld_integrateTransforms(void *c,float p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->integrateTransforms(p0);
}
//method: debugDrawConstraint void ( ::btDiscreteDynamicsWorld::* )( ::btTypedConstraint * ) 
void btDiscreteDynamicsWorld_debugDrawConstraint(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btTypedConstraint * tp0 = (::btTypedConstraint *)p0;
	o->debugDrawConstraint(tp0);
}
//method: debugDrawWorld void ( ::btDiscreteDynamicsWorld::* )(  ) 
void btDiscreteDynamicsWorld_debugDrawWorld(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->debugDrawWorld();
}
//method: calculateSimulationIslands void ( ::btDiscreteDynamicsWorld::* )(  ) 
void btDiscreteDynamicsWorld_calculateSimulationIslands(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->calculateSimulationIslands();
}
//method: addConstraint void ( ::btDiscreteDynamicsWorld::* )( ::btTypedConstraint *,bool ) 
void btDiscreteDynamicsWorld_addConstraint(void *c,void* p0,int p1) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btTypedConstraint * tp0 = (::btTypedConstraint *)p0;
	o->addConstraint(tp0,p1);
}
//method: startProfiling void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
void btDiscreteDynamicsWorld_startProfiling(void *c,float p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->startProfiling(p0);
}
//method: updateActivationState void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
void btDiscreteDynamicsWorld_updateActivationState(void *c,float p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->updateActivationState(p0);
}
//method: getGravity ::btVector3 ( ::btDiscreteDynamicsWorld::* )(  ) const
void btDiscreteDynamicsWorld_getGravity(void *c,float* ret) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getGravity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: removeAction void ( ::btDiscreteDynamicsWorld::* )( ::btActionInterface * ) 
void btDiscreteDynamicsWorld_removeAction(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	o->removeAction(tp0);
}
//method: removeCharacter void ( ::btDiscreteDynamicsWorld::* )( ::btActionInterface * ) 
void btDiscreteDynamicsWorld_removeCharacter(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	o->removeCharacter(tp0);
}
//method: saveKinematicState void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
void btDiscreteDynamicsWorld_saveKinematicState(void *c,float p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->saveKinematicState(p0);
}
//method: getConstraint ::btTypedConstraint * ( ::btDiscreteDynamicsWorld::* )( int ) 
void* btDiscreteDynamicsWorld_getConstraint(void *c,int p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	void* retVal = (void*) o->getConstraint(p0);
	return retVal;
}
//method: getConstraint ::btTypedConstraint * ( ::btDiscreteDynamicsWorld::* )( int ) 
void* btDiscreteDynamicsWorld_getConstraint0(void *c,int p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	void* retVal = (void*) o->getConstraint(p0);
	return retVal;
}
//method: getConstraint ::btTypedConstraint const * ( ::btDiscreteDynamicsWorld::* )( int ) const
void* btDiscreteDynamicsWorld_getConstraint1(void *c,int p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	void* retVal = (void*) o->getConstraint(p0);
	return retVal;
}
//method: getConstraintSolver ::btConstraintSolver * ( ::btDiscreteDynamicsWorld::* )(  ) 
void* btDiscreteDynamicsWorld_getConstraintSolver(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	void* retVal = (void*) o->getConstraintSolver();
	return retVal;
}
//not supported method: getSimulationIslandManager ::btSimulationIslandManager * ( ::btDiscreteDynamicsWorld::* )(  ) 
// error:  - unsupported

//not supported method: getSimulationIslandManager ::btSimulationIslandManager * ( ::btDiscreteDynamicsWorld::* )(  ) 
// error:  - unsupported

//not supported method: getSimulationIslandManager ::btSimulationIslandManager const * ( ::btDiscreteDynamicsWorld::* )(  ) const
// error:  - unsupported

//method: addCharacter void ( ::btDiscreteDynamicsWorld::* )( ::btActionInterface * ) 
void btDiscreteDynamicsWorld_addCharacter(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	o->addCharacter(tp0);
}
//method: solveConstraints void ( ::btDiscreteDynamicsWorld::* )( ::btContactSolverInfo & ) 
void btDiscreteDynamicsWorld_solveConstraints(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btContactSolverInfo & tp0 = *(::btContactSolverInfo *)p0;
	o->solveConstraints(tp0);
}
//not supported method: getWorldType ::btDynamicsWorldType ( ::btDiscreteDynamicsWorld::* )(  ) const
// error:  - unsupported

//method: updateActions void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
void btDiscreteDynamicsWorld_updateActions(void *c,float p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->updateActions(p0);
}
//method: updateVehicles void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
void btDiscreteDynamicsWorld_updateVehicles(void *c,float p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->updateVehicles(p0);
}
//method: synchronizeSingleMotionState void ( ::btDiscreteDynamicsWorld::* )( ::btRigidBody * ) 
void btDiscreteDynamicsWorld_synchronizeSingleMotionState(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btRigidBody * tp0 = (::btRigidBody *)p0;
	o->synchronizeSingleMotionState(tp0);
}
//method: addVehicle void ( ::btDiscreteDynamicsWorld::* )( ::btActionInterface * ) 
void btDiscreteDynamicsWorld_addVehicle(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	o->addVehicle(tp0);
}
//method: synchronizeMotionStates void ( ::btDiscreteDynamicsWorld::* )(  ) 
void btDiscreteDynamicsWorld_synchronizeMotionStates(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->synchronizeMotionStates();
}
//method: stepSimulation int ( ::btDiscreteDynamicsWorld::* )( ::btScalar,int,::btScalar ) 
int btDiscreteDynamicsWorld_stepSimulation(void *c,float p0,int p1,float p2) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	int retVal = (int)o->stepSimulation(p0,p1,p2);
	return retVal;
}
//method: removeCollisionObject void ( ::btDiscreteDynamicsWorld::* )( ::btCollisionObject * ) 
void btDiscreteDynamicsWorld_removeCollisionObject(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	o->removeCollisionObject(tp0);
}
//method: setConstraintSolver void ( ::btDiscreteDynamicsWorld::* )( ::btConstraintSolver * ) 
void btDiscreteDynamicsWorld_setConstraintSolver(void *c,void* p0) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btConstraintSolver * tp0 = (::btConstraintSolver *)p0;
	o->setConstraintSolver(tp0);
}
//attribute: ::btConstraintSolver * btDiscreteDynamicsWorld->m_constraintSolver
void btDiscreteDynamicsWorld_m_constraintSolver_set(void *c,void* a) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btConstraintSolver * ta = (::btConstraintSolver *)a;
	o->m_constraintSolver = ta;
}
void* btDiscreteDynamicsWorld_m_constraintSolver_get(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	return (void*)(o->m_constraintSolver);
}

//attribute: ::btSimulationIslandManager * btDiscreteDynamicsWorld->m_islandManager
// attribute not supported: //attribute: ::btSimulationIslandManager * btDiscreteDynamicsWorld->m_islandManager
//attribute: ::btAlignedObjectArray<btTypedConstraint*> btDiscreteDynamicsWorld->m_constraints
void btDiscreteDynamicsWorld_m_constraints_set(void *c,void* a) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btAlignedObjectArray<btTypedConstraint*> & ta = *(::btAlignedObjectArray<btTypedConstraint*> *)a;
	o->m_constraints = ta;
}
void* btDiscreteDynamicsWorld_m_constraints_get(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	return (void*)&(o->m_constraints);
}

//attribute: ::btAlignedObjectArray<btRigidBody*> btDiscreteDynamicsWorld->m_nonStaticRigidBodies
void btDiscreteDynamicsWorld_m_nonStaticRigidBodies_set(void *c,void* a) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btAlignedObjectArray<btRigidBody*> & ta = *(::btAlignedObjectArray<btRigidBody*> *)a;
	o->m_nonStaticRigidBodies = ta;
}
void* btDiscreteDynamicsWorld_m_nonStaticRigidBodies_get(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	return (void*)&(o->m_nonStaticRigidBodies);
}

//attribute: ::btVector3 btDiscreteDynamicsWorld->m_gravity
void btDiscreteDynamicsWorld_m_gravity_set(void *c,float* a) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_gravity = ta;
}
void btDiscreteDynamicsWorld_m_gravity_get(void *c,float* a) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	a[0]=(o->m_gravity).m_floats[0];a[1]=(o->m_gravity).m_floats[1];a[2]=(o->m_gravity).m_floats[2];
}

//attribute: ::btScalar btDiscreteDynamicsWorld->m_localTime
void btDiscreteDynamicsWorld_m_localTime_set(void *c,float a) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->m_localTime = a;
}
float btDiscreteDynamicsWorld_m_localTime_get(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	return (float)(o->m_localTime);
}

//attribute: bool btDiscreteDynamicsWorld->m_ownsIslandManager
void btDiscreteDynamicsWorld_m_ownsIslandManager_set(void *c,int a) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->m_ownsIslandManager = a;
}
int btDiscreteDynamicsWorld_m_ownsIslandManager_get(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	return (int)(o->m_ownsIslandManager);
}

//attribute: bool btDiscreteDynamicsWorld->m_ownsConstraintSolver
void btDiscreteDynamicsWorld_m_ownsConstraintSolver_set(void *c,int a) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->m_ownsConstraintSolver = a;
}
int btDiscreteDynamicsWorld_m_ownsConstraintSolver_get(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	return (int)(o->m_ownsConstraintSolver);
}

//attribute: bool btDiscreteDynamicsWorld->m_synchronizeAllMotionStates
void btDiscreteDynamicsWorld_m_synchronizeAllMotionStates_set(void *c,int a) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->m_synchronizeAllMotionStates = a;
}
int btDiscreteDynamicsWorld_m_synchronizeAllMotionStates_get(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	return (int)(o->m_synchronizeAllMotionStates);
}

//attribute: ::btAlignedObjectArray<btActionInterface*> btDiscreteDynamicsWorld->m_actions
void btDiscreteDynamicsWorld_m_actions_set(void *c,void* a) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	::btAlignedObjectArray<btActionInterface*> & ta = *(::btAlignedObjectArray<btActionInterface*> *)a;
	o->m_actions = ta;
}
void* btDiscreteDynamicsWorld_m_actions_get(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	return (void*)&(o->m_actions);
}

//attribute: int btDiscreteDynamicsWorld->m_profileTimings
void btDiscreteDynamicsWorld_m_profileTimings_set(void *c,int a) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	o->m_profileTimings = a;
}
int btDiscreteDynamicsWorld_m_profileTimings_get(void *c) {
	::btDiscreteDynamicsWorld *o = (::btDiscreteDynamicsWorld*)c;
	return (int)(o->m_profileTimings);
}


// ::btDynamicsWorld
//method: setGravity void ( ::btDynamicsWorld::* )( ::btVector3 const & ) 
void btDynamicsWorld_setGravity(void *c,float* p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setGravity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: addAction void ( ::btDynamicsWorld::* )( ::btActionInterface * ) 
void btDynamicsWorld_addAction(void *c,void* p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	o->addAction(tp0);
}
//method: getSolverInfo ::btContactSolverInfo & ( ::btDynamicsWorld::* )(  ) 
void* btDynamicsWorld_getSolverInfo(void *c) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	void* retVal = (void*) &(o->getSolverInfo());
	return retVal;
}
//method: addRigidBody void ( ::btDynamicsWorld::* )( ::btRigidBody * ) 
void btDynamicsWorld_addRigidBody(void *c,void* p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	::btRigidBody * tp0 = (::btRigidBody *)p0;
	o->addRigidBody(tp0);
}
//method: addRigidBody void ( ::btDynamicsWorld::* )( ::btRigidBody * ) 
void btDynamicsWorld_addRigidBody0(void *c,void* p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	::btRigidBody * tp0 = (::btRigidBody *)p0;
	o->addRigidBody(tp0);
}
//method: addRigidBody void ( ::btDynamicsWorld::* )( ::btRigidBody *,short int,short int ) 
void btDynamicsWorld_addRigidBody1(void *c,void* p0,short int p1,short int p2) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	::btRigidBody * tp0 = (::btRigidBody *)p0;
	o->addRigidBody(tp0,p1,p2);
}
//method: clearForces void ( ::btDynamicsWorld::* )(  ) 
void btDynamicsWorld_clearForces(void *c) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	o->clearForces();
}
//method: removeVehicle void ( ::btDynamicsWorld::* )( ::btActionInterface * ) 
void btDynamicsWorld_removeVehicle(void *c,void* p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	o->removeVehicle(tp0);
}
//method: removeConstraint void ( ::btDynamicsWorld::* )( ::btTypedConstraint * ) 
void btDynamicsWorld_removeConstraint(void *c,void* p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	::btTypedConstraint * tp0 = (::btTypedConstraint *)p0;
	o->removeConstraint(tp0);
}
//method: getNumConstraints int ( ::btDynamicsWorld::* )(  ) const
int btDynamicsWorld_getNumConstraints(void *c) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	int retVal = (int)o->getNumConstraints();
	return retVal;
}
//method: removeRigidBody void ( ::btDynamicsWorld::* )( ::btRigidBody * ) 
void btDynamicsWorld_removeRigidBody(void *c,void* p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	::btRigidBody * tp0 = (::btRigidBody *)p0;
	o->removeRigidBody(tp0);
}
//not supported method: setInternalTickCallback void ( ::btDynamicsWorld::* )( ::btInternalTickCallback,void *,bool ) 
// error:  - unsupported, void * - ok, bool - ok, void - ok

//method: synchronizeMotionStates void ( ::btDynamicsWorld::* )(  ) 
void btDynamicsWorld_synchronizeMotionStates(void *c) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	o->synchronizeMotionStates();
}
//method: addConstraint void ( ::btDynamicsWorld::* )( ::btTypedConstraint *,bool ) 
void btDynamicsWorld_addConstraint(void *c,void* p0,int p1) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	::btTypedConstraint * tp0 = (::btTypedConstraint *)p0;
	o->addConstraint(tp0,p1);
}
//method: getGravity ::btVector3 ( ::btDynamicsWorld::* )(  ) const
void btDynamicsWorld_getGravity(void *c,float* ret) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getGravity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: debugDrawWorld void ( ::btDynamicsWorld::* )(  ) 
void btDynamicsWorld_debugDrawWorld(void *c) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	o->debugDrawWorld();
}
//method: removeAction void ( ::btDynamicsWorld::* )( ::btActionInterface * ) 
void btDynamicsWorld_removeAction(void *c,void* p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	o->removeAction(tp0);
}
//method: setWorldUserInfo void ( ::btDynamicsWorld::* )( void * ) 
void btDynamicsWorld_setWorldUserInfo(void *c,void* p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	void * tp0 = (void *)p0;
	o->setWorldUserInfo(tp0);
}
//method: removeCharacter void ( ::btDynamicsWorld::* )( ::btActionInterface * ) 
void btDynamicsWorld_removeCharacter(void *c,void* p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	o->removeCharacter(tp0);
}
//method: getConstraint ::btTypedConstraint * ( ::btDynamicsWorld::* )( int ) 
void* btDynamicsWorld_getConstraint(void *c,int p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	void* retVal = (void*) o->getConstraint(p0);
	return retVal;
}
//method: getConstraint ::btTypedConstraint * ( ::btDynamicsWorld::* )( int ) 
void* btDynamicsWorld_getConstraint0(void *c,int p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	void* retVal = (void*) o->getConstraint(p0);
	return retVal;
}
//method: getConstraint ::btTypedConstraint const * ( ::btDynamicsWorld::* )( int ) const
void* btDynamicsWorld_getConstraint1(void *c,int p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	void* retVal = (void*) o->getConstraint(p0);
	return retVal;
}
//method: getConstraintSolver ::btConstraintSolver * ( ::btDynamicsWorld::* )(  ) 
void* btDynamicsWorld_getConstraintSolver(void *c) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	void* retVal = (void*) o->getConstraintSolver();
	return retVal;
}
//method: stepSimulation int ( ::btDynamicsWorld::* )( ::btScalar,int,::btScalar ) 
int btDynamicsWorld_stepSimulation(void *c,float p0,int p1,float p2) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	int retVal = (int)o->stepSimulation(p0,p1,p2);
	return retVal;
}
//method: addCharacter void ( ::btDynamicsWorld::* )( ::btActionInterface * ) 
void btDynamicsWorld_addCharacter(void *c,void* p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	o->addCharacter(tp0);
}
//not supported method: getWorldType ::btDynamicsWorldType ( ::btDynamicsWorld::* )(  ) const
// error:  - unsupported

//method: addVehicle void ( ::btDynamicsWorld::* )( ::btActionInterface * ) 
void btDynamicsWorld_addVehicle(void *c,void* p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	o->addVehicle(tp0);
}
//method: getWorldUserInfo void * ( ::btDynamicsWorld::* )(  ) const
void* btDynamicsWorld_getWorldUserInfo(void *c) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	void* retVal = (void*) o->getWorldUserInfo();
	return retVal;
}
//method: setConstraintSolver void ( ::btDynamicsWorld::* )( ::btConstraintSolver * ) 
void btDynamicsWorld_setConstraintSolver(void *c,void* p0) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	::btConstraintSolver * tp0 = (::btConstraintSolver *)p0;
	o->setConstraintSolver(tp0);
}
//attribute: ::btInternalTickCallback btDynamicsWorld->m_internalTickCallback
// attribute not supported: //attribute: ::btInternalTickCallback btDynamicsWorld->m_internalTickCallback
//attribute: ::btInternalTickCallback btDynamicsWorld->m_internalPreTickCallback
// attribute not supported: //attribute: ::btInternalTickCallback btDynamicsWorld->m_internalPreTickCallback
//attribute: void * btDynamicsWorld->m_worldUserInfo
void btDynamicsWorld_m_worldUserInfo_set(void *c,void* a) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	void * ta = (void *)a;
	o->m_worldUserInfo = ta;
}
void* btDynamicsWorld_m_worldUserInfo_get(void *c) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	return (void*)(o->m_worldUserInfo);
}

//attribute: ::btContactSolverInfo btDynamicsWorld->m_solverInfo
void btDynamicsWorld_m_solverInfo_set(void *c,void* a) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	::btContactSolverInfo & ta = *(::btContactSolverInfo *)a;
	o->m_solverInfo = ta;
}
void* btDynamicsWorld_m_solverInfo_get(void *c) {
	::btDynamicsWorld *o = (::btDynamicsWorld*)c;
	return (void*)&(o->m_solverInfo);
}


// ::btRigidBody
//constructor: btRigidBody  ( ::btRigidBody::* )( ::btRigidBody::btRigidBodyConstructionInfo const & ) 
void* btRigidBody_new0(void* p0) {
	::btRigidBody *o = 0;
	 void *mem = 0;
	::btRigidBody::btRigidBodyConstructionInfo const & tp0 = *(::btRigidBody::btRigidBodyConstructionInfo const *)p0;
	mem = btAlignedAlloc(sizeof(::btRigidBody),16);
	o = new (mem)::btRigidBody(tp0);
	return (void*)o;
}
//constructor: btRigidBody  ( ::btRigidBody::* )( ::btScalar,::btMotionState *,::btCollisionShape *,::btVector3 const & ) 
void* btRigidBody_new1(float p0,void* p1,void* p2,float* p3) {
	::btRigidBody *o = 0;
	 void *mem = 0;
	::btMotionState * tp1 = (::btMotionState *)p1;
	::btCollisionShape * tp2 = (::btCollisionShape *)p2;
	btVector3 tp3(p3[0],p3[1],p3[2]);
	mem = btAlignedAlloc(sizeof(::btRigidBody),16);
	o = new (mem)::btRigidBody(p0,tp1,tp2,tp3);
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	return (void*)o;
}
void btRigidBody_free(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	delete o;
}
//method: setGravity void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_setGravity(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setGravity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: updateDeactivation void ( ::btRigidBody::* )( ::btScalar ) 
void btRigidBody_updateDeactivation(void *c,float p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->updateDeactivation(p0);
}
//method: setAngularFactor void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_setAngularFactor(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setAngularFactor(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: setAngularFactor void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_setAngularFactor0(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setAngularFactor(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: setAngularFactor void ( ::btRigidBody::* )( ::btScalar ) 
void btRigidBody_setAngularFactor1(void *c,float p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->setAngularFactor(p0);
}
//method: internalWritebackVelocity void ( ::btRigidBody::* )(  ) 
void btRigidBody_internalWritebackVelocity(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->internalWritebackVelocity();
}
//method: internalWritebackVelocity void ( ::btRigidBody::* )(  ) 
void btRigidBody_internalWritebackVelocity0(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->internalWritebackVelocity();
}
//method: internalWritebackVelocity void ( ::btRigidBody::* )( ::btScalar ) 
void btRigidBody_internalWritebackVelocity1(void *c,float p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->internalWritebackVelocity(p0);
}
//method: getPushVelocity ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getPushVelocity(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getPushVelocity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: internalGetDeltaAngularVelocity ::btVector3 & ( ::btRigidBody::* )(  ) 
void btRigidBody_internalGetDeltaAngularVelocity(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->internalGetDeltaAngularVelocity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: applyGravity void ( ::btRigidBody::* )(  ) 
void btRigidBody_applyGravity(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->applyGravity();
}
//method: serialize char const * ( ::btRigidBody::* )( void *,::btSerializer * ) const
char const * btRigidBody_serialize(void *c,void* p0,void* p1) {
	::btRigidBody *o = (::btRigidBody*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: getOrientation ::btQuaternion ( ::btRigidBody::* )(  ) const
void btRigidBody_getOrientation(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btQuaternion tret(ret[0],ret[1],ret[2],ret[3]);
	tret = o->getOrientation();
	ret[0]=tret.getX();ret[1]=tret.getY();ret[2]=tret.getZ();ret[3]=tret.getW();
}
//method: applyCentralForce void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_applyCentralForce(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->applyCentralForce(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//not supported method: internalApplyImpulse void ( ::btRigidBody::* )( ::btVector3 const &,::btVector3 const &,::btScalar const ) 
// error: ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported, void - ok

//method: setMotionState void ( ::btRigidBody::* )( ::btMotionState * ) 
void btRigidBody_setMotionState(void *c,void* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	::btMotionState * tp0 = (::btMotionState *)p0;
	o->setMotionState(tp0);
}
//method: clearForces void ( ::btRigidBody::* )(  ) 
void btRigidBody_clearForces(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->clearForces();
}
//method: getMotionState ::btMotionState * ( ::btRigidBody::* )(  ) 
void* btRigidBody_getMotionState(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	void* retVal = (void*) o->getMotionState();
	return retVal;
}
//method: getMotionState ::btMotionState * ( ::btRigidBody::* )(  ) 
void* btRigidBody_getMotionState0(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	void* retVal = (void*) o->getMotionState();
	return retVal;
}
//method: getMotionState ::btMotionState const * ( ::btRigidBody::* )(  ) const
void* btRigidBody_getMotionState1(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	void* retVal = (void*) o->getMotionState();
	return retVal;
}
//method: setDamping void ( ::btRigidBody::* )( ::btScalar,::btScalar ) 
void btRigidBody_setDamping(void *c,float p0,float p1) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->setDamping(p0,p1);
}
//method: applyImpulse void ( ::btRigidBody::* )( ::btVector3 const &,::btVector3 const & ) 
void btRigidBody_applyImpulse(void *c,float* p0,float* p1) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->applyImpulse(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: applyTorque void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_applyTorque(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->applyTorque(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: internalApplyPushImpulse void ( ::btRigidBody::* )( ::btVector3 const &,::btVector3 const &,::btScalar ) 
void btRigidBody_internalApplyPushImpulse(void *c,float* p0,float* p1,float p2) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->internalApplyPushImpulse(tp0,tp1,p2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: wantsSleeping bool ( ::btRigidBody::* )(  ) 
int btRigidBody_wantsSleeping(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	int retVal = (int)o->wantsSleeping();
	return retVal;
}
//method: setNewBroadphaseProxy void ( ::btRigidBody::* )( ::btBroadphaseProxy * ) 
void btRigidBody_setNewBroadphaseProxy(void *c,void* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	o->setNewBroadphaseProxy(tp0);
}
//method: getVelocityInLocalPoint ::btVector3 ( ::btRigidBody::* )( ::btVector3 const & ) const
void btRigidBody_getVelocityInLocalPoint(void *c,float* p0,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getVelocityInLocalPoint(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: calculateSerializeBufferSize int ( ::btRigidBody::* )(  ) const
int btRigidBody_calculateSerializeBufferSize(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: setAngularVelocity void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_setAngularVelocity(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setAngularVelocity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getLinearFactor ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getLinearFactor(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLinearFactor();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: predictIntegratedTransform void ( ::btRigidBody::* )( ::btScalar,::btTransform & ) 
void btRigidBody_predictIntegratedTransform(void *c,float p0,float* p1) {
	::btRigidBody *o = (::btRigidBody*)c;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->predictIntegratedTransform(p0,tp1);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: internalGetAngularFactor ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_internalGetAngularFactor(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->internalGetAngularFactor();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getAngularSleepingThreshold ::btScalar ( ::btRigidBody::* )(  ) const
float btRigidBody_getAngularSleepingThreshold(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	float retVal = (float)o->getAngularSleepingThreshold();
	return retVal;
}
//method: applyDamping void ( ::btRigidBody::* )( ::btScalar ) 
void btRigidBody_applyDamping(void *c,float p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->applyDamping(p0);
}
//method: saveKinematicState void ( ::btRigidBody::* )( ::btScalar ) 
void btRigidBody_saveKinematicState(void *c,float p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->saveKinematicState(p0);
}
//method: setSleepingThresholds void ( ::btRigidBody::* )( ::btScalar,::btScalar ) 
void btRigidBody_setSleepingThresholds(void *c,float p0,float p1) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->setSleepingThresholds(p0,p1);
}
//method: getAngularVelocity ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getAngularVelocity(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAngularVelocity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getLinearSleepingThreshold ::btScalar ( ::btRigidBody::* )(  ) const
float btRigidBody_getLinearSleepingThreshold(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	float retVal = (float)o->getLinearSleepingThreshold();
	return retVal;
}
//method: internalGetInvMass ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_internalGetInvMass(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->internalGetInvMass();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: applyTorqueImpulse void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_applyTorqueImpulse(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->applyTorqueImpulse(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: internalGetPushVelocity ::btVector3 & ( ::btRigidBody::* )(  ) 
void btRigidBody_internalGetPushVelocity(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->internalGetPushVelocity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: setLinearFactor void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_setLinearFactor(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLinearFactor(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: serializeSingleObject void ( ::btRigidBody::* )( ::btSerializer * ) const
void btRigidBody_serializeSingleObject(void *c,void* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	::btSerializer * tp0 = (::btSerializer *)p0;
	o->serializeSingleObject(tp0);
}
//method: getInvMass ::btScalar ( ::btRigidBody::* )(  ) const
float btRigidBody_getInvMass(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	float retVal = (float)o->getInvMass();
	return retVal;
}
//method: getTotalForce ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getTotalForce(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getTotalForce();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getCenterOfMassPosition ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getCenterOfMassPosition(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getCenterOfMassPosition();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getAabb void ( ::btRigidBody::* )( ::btVector3 &,::btVector3 & ) const
void btRigidBody_getAabb(void *c,float* p0,float* p1) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getAabb(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getBroadphaseProxy ::btBroadphaseProxy const * ( ::btRigidBody::* )(  ) const
void* btRigidBody_getBroadphaseProxy(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	void* retVal = (void*) o->getBroadphaseProxy();
	return retVal;
}
//method: getBroadphaseProxy ::btBroadphaseProxy const * ( ::btRigidBody::* )(  ) const
void* btRigidBody_getBroadphaseProxy0(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	void* retVal = (void*) o->getBroadphaseProxy();
	return retVal;
}
//method: getBroadphaseProxy ::btBroadphaseProxy * ( ::btRigidBody::* )(  ) 
void* btRigidBody_getBroadphaseProxy1(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	void* retVal = (void*) o->getBroadphaseProxy();
	return retVal;
}
//method: getCollisionShape ::btCollisionShape const * ( ::btRigidBody::* )(  ) const
void* btRigidBody_getCollisionShape(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	void* retVal = (void*) o->getCollisionShape();
	return retVal;
}
//method: getCollisionShape ::btCollisionShape const * ( ::btRigidBody::* )(  ) const
void* btRigidBody_getCollisionShape0(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	void* retVal = (void*) o->getCollisionShape();
	return retVal;
}
//method: getCollisionShape ::btCollisionShape * ( ::btRigidBody::* )(  ) 
void* btRigidBody_getCollisionShape1(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	void* retVal = (void*) o->getCollisionShape();
	return retVal;
}
//method: upcast ::btRigidBody const * (*)( ::btCollisionObject const * )
void* btRigidBody_upcast(void* p0) {
	::btCollisionObject const * tp0 = (::btCollisionObject const *)p0;
	void* retVal = (void*) ::btRigidBody::upcast(tp0);
	return retVal;
}
//method: upcast ::btRigidBody const * (*)( ::btCollisionObject const * )
void* btRigidBody_upcast0(void* p0) {
	::btCollisionObject const * tp0 = (::btCollisionObject const *)p0;
	void* retVal = (void*) ::btRigidBody::upcast(tp0);
	return retVal;
}
//method: upcast ::btRigidBody * (*)( ::btCollisionObject * )
void* btRigidBody_upcast1(void* p0) {
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	void* retVal = (void*) ::btRigidBody::upcast(tp0);
	return retVal;
}
//method: checkCollideWithOverride bool ( ::btRigidBody::* )( ::btCollisionObject * ) 
int btRigidBody_checkCollideWithOverride(void *c,void* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	int retVal = (int)o->checkCollideWithOverride(tp0);
	return retVal;
}
//method: translate void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_translate(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->translate(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: updateInertiaTensor void ( ::btRigidBody::* )(  ) 
void btRigidBody_updateInertiaTensor(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->updateInertiaTensor();
}
//method: applyForce void ( ::btRigidBody::* )( ::btVector3 const &,::btVector3 const & ) 
void btRigidBody_applyForce(void *c,float* p0,float* p1) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->applyForce(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: internalGetAngularVelocity void ( ::btRigidBody::* )( ::btVector3 & ) const
void btRigidBody_internalGetAngularVelocity(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->internalGetAngularVelocity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: setupRigidBody void ( ::btRigidBody::* )( ::btRigidBody::btRigidBodyConstructionInfo const & ) 
void btRigidBody_setupRigidBody(void *c,void* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	::btRigidBody::btRigidBodyConstructionInfo const & tp0 = *(::btRigidBody::btRigidBodyConstructionInfo const *)p0;
	o->setupRigidBody(tp0);
}
//method: applyCentralImpulse void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_applyCentralImpulse(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->applyCentralImpulse(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getTurnVelocity ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getTurnVelocity(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getTurnVelocity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getDeltaLinearVelocity ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getDeltaLinearVelocity(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getDeltaLinearVelocity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: integrateVelocities void ( ::btRigidBody::* )( ::btScalar ) 
void btRigidBody_integrateVelocities(void *c,float p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->integrateVelocities(p0);
}
//method: getGravity ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getGravity(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getGravity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: setMassProps void ( ::btRigidBody::* )( ::btScalar,::btVector3 const & ) 
void btRigidBody_setMassProps(void *c,float p0,float* p1) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->setMassProps(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: setCenterOfMassTransform void ( ::btRigidBody::* )( ::btTransform const & ) 
void btRigidBody_setCenterOfMassTransform(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	o->setCenterOfMassTransform(tp0);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//method: setFlags void ( ::btRigidBody::* )( int ) 
void btRigidBody_setFlags(void *c,int p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->setFlags(p0);
}
//method: addConstraintRef void ( ::btRigidBody::* )( ::btTypedConstraint * ) 
void btRigidBody_addConstraintRef(void *c,void* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	::btTypedConstraint * tp0 = (::btTypedConstraint *)p0;
	o->addConstraintRef(tp0);
}
//method: setLinearVelocity void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_setLinearVelocity(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLinearVelocity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: isInWorld bool ( ::btRigidBody::* )(  ) const
int btRigidBody_isInWorld(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	int retVal = (int)o->isInWorld();
	return retVal;
}
//method: getTotalTorque ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getTotalTorque(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getTotalTorque();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getNumConstraintRefs int ( ::btRigidBody::* )(  ) const
int btRigidBody_getNumConstraintRefs(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	int retVal = (int)o->getNumConstraintRefs();
	return retVal;
}
//method: computeAngularImpulseDenominator ::btScalar ( ::btRigidBody::* )( ::btVector3 const & ) const
float btRigidBody_computeAngularImpulseDenominator(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	float retVal = (float)o->computeAngularImpulseDenominator(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return retVal;
}
//method: getInvInertiaTensorWorld ::btMatrix3x3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getInvInertiaTensorWorld(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btMatrix3x3 tret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	tret = o->getInvInertiaTensorWorld();
	ret[0]=tret.getRow(0).m_floats[0];ret[1]=tret.getRow(0).m_floats[1];ret[2]=tret.getRow(0).m_floats[2];ret[3]=tret.getRow(1).m_floats[0];ret[4]=tret.getRow(1).m_floats[1];ret[5]=tret.getRow(1).m_floats[2];ret[6]=tret.getRow(2).m_floats[0];ret[7]=tret.getRow(2).m_floats[1];ret[8]=tret.getRow(2).m_floats[2];
}
//method: getDeltaAngularVelocity ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getDeltaAngularVelocity(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getDeltaAngularVelocity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: internalGetDeltaLinearVelocity ::btVector3 & ( ::btRigidBody::* )(  ) 
void btRigidBody_internalGetDeltaLinearVelocity(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->internalGetDeltaLinearVelocity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: computeImpulseDenominator ::btScalar ( ::btRigidBody::* )( ::btVector3 const &,::btVector3 const & ) const
float btRigidBody_computeImpulseDenominator(void *c,float* p0,float* p1) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	float retVal = (float)o->computeImpulseDenominator(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//method: getConstraintRef ::btTypedConstraint * ( ::btRigidBody::* )( int ) 
void* btRigidBody_getConstraintRef(void *c,int p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	void* retVal = (void*) o->getConstraintRef(p0);
	return retVal;
}
//method: getAngularDamping ::btScalar ( ::btRigidBody::* )(  ) const
float btRigidBody_getAngularDamping(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	float retVal = (float)o->getAngularDamping();
	return retVal;
}
//method: internalGetTurnVelocity ::btVector3 & ( ::btRigidBody::* )(  ) 
void btRigidBody_internalGetTurnVelocity(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->internalGetTurnVelocity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: proceedToTransform void ( ::btRigidBody::* )( ::btTransform const & ) 
void btRigidBody_proceedToTransform(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	o->proceedToTransform(tp0);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//method: setInvInertiaDiagLocal void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_setInvInertiaDiagLocal(void *c,float* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setInvInertiaDiagLocal(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getInvInertiaDiagLocal ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getInvInertiaDiagLocal(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getInvInertiaDiagLocal();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getCenterOfMassTransform ::btTransform const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getCenterOfMassTransform(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getCenterOfMassTransform();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: removeConstraintRef void ( ::btRigidBody::* )( ::btTypedConstraint * ) 
void btRigidBody_removeConstraintRef(void *c,void* p0) {
	::btRigidBody *o = (::btRigidBody*)c;
	::btTypedConstraint * tp0 = (::btTypedConstraint *)p0;
	o->removeConstraintRef(tp0);
}
//method: getAngularFactor ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getAngularFactor(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAngularFactor();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getLinearVelocity ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getLinearVelocity(void *c,float* ret) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLinearVelocity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getFlags int ( ::btRigidBody::* )(  ) const
int btRigidBody_getFlags(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	int retVal = (int)o->getFlags();
	return retVal;
}
//method: internalGetVelocityInLocalPointObsolete void ( ::btRigidBody::* )( ::btVector3 const &,::btVector3 & ) const
void btRigidBody_internalGetVelocityInLocalPointObsolete(void *c,float* p0,float* p1) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->internalGetVelocityInLocalPointObsolete(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getLinearDamping ::btScalar ( ::btRigidBody::* )(  ) const
float btRigidBody_getLinearDamping(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	float retVal = (float)o->getLinearDamping();
	return retVal;
}
//attribute: ::btScalar btRigidBody->m_additionalAngularDampingFactor
void btRigidBody_m_additionalAngularDampingFactor_set(void *c,float a) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->m_additionalAngularDampingFactor = a;
}
float btRigidBody_m_additionalAngularDampingFactor_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (float)(o->m_additionalAngularDampingFactor);
}

//attribute: ::btScalar btRigidBody->m_additionalAngularDampingThresholdSqr
void btRigidBody_m_additionalAngularDampingThresholdSqr_set(void *c,float a) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->m_additionalAngularDampingThresholdSqr = a;
}
float btRigidBody_m_additionalAngularDampingThresholdSqr_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (float)(o->m_additionalAngularDampingThresholdSqr);
}

//attribute: bool btRigidBody->m_additionalDamping
void btRigidBody_m_additionalDamping_set(void *c,int a) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->m_additionalDamping = a;
}
int btRigidBody_m_additionalDamping_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (int)(o->m_additionalDamping);
}

//attribute: ::btScalar btRigidBody->m_additionalDampingFactor
void btRigidBody_m_additionalDampingFactor_set(void *c,float a) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->m_additionalDampingFactor = a;
}
float btRigidBody_m_additionalDampingFactor_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (float)(o->m_additionalDampingFactor);
}

//attribute: ::btScalar btRigidBody->m_additionalLinearDampingThresholdSqr
void btRigidBody_m_additionalLinearDampingThresholdSqr_set(void *c,float a) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->m_additionalLinearDampingThresholdSqr = a;
}
float btRigidBody_m_additionalLinearDampingThresholdSqr_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (float)(o->m_additionalLinearDampingThresholdSqr);
}

//attribute: ::btScalar btRigidBody->m_angularDamping
void btRigidBody_m_angularDamping_set(void *c,float a) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->m_angularDamping = a;
}
float btRigidBody_m_angularDamping_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (float)(o->m_angularDamping);
}

//attribute: ::btVector3 btRigidBody->m_angularFactor
void btRigidBody_m_angularFactor_set(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_angularFactor = ta;
}
void btRigidBody_m_angularFactor_get(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	a[0]=(o->m_angularFactor).m_floats[0];a[1]=(o->m_angularFactor).m_floats[1];a[2]=(o->m_angularFactor).m_floats[2];
}

//attribute: ::btScalar btRigidBody->m_angularSleepingThreshold
void btRigidBody_m_angularSleepingThreshold_set(void *c,float a) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->m_angularSleepingThreshold = a;
}
float btRigidBody_m_angularSleepingThreshold_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (float)(o->m_angularSleepingThreshold);
}

//attribute: ::btVector3 btRigidBody->m_angularVelocity
void btRigidBody_m_angularVelocity_set(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_angularVelocity = ta;
}
void btRigidBody_m_angularVelocity_get(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	a[0]=(o->m_angularVelocity).m_floats[0];a[1]=(o->m_angularVelocity).m_floats[1];a[2]=(o->m_angularVelocity).m_floats[2];
}

//attribute: ::btAlignedObjectArray<btTypedConstraint*> btRigidBody->m_constraintRefs
void btRigidBody_m_constraintRefs_set(void *c,void* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	::btAlignedObjectArray<btTypedConstraint*> & ta = *(::btAlignedObjectArray<btTypedConstraint*> *)a;
	o->m_constraintRefs = ta;
}
void* btRigidBody_m_constraintRefs_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (void*)&(o->m_constraintRefs);
}

//attribute: int btRigidBody->m_contactSolverType
void btRigidBody_m_contactSolverType_set(void *c,int a) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->m_contactSolverType = a;
}
int btRigidBody_m_contactSolverType_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (int)(o->m_contactSolverType);
}

//attribute: int btRigidBody->m_debugBodyId
void btRigidBody_m_debugBodyId_set(void *c,int a) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->m_debugBodyId = a;
}
int btRigidBody_m_debugBodyId_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (int)(o->m_debugBodyId);
}

//attribute: ::btVector3 btRigidBody->m_deltaAngularVelocity
void btRigidBody_m_deltaAngularVelocity_set(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_deltaAngularVelocity = ta;
}
void btRigidBody_m_deltaAngularVelocity_get(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	a[0]=(o->m_deltaAngularVelocity).m_floats[0];a[1]=(o->m_deltaAngularVelocity).m_floats[1];a[2]=(o->m_deltaAngularVelocity).m_floats[2];
}

//attribute: ::btVector3 btRigidBody->m_deltaLinearVelocity
void btRigidBody_m_deltaLinearVelocity_set(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_deltaLinearVelocity = ta;
}
void btRigidBody_m_deltaLinearVelocity_get(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	a[0]=(o->m_deltaLinearVelocity).m_floats[0];a[1]=(o->m_deltaLinearVelocity).m_floats[1];a[2]=(o->m_deltaLinearVelocity).m_floats[2];
}

//attribute: int btRigidBody->m_frictionSolverType
void btRigidBody_m_frictionSolverType_set(void *c,int a) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->m_frictionSolverType = a;
}
int btRigidBody_m_frictionSolverType_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (int)(o->m_frictionSolverType);
}

//attribute: ::btVector3 btRigidBody->m_gravity
void btRigidBody_m_gravity_set(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_gravity = ta;
}
void btRigidBody_m_gravity_get(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	a[0]=(o->m_gravity).m_floats[0];a[1]=(o->m_gravity).m_floats[1];a[2]=(o->m_gravity).m_floats[2];
}

//attribute: ::btVector3 btRigidBody->m_gravity_acceleration
void btRigidBody_m_gravity_acceleration_set(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_gravity_acceleration = ta;
}
void btRigidBody_m_gravity_acceleration_get(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	a[0]=(o->m_gravity_acceleration).m_floats[0];a[1]=(o->m_gravity_acceleration).m_floats[1];a[2]=(o->m_gravity_acceleration).m_floats[2];
}

//attribute: ::btVector3 btRigidBody->m_invInertiaLocal
void btRigidBody_m_invInertiaLocal_set(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_invInertiaLocal = ta;
}
void btRigidBody_m_invInertiaLocal_get(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	a[0]=(o->m_invInertiaLocal).m_floats[0];a[1]=(o->m_invInertiaLocal).m_floats[1];a[2]=(o->m_invInertiaLocal).m_floats[2];
}

//attribute: ::btMatrix3x3 btRigidBody->m_invInertiaTensorWorld
void btRigidBody_m_invInertiaTensorWorld_set(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	btMatrix3x3 ta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	o->m_invInertiaTensorWorld = ta;
}
void btRigidBody_m_invInertiaTensorWorld_get(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	a[0]=(o->m_invInertiaTensorWorld).getRow(0).m_floats[0];a[1]=(o->m_invInertiaTensorWorld).getRow(0).m_floats[1];a[2]=(o->m_invInertiaTensorWorld).getRow(0).m_floats[2];a[3]=(o->m_invInertiaTensorWorld).getRow(1).m_floats[0];a[4]=(o->m_invInertiaTensorWorld).getRow(1).m_floats[1];a[5]=(o->m_invInertiaTensorWorld).getRow(1).m_floats[2];a[6]=(o->m_invInertiaTensorWorld).getRow(2).m_floats[0];a[7]=(o->m_invInertiaTensorWorld).getRow(2).m_floats[1];a[8]=(o->m_invInertiaTensorWorld).getRow(2).m_floats[2];
}

//attribute: ::btVector3 btRigidBody->m_invMass
void btRigidBody_m_invMass_set(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_invMass = ta;
}
void btRigidBody_m_invMass_get(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	a[0]=(o->m_invMass).m_floats[0];a[1]=(o->m_invMass).m_floats[1];a[2]=(o->m_invMass).m_floats[2];
}

//attribute: ::btScalar btRigidBody->m_inverseMass
void btRigidBody_m_inverseMass_set(void *c,float a) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->m_inverseMass = a;
}
float btRigidBody_m_inverseMass_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (float)(o->m_inverseMass);
}

//attribute: ::btScalar btRigidBody->m_linearDamping
void btRigidBody_m_linearDamping_set(void *c,float a) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->m_linearDamping = a;
}
float btRigidBody_m_linearDamping_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (float)(o->m_linearDamping);
}

//attribute: ::btVector3 btRigidBody->m_linearFactor
void btRigidBody_m_linearFactor_set(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_linearFactor = ta;
}
void btRigidBody_m_linearFactor_get(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	a[0]=(o->m_linearFactor).m_floats[0];a[1]=(o->m_linearFactor).m_floats[1];a[2]=(o->m_linearFactor).m_floats[2];
}

//attribute: ::btScalar btRigidBody->m_linearSleepingThreshold
void btRigidBody_m_linearSleepingThreshold_set(void *c,float a) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->m_linearSleepingThreshold = a;
}
float btRigidBody_m_linearSleepingThreshold_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (float)(o->m_linearSleepingThreshold);
}

//attribute: ::btVector3 btRigidBody->m_linearVelocity
void btRigidBody_m_linearVelocity_set(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_linearVelocity = ta;
}
void btRigidBody_m_linearVelocity_get(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	a[0]=(o->m_linearVelocity).m_floats[0];a[1]=(o->m_linearVelocity).m_floats[1];a[2]=(o->m_linearVelocity).m_floats[2];
}

//attribute: ::btMotionState * btRigidBody->m_optionalMotionState
void btRigidBody_m_optionalMotionState_set(void *c,void* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	::btMotionState * ta = (::btMotionState *)a;
	o->m_optionalMotionState = ta;
}
void* btRigidBody_m_optionalMotionState_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (void*)(o->m_optionalMotionState);
}

//attribute: ::btVector3 btRigidBody->m_pushVelocity
void btRigidBody_m_pushVelocity_set(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_pushVelocity = ta;
}
void btRigidBody_m_pushVelocity_get(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	a[0]=(o->m_pushVelocity).m_floats[0];a[1]=(o->m_pushVelocity).m_floats[1];a[2]=(o->m_pushVelocity).m_floats[2];
}

//attribute: int btRigidBody->m_rigidbodyFlags
void btRigidBody_m_rigidbodyFlags_set(void *c,int a) {
	::btRigidBody *o = (::btRigidBody*)c;
	o->m_rigidbodyFlags = a;
}
int btRigidBody_m_rigidbodyFlags_get(void *c) {
	::btRigidBody *o = (::btRigidBody*)c;
	return (int)(o->m_rigidbodyFlags);
}

//attribute: ::btVector3 btRigidBody->m_totalForce
void btRigidBody_m_totalForce_set(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_totalForce = ta;
}
void btRigidBody_m_totalForce_get(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	a[0]=(o->m_totalForce).m_floats[0];a[1]=(o->m_totalForce).m_floats[1];a[2]=(o->m_totalForce).m_floats[2];
}

//attribute: ::btVector3 btRigidBody->m_totalTorque
void btRigidBody_m_totalTorque_set(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_totalTorque = ta;
}
void btRigidBody_m_totalTorque_get(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	a[0]=(o->m_totalTorque).m_floats[0];a[1]=(o->m_totalTorque).m_floats[1];a[2]=(o->m_totalTorque).m_floats[2];
}

//attribute: ::btVector3 btRigidBody->m_turnVelocity
void btRigidBody_m_turnVelocity_set(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_turnVelocity = ta;
}
void btRigidBody_m_turnVelocity_get(void *c,float* a) {
	::btRigidBody *o = (::btRigidBody*)c;
	a[0]=(o->m_turnVelocity).m_floats[0];a[1]=(o->m_turnVelocity).m_floats[1];a[2]=(o->m_turnVelocity).m_floats[2];
}


// ::btRigidBody::btRigidBodyConstructionInfo
//constructor: btRigidBodyConstructionInfo  ( ::btRigidBody::btRigidBodyConstructionInfo::* )( ::btScalar,::btMotionState *,::btCollisionShape *,::btVector3 const & ) 
void* btRigidBody_btRigidBodyConstructionInfo_new(float p0,void* p1,void* p2,float* p3) {
	::btRigidBody::btRigidBodyConstructionInfo *o = 0;
	 void *mem = 0;
	::btMotionState * tp1 = (::btMotionState *)p1;
	::btCollisionShape * tp2 = (::btCollisionShape *)p2;
	btVector3 tp3(p3[0],p3[1],p3[2]);
	mem = btAlignedAlloc(sizeof(::btRigidBody::btRigidBodyConstructionInfo),16);
	o = new (mem)::btRigidBody::btRigidBodyConstructionInfo(p0,tp1,tp2,tp3);
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	return (void*)o;
}
void btRigidBody_btRigidBodyConstructionInfo_free(void *c) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	delete o;
}
//attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_additionalAngularDampingFactor
void btRigidBody_btRigidBodyConstructionInfo_m_additionalAngularDampingFactor_set(void *c,float a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	o->m_additionalAngularDampingFactor = a;
}
float btRigidBody_btRigidBodyConstructionInfo_m_additionalAngularDampingFactor_get(void *c) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	return (float)(o->m_additionalAngularDampingFactor);
}

//attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_additionalAngularDampingThresholdSqr
void btRigidBody_btRigidBodyConstructionInfo_m_additionalAngularDampingThresholdSqr_set(void *c,float a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	o->m_additionalAngularDampingThresholdSqr = a;
}
float btRigidBody_btRigidBodyConstructionInfo_m_additionalAngularDampingThresholdSqr_get(void *c) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	return (float)(o->m_additionalAngularDampingThresholdSqr);
}

//attribute: bool btRigidBody_btRigidBodyConstructionInfo->m_additionalDamping
void btRigidBody_btRigidBodyConstructionInfo_m_additionalDamping_set(void *c,int a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	o->m_additionalDamping = a;
}
int btRigidBody_btRigidBodyConstructionInfo_m_additionalDamping_get(void *c) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	return (int)(o->m_additionalDamping);
}

//attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_additionalDampingFactor
void btRigidBody_btRigidBodyConstructionInfo_m_additionalDampingFactor_set(void *c,float a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	o->m_additionalDampingFactor = a;
}
float btRigidBody_btRigidBodyConstructionInfo_m_additionalDampingFactor_get(void *c) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	return (float)(o->m_additionalDampingFactor);
}

//attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_additionalLinearDampingThresholdSqr
void btRigidBody_btRigidBodyConstructionInfo_m_additionalLinearDampingThresholdSqr_set(void *c,float a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	o->m_additionalLinearDampingThresholdSqr = a;
}
float btRigidBody_btRigidBodyConstructionInfo_m_additionalLinearDampingThresholdSqr_get(void *c) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	return (float)(o->m_additionalLinearDampingThresholdSqr);
}

//attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_angularDamping
void btRigidBody_btRigidBodyConstructionInfo_m_angularDamping_set(void *c,float a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	o->m_angularDamping = a;
}
float btRigidBody_btRigidBodyConstructionInfo_m_angularDamping_get(void *c) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	return (float)(o->m_angularDamping);
}

//attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_angularSleepingThreshold
void btRigidBody_btRigidBodyConstructionInfo_m_angularSleepingThreshold_set(void *c,float a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	o->m_angularSleepingThreshold = a;
}
float btRigidBody_btRigidBodyConstructionInfo_m_angularSleepingThreshold_get(void *c) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	return (float)(o->m_angularSleepingThreshold);
}

//attribute: ::btCollisionShape * btRigidBody_btRigidBodyConstructionInfo->m_collisionShape
void btRigidBody_btRigidBodyConstructionInfo_m_collisionShape_set(void *c,void* a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	::btCollisionShape * ta = (::btCollisionShape *)a;
	o->m_collisionShape = ta;
}
void* btRigidBody_btRigidBodyConstructionInfo_m_collisionShape_get(void *c) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	return (void*)(o->m_collisionShape);
}

//attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_friction
void btRigidBody_btRigidBodyConstructionInfo_m_friction_set(void *c,float a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	o->m_friction = a;
}
float btRigidBody_btRigidBodyConstructionInfo_m_friction_get(void *c) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	return (float)(o->m_friction);
}

//attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_linearDamping
void btRigidBody_btRigidBodyConstructionInfo_m_linearDamping_set(void *c,float a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	o->m_linearDamping = a;
}
float btRigidBody_btRigidBodyConstructionInfo_m_linearDamping_get(void *c) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	return (float)(o->m_linearDamping);
}

//attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_linearSleepingThreshold
void btRigidBody_btRigidBodyConstructionInfo_m_linearSleepingThreshold_set(void *c,float a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	o->m_linearSleepingThreshold = a;
}
float btRigidBody_btRigidBodyConstructionInfo_m_linearSleepingThreshold_get(void *c) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	return (float)(o->m_linearSleepingThreshold);
}

//attribute: ::btVector3 btRigidBody_btRigidBodyConstructionInfo->m_localInertia
void btRigidBody_btRigidBodyConstructionInfo_m_localInertia_set(void *c,float* a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localInertia = ta;
}
void btRigidBody_btRigidBodyConstructionInfo_m_localInertia_get(void *c,float* a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	a[0]=(o->m_localInertia).m_floats[0];a[1]=(o->m_localInertia).m_floats[1];a[2]=(o->m_localInertia).m_floats[2];
}

//attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_mass
void btRigidBody_btRigidBodyConstructionInfo_m_mass_set(void *c,float a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	o->m_mass = a;
}
float btRigidBody_btRigidBodyConstructionInfo_m_mass_get(void *c) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	return (float)(o->m_mass);
}

//attribute: ::btMotionState * btRigidBody_btRigidBodyConstructionInfo->m_motionState
void btRigidBody_btRigidBodyConstructionInfo_m_motionState_set(void *c,void* a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	::btMotionState * ta = (::btMotionState *)a;
	o->m_motionState = ta;
}
void* btRigidBody_btRigidBodyConstructionInfo_m_motionState_get(void *c) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	return (void*)(o->m_motionState);
}

//attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_restitution
void btRigidBody_btRigidBodyConstructionInfo_m_restitution_set(void *c,float a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	o->m_restitution = a;
}
float btRigidBody_btRigidBodyConstructionInfo_m_restitution_get(void *c) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	return (float)(o->m_restitution);
}

//attribute: ::btTransform btRigidBody_btRigidBodyConstructionInfo->m_startWorldTransform
void btRigidBody_btRigidBodyConstructionInfo_m_startWorldTransform_set(void *c,float* a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_startWorldTransform = ta;
}
void btRigidBody_btRigidBodyConstructionInfo_m_startWorldTransform_get(void *c,float* a) {
	::btRigidBody::btRigidBodyConstructionInfo *o = (::btRigidBody::btRigidBodyConstructionInfo*)c;
	a[0]=(o->m_startWorldTransform).getBasis().getRow(0).m_floats[0];a[1]=(o->m_startWorldTransform).getBasis().getRow(0).m_floats[1];a[2]=(o->m_startWorldTransform).getBasis().getRow(0).m_floats[2];a[3]=(o->m_startWorldTransform).getBasis().getRow(1).m_floats[0];a[4]=(o->m_startWorldTransform).getBasis().getRow(1).m_floats[1];a[5]=(o->m_startWorldTransform).getBasis().getRow(1).m_floats[2];a[6]=(o->m_startWorldTransform).getBasis().getRow(2).m_floats[0];a[7]=(o->m_startWorldTransform).getBasis().getRow(2).m_floats[1];a[8]=(o->m_startWorldTransform).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_startWorldTransform).getOrigin().m_floats[0];a[10]=(o->m_startWorldTransform).getOrigin().m_floats[1];a[11]=(o->m_startWorldTransform).getOrigin().m_floats[2];
}


// ::btRigidBodyDoubleData
//constructor: btRigidBodyDoubleData  ( ::btRigidBodyDoubleData::* )(  ) 
void* btRigidBodyDoubleData_new() {
	::btRigidBodyDoubleData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btRigidBodyDoubleData),16);
	o = new (mem)::btRigidBodyDoubleData();
	return (void*)o;
}
void btRigidBodyDoubleData_free(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	delete o;
}
//attribute: ::btCollisionObjectDoubleData btRigidBodyDoubleData->m_collisionObjectData
void btRigidBodyDoubleData_m_collisionObjectData_set(void *c,void* a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	::btCollisionObjectDoubleData & ta = *(::btCollisionObjectDoubleData *)a;
	o->m_collisionObjectData = ta;
}
void* btRigidBodyDoubleData_m_collisionObjectData_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (void*)&(o->m_collisionObjectData);
}

//attribute: ::btMatrix3x3DoubleData btRigidBodyDoubleData->m_invInertiaTensorWorld
void btRigidBodyDoubleData_m_invInertiaTensorWorld_set(void *c,void* a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	::btMatrix3x3DoubleData & ta = *(::btMatrix3x3DoubleData *)a;
	o->m_invInertiaTensorWorld = ta;
}
void* btRigidBodyDoubleData_m_invInertiaTensorWorld_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (void*)&(o->m_invInertiaTensorWorld);
}

//attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_linearVelocity
void btRigidBodyDoubleData_m_linearVelocity_set(void *c,void* a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_linearVelocity = ta;
}
void* btRigidBodyDoubleData_m_linearVelocity_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (void*)&(o->m_linearVelocity);
}

//attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_angularVelocity
void btRigidBodyDoubleData_m_angularVelocity_set(void *c,void* a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_angularVelocity = ta;
}
void* btRigidBodyDoubleData_m_angularVelocity_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (void*)&(o->m_angularVelocity);
}

//attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_angularFactor
void btRigidBodyDoubleData_m_angularFactor_set(void *c,void* a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_angularFactor = ta;
}
void* btRigidBodyDoubleData_m_angularFactor_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (void*)&(o->m_angularFactor);
}

//attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_linearFactor
void btRigidBodyDoubleData_m_linearFactor_set(void *c,void* a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_linearFactor = ta;
}
void* btRigidBodyDoubleData_m_linearFactor_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (void*)&(o->m_linearFactor);
}

//attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_gravity
void btRigidBodyDoubleData_m_gravity_set(void *c,void* a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_gravity = ta;
}
void* btRigidBodyDoubleData_m_gravity_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (void*)&(o->m_gravity);
}

//attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_gravity_acceleration
void btRigidBodyDoubleData_m_gravity_acceleration_set(void *c,void* a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_gravity_acceleration = ta;
}
void* btRigidBodyDoubleData_m_gravity_acceleration_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (void*)&(o->m_gravity_acceleration);
}

//attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_invInertiaLocal
void btRigidBodyDoubleData_m_invInertiaLocal_set(void *c,void* a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_invInertiaLocal = ta;
}
void* btRigidBodyDoubleData_m_invInertiaLocal_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (void*)&(o->m_invInertiaLocal);
}

//attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_totalForce
void btRigidBodyDoubleData_m_totalForce_set(void *c,void* a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_totalForce = ta;
}
void* btRigidBodyDoubleData_m_totalForce_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (void*)&(o->m_totalForce);
}

//attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_totalTorque
void btRigidBodyDoubleData_m_totalTorque_set(void *c,void* a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_totalTorque = ta;
}
void* btRigidBodyDoubleData_m_totalTorque_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (void*)&(o->m_totalTorque);
}

//attribute: double btRigidBodyDoubleData->m_inverseMass
void btRigidBodyDoubleData_m_inverseMass_set(void *c,double a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	o->m_inverseMass = a;
}
double btRigidBodyDoubleData_m_inverseMass_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (double)(o->m_inverseMass);
}

//attribute: double btRigidBodyDoubleData->m_linearDamping
void btRigidBodyDoubleData_m_linearDamping_set(void *c,double a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	o->m_linearDamping = a;
}
double btRigidBodyDoubleData_m_linearDamping_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (double)(o->m_linearDamping);
}

//attribute: double btRigidBodyDoubleData->m_angularDamping
void btRigidBodyDoubleData_m_angularDamping_set(void *c,double a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	o->m_angularDamping = a;
}
double btRigidBodyDoubleData_m_angularDamping_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (double)(o->m_angularDamping);
}

//attribute: double btRigidBodyDoubleData->m_additionalDampingFactor
void btRigidBodyDoubleData_m_additionalDampingFactor_set(void *c,double a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	o->m_additionalDampingFactor = a;
}
double btRigidBodyDoubleData_m_additionalDampingFactor_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (double)(o->m_additionalDampingFactor);
}

//attribute: double btRigidBodyDoubleData->m_additionalLinearDampingThresholdSqr
void btRigidBodyDoubleData_m_additionalLinearDampingThresholdSqr_set(void *c,double a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	o->m_additionalLinearDampingThresholdSqr = a;
}
double btRigidBodyDoubleData_m_additionalLinearDampingThresholdSqr_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (double)(o->m_additionalLinearDampingThresholdSqr);
}

//attribute: double btRigidBodyDoubleData->m_additionalAngularDampingThresholdSqr
void btRigidBodyDoubleData_m_additionalAngularDampingThresholdSqr_set(void *c,double a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	o->m_additionalAngularDampingThresholdSqr = a;
}
double btRigidBodyDoubleData_m_additionalAngularDampingThresholdSqr_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (double)(o->m_additionalAngularDampingThresholdSqr);
}

//attribute: double btRigidBodyDoubleData->m_additionalAngularDampingFactor
void btRigidBodyDoubleData_m_additionalAngularDampingFactor_set(void *c,double a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	o->m_additionalAngularDampingFactor = a;
}
double btRigidBodyDoubleData_m_additionalAngularDampingFactor_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (double)(o->m_additionalAngularDampingFactor);
}

//attribute: double btRigidBodyDoubleData->m_linearSleepingThreshold
void btRigidBodyDoubleData_m_linearSleepingThreshold_set(void *c,double a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	o->m_linearSleepingThreshold = a;
}
double btRigidBodyDoubleData_m_linearSleepingThreshold_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (double)(o->m_linearSleepingThreshold);
}

//attribute: double btRigidBodyDoubleData->m_angularSleepingThreshold
void btRigidBodyDoubleData_m_angularSleepingThreshold_set(void *c,double a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	o->m_angularSleepingThreshold = a;
}
double btRigidBodyDoubleData_m_angularSleepingThreshold_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (double)(o->m_angularSleepingThreshold);
}

//attribute: int btRigidBodyDoubleData->m_additionalDamping
void btRigidBodyDoubleData_m_additionalDamping_set(void *c,int a) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	o->m_additionalDamping = a;
}
int btRigidBodyDoubleData_m_additionalDamping_get(void *c) {
	::btRigidBodyDoubleData *o = (::btRigidBodyDoubleData*)c;
	return (int)(o->m_additionalDamping);
}

//attribute: char[4] btRigidBodyDoubleData->m_padding
// attribute not supported: //attribute: char[4] btRigidBodyDoubleData->m_padding

// ::btRigidBodyFloatData
//constructor: btRigidBodyFloatData  ( ::btRigidBodyFloatData::* )(  ) 
void* btRigidBodyFloatData_new() {
	::btRigidBodyFloatData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btRigidBodyFloatData),16);
	o = new (mem)::btRigidBodyFloatData();
	return (void*)o;
}
void btRigidBodyFloatData_free(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	delete o;
}
//attribute: float btRigidBodyFloatData->m_additionalAngularDampingFactor
void btRigidBodyFloatData_m_additionalAngularDampingFactor_set(void *c,float a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	o->m_additionalAngularDampingFactor = a;
}
float btRigidBodyFloatData_m_additionalAngularDampingFactor_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (float)(o->m_additionalAngularDampingFactor);
}

//attribute: float btRigidBodyFloatData->m_additionalAngularDampingThresholdSqr
void btRigidBodyFloatData_m_additionalAngularDampingThresholdSqr_set(void *c,float a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	o->m_additionalAngularDampingThresholdSqr = a;
}
float btRigidBodyFloatData_m_additionalAngularDampingThresholdSqr_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (float)(o->m_additionalAngularDampingThresholdSqr);
}

//attribute: int btRigidBodyFloatData->m_additionalDamping
void btRigidBodyFloatData_m_additionalDamping_set(void *c,int a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	o->m_additionalDamping = a;
}
int btRigidBodyFloatData_m_additionalDamping_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (int)(o->m_additionalDamping);
}

//attribute: float btRigidBodyFloatData->m_additionalDampingFactor
void btRigidBodyFloatData_m_additionalDampingFactor_set(void *c,float a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	o->m_additionalDampingFactor = a;
}
float btRigidBodyFloatData_m_additionalDampingFactor_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (float)(o->m_additionalDampingFactor);
}

//attribute: float btRigidBodyFloatData->m_additionalLinearDampingThresholdSqr
void btRigidBodyFloatData_m_additionalLinearDampingThresholdSqr_set(void *c,float a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	o->m_additionalLinearDampingThresholdSqr = a;
}
float btRigidBodyFloatData_m_additionalLinearDampingThresholdSqr_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (float)(o->m_additionalLinearDampingThresholdSqr);
}

//attribute: float btRigidBodyFloatData->m_angularDamping
void btRigidBodyFloatData_m_angularDamping_set(void *c,float a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	o->m_angularDamping = a;
}
float btRigidBodyFloatData_m_angularDamping_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (float)(o->m_angularDamping);
}

//attribute: ::btVector3FloatData btRigidBodyFloatData->m_angularFactor
void btRigidBodyFloatData_m_angularFactor_set(void *c,void* a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_angularFactor = ta;
}
void* btRigidBodyFloatData_m_angularFactor_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (void*)&(o->m_angularFactor);
}

//attribute: float btRigidBodyFloatData->m_angularSleepingThreshold
void btRigidBodyFloatData_m_angularSleepingThreshold_set(void *c,float a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	o->m_angularSleepingThreshold = a;
}
float btRigidBodyFloatData_m_angularSleepingThreshold_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (float)(o->m_angularSleepingThreshold);
}

//attribute: ::btVector3FloatData btRigidBodyFloatData->m_angularVelocity
void btRigidBodyFloatData_m_angularVelocity_set(void *c,void* a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_angularVelocity = ta;
}
void* btRigidBodyFloatData_m_angularVelocity_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (void*)&(o->m_angularVelocity);
}

//attribute: ::btCollisionObjectFloatData btRigidBodyFloatData->m_collisionObjectData
void btRigidBodyFloatData_m_collisionObjectData_set(void *c,void* a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	::btCollisionObjectFloatData & ta = *(::btCollisionObjectFloatData *)a;
	o->m_collisionObjectData = ta;
}
void* btRigidBodyFloatData_m_collisionObjectData_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (void*)&(o->m_collisionObjectData);
}

//attribute: ::btVector3FloatData btRigidBodyFloatData->m_gravity
void btRigidBodyFloatData_m_gravity_set(void *c,void* a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_gravity = ta;
}
void* btRigidBodyFloatData_m_gravity_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (void*)&(o->m_gravity);
}

//attribute: ::btVector3FloatData btRigidBodyFloatData->m_gravity_acceleration
void btRigidBodyFloatData_m_gravity_acceleration_set(void *c,void* a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_gravity_acceleration = ta;
}
void* btRigidBodyFloatData_m_gravity_acceleration_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (void*)&(o->m_gravity_acceleration);
}

//attribute: ::btVector3FloatData btRigidBodyFloatData->m_invInertiaLocal
void btRigidBodyFloatData_m_invInertiaLocal_set(void *c,void* a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_invInertiaLocal = ta;
}
void* btRigidBodyFloatData_m_invInertiaLocal_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (void*)&(o->m_invInertiaLocal);
}

//attribute: ::btMatrix3x3FloatData btRigidBodyFloatData->m_invInertiaTensorWorld
void btRigidBodyFloatData_m_invInertiaTensorWorld_set(void *c,void* a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	::btMatrix3x3FloatData & ta = *(::btMatrix3x3FloatData *)a;
	o->m_invInertiaTensorWorld = ta;
}
void* btRigidBodyFloatData_m_invInertiaTensorWorld_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (void*)&(o->m_invInertiaTensorWorld);
}

//attribute: float btRigidBodyFloatData->m_inverseMass
void btRigidBodyFloatData_m_inverseMass_set(void *c,float a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	o->m_inverseMass = a;
}
float btRigidBodyFloatData_m_inverseMass_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (float)(o->m_inverseMass);
}

//attribute: float btRigidBodyFloatData->m_linearDamping
void btRigidBodyFloatData_m_linearDamping_set(void *c,float a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	o->m_linearDamping = a;
}
float btRigidBodyFloatData_m_linearDamping_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (float)(o->m_linearDamping);
}

//attribute: ::btVector3FloatData btRigidBodyFloatData->m_linearFactor
void btRigidBodyFloatData_m_linearFactor_set(void *c,void* a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_linearFactor = ta;
}
void* btRigidBodyFloatData_m_linearFactor_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (void*)&(o->m_linearFactor);
}

//attribute: float btRigidBodyFloatData->m_linearSleepingThreshold
void btRigidBodyFloatData_m_linearSleepingThreshold_set(void *c,float a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	o->m_linearSleepingThreshold = a;
}
float btRigidBodyFloatData_m_linearSleepingThreshold_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (float)(o->m_linearSleepingThreshold);
}

//attribute: ::btVector3FloatData btRigidBodyFloatData->m_linearVelocity
void btRigidBodyFloatData_m_linearVelocity_set(void *c,void* a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_linearVelocity = ta;
}
void* btRigidBodyFloatData_m_linearVelocity_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (void*)&(o->m_linearVelocity);
}

//attribute: ::btVector3FloatData btRigidBodyFloatData->m_totalForce
void btRigidBodyFloatData_m_totalForce_set(void *c,void* a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_totalForce = ta;
}
void* btRigidBodyFloatData_m_totalForce_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (void*)&(o->m_totalForce);
}

//attribute: ::btVector3FloatData btRigidBodyFloatData->m_totalTorque
void btRigidBodyFloatData_m_totalTorque_set(void *c,void* a) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_totalTorque = ta;
}
void* btRigidBodyFloatData_m_totalTorque_get(void *c) {
	::btRigidBodyFloatData *o = (::btRigidBodyFloatData*)c;
	return (void*)&(o->m_totalTorque);
}


// ::btSimpleDynamicsWorld
//constructor: btSimpleDynamicsWorld  ( ::btSimpleDynamicsWorld::* )( ::btDispatcher *,::btBroadphaseInterface *,::btConstraintSolver *,::btCollisionConfiguration * ) 
void* btSimpleDynamicsWorld_new(void* p0,void* p1,void* p2,void* p3) {
	::btSimpleDynamicsWorld *o = 0;
	 void *mem = 0;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	::btBroadphaseInterface * tp1 = (::btBroadphaseInterface *)p1;
	::btConstraintSolver * tp2 = (::btConstraintSolver *)p2;
	::btCollisionConfiguration * tp3 = (::btCollisionConfiguration *)p3;
	mem = btAlignedAlloc(sizeof(::btSimpleDynamicsWorld),16);
	o = new (mem)::btSimpleDynamicsWorld(tp0,tp1,tp2,tp3);
	return (void*)o;
}
void btSimpleDynamicsWorld_free(void *c) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	delete o;
}
//method: predictUnconstraintMotion void ( ::btSimpleDynamicsWorld::* )( ::btScalar ) 
void btSimpleDynamicsWorld_predictUnconstraintMotion(void *c,float p0) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	o->predictUnconstraintMotion(p0);
}
//method: setGravity void ( ::btSimpleDynamicsWorld::* )( ::btVector3 const & ) 
void btSimpleDynamicsWorld_setGravity(void *c,float* p0) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setGravity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: addAction void ( ::btSimpleDynamicsWorld::* )( ::btActionInterface * ) 
void btSimpleDynamicsWorld_addAction(void *c,void* p0) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	o->addAction(tp0);
}
//method: synchronizeMotionStates void ( ::btSimpleDynamicsWorld::* )(  ) 
void btSimpleDynamicsWorld_synchronizeMotionStates(void *c) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	o->synchronizeMotionStates();
}
//method: setConstraintSolver void ( ::btSimpleDynamicsWorld::* )( ::btConstraintSolver * ) 
void btSimpleDynamicsWorld_setConstraintSolver(void *c,void* p0) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	::btConstraintSolver * tp0 = (::btConstraintSolver *)p0;
	o->setConstraintSolver(tp0);
}
//method: stepSimulation int ( ::btSimpleDynamicsWorld::* )( ::btScalar,int,::btScalar ) 
int btSimpleDynamicsWorld_stepSimulation(void *c,float p0,int p1,float p2) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	int retVal = (int)o->stepSimulation(p0,p1,p2);
	return retVal;
}
//method: getConstraintSolver ::btConstraintSolver * ( ::btSimpleDynamicsWorld::* )(  ) 
void* btSimpleDynamicsWorld_getConstraintSolver(void *c) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	void* retVal = (void*) o->getConstraintSolver();
	return retVal;
}
//not supported method: getWorldType ::btDynamicsWorldType ( ::btSimpleDynamicsWorld::* )(  ) const
// error:  - unsupported

//method: removeRigidBody void ( ::btSimpleDynamicsWorld::* )( ::btRigidBody * ) 
void btSimpleDynamicsWorld_removeRigidBody(void *c,void* p0) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	::btRigidBody * tp0 = (::btRigidBody *)p0;
	o->removeRigidBody(tp0);
}
//method: addRigidBody void ( ::btSimpleDynamicsWorld::* )( ::btRigidBody * ) 
void btSimpleDynamicsWorld_addRigidBody(void *c,void* p0) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	::btRigidBody * tp0 = (::btRigidBody *)p0;
	o->addRigidBody(tp0);
}
//method: addRigidBody void ( ::btSimpleDynamicsWorld::* )( ::btRigidBody * ) 
void btSimpleDynamicsWorld_addRigidBody0(void *c,void* p0) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	::btRigidBody * tp0 = (::btRigidBody *)p0;
	o->addRigidBody(tp0);
}
//method: addRigidBody void ( ::btSimpleDynamicsWorld::* )( ::btRigidBody *,short int,short int ) 
void btSimpleDynamicsWorld_addRigidBody1(void *c,void* p0,short int p1,short int p2) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	::btRigidBody * tp0 = (::btRigidBody *)p0;
	o->addRigidBody(tp0,p1,p2);
}
//method: getGravity ::btVector3 ( ::btSimpleDynamicsWorld::* )(  ) const
void btSimpleDynamicsWorld_getGravity(void *c,float* ret) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getGravity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: integrateTransforms void ( ::btSimpleDynamicsWorld::* )( ::btScalar ) 
void btSimpleDynamicsWorld_integrateTransforms(void *c,float p0) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	o->integrateTransforms(p0);
}
//method: removeCollisionObject void ( ::btSimpleDynamicsWorld::* )( ::btCollisionObject * ) 
void btSimpleDynamicsWorld_removeCollisionObject(void *c,void* p0) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	o->removeCollisionObject(tp0);
}
//method: clearForces void ( ::btSimpleDynamicsWorld::* )(  ) 
void btSimpleDynamicsWorld_clearForces(void *c) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	o->clearForces();
}
//method: removeAction void ( ::btSimpleDynamicsWorld::* )( ::btActionInterface * ) 
void btSimpleDynamicsWorld_removeAction(void *c,void* p0) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	::btActionInterface * tp0 = (::btActionInterface *)p0;
	o->removeAction(tp0);
}
//method: updateAabbs void ( ::btSimpleDynamicsWorld::* )(  ) 
void btSimpleDynamicsWorld_updateAabbs(void *c) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	o->updateAabbs();
}
//method: debugDrawWorld void ( ::btSimpleDynamicsWorld::* )(  ) 
void btSimpleDynamicsWorld_debugDrawWorld(void *c) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	o->debugDrawWorld();
}
//attribute: ::btConstraintSolver * btSimpleDynamicsWorld->m_constraintSolver
void btSimpleDynamicsWorld_m_constraintSolver_set(void *c,void* a) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	::btConstraintSolver * ta = (::btConstraintSolver *)a;
	o->m_constraintSolver = ta;
}
void* btSimpleDynamicsWorld_m_constraintSolver_get(void *c) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	return (void*)(o->m_constraintSolver);
}

//attribute: bool btSimpleDynamicsWorld->m_ownsConstraintSolver
void btSimpleDynamicsWorld_m_ownsConstraintSolver_set(void *c,int a) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	o->m_ownsConstraintSolver = a;
}
int btSimpleDynamicsWorld_m_ownsConstraintSolver_get(void *c) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	return (int)(o->m_ownsConstraintSolver);
}

//attribute: ::btVector3 btSimpleDynamicsWorld->m_gravity
void btSimpleDynamicsWorld_m_gravity_set(void *c,float* a) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_gravity = ta;
}
void btSimpleDynamicsWorld_m_gravity_get(void *c,float* a) {
	::btSimpleDynamicsWorld *o = (::btSimpleDynamicsWorld*)c;
	a[0]=(o->m_gravity).m_floats[0];a[1]=(o->m_gravity).m_floats[1];a[2]=(o->m_gravity).m_floats[2];
}


// ::btWheelInfo::RaycastInfo
//constructor: RaycastInfo  ( ::btWheelInfo::RaycastInfo::* )(  ) 
void* btWheelInfo_RaycastInfo_new() {
	::btWheelInfo::RaycastInfo *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btWheelInfo::RaycastInfo),16);
	o = new (mem)::btWheelInfo::RaycastInfo();
	return (void*)o;
}
void btWheelInfo_RaycastInfo_free(void *c) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	delete o;
}
//attribute: ::btVector3 btWheelInfo_RaycastInfo->m_contactNormalWS
void btWheelInfo_RaycastInfo_m_contactNormalWS_set(void *c,float* a) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_contactNormalWS = ta;
}
void btWheelInfo_RaycastInfo_m_contactNormalWS_get(void *c,float* a) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	a[0]=(o->m_contactNormalWS).m_floats[0];a[1]=(o->m_contactNormalWS).m_floats[1];a[2]=(o->m_contactNormalWS).m_floats[2];
}

//attribute: ::btVector3 btWheelInfo_RaycastInfo->m_contactPointWS
void btWheelInfo_RaycastInfo_m_contactPointWS_set(void *c,float* a) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_contactPointWS = ta;
}
void btWheelInfo_RaycastInfo_m_contactPointWS_get(void *c,float* a) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	a[0]=(o->m_contactPointWS).m_floats[0];a[1]=(o->m_contactPointWS).m_floats[1];a[2]=(o->m_contactPointWS).m_floats[2];
}

//attribute: ::btScalar btWheelInfo_RaycastInfo->m_suspensionLength
void btWheelInfo_RaycastInfo_m_suspensionLength_set(void *c,float a) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	o->m_suspensionLength = a;
}
float btWheelInfo_RaycastInfo_m_suspensionLength_get(void *c) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	return (float)(o->m_suspensionLength);
}

//attribute: ::btVector3 btWheelInfo_RaycastInfo->m_hardPointWS
void btWheelInfo_RaycastInfo_m_hardPointWS_set(void *c,float* a) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_hardPointWS = ta;
}
void btWheelInfo_RaycastInfo_m_hardPointWS_get(void *c,float* a) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	a[0]=(o->m_hardPointWS).m_floats[0];a[1]=(o->m_hardPointWS).m_floats[1];a[2]=(o->m_hardPointWS).m_floats[2];
}

//attribute: ::btVector3 btWheelInfo_RaycastInfo->m_wheelDirectionWS
void btWheelInfo_RaycastInfo_m_wheelDirectionWS_set(void *c,float* a) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_wheelDirectionWS = ta;
}
void btWheelInfo_RaycastInfo_m_wheelDirectionWS_get(void *c,float* a) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	a[0]=(o->m_wheelDirectionWS).m_floats[0];a[1]=(o->m_wheelDirectionWS).m_floats[1];a[2]=(o->m_wheelDirectionWS).m_floats[2];
}

//attribute: ::btVector3 btWheelInfo_RaycastInfo->m_wheelAxleWS
void btWheelInfo_RaycastInfo_m_wheelAxleWS_set(void *c,float* a) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_wheelAxleWS = ta;
}
void btWheelInfo_RaycastInfo_m_wheelAxleWS_get(void *c,float* a) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	a[0]=(o->m_wheelAxleWS).m_floats[0];a[1]=(o->m_wheelAxleWS).m_floats[1];a[2]=(o->m_wheelAxleWS).m_floats[2];
}

//attribute: bool btWheelInfo_RaycastInfo->m_isInContact
void btWheelInfo_RaycastInfo_m_isInContact_set(void *c,int a) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	o->m_isInContact = a;
}
int btWheelInfo_RaycastInfo_m_isInContact_get(void *c) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	return (int)(o->m_isInContact);
}

//attribute: void * btWheelInfo_RaycastInfo->m_groundObject
void btWheelInfo_RaycastInfo_m_groundObject_set(void *c,void* a) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	void * ta = (void *)a;
	o->m_groundObject = ta;
}
void* btWheelInfo_RaycastInfo_m_groundObject_get(void *c) {
	::btWheelInfo::RaycastInfo *o = (::btWheelInfo::RaycastInfo*)c;
	return (void*)(o->m_groundObject);
}


// ::btDefaultVehicleRaycaster
//constructor: btDefaultVehicleRaycaster  ( ::btDefaultVehicleRaycaster::* )( ::btDynamicsWorld * ) 
void* btDefaultVehicleRaycaster_new(void* p0) {
	::btDefaultVehicleRaycaster *o = 0;
	 void *mem = 0;
	::btDynamicsWorld * tp0 = (::btDynamicsWorld *)p0;
	mem = btAlignedAlloc(sizeof(::btDefaultVehicleRaycaster),16);
	o = new (mem)::btDefaultVehicleRaycaster(tp0);
	return (void*)o;
}
void btDefaultVehicleRaycaster_free(void *c) {
	::btDefaultVehicleRaycaster *o = (::btDefaultVehicleRaycaster*)c;
	delete o;
}
//method: castRay void * ( ::btDefaultVehicleRaycaster::* )( ::btVector3 const &,::btVector3 const &,::btVehicleRaycaster::btVehicleRaycasterResult & ) 
void* btDefaultVehicleRaycaster_castRay(void *c,float* p0,float* p1,void* p2) {
	::btDefaultVehicleRaycaster *o = (::btDefaultVehicleRaycaster*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btVehicleRaycaster::btVehicleRaycasterResult & tp2 = *(::btVehicleRaycaster::btVehicleRaycasterResult *)p2;
	void* retVal = (void*) o->castRay(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//attribute: ::btDynamicsWorld * btDefaultVehicleRaycaster->m_dynamicsWorld
void btDefaultVehicleRaycaster_m_dynamicsWorld_set(void *c,void* a) {
	::btDefaultVehicleRaycaster *o = (::btDefaultVehicleRaycaster*)c;
	::btDynamicsWorld * ta = (::btDynamicsWorld *)a;
	o->m_dynamicsWorld = ta;
}
void* btDefaultVehicleRaycaster_m_dynamicsWorld_get(void *c) {
	::btDefaultVehicleRaycaster *o = (::btDefaultVehicleRaycaster*)c;
	return (void*)(o->m_dynamicsWorld);
}


// ::btRaycastVehicle
//constructor: btRaycastVehicle  ( ::btRaycastVehicle::* )( ::btRaycastVehicle::btVehicleTuning const &,::btRigidBody *,::btVehicleRaycaster * ) 
void* btRaycastVehicle_new(void* p0,void* p1,void* p2) {
	::btRaycastVehicle *o = 0;
	 void *mem = 0;
	::btRaycastVehicle::btVehicleTuning const & tp0 = *(::btRaycastVehicle::btVehicleTuning const *)p0;
	::btRigidBody * tp1 = (::btRigidBody *)p1;
	::btVehicleRaycaster * tp2 = (::btVehicleRaycaster *)p2;
	mem = btAlignedAlloc(sizeof(::btRaycastVehicle),16);
	o = new (mem)::btRaycastVehicle(tp0,tp1,tp2);
	return (void*)o;
}
void btRaycastVehicle_free(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	delete o;
}
//method: updateSuspension void ( ::btRaycastVehicle::* )( ::btScalar ) 
void btRaycastVehicle_updateSuspension(void *c,float p0) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->updateSuspension(p0);
}
//method: getRigidBody ::btRigidBody * ( ::btRaycastVehicle::* )(  ) 
void* btRaycastVehicle_getRigidBody(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	void* retVal = (void*) o->getRigidBody();
	return retVal;
}
//method: getRigidBody ::btRigidBody * ( ::btRaycastVehicle::* )(  ) 
void* btRaycastVehicle_getRigidBody0(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	void* retVal = (void*) o->getRigidBody();
	return retVal;
}
//method: getRigidBody ::btRigidBody const * ( ::btRaycastVehicle::* )(  ) const
void* btRaycastVehicle_getRigidBody1(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	void* retVal = (void*) o->getRigidBody();
	return retVal;
}
//method: getUserConstraintId int ( ::btRaycastVehicle::* )(  ) const
int btRaycastVehicle_getUserConstraintId(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	int retVal = (int)o->getUserConstraintId();
	return retVal;
}
//method: defaultInit void ( ::btRaycastVehicle::* )( ::btRaycastVehicle::btVehicleTuning const & ) 
void btRaycastVehicle_defaultInit(void *c,void* p0) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	::btRaycastVehicle::btVehicleTuning const & tp0 = *(::btRaycastVehicle::btVehicleTuning const *)p0;
	o->defaultInit(tp0);
}
//method: getWheelTransformWS ::btTransform const & ( ::btRaycastVehicle::* )( int ) const
void btRaycastVehicle_getWheelTransformWS(void *c,int p0,float* ret) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getWheelTransformWS(p0);
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: addWheel ::btWheelInfo & ( ::btRaycastVehicle::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar,::btScalar,::btRaycastVehicle::btVehicleTuning const &,bool ) 
void* btRaycastVehicle_addWheel(void *c,float* p0,float* p1,float* p2,float p3,float p4,void* p5,int p6) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	::btRaycastVehicle::btVehicleTuning const & tp5 = *(::btRaycastVehicle::btVehicleTuning const *)p5;
	void* retVal = (void*) &(o->addWheel(tp0,tp1,tp2,p3,p4,tp5,p6));
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	return retVal;
}
//method: updateWheelTransform void ( ::btRaycastVehicle::* )( int,bool ) 
void btRaycastVehicle_updateWheelTransform(void *c,int p0,int p1) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->updateWheelTransform(p0,p1);
}
//method: setUserConstraintId void ( ::btRaycastVehicle::* )( int ) 
void btRaycastVehicle_setUserConstraintId(void *c,int p0) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->setUserConstraintId(p0);
}
//method: getNumWheels int ( ::btRaycastVehicle::* )(  ) const
int btRaycastVehicle_getNumWheels(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	int retVal = (int)o->getNumWheels();
	return retVal;
}
//method: rayCast ::btScalar ( ::btRaycastVehicle::* )( ::btWheelInfo & ) 
float btRaycastVehicle_rayCast(void *c,void* p0) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	::btWheelInfo & tp0 = *(::btWheelInfo *)p0;
	float retVal = (float)o->rayCast(tp0);
	return retVal;
}
//method: getRightAxis int ( ::btRaycastVehicle::* )(  ) const
int btRaycastVehicle_getRightAxis(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	int retVal = (int)o->getRightAxis();
	return retVal;
}
//method: applyEngineForce void ( ::btRaycastVehicle::* )( ::btScalar,int ) 
void btRaycastVehicle_applyEngineForce(void *c,float p0,int p1) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->applyEngineForce(p0,p1);
}
//method: getForwardVector ::btVector3 ( ::btRaycastVehicle::* )(  ) const
void btRaycastVehicle_getForwardVector(void *c,float* ret) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getForwardVector();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getWheelInfo ::btWheelInfo const & ( ::btRaycastVehicle::* )( int ) const
void* btRaycastVehicle_getWheelInfo(void *c,int p0) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	void* retVal = (void*) &(o->getWheelInfo(p0));
	return retVal;
}
//method: getWheelInfo ::btWheelInfo const & ( ::btRaycastVehicle::* )( int ) const
void* btRaycastVehicle_getWheelInfo0(void *c,int p0) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	void* retVal = (void*) &(o->getWheelInfo(p0));
	return retVal;
}
//method: getWheelInfo ::btWheelInfo & ( ::btRaycastVehicle::* )( int ) 
void* btRaycastVehicle_getWheelInfo1(void *c,int p0) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	void* retVal = (void*) &(o->getWheelInfo(p0));
	return retVal;
}
//method: getChassisWorldTransform ::btTransform const & ( ::btRaycastVehicle::* )(  ) const
void btRaycastVehicle_getChassisWorldTransform(void *c,float* ret) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getChassisWorldTransform();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: updateWheelTransformsWS void ( ::btRaycastVehicle::* )( ::btWheelInfo &,bool ) 
void btRaycastVehicle_updateWheelTransformsWS(void *c,void* p0,int p1) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	::btWheelInfo & tp0 = *(::btWheelInfo *)p0;
	o->updateWheelTransformsWS(tp0,p1);
}
//method: resetSuspension void ( ::btRaycastVehicle::* )(  ) 
void btRaycastVehicle_resetSuspension(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->resetSuspension();
}
//method: setCoordinateSystem void ( ::btRaycastVehicle::* )( int,int,int ) 
void btRaycastVehicle_setCoordinateSystem(void *c,int p0,int p1,int p2) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->setCoordinateSystem(p0,p1,p2);
}
//method: setUserConstraintType void ( ::btRaycastVehicle::* )( int ) 
void btRaycastVehicle_setUserConstraintType(void *c,int p0) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->setUserConstraintType(p0);
}
//method: debugDraw void ( ::btRaycastVehicle::* )( ::btIDebugDraw * ) 
void btRaycastVehicle_debugDraw(void *c,void* p0) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	::btIDebugDraw * tp0 = (::btIDebugDraw *)p0;
	o->debugDraw(tp0);
}
//method: updateFriction void ( ::btRaycastVehicle::* )( ::btScalar ) 
void btRaycastVehicle_updateFriction(void *c,float p0) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->updateFriction(p0);
}
//method: getForwardAxis int ( ::btRaycastVehicle::* )(  ) const
int btRaycastVehicle_getForwardAxis(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	int retVal = (int)o->getForwardAxis();
	return retVal;
}
//method: getSteeringValue ::btScalar ( ::btRaycastVehicle::* )( int ) const
float btRaycastVehicle_getSteeringValue(void *c,int p0) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	float retVal = (float)o->getSteeringValue(p0);
	return retVal;
}
//method: getUserConstraintType int ( ::btRaycastVehicle::* )(  ) const
int btRaycastVehicle_getUserConstraintType(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	int retVal = (int)o->getUserConstraintType();
	return retVal;
}
//method: getUpAxis int ( ::btRaycastVehicle::* )(  ) const
int btRaycastVehicle_getUpAxis(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	int retVal = (int)o->getUpAxis();
	return retVal;
}
//method: setPitchControl void ( ::btRaycastVehicle::* )( ::btScalar ) 
void btRaycastVehicle_setPitchControl(void *c,float p0) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->setPitchControl(p0);
}
//method: getCurrentSpeedKmHour ::btScalar ( ::btRaycastVehicle::* )(  ) const
float btRaycastVehicle_getCurrentSpeedKmHour(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	float retVal = (float)o->getCurrentSpeedKmHour();
	return retVal;
}
//method: setBrake void ( ::btRaycastVehicle::* )( ::btScalar,int ) 
void btRaycastVehicle_setBrake(void *c,float p0,int p1) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->setBrake(p0,p1);
}
//method: setSteeringValue void ( ::btRaycastVehicle::* )( ::btScalar,int ) 
void btRaycastVehicle_setSteeringValue(void *c,float p0,int p1) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->setSteeringValue(p0,p1);
}
//method: updateVehicle void ( ::btRaycastVehicle::* )( ::btScalar ) 
void btRaycastVehicle_updateVehicle(void *c,float p0) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->updateVehicle(p0);
}
//method: updateAction void ( ::btRaycastVehicle::* )( ::btCollisionWorld *,::btScalar ) 
void btRaycastVehicle_updateAction(void *c,void* p0,float p1) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	::btCollisionWorld * tp0 = (::btCollisionWorld *)p0;
	o->updateAction(tp0,p1);
}
//attribute: ::btAlignedObjectArray<btVector3> btRaycastVehicle->m_forwardWS
void btRaycastVehicle_m_forwardWS_set(void *c,void* a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	::btAlignedObjectArray<btVector3> & ta = *(::btAlignedObjectArray<btVector3> *)a;
	o->m_forwardWS = ta;
}
void* btRaycastVehicle_m_forwardWS_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (void*)&(o->m_forwardWS);
}

//attribute: ::btAlignedObjectArray<btVector3> btRaycastVehicle->m_axle
void btRaycastVehicle_m_axle_set(void *c,void* a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	::btAlignedObjectArray<btVector3> & ta = *(::btAlignedObjectArray<btVector3> *)a;
	o->m_axle = ta;
}
void* btRaycastVehicle_m_axle_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (void*)&(o->m_axle);
}

//attribute: ::btAlignedObjectArray<float> btRaycastVehicle->m_forwardImpulse
void btRaycastVehicle_m_forwardImpulse_set(void *c,void* a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	::btAlignedObjectArray<float> & ta = *(::btAlignedObjectArray<float> *)a;
	o->m_forwardImpulse = ta;
}
void* btRaycastVehicle_m_forwardImpulse_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (void*)&(o->m_forwardImpulse);
}

//attribute: ::btAlignedObjectArray<float> btRaycastVehicle->m_sideImpulse
void btRaycastVehicle_m_sideImpulse_set(void *c,void* a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	::btAlignedObjectArray<float> & ta = *(::btAlignedObjectArray<float> *)a;
	o->m_sideImpulse = ta;
}
void* btRaycastVehicle_m_sideImpulse_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (void*)&(o->m_sideImpulse);
}

//attribute: int btRaycastVehicle->m_userConstraintType
void btRaycastVehicle_m_userConstraintType_set(void *c,int a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->m_userConstraintType = a;
}
int btRaycastVehicle_m_userConstraintType_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (int)(o->m_userConstraintType);
}

//attribute: int btRaycastVehicle->m_userConstraintId
void btRaycastVehicle_m_userConstraintId_set(void *c,int a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->m_userConstraintId = a;
}
int btRaycastVehicle_m_userConstraintId_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (int)(o->m_userConstraintId);
}

//attribute: ::btScalar btRaycastVehicle->m_tau
void btRaycastVehicle_m_tau_set(void *c,float a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->m_tau = a;
}
float btRaycastVehicle_m_tau_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (float)(o->m_tau);
}

//attribute: ::btScalar btRaycastVehicle->m_damping
void btRaycastVehicle_m_damping_set(void *c,float a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->m_damping = a;
}
float btRaycastVehicle_m_damping_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (float)(o->m_damping);
}

//attribute: ::btVehicleRaycaster * btRaycastVehicle->m_vehicleRaycaster
void btRaycastVehicle_m_vehicleRaycaster_set(void *c,void* a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	::btVehicleRaycaster * ta = (::btVehicleRaycaster *)a;
	o->m_vehicleRaycaster = ta;
}
void* btRaycastVehicle_m_vehicleRaycaster_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (void*)(o->m_vehicleRaycaster);
}

//attribute: ::btScalar btRaycastVehicle->m_pitchControl
void btRaycastVehicle_m_pitchControl_set(void *c,float a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->m_pitchControl = a;
}
float btRaycastVehicle_m_pitchControl_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (float)(o->m_pitchControl);
}

//attribute: ::btScalar btRaycastVehicle->m_steeringValue
void btRaycastVehicle_m_steeringValue_set(void *c,float a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->m_steeringValue = a;
}
float btRaycastVehicle_m_steeringValue_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (float)(o->m_steeringValue);
}

//attribute: ::btScalar btRaycastVehicle->m_currentVehicleSpeedKmHour
void btRaycastVehicle_m_currentVehicleSpeedKmHour_set(void *c,float a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->m_currentVehicleSpeedKmHour = a;
}
float btRaycastVehicle_m_currentVehicleSpeedKmHour_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (float)(o->m_currentVehicleSpeedKmHour);
}

//attribute: ::btRigidBody * btRaycastVehicle->m_chassisBody
void btRaycastVehicle_m_chassisBody_set(void *c,void* a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	::btRigidBody * ta = (::btRigidBody *)a;
	o->m_chassisBody = ta;
}
void* btRaycastVehicle_m_chassisBody_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (void*)(o->m_chassisBody);
}

//attribute: int btRaycastVehicle->m_indexRightAxis
void btRaycastVehicle_m_indexRightAxis_set(void *c,int a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->m_indexRightAxis = a;
}
int btRaycastVehicle_m_indexRightAxis_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (int)(o->m_indexRightAxis);
}

//attribute: int btRaycastVehicle->m_indexUpAxis
void btRaycastVehicle_m_indexUpAxis_set(void *c,int a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->m_indexUpAxis = a;
}
int btRaycastVehicle_m_indexUpAxis_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (int)(o->m_indexUpAxis);
}

//attribute: int btRaycastVehicle->m_indexForwardAxis
void btRaycastVehicle_m_indexForwardAxis_set(void *c,int a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	o->m_indexForwardAxis = a;
}
int btRaycastVehicle_m_indexForwardAxis_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (int)(o->m_indexForwardAxis);
}

//attribute: ::btAlignedObjectArray<btWheelInfo> btRaycastVehicle->m_wheelInfo
void btRaycastVehicle_m_wheelInfo_set(void *c,void* a) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	::btAlignedObjectArray<btWheelInfo> & ta = *(::btAlignedObjectArray<btWheelInfo> *)a;
	o->m_wheelInfo = ta;
}
void* btRaycastVehicle_m_wheelInfo_get(void *c) {
	::btRaycastVehicle *o = (::btRaycastVehicle*)c;
	return (void*)&(o->m_wheelInfo);
}


// ::btVehicleRaycaster
//method: castRay void * ( ::btVehicleRaycaster::* )( ::btVector3 const &,::btVector3 const &,::btVehicleRaycaster::btVehicleRaycasterResult & ) 
void* btVehicleRaycaster_castRay(void *c,float* p0,float* p1,void* p2) {
	::btVehicleRaycaster *o = (::btVehicleRaycaster*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btVehicleRaycaster::btVehicleRaycasterResult & tp2 = *(::btVehicleRaycaster::btVehicleRaycasterResult *)p2;
	void* retVal = (void*) o->castRay(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}

// ::btVehicleRaycaster::btVehicleRaycasterResult
//constructor: btVehicleRaycasterResult  ( ::btVehicleRaycaster::btVehicleRaycasterResult::* )(  ) 
void* btVehicleRaycaster_btVehicleRaycasterResult_new() {
	::btVehicleRaycaster::btVehicleRaycasterResult *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btVehicleRaycaster::btVehicleRaycasterResult),16);
	o = new (mem)::btVehicleRaycaster::btVehicleRaycasterResult();
	return (void*)o;
}
void btVehicleRaycaster_btVehicleRaycasterResult_free(void *c) {
	::btVehicleRaycaster::btVehicleRaycasterResult *o = (::btVehicleRaycaster::btVehicleRaycasterResult*)c;
	delete o;
}
//attribute: ::btScalar btVehicleRaycaster_btVehicleRaycasterResult->m_distFraction
void btVehicleRaycaster_btVehicleRaycasterResult_m_distFraction_set(void *c,float a) {
	::btVehicleRaycaster::btVehicleRaycasterResult *o = (::btVehicleRaycaster::btVehicleRaycasterResult*)c;
	o->m_distFraction = a;
}
float btVehicleRaycaster_btVehicleRaycasterResult_m_distFraction_get(void *c) {
	::btVehicleRaycaster::btVehicleRaycasterResult *o = (::btVehicleRaycaster::btVehicleRaycasterResult*)c;
	return (float)(o->m_distFraction);
}

//attribute: ::btVector3 btVehicleRaycaster_btVehicleRaycasterResult->m_hitNormalInWorld
void btVehicleRaycaster_btVehicleRaycasterResult_m_hitNormalInWorld_set(void *c,float* a) {
	::btVehicleRaycaster::btVehicleRaycasterResult *o = (::btVehicleRaycaster::btVehicleRaycasterResult*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_hitNormalInWorld = ta;
}
void btVehicleRaycaster_btVehicleRaycasterResult_m_hitNormalInWorld_get(void *c,float* a) {
	::btVehicleRaycaster::btVehicleRaycasterResult *o = (::btVehicleRaycaster::btVehicleRaycasterResult*)c;
	a[0]=(o->m_hitNormalInWorld).m_floats[0];a[1]=(o->m_hitNormalInWorld).m_floats[1];a[2]=(o->m_hitNormalInWorld).m_floats[2];
}

//attribute: ::btVector3 btVehicleRaycaster_btVehicleRaycasterResult->m_hitPointInWorld
void btVehicleRaycaster_btVehicleRaycasterResult_m_hitPointInWorld_set(void *c,float* a) {
	::btVehicleRaycaster::btVehicleRaycasterResult *o = (::btVehicleRaycaster::btVehicleRaycasterResult*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_hitPointInWorld = ta;
}
void btVehicleRaycaster_btVehicleRaycasterResult_m_hitPointInWorld_get(void *c,float* a) {
	::btVehicleRaycaster::btVehicleRaycasterResult *o = (::btVehicleRaycaster::btVehicleRaycasterResult*)c;
	a[0]=(o->m_hitPointInWorld).m_floats[0];a[1]=(o->m_hitPointInWorld).m_floats[1];a[2]=(o->m_hitPointInWorld).m_floats[2];
}


// ::btRaycastVehicle::btVehicleTuning
//constructor: btVehicleTuning  ( ::btRaycastVehicle::btVehicleTuning::* )(  ) 
void* btRaycastVehicle_btVehicleTuning_new() {
	::btRaycastVehicle::btVehicleTuning *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btRaycastVehicle::btVehicleTuning),16);
	o = new (mem)::btRaycastVehicle::btVehicleTuning();
	return (void*)o;
}
void btRaycastVehicle_btVehicleTuning_free(void *c) {
	::btRaycastVehicle::btVehicleTuning *o = (::btRaycastVehicle::btVehicleTuning*)c;
	delete o;
}
//attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_frictionSlip
void btRaycastVehicle_btVehicleTuning_m_frictionSlip_set(void *c,float a) {
	::btRaycastVehicle::btVehicleTuning *o = (::btRaycastVehicle::btVehicleTuning*)c;
	o->m_frictionSlip = a;
}
float btRaycastVehicle_btVehicleTuning_m_frictionSlip_get(void *c) {
	::btRaycastVehicle::btVehicleTuning *o = (::btRaycastVehicle::btVehicleTuning*)c;
	return (float)(o->m_frictionSlip);
}

//attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_maxSuspensionForce
void btRaycastVehicle_btVehicleTuning_m_maxSuspensionForce_set(void *c,float a) {
	::btRaycastVehicle::btVehicleTuning *o = (::btRaycastVehicle::btVehicleTuning*)c;
	o->m_maxSuspensionForce = a;
}
float btRaycastVehicle_btVehicleTuning_m_maxSuspensionForce_get(void *c) {
	::btRaycastVehicle::btVehicleTuning *o = (::btRaycastVehicle::btVehicleTuning*)c;
	return (float)(o->m_maxSuspensionForce);
}

//attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_maxSuspensionTravelCm
void btRaycastVehicle_btVehicleTuning_m_maxSuspensionTravelCm_set(void *c,float a) {
	::btRaycastVehicle::btVehicleTuning *o = (::btRaycastVehicle::btVehicleTuning*)c;
	o->m_maxSuspensionTravelCm = a;
}
float btRaycastVehicle_btVehicleTuning_m_maxSuspensionTravelCm_get(void *c) {
	::btRaycastVehicle::btVehicleTuning *o = (::btRaycastVehicle::btVehicleTuning*)c;
	return (float)(o->m_maxSuspensionTravelCm);
}

//attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_suspensionCompression
void btRaycastVehicle_btVehicleTuning_m_suspensionCompression_set(void *c,float a) {
	::btRaycastVehicle::btVehicleTuning *o = (::btRaycastVehicle::btVehicleTuning*)c;
	o->m_suspensionCompression = a;
}
float btRaycastVehicle_btVehicleTuning_m_suspensionCompression_get(void *c) {
	::btRaycastVehicle::btVehicleTuning *o = (::btRaycastVehicle::btVehicleTuning*)c;
	return (float)(o->m_suspensionCompression);
}

//attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_suspensionDamping
void btRaycastVehicle_btVehicleTuning_m_suspensionDamping_set(void *c,float a) {
	::btRaycastVehicle::btVehicleTuning *o = (::btRaycastVehicle::btVehicleTuning*)c;
	o->m_suspensionDamping = a;
}
float btRaycastVehicle_btVehicleTuning_m_suspensionDamping_get(void *c) {
	::btRaycastVehicle::btVehicleTuning *o = (::btRaycastVehicle::btVehicleTuning*)c;
	return (float)(o->m_suspensionDamping);
}

//attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_suspensionStiffness
void btRaycastVehicle_btVehicleTuning_m_suspensionStiffness_set(void *c,float a) {
	::btRaycastVehicle::btVehicleTuning *o = (::btRaycastVehicle::btVehicleTuning*)c;
	o->m_suspensionStiffness = a;
}
float btRaycastVehicle_btVehicleTuning_m_suspensionStiffness_get(void *c) {
	::btRaycastVehicle::btVehicleTuning *o = (::btRaycastVehicle::btVehicleTuning*)c;
	return (float)(o->m_suspensionStiffness);
}


// ::btWheelInfo
//constructor: btWheelInfo  ( ::btWheelInfo::* )( ::btWheelInfoConstructionInfo & ) 
void* btWheelInfo_new(void* p0) {
	::btWheelInfo *o = 0;
	 void *mem = 0;
	::btWheelInfoConstructionInfo & tp0 = *(::btWheelInfoConstructionInfo *)p0;
	mem = btAlignedAlloc(sizeof(::btWheelInfo),16);
	o = new (mem)::btWheelInfo(tp0);
	return (void*)o;
}
void btWheelInfo_free(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	delete o;
}
//method: getSuspensionRestLength ::btScalar ( ::btWheelInfo::* )(  ) const
float btWheelInfo_getSuspensionRestLength(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	float retVal = (float)o->getSuspensionRestLength();
	return retVal;
}
//method: updateWheel void ( ::btWheelInfo::* )( ::btRigidBody const &,::btWheelInfo::RaycastInfo & ) 
void btWheelInfo_updateWheel(void *c,void* p0,void* p1) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	::btRigidBody const & tp0 = *(::btRigidBody const *)p0;
	::btWheelInfo::RaycastInfo & tp1 = *(::btWheelInfo::RaycastInfo *)p1;
	o->updateWheel(tp0,tp1);
}
//attribute: bool btWheelInfo->m_bIsFrontWheel
void btWheelInfo_m_bIsFrontWheel_set(void *c,int a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_bIsFrontWheel = a;
}
int btWheelInfo_m_bIsFrontWheel_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (int)(o->m_bIsFrontWheel);
}

//attribute: ::btScalar btWheelInfo->m_brake
void btWheelInfo_m_brake_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_brake = a;
}
float btWheelInfo_m_brake_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_brake);
}

//attribute: ::btVector3 btWheelInfo->m_chassisConnectionPointCS
void btWheelInfo_m_chassisConnectionPointCS_set(void *c,float* a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_chassisConnectionPointCS = ta;
}
void btWheelInfo_m_chassisConnectionPointCS_get(void *c,float* a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	a[0]=(o->m_chassisConnectionPointCS).m_floats[0];a[1]=(o->m_chassisConnectionPointCS).m_floats[1];a[2]=(o->m_chassisConnectionPointCS).m_floats[2];
}

//attribute: void * btWheelInfo->m_clientInfo
void btWheelInfo_m_clientInfo_set(void *c,void* a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	void * ta = (void *)a;
	o->m_clientInfo = ta;
}
void* btWheelInfo_m_clientInfo_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (void*)(o->m_clientInfo);
}

//attribute: ::btScalar btWheelInfo->m_clippedInvContactDotSuspension
void btWheelInfo_m_clippedInvContactDotSuspension_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_clippedInvContactDotSuspension = a;
}
float btWheelInfo_m_clippedInvContactDotSuspension_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_clippedInvContactDotSuspension);
}

//attribute: ::btScalar btWheelInfo->m_deltaRotation
void btWheelInfo_m_deltaRotation_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_deltaRotation = a;
}
float btWheelInfo_m_deltaRotation_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_deltaRotation);
}

//attribute: ::btScalar btWheelInfo->m_engineForce
void btWheelInfo_m_engineForce_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_engineForce = a;
}
float btWheelInfo_m_engineForce_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_engineForce);
}

//attribute: ::btScalar btWheelInfo->m_frictionSlip
void btWheelInfo_m_frictionSlip_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_frictionSlip = a;
}
float btWheelInfo_m_frictionSlip_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_frictionSlip);
}

//attribute: ::btScalar btWheelInfo->m_maxSuspensionForce
void btWheelInfo_m_maxSuspensionForce_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_maxSuspensionForce = a;
}
float btWheelInfo_m_maxSuspensionForce_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_maxSuspensionForce);
}

//attribute: ::btScalar btWheelInfo->m_maxSuspensionTravelCm
void btWheelInfo_m_maxSuspensionTravelCm_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_maxSuspensionTravelCm = a;
}
float btWheelInfo_m_maxSuspensionTravelCm_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_maxSuspensionTravelCm);
}

//attribute: ::btWheelInfo::RaycastInfo btWheelInfo->m_raycastInfo
void btWheelInfo_m_raycastInfo_set(void *c,void* a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	::btWheelInfo::RaycastInfo & ta = *(::btWheelInfo::RaycastInfo *)a;
	o->m_raycastInfo = ta;
}
void* btWheelInfo_m_raycastInfo_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (void*)&(o->m_raycastInfo);
}

//attribute: ::btScalar btWheelInfo->m_rollInfluence
void btWheelInfo_m_rollInfluence_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_rollInfluence = a;
}
float btWheelInfo_m_rollInfluence_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_rollInfluence);
}

//attribute: ::btScalar btWheelInfo->m_rotation
void btWheelInfo_m_rotation_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_rotation = a;
}
float btWheelInfo_m_rotation_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_rotation);
}

//attribute: ::btScalar btWheelInfo->m_skidInfo
void btWheelInfo_m_skidInfo_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_skidInfo = a;
}
float btWheelInfo_m_skidInfo_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_skidInfo);
}

//attribute: ::btScalar btWheelInfo->m_steering
void btWheelInfo_m_steering_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_steering = a;
}
float btWheelInfo_m_steering_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_steering);
}

//attribute: ::btScalar btWheelInfo->m_suspensionRelativeVelocity
void btWheelInfo_m_suspensionRelativeVelocity_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_suspensionRelativeVelocity = a;
}
float btWheelInfo_m_suspensionRelativeVelocity_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_suspensionRelativeVelocity);
}

//attribute: ::btScalar btWheelInfo->m_suspensionRestLength1
void btWheelInfo_m_suspensionRestLength1_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_suspensionRestLength1 = a;
}
float btWheelInfo_m_suspensionRestLength1_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_suspensionRestLength1);
}

//attribute: ::btScalar btWheelInfo->m_suspensionStiffness
void btWheelInfo_m_suspensionStiffness_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_suspensionStiffness = a;
}
float btWheelInfo_m_suspensionStiffness_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_suspensionStiffness);
}

//attribute: ::btVector3 btWheelInfo->m_wheelAxleCS
void btWheelInfo_m_wheelAxleCS_set(void *c,float* a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_wheelAxleCS = ta;
}
void btWheelInfo_m_wheelAxleCS_get(void *c,float* a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	a[0]=(o->m_wheelAxleCS).m_floats[0];a[1]=(o->m_wheelAxleCS).m_floats[1];a[2]=(o->m_wheelAxleCS).m_floats[2];
}

//attribute: ::btVector3 btWheelInfo->m_wheelDirectionCS
void btWheelInfo_m_wheelDirectionCS_set(void *c,float* a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_wheelDirectionCS = ta;
}
void btWheelInfo_m_wheelDirectionCS_get(void *c,float* a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	a[0]=(o->m_wheelDirectionCS).m_floats[0];a[1]=(o->m_wheelDirectionCS).m_floats[1];a[2]=(o->m_wheelDirectionCS).m_floats[2];
}

//attribute: ::btScalar btWheelInfo->m_wheelsDampingCompression
void btWheelInfo_m_wheelsDampingCompression_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_wheelsDampingCompression = a;
}
float btWheelInfo_m_wheelsDampingCompression_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_wheelsDampingCompression);
}

//attribute: ::btScalar btWheelInfo->m_wheelsDampingRelaxation
void btWheelInfo_m_wheelsDampingRelaxation_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_wheelsDampingRelaxation = a;
}
float btWheelInfo_m_wheelsDampingRelaxation_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_wheelsDampingRelaxation);
}

//attribute: ::btScalar btWheelInfo->m_wheelsRadius
void btWheelInfo_m_wheelsRadius_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_wheelsRadius = a;
}
float btWheelInfo_m_wheelsRadius_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_wheelsRadius);
}

//attribute: ::btScalar btWheelInfo->m_wheelsSuspensionForce
void btWheelInfo_m_wheelsSuspensionForce_set(void *c,float a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	o->m_wheelsSuspensionForce = a;
}
float btWheelInfo_m_wheelsSuspensionForce_get(void *c) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	return (float)(o->m_wheelsSuspensionForce);
}

//attribute: ::btTransform btWheelInfo->m_worldTransform
void btWheelInfo_m_worldTransform_set(void *c,float* a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_worldTransform = ta;
}
void btWheelInfo_m_worldTransform_get(void *c,float* a) {
	::btWheelInfo *o = (::btWheelInfo*)c;
	a[0]=(o->m_worldTransform).getBasis().getRow(0).m_floats[0];a[1]=(o->m_worldTransform).getBasis().getRow(0).m_floats[1];a[2]=(o->m_worldTransform).getBasis().getRow(0).m_floats[2];a[3]=(o->m_worldTransform).getBasis().getRow(1).m_floats[0];a[4]=(o->m_worldTransform).getBasis().getRow(1).m_floats[1];a[5]=(o->m_worldTransform).getBasis().getRow(1).m_floats[2];a[6]=(o->m_worldTransform).getBasis().getRow(2).m_floats[0];a[7]=(o->m_worldTransform).getBasis().getRow(2).m_floats[1];a[8]=(o->m_worldTransform).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_worldTransform).getOrigin().m_floats[0];a[10]=(o->m_worldTransform).getOrigin().m_floats[1];a[11]=(o->m_worldTransform).getOrigin().m_floats[2];
}


// ::btWheelInfoConstructionInfo
//constructor: btWheelInfoConstructionInfo  ( ::btWheelInfoConstructionInfo::* )(  ) 
void* btWheelInfoConstructionInfo_new() {
	::btWheelInfoConstructionInfo *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btWheelInfoConstructionInfo),16);
	o = new (mem)::btWheelInfoConstructionInfo();
	return (void*)o;
}
void btWheelInfoConstructionInfo_free(void *c) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	delete o;
}
//attribute: bool btWheelInfoConstructionInfo->m_bIsFrontWheel
void btWheelInfoConstructionInfo_m_bIsFrontWheel_set(void *c,int a) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	o->m_bIsFrontWheel = a;
}
int btWheelInfoConstructionInfo_m_bIsFrontWheel_get(void *c) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	return (int)(o->m_bIsFrontWheel);
}

//attribute: ::btVector3 btWheelInfoConstructionInfo->m_chassisConnectionCS
void btWheelInfoConstructionInfo_m_chassisConnectionCS_set(void *c,float* a) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_chassisConnectionCS = ta;
}
void btWheelInfoConstructionInfo_m_chassisConnectionCS_get(void *c,float* a) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	a[0]=(o->m_chassisConnectionCS).m_floats[0];a[1]=(o->m_chassisConnectionCS).m_floats[1];a[2]=(o->m_chassisConnectionCS).m_floats[2];
}

//attribute: ::btScalar btWheelInfoConstructionInfo->m_frictionSlip
void btWheelInfoConstructionInfo_m_frictionSlip_set(void *c,float a) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	o->m_frictionSlip = a;
}
float btWheelInfoConstructionInfo_m_frictionSlip_get(void *c) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	return (float)(o->m_frictionSlip);
}

//attribute: ::btScalar btWheelInfoConstructionInfo->m_maxSuspensionForce
void btWheelInfoConstructionInfo_m_maxSuspensionForce_set(void *c,float a) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	o->m_maxSuspensionForce = a;
}
float btWheelInfoConstructionInfo_m_maxSuspensionForce_get(void *c) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	return (float)(o->m_maxSuspensionForce);
}

//attribute: ::btScalar btWheelInfoConstructionInfo->m_maxSuspensionTravelCm
void btWheelInfoConstructionInfo_m_maxSuspensionTravelCm_set(void *c,float a) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	o->m_maxSuspensionTravelCm = a;
}
float btWheelInfoConstructionInfo_m_maxSuspensionTravelCm_get(void *c) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	return (float)(o->m_maxSuspensionTravelCm);
}

//attribute: ::btScalar btWheelInfoConstructionInfo->m_suspensionRestLength
void btWheelInfoConstructionInfo_m_suspensionRestLength_set(void *c,float a) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	o->m_suspensionRestLength = a;
}
float btWheelInfoConstructionInfo_m_suspensionRestLength_get(void *c) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	return (float)(o->m_suspensionRestLength);
}

//attribute: ::btScalar btWheelInfoConstructionInfo->m_suspensionStiffness
void btWheelInfoConstructionInfo_m_suspensionStiffness_set(void *c,float a) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	o->m_suspensionStiffness = a;
}
float btWheelInfoConstructionInfo_m_suspensionStiffness_get(void *c) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	return (float)(o->m_suspensionStiffness);
}

//attribute: ::btVector3 btWheelInfoConstructionInfo->m_wheelAxleCS
void btWheelInfoConstructionInfo_m_wheelAxleCS_set(void *c,float* a) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_wheelAxleCS = ta;
}
void btWheelInfoConstructionInfo_m_wheelAxleCS_get(void *c,float* a) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	a[0]=(o->m_wheelAxleCS).m_floats[0];a[1]=(o->m_wheelAxleCS).m_floats[1];a[2]=(o->m_wheelAxleCS).m_floats[2];
}

//attribute: ::btVector3 btWheelInfoConstructionInfo->m_wheelDirectionCS
void btWheelInfoConstructionInfo_m_wheelDirectionCS_set(void *c,float* a) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_wheelDirectionCS = ta;
}
void btWheelInfoConstructionInfo_m_wheelDirectionCS_get(void *c,float* a) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	a[0]=(o->m_wheelDirectionCS).m_floats[0];a[1]=(o->m_wheelDirectionCS).m_floats[1];a[2]=(o->m_wheelDirectionCS).m_floats[2];
}

//attribute: ::btScalar btWheelInfoConstructionInfo->m_wheelRadius
void btWheelInfoConstructionInfo_m_wheelRadius_set(void *c,float a) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	o->m_wheelRadius = a;
}
float btWheelInfoConstructionInfo_m_wheelRadius_get(void *c) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	return (float)(o->m_wheelRadius);
}

//attribute: ::btScalar btWheelInfoConstructionInfo->m_wheelsDampingCompression
void btWheelInfoConstructionInfo_m_wheelsDampingCompression_set(void *c,float a) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	o->m_wheelsDampingCompression = a;
}
float btWheelInfoConstructionInfo_m_wheelsDampingCompression_get(void *c) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	return (float)(o->m_wheelsDampingCompression);
}

//attribute: ::btScalar btWheelInfoConstructionInfo->m_wheelsDampingRelaxation
void btWheelInfoConstructionInfo_m_wheelsDampingRelaxation_set(void *c,float a) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	o->m_wheelsDampingRelaxation = a;
}
float btWheelInfoConstructionInfo_m_wheelsDampingRelaxation_get(void *c) {
	::btWheelInfoConstructionInfo *o = (::btWheelInfoConstructionInfo*)c;
	return (float)(o->m_wheelsDampingRelaxation);
}


// ::btBU_Simplex1to4
//constructor: btBU_Simplex1to4  ( ::btBU_Simplex1to4::* )(  ) 
void* btBU_Simplex1to4_new0() {
	::btBU_Simplex1to4 *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btBU_Simplex1to4),16);
	o = new (mem)::btBU_Simplex1to4();
	return (void*)o;
}
//constructor: btBU_Simplex1to4  ( ::btBU_Simplex1to4::* )( ::btVector3 const & ) 
void* btBU_Simplex1to4_new1(float* p0) {
	::btBU_Simplex1to4 *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	mem = btAlignedAlloc(sizeof(::btBU_Simplex1to4),16);
	o = new (mem)::btBU_Simplex1to4(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return (void*)o;
}
//constructor: btBU_Simplex1to4  ( ::btBU_Simplex1to4::* )( ::btVector3 const &,::btVector3 const & ) 
void* btBU_Simplex1to4_new2(float* p0,float* p1) {
	::btBU_Simplex1to4 *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	mem = btAlignedAlloc(sizeof(::btBU_Simplex1to4),16);
	o = new (mem)::btBU_Simplex1to4(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return (void*)o;
}
//constructor: btBU_Simplex1to4  ( ::btBU_Simplex1to4::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void* btBU_Simplex1to4_new3(float* p0,float* p1,float* p2) {
	::btBU_Simplex1to4 *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	mem = btAlignedAlloc(sizeof(::btBU_Simplex1to4),16);
	o = new (mem)::btBU_Simplex1to4(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	return (void*)o;
}
//constructor: btBU_Simplex1to4  ( ::btBU_Simplex1to4::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void* btBU_Simplex1to4_new4(float* p0,float* p1,float* p2,float* p3) {
	::btBU_Simplex1to4 *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	mem = btAlignedAlloc(sizeof(::btBU_Simplex1to4),16);
	o = new (mem)::btBU_Simplex1to4(tp0,tp1,tp2,tp3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	return (void*)o;
}
void btBU_Simplex1to4_free(void *c) {
	::btBU_Simplex1to4 *o = (::btBU_Simplex1to4*)c;
	delete o;
}
//method: reset void ( ::btBU_Simplex1to4::* )(  ) 
void btBU_Simplex1to4_reset(void *c) {
	::btBU_Simplex1to4 *o = (::btBU_Simplex1to4*)c;
	o->reset();
}
//method: getNumPlanes int ( ::btBU_Simplex1to4::* )(  ) const
int btBU_Simplex1to4_getNumPlanes(void *c) {
	::btBU_Simplex1to4 *o = (::btBU_Simplex1to4*)c;
	int retVal = (int)o->getNumPlanes();
	return retVal;
}
//method: getIndex int ( ::btBU_Simplex1to4::* )( int ) const
int btBU_Simplex1to4_getIndex(void *c,int p0) {
	::btBU_Simplex1to4 *o = (::btBU_Simplex1to4*)c;
	int retVal = (int)o->getIndex(p0);
	return retVal;
}
//method: getNumEdges int ( ::btBU_Simplex1to4::* )(  ) const
int btBU_Simplex1to4_getNumEdges(void *c) {
	::btBU_Simplex1to4 *o = (::btBU_Simplex1to4*)c;
	int retVal = (int)o->getNumEdges();
	return retVal;
}
//method: getName char const * ( ::btBU_Simplex1to4::* )(  ) const
char const * btBU_Simplex1to4_getName(void *c) {
	::btBU_Simplex1to4 *o = (::btBU_Simplex1to4*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: getVertex void ( ::btBU_Simplex1to4::* )( int,::btVector3 & ) const
void btBU_Simplex1to4_getVertex(void *c,int p0,float* p1) {
	::btBU_Simplex1to4 *o = (::btBU_Simplex1to4*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getVertex(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getEdge void ( ::btBU_Simplex1to4::* )( int,::btVector3 &,::btVector3 & ) const
void btBU_Simplex1to4_getEdge(void *c,int p0,float* p1,float* p2) {
	::btBU_Simplex1to4 *o = (::btBU_Simplex1to4*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getEdge(p0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: addVertex void ( ::btBU_Simplex1to4::* )( ::btVector3 const & ) 
void btBU_Simplex1to4_addVertex(void *c,float* p0) {
	::btBU_Simplex1to4 *o = (::btBU_Simplex1to4*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->addVertex(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: isInside bool ( ::btBU_Simplex1to4::* )( ::btVector3 const &,::btScalar ) const
int btBU_Simplex1to4_isInside(void *c,float* p0,float p1) {
	::btBU_Simplex1to4 *o = (::btBU_Simplex1to4*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	int retVal = (int)o->isInside(tp0,p1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return retVal;
}
//method: getPlane void ( ::btBU_Simplex1to4::* )( ::btVector3 &,::btVector3 &,int ) const
void btBU_Simplex1to4_getPlane(void *c,float* p0,float* p1,int p2) {
	::btBU_Simplex1to4 *o = (::btBU_Simplex1to4*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getPlane(tp0,tp1,p2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getAabb void ( ::btBU_Simplex1to4::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btBU_Simplex1to4_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btBU_Simplex1to4 *o = (::btBU_Simplex1to4*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getNumVertices int ( ::btBU_Simplex1to4::* )(  ) const
int btBU_Simplex1to4_getNumVertices(void *c) {
	::btBU_Simplex1to4 *o = (::btBU_Simplex1to4*)c;
	int retVal = (int)o->getNumVertices();
	return retVal;
}
//attribute: int btBU_Simplex1to4->m_numVertices
void btBU_Simplex1to4_m_numVertices_set(void *c,int a) {
	::btBU_Simplex1to4 *o = (::btBU_Simplex1to4*)c;
	o->m_numVertices = a;
}
int btBU_Simplex1to4_m_numVertices_get(void *c) {
	::btBU_Simplex1to4 *o = (::btBU_Simplex1to4*)c;
	return (int)(o->m_numVertices);
}

//attribute: ::btVector3[4] btBU_Simplex1to4->m_vertices
// attribute not supported: //attribute: ::btVector3[4] btBU_Simplex1to4->m_vertices

// ::btBoxShape
//constructor: btBoxShape  ( ::btBoxShape::* )( ::btVector3 const & ) 
void* btBoxShape_new(float* p0) {
	::btBoxShape *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	mem = btAlignedAlloc(sizeof(::btBoxShape),16);
	o = new (mem)::btBoxShape(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return (void*)o;
}
void btBoxShape_free(void *c) {
	::btBoxShape *o = (::btBoxShape*)c;
	delete o;
}
//method: calculateLocalInertia void ( ::btBoxShape::* )( ::btScalar,::btVector3 & ) const
void btBoxShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btBoxShape *o = (::btBoxShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getNumPlanes int ( ::btBoxShape::* )(  ) const
int btBoxShape_getNumPlanes(void *c) {
	::btBoxShape *o = (::btBoxShape*)c;
	int retVal = (int)o->getNumPlanes();
	return retVal;
}
//method: localGetSupportingVertex ::btVector3 ( ::btBoxShape::* )( ::btVector3 const & ) const
void btBoxShape_localGetSupportingVertex(void *c,float* p0,float* ret) {
	::btBoxShape *o = (::btBoxShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertex(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btBoxShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

//method: setLocalScaling void ( ::btBoxShape::* )( ::btVector3 const & ) 
void btBoxShape_setLocalScaling(void *c,float* p0) {
	::btBoxShape *o = (::btBoxShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getPlaneEquation void ( ::btBoxShape::* )( ::btVector4 &,int ) const
void btBoxShape_getPlaneEquation(void *c,float* p0,int p1) {
	::btBoxShape *o = (::btBoxShape*)c;
	btVector4 tp0(p0[0],p0[1],p0[2],p0[3]);
	o->getPlaneEquation(tp0,p1);
	p0[0]=tp0.getX();p0[1]=tp0.getY();p0[2]=tp0.getZ();p0[3]=tp0.getW();
}
//method: getPreferredPenetrationDirection void ( ::btBoxShape::* )( int,::btVector3 & ) const
void btBoxShape_getPreferredPenetrationDirection(void *c,int p0,float* p1) {
	::btBoxShape *o = (::btBoxShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getPreferredPenetrationDirection(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getNumEdges int ( ::btBoxShape::* )(  ) const
int btBoxShape_getNumEdges(void *c) {
	::btBoxShape *o = (::btBoxShape*)c;
	int retVal = (int)o->getNumEdges();
	return retVal;
}
//method: getName char const * ( ::btBoxShape::* )(  ) const
char const * btBoxShape_getName(void *c) {
	::btBoxShape *o = (::btBoxShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: getVertex void ( ::btBoxShape::* )( int,::btVector3 & ) const
void btBoxShape_getVertex(void *c,int p0,float* p1) {
	::btBoxShape *o = (::btBoxShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getVertex(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getEdge void ( ::btBoxShape::* )( int,::btVector3 &,::btVector3 & ) const
void btBoxShape_getEdge(void *c,int p0,float* p1,float* p2) {
	::btBoxShape *o = (::btBoxShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getEdge(p0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: isInside bool ( ::btBoxShape::* )( ::btVector3 const &,::btScalar ) const
int btBoxShape_isInside(void *c,float* p0,float p1) {
	::btBoxShape *o = (::btBoxShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	int retVal = (int)o->isInside(tp0,p1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return retVal;
}
//method: getPlane void ( ::btBoxShape::* )( ::btVector3 &,::btVector3 &,int ) const
void btBoxShape_getPlane(void *c,float* p0,float* p1,int p2) {
	::btBoxShape *o = (::btBoxShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getPlane(tp0,tp1,p2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getHalfExtentsWithoutMargin ::btVector3 const & ( ::btBoxShape::* )(  ) const
void btBoxShape_getHalfExtentsWithoutMargin(void *c,float* ret) {
	::btBoxShape *o = (::btBoxShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getHalfExtentsWithoutMargin();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getNumPreferredPenetrationDirections int ( ::btBoxShape::* )(  ) const
int btBoxShape_getNumPreferredPenetrationDirections(void *c) {
	::btBoxShape *o = (::btBoxShape*)c;
	int retVal = (int)o->getNumPreferredPenetrationDirections();
	return retVal;
}
//method: getAabb void ( ::btBoxShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btBoxShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btBoxShape *o = (::btBoxShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: setMargin void ( ::btBoxShape::* )( ::btScalar ) 
void btBoxShape_setMargin(void *c,float p0) {
	::btBoxShape *o = (::btBoxShape*)c;
	o->setMargin(p0);
}
//method: getNumVertices int ( ::btBoxShape::* )(  ) const
int btBoxShape_getNumVertices(void *c) {
	::btBoxShape *o = (::btBoxShape*)c;
	int retVal = (int)o->getNumVertices();
	return retVal;
}
//method: getHalfExtentsWithMargin ::btVector3 ( ::btBoxShape::* )(  ) const
void btBoxShape_getHalfExtentsWithMargin(void *c,float* ret) {
	::btBoxShape *o = (::btBoxShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getHalfExtentsWithMargin();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btBoxShape::* )( ::btVector3 const & ) const
void btBoxShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret) {
	::btBoxShape *o = (::btBoxShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertexWithoutMargin(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}

// ::btBvhTriangleMeshShape
//constructor: btBvhTriangleMeshShape  ( ::btBvhTriangleMeshShape::* )( ::btStridingMeshInterface *,bool,bool ) 
void* btBvhTriangleMeshShape_new0(void* p0,int p1,int p2) {
	::btBvhTriangleMeshShape *o = 0;
	 void *mem = 0;
	::btStridingMeshInterface * tp0 = (::btStridingMeshInterface *)p0;
	mem = btAlignedAlloc(sizeof(::btBvhTriangleMeshShape),16);
	o = new (mem)::btBvhTriangleMeshShape(tp0,p1,p2);
	return (void*)o;
}
//constructor: btBvhTriangleMeshShape  ( ::btBvhTriangleMeshShape::* )( ::btStridingMeshInterface *,bool,::btVector3 const &,::btVector3 const &,bool ) 
void* btBvhTriangleMeshShape_new1(void* p0,int p1,float* p2,float* p3,int p4) {
	::btBvhTriangleMeshShape *o = 0;
	 void *mem = 0;
	::btStridingMeshInterface * tp0 = (::btStridingMeshInterface *)p0;
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	mem = btAlignedAlloc(sizeof(::btBvhTriangleMeshShape),16);
	o = new (mem)::btBvhTriangleMeshShape(tp0,p1,tp2,tp3,p4);
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	return (void*)o;
}
void btBvhTriangleMeshShape_free(void *c) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	delete o;
}
//method: calculateSerializeBufferSize int ( ::btBvhTriangleMeshShape::* )(  ) const
int btBvhTriangleMeshShape_calculateSerializeBufferSize(void *c) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: buildOptimizedBvh void ( ::btBvhTriangleMeshShape::* )(  ) 
void btBvhTriangleMeshShape_buildOptimizedBvh(void *c) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	o->buildOptimizedBvh();
}
//method: setLocalScaling void ( ::btBvhTriangleMeshShape::* )( ::btVector3 const & ) 
void btBvhTriangleMeshShape_setLocalScaling(void *c,float* p0) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: performRaycast void ( ::btBvhTriangleMeshShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) 
void btBvhTriangleMeshShape_performRaycast(void *c,void* p0,float* p1,float* p2) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	::btTriangleCallback * tp0 = (::btTriangleCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->performRaycast(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: setTriangleInfoMap void ( ::btBvhTriangleMeshShape::* )( ::btTriangleInfoMap * ) 
void btBvhTriangleMeshShape_setTriangleInfoMap(void *c,void* p0) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	::btTriangleInfoMap * tp0 = (::btTriangleInfoMap *)p0;
	o->setTriangleInfoMap(tp0);
}
//method: usesQuantizedAabbCompression bool ( ::btBvhTriangleMeshShape::* )(  ) const
int btBvhTriangleMeshShape_usesQuantizedAabbCompression(void *c) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	int retVal = (int)o->usesQuantizedAabbCompression();
	return retVal;
}
//method: getName char const * ( ::btBvhTriangleMeshShape::* )(  ) const
char const * btBvhTriangleMeshShape_getName(void *c) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: serialize char const * ( ::btBvhTriangleMeshShape::* )( void *,::btSerializer * ) const
char const * btBvhTriangleMeshShape_serialize(void *c,void* p0,void* p1) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: getTriangleInfoMap ::btTriangleInfoMap const * ( ::btBvhTriangleMeshShape::* )(  ) const
void* btBvhTriangleMeshShape_getTriangleInfoMap(void *c) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	void* retVal = (void*) o->getTriangleInfoMap();
	return retVal;
}
//method: getTriangleInfoMap ::btTriangleInfoMap const * ( ::btBvhTriangleMeshShape::* )(  ) const
void* btBvhTriangleMeshShape_getTriangleInfoMap0(void *c) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	void* retVal = (void*) o->getTriangleInfoMap();
	return retVal;
}
//method: getTriangleInfoMap ::btTriangleInfoMap * ( ::btBvhTriangleMeshShape::* )(  ) 
void* btBvhTriangleMeshShape_getTriangleInfoMap1(void *c) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	void* retVal = (void*) o->getTriangleInfoMap();
	return retVal;
}
//method: serializeSingleTriangleInfoMap void ( ::btBvhTriangleMeshShape::* )( ::btSerializer * ) const
void btBvhTriangleMeshShape_serializeSingleTriangleInfoMap(void *c,void* p0) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	::btSerializer * tp0 = (::btSerializer *)p0;
	o->serializeSingleTriangleInfoMap(tp0);
}
//method: getOwnsBvh bool ( ::btBvhTriangleMeshShape::* )(  ) const
int btBvhTriangleMeshShape_getOwnsBvh(void *c) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	int retVal = (int)o->getOwnsBvh();
	return retVal;
}
//method: partialRefitTree void ( ::btBvhTriangleMeshShape::* )( ::btVector3 const &,::btVector3 const & ) 
void btBvhTriangleMeshShape_partialRefitTree(void *c,float* p0,float* p1) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->partialRefitTree(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getOptimizedBvh ::btOptimizedBvh * ( ::btBvhTriangleMeshShape::* )(  ) 
void* btBvhTriangleMeshShape_getOptimizedBvh(void *c) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	void* retVal = (void*) o->getOptimizedBvh();
	return retVal;
}
//method: processAllTriangles void ( ::btBvhTriangleMeshShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
void btBvhTriangleMeshShape_processAllTriangles(void *c,void* p0,float* p1,float* p2) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	::btTriangleCallback * tp0 = (::btTriangleCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->processAllTriangles(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: refitTree void ( ::btBvhTriangleMeshShape::* )( ::btVector3 const &,::btVector3 const & ) 
void btBvhTriangleMeshShape_refitTree(void *c,float* p0,float* p1) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->refitTree(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: performConvexcast void ( ::btBvhTriangleMeshShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btBvhTriangleMeshShape_performConvexcast(void *c,void* p0,float* p1,float* p2,float* p3,float* p4) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	::btTriangleCallback * tp0 = (::btTriangleCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->performConvexcast(tp0,tp1,tp2,tp3,tp4);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: serializeSingleBvh void ( ::btBvhTriangleMeshShape::* )( ::btSerializer * ) const
void btBvhTriangleMeshShape_serializeSingleBvh(void *c,void* p0) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	::btSerializer * tp0 = (::btSerializer *)p0;
	o->serializeSingleBvh(tp0);
}
//method: setOptimizedBvh void ( ::btBvhTriangleMeshShape::* )( ::btOptimizedBvh *,::btVector3 const & ) 
void btBvhTriangleMeshShape_setOptimizedBvh(void *c,void* p0,float* p1) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	::btOptimizedBvh * tp0 = (::btOptimizedBvh *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->setOptimizedBvh(tp0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//attribute: ::btOptimizedBvh * btBvhTriangleMeshShape->m_bvh
void btBvhTriangleMeshShape_m_bvh_set(void *c,void* a) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	::btOptimizedBvh * ta = (::btOptimizedBvh *)a;
	o->m_bvh = ta;
}
void* btBvhTriangleMeshShape_m_bvh_get(void *c) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	return (void*)(o->m_bvh);
}

//attribute: ::btTriangleInfoMap * btBvhTriangleMeshShape->m_triangleInfoMap
void btBvhTriangleMeshShape_m_triangleInfoMap_set(void *c,void* a) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	::btTriangleInfoMap * ta = (::btTriangleInfoMap *)a;
	o->m_triangleInfoMap = ta;
}
void* btBvhTriangleMeshShape_m_triangleInfoMap_get(void *c) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	return (void*)(o->m_triangleInfoMap);
}

//attribute: bool btBvhTriangleMeshShape->m_useQuantizedAabbCompression
void btBvhTriangleMeshShape_m_useQuantizedAabbCompression_set(void *c,int a) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	o->m_useQuantizedAabbCompression = a;
}
int btBvhTriangleMeshShape_m_useQuantizedAabbCompression_get(void *c) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	return (int)(o->m_useQuantizedAabbCompression);
}

//attribute: bool btBvhTriangleMeshShape->m_ownsBvh
void btBvhTriangleMeshShape_m_ownsBvh_set(void *c,int a) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	o->m_ownsBvh = a;
}
int btBvhTriangleMeshShape_m_ownsBvh_get(void *c) {
	::btBvhTriangleMeshShape *o = (::btBvhTriangleMeshShape*)c;
	return (int)(o->m_ownsBvh);
}

//attribute: bool[11] btBvhTriangleMeshShape->m_pad
// attribute not supported: //attribute: bool[11] btBvhTriangleMeshShape->m_pad

// ::btCapsuleShape
//constructor: btCapsuleShape  ( ::btCapsuleShape::* )(  ) 
void* btCapsuleShape_new0() {
	::btCapsuleShape *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCapsuleShape),16);
	o = new (mem)::btCapsuleShape();
	return (void*)o;
}
//constructor: btCapsuleShape  ( ::btCapsuleShape::* )( ::btScalar,::btScalar ) 
void* btCapsuleShape_new1(float p0,float p1) {
	::btCapsuleShape *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCapsuleShape),16);
	o = new (mem)::btCapsuleShape(p0,p1);
	return (void*)o;
}
void btCapsuleShape_free(void *c) {
	::btCapsuleShape *o = (::btCapsuleShape*)c;
	delete o;
}
//method: calculateLocalInertia void ( ::btCapsuleShape::* )( ::btScalar,::btVector3 & ) const
void btCapsuleShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btCapsuleShape *o = (::btCapsuleShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: calculateSerializeBufferSize int ( ::btCapsuleShape::* )(  ) const
int btCapsuleShape_calculateSerializeBufferSize(void *c) {
	::btCapsuleShape *o = (::btCapsuleShape*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btCapsuleShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

//method: setLocalScaling void ( ::btCapsuleShape::* )( ::btVector3 const & ) 
void btCapsuleShape_setLocalScaling(void *c,float* p0) {
	::btCapsuleShape *o = (::btCapsuleShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getUpAxis int ( ::btCapsuleShape::* )(  ) const
int btCapsuleShape_getUpAxis(void *c) {
	::btCapsuleShape *o = (::btCapsuleShape*)c;
	int retVal = (int)o->getUpAxis();
	return retVal;
}
//method: getName char const * ( ::btCapsuleShape::* )(  ) const
char const * btCapsuleShape_getName(void *c) {
	::btCapsuleShape *o = (::btCapsuleShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: getHalfHeight ::btScalar ( ::btCapsuleShape::* )(  ) const
float btCapsuleShape_getHalfHeight(void *c) {
	::btCapsuleShape *o = (::btCapsuleShape*)c;
	float retVal = (float)o->getHalfHeight();
	return retVal;
}
//method: setMargin void ( ::btCapsuleShape::* )( ::btScalar ) 
void btCapsuleShape_setMargin(void *c,float p0) {
	::btCapsuleShape *o = (::btCapsuleShape*)c;
	o->setMargin(p0);
}
//method: getAabb void ( ::btCapsuleShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btCapsuleShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btCapsuleShape *o = (::btCapsuleShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: serialize char const * ( ::btCapsuleShape::* )( void *,::btSerializer * ) const
char const * btCapsuleShape_serialize(void *c,void* p0,void* p1) {
	::btCapsuleShape *o = (::btCapsuleShape*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btCapsuleShape::* )( ::btVector3 const & ) const
void btCapsuleShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret) {
	::btCapsuleShape *o = (::btCapsuleShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertexWithoutMargin(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getRadius ::btScalar ( ::btCapsuleShape::* )(  ) const
float btCapsuleShape_getRadius(void *c) {
	::btCapsuleShape *o = (::btCapsuleShape*)c;
	float retVal = (float)o->getRadius();
	return retVal;
}
//attribute: int btCapsuleShape->m_upAxis
void btCapsuleShape_m_upAxis_set(void *c,int a) {
	::btCapsuleShape *o = (::btCapsuleShape*)c;
	o->m_upAxis = a;
}
int btCapsuleShape_m_upAxis_get(void *c) {
	::btCapsuleShape *o = (::btCapsuleShape*)c;
	return (int)(o->m_upAxis);
}


// ::btCapsuleShapeData
//constructor: btCapsuleShapeData  ( ::btCapsuleShapeData::* )(  ) 
void* btCapsuleShapeData_new() {
	::btCapsuleShapeData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCapsuleShapeData),16);
	o = new (mem)::btCapsuleShapeData();
	return (void*)o;
}
void btCapsuleShapeData_free(void *c) {
	::btCapsuleShapeData *o = (::btCapsuleShapeData*)c;
	delete o;
}
//attribute: ::btConvexInternalShapeData btCapsuleShapeData->m_convexInternalShapeData
void btCapsuleShapeData_m_convexInternalShapeData_set(void *c,void* a) {
	::btCapsuleShapeData *o = (::btCapsuleShapeData*)c;
	::btConvexInternalShapeData & ta = *(::btConvexInternalShapeData *)a;
	o->m_convexInternalShapeData = ta;
}
void* btCapsuleShapeData_m_convexInternalShapeData_get(void *c) {
	::btCapsuleShapeData *o = (::btCapsuleShapeData*)c;
	return (void*)&(o->m_convexInternalShapeData);
}

//attribute: int btCapsuleShapeData->m_upAxis
void btCapsuleShapeData_m_upAxis_set(void *c,int a) {
	::btCapsuleShapeData *o = (::btCapsuleShapeData*)c;
	o->m_upAxis = a;
}
int btCapsuleShapeData_m_upAxis_get(void *c) {
	::btCapsuleShapeData *o = (::btCapsuleShapeData*)c;
	return (int)(o->m_upAxis);
}

//attribute: char[4] btCapsuleShapeData->m_padding
// attribute not supported: //attribute: char[4] btCapsuleShapeData->m_padding

// ::btCapsuleShapeX
//constructor: btCapsuleShapeX  ( ::btCapsuleShapeX::* )( ::btScalar,::btScalar ) 
void* btCapsuleShapeX_new(float p0,float p1) {
	::btCapsuleShapeX *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCapsuleShapeX),16);
	o = new (mem)::btCapsuleShapeX(p0,p1);
	return (void*)o;
}
void btCapsuleShapeX_free(void *c) {
	::btCapsuleShapeX *o = (::btCapsuleShapeX*)c;
	delete o;
}
//method: getName char const * ( ::btCapsuleShapeX::* )(  ) const
char const * btCapsuleShapeX_getName(void *c) {
	::btCapsuleShapeX *o = (::btCapsuleShapeX*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}

// ::btCapsuleShapeZ
//constructor: btCapsuleShapeZ  ( ::btCapsuleShapeZ::* )( ::btScalar,::btScalar ) 
void* btCapsuleShapeZ_new(float p0,float p1) {
	::btCapsuleShapeZ *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCapsuleShapeZ),16);
	o = new (mem)::btCapsuleShapeZ(p0,p1);
	return (void*)o;
}
void btCapsuleShapeZ_free(void *c) {
	::btCapsuleShapeZ *o = (::btCapsuleShapeZ*)c;
	delete o;
}
//method: getName char const * ( ::btCapsuleShapeZ::* )(  ) const
char const * btCapsuleShapeZ_getName(void *c) {
	::btCapsuleShapeZ *o = (::btCapsuleShapeZ*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}

// ::btCharIndexTripletData
//constructor: btCharIndexTripletData  ( ::btCharIndexTripletData::* )(  ) 
void* btCharIndexTripletData_new() {
	::btCharIndexTripletData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCharIndexTripletData),16);
	o = new (mem)::btCharIndexTripletData();
	return (void*)o;
}
void btCharIndexTripletData_free(void *c) {
	::btCharIndexTripletData *o = (::btCharIndexTripletData*)c;
	delete o;
}
//attribute: unsigned char[3] btCharIndexTripletData->m_values
// attribute not supported: //attribute: unsigned char[3] btCharIndexTripletData->m_values
//attribute: char btCharIndexTripletData->m_pad
void btCharIndexTripletData_m_pad_set(void *c,char a) {
	::btCharIndexTripletData *o = (::btCharIndexTripletData*)c;
	o->m_pad = a;
}
char btCharIndexTripletData_m_pad_get(void *c) {
	::btCharIndexTripletData *o = (::btCharIndexTripletData*)c;
	return (char)(o->m_pad);
}


// ::btCollisionShape
//method: calculateLocalInertia void ( ::btCollisionShape::* )( ::btScalar,::btVector3 & ) const
void btCollisionShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: setUserPointer void ( ::btCollisionShape::* )( void * ) 
void btCollisionShape_setUserPointer(void *c,void* p0) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	void * tp0 = (void *)p0;
	o->setUserPointer(tp0);
}
//method: serialize char const * ( ::btCollisionShape::* )( void *,::btSerializer * ) const
char const * btCollisionShape_serialize(void *c,void* p0,void* p1) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: getLocalScaling ::btVector3 const & ( ::btCollisionShape::* )(  ) const
void btCollisionShape_getLocalScaling(void *c,float* ret) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLocalScaling();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: calculateSerializeBufferSize int ( ::btCollisionShape::* )(  ) const
int btCollisionShape_calculateSerializeBufferSize(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: getName char const * ( ::btCollisionShape::* )(  ) const
char const * btCollisionShape_getName(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: isCompound bool ( ::btCollisionShape::* )(  ) const
int btCollisionShape_isCompound(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	int retVal = (int)o->isCompound();
	return retVal;
}
//method: isPolyhedral bool ( ::btCollisionShape::* )(  ) const
int btCollisionShape_isPolyhedral(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	int retVal = (int)o->isPolyhedral();
	return retVal;
}
//method: setLocalScaling void ( ::btCollisionShape::* )( ::btVector3 const & ) 
void btCollisionShape_setLocalScaling(void *c,float* p0) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getAabb void ( ::btCollisionShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btCollisionShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getContactBreakingThreshold ::btScalar ( ::btCollisionShape::* )( ::btScalar ) const
float btCollisionShape_getContactBreakingThreshold(void *c,float p0) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	float retVal = (float)o->getContactBreakingThreshold(p0);
	return retVal;
}
//method: isConvex bool ( ::btCollisionShape::* )(  ) const
int btCollisionShape_isConvex(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	int retVal = (int)o->isConvex();
	return retVal;
}
//method: isInfinite bool ( ::btCollisionShape::* )(  ) const
int btCollisionShape_isInfinite(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	int retVal = (int)o->isInfinite();
	return retVal;
}
//method: getUserPointer void * ( ::btCollisionShape::* )(  ) const
void* btCollisionShape_getUserPointer(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	void* retVal = (void*) o->getUserPointer();
	return retVal;
}
//method: isNonMoving bool ( ::btCollisionShape::* )(  ) const
int btCollisionShape_isNonMoving(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	int retVal = (int)o->isNonMoving();
	return retVal;
}
//method: getMargin ::btScalar ( ::btCollisionShape::* )(  ) const
float btCollisionShape_getMargin(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	float retVal = (float)o->getMargin();
	return retVal;
}
//method: setMargin void ( ::btCollisionShape::* )( ::btScalar ) 
void btCollisionShape_setMargin(void *c,float p0) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	o->setMargin(p0);
}
//method: isConvex2d bool ( ::btCollisionShape::* )(  ) const
int btCollisionShape_isConvex2d(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	int retVal = (int)o->isConvex2d();
	return retVal;
}
//method: isSoftBody bool ( ::btCollisionShape::* )(  ) const
int btCollisionShape_isSoftBody(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	int retVal = (int)o->isSoftBody();
	return retVal;
}
//method: calculateTemporalAabb void ( ::btCollisionShape::* )( ::btTransform const &,::btVector3 const &,::btVector3 const &,::btScalar,::btVector3 &,::btVector3 & ) const
void btCollisionShape_calculateTemporalAabb(void *c,float* p0,float* p1,float* p2,float p3,float* p4,float* p5) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	btVector3 tp5(p5[0],p5[1],p5[2]);
	o->calculateTemporalAabb(tp0,tp1,tp2,p3,tp4,tp5);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	p5[0]=tp5.m_floats[0];p5[1]=tp5.m_floats[1];p5[2]=tp5.m_floats[2];
}
//method: isConcave bool ( ::btCollisionShape::* )(  ) const
int btCollisionShape_isConcave(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	int retVal = (int)o->isConcave();
	return retVal;
}
//method: getAngularMotionDisc ::btScalar ( ::btCollisionShape::* )(  ) const
float btCollisionShape_getAngularMotionDisc(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	float retVal = (float)o->getAngularMotionDisc();
	return retVal;
}
//method: serializeSingleShape void ( ::btCollisionShape::* )( ::btSerializer * ) const
void btCollisionShape_serializeSingleShape(void *c,void* p0) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	::btSerializer * tp0 = (::btSerializer *)p0;
	o->serializeSingleShape(tp0);
}
//not supported method: getBoundingSphere void ( ::btCollisionShape::* )( ::btVector3 &,::btScalar & ) const
// error: ::btVector3 & - ok,  - unsupported, void - ok

//method: getShapeType int ( ::btCollisionShape::* )(  ) const
int btCollisionShape_getShapeType(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	int retVal = (int)o->getShapeType();
	return retVal;
}
//attribute: int btCollisionShape->m_shapeType
void btCollisionShape_m_shapeType_set(void *c,int a) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	o->m_shapeType = a;
}
int btCollisionShape_m_shapeType_get(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	return (int)(o->m_shapeType);
}

//attribute: void * btCollisionShape->m_userPointer
void btCollisionShape_m_userPointer_set(void *c,void* a) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	void * ta = (void *)a;
	o->m_userPointer = ta;
}
void* btCollisionShape_m_userPointer_get(void *c) {
	::btCollisionShape *o = (::btCollisionShape*)c;
	return (void*)(o->m_userPointer);
}


// ::btCollisionShapeData
//constructor: btCollisionShapeData  ( ::btCollisionShapeData::* )(  ) 
void* btCollisionShapeData_new() {
	::btCollisionShapeData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCollisionShapeData),16);
	o = new (mem)::btCollisionShapeData();
	return (void*)o;
}
void btCollisionShapeData_free(void *c) {
	::btCollisionShapeData *o = (::btCollisionShapeData*)c;
	delete o;
}
//attribute: char * btCollisionShapeData->m_name
void btCollisionShapeData_m_name_set(void *c,char * a) {
	::btCollisionShapeData *o = (::btCollisionShapeData*)c;
	o->m_name = a;
}
char * btCollisionShapeData_m_name_get(void *c) {
	::btCollisionShapeData *o = (::btCollisionShapeData*)c;
	return (char *)(o->m_name);
}

//attribute: int btCollisionShapeData->m_shapeType
void btCollisionShapeData_m_shapeType_set(void *c,int a) {
	::btCollisionShapeData *o = (::btCollisionShapeData*)c;
	o->m_shapeType = a;
}
int btCollisionShapeData_m_shapeType_get(void *c) {
	::btCollisionShapeData *o = (::btCollisionShapeData*)c;
	return (int)(o->m_shapeType);
}

//attribute: char[4] btCollisionShapeData->m_padding
// attribute not supported: //attribute: char[4] btCollisionShapeData->m_padding

// ::btCompoundShape
//constructor: btCompoundShape  ( ::btCompoundShape::* )( bool ) 
void* btCompoundShape_new(int p0) {
	::btCompoundShape *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCompoundShape),16);
	o = new (mem)::btCompoundShape(p0);
	return (void*)o;
}
void btCompoundShape_free(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	delete o;
}
//method: calculateLocalInertia void ( ::btCompoundShape::* )( ::btScalar,::btVector3 & ) const
void btCompoundShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getDynamicAabbTree ::btDbvt const * ( ::btCompoundShape::* )(  ) const
void* btCompoundShape_getDynamicAabbTree(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	void* retVal = (void*) o->getDynamicAabbTree();
	return retVal;
}
//method: getDynamicAabbTree ::btDbvt const * ( ::btCompoundShape::* )(  ) const
void* btCompoundShape_getDynamicAabbTree0(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	void* retVal = (void*) o->getDynamicAabbTree();
	return retVal;
}
//method: getDynamicAabbTree ::btDbvt * ( ::btCompoundShape::* )(  ) 
void* btCompoundShape_getDynamicAabbTree1(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	void* retVal = (void*) o->getDynamicAabbTree();
	return retVal;
}
//method: getUpdateRevision int ( ::btCompoundShape::* )(  ) const
int btCompoundShape_getUpdateRevision(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	int retVal = (int)o->getUpdateRevision();
	return retVal;
}
//method: serialize char const * ( ::btCompoundShape::* )( void *,::btSerializer * ) const
char const * btCompoundShape_serialize(void *c,void* p0,void* p1) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: getLocalScaling ::btVector3 const & ( ::btCompoundShape::* )(  ) const
void btCompoundShape_getLocalScaling(void *c,float* ret) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLocalScaling();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: createAabbTreeFromChildren void ( ::btCompoundShape::* )(  ) 
void btCompoundShape_createAabbTreeFromChildren(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	o->createAabbTreeFromChildren();
}
//method: calculateSerializeBufferSize int ( ::btCompoundShape::* )(  ) const
int btCompoundShape_calculateSerializeBufferSize(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: getName char const * ( ::btCompoundShape::* )(  ) const
char const * btCompoundShape_getName(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: setLocalScaling void ( ::btCompoundShape::* )( ::btVector3 const & ) 
void btCompoundShape_setLocalScaling(void *c,float* p0) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getAabb void ( ::btCompoundShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btCompoundShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getChildShape ::btCollisionShape * ( ::btCompoundShape::* )( int ) 
void* btCompoundShape_getChildShape(void *c,int p0) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	void* retVal = (void*) o->getChildShape(p0);
	return retVal;
}
//method: getChildShape ::btCollisionShape * ( ::btCompoundShape::* )( int ) 
void* btCompoundShape_getChildShape0(void *c,int p0) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	void* retVal = (void*) o->getChildShape(p0);
	return retVal;
}
//method: getChildShape ::btCollisionShape const * ( ::btCompoundShape::* )( int ) const
void* btCompoundShape_getChildShape1(void *c,int p0) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	void* retVal = (void*) o->getChildShape(p0);
	return retVal;
}
//method: addChildShape void ( ::btCompoundShape::* )( ::btTransform const &,::btCollisionShape * ) 
void btCompoundShape_addChildShape(void *c,float* p0,void* p1) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	::btCollisionShape * tp1 = (::btCollisionShape *)p1;
	o->addChildShape(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//method: getChildTransform ::btTransform & ( ::btCompoundShape::* )( int ) 
void btCompoundShape_getChildTransform(void *c,int p0,float* ret) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getChildTransform(p0);
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getChildTransform ::btTransform & ( ::btCompoundShape::* )( int ) 
void btCompoundShape_getChildTransform0(void *c,int p0,float* ret) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getChildTransform(p0);
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getChildTransform ::btTransform const & ( ::btCompoundShape::* )( int ) const
void btCompoundShape_getChildTransform1(void *c,int p0,float* ret) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getChildTransform(p0);
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getChildList ::btCompoundShapeChild * ( ::btCompoundShape::* )(  ) 
void* btCompoundShape_getChildList(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	void* retVal = (void*) o->getChildList();
	return retVal;
}
//method: getMargin ::btScalar ( ::btCompoundShape::* )(  ) const
float btCompoundShape_getMargin(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	float retVal = (float)o->getMargin();
	return retVal;
}
//method: setMargin void ( ::btCompoundShape::* )( ::btScalar ) 
void btCompoundShape_setMargin(void *c,float p0) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	o->setMargin(p0);
}
//method: getNumChildShapes int ( ::btCompoundShape::* )(  ) const
int btCompoundShape_getNumChildShapes(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	int retVal = (int)o->getNumChildShapes();
	return retVal;
}
//method: removeChildShapeByIndex void ( ::btCompoundShape::* )( int ) 
void btCompoundShape_removeChildShapeByIndex(void *c,int p0) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	o->removeChildShapeByIndex(p0);
}
//method: recalculateLocalAabb void ( ::btCompoundShape::* )(  ) 
void btCompoundShape_recalculateLocalAabb(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	o->recalculateLocalAabb();
}
//method: updateChildTransform void ( ::btCompoundShape::* )( int,::btTransform const &,bool ) 
void btCompoundShape_updateChildTransform(void *c,int p0,float* p1,int p2) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->updateChildTransform(p0,tp1,p2);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//not supported method: calculatePrincipalAxisTransform void ( ::btCompoundShape::* )( ::btScalar *,::btTransform &,::btVector3 & ) const
// error:  - unsupported, ::btTransform & - ok, ::btVector3 & - ok, void - ok

//method: removeChildShape void ( ::btCompoundShape::* )( ::btCollisionShape * ) 
void btCompoundShape_removeChildShape(void *c,void* p0) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	::btCollisionShape * tp0 = (::btCollisionShape *)p0;
	o->removeChildShape(tp0);
}
//attribute: ::btAlignedObjectArray<btCompoundShapeChild> btCompoundShape->m_children
void btCompoundShape_m_children_set(void *c,void* a) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	::btAlignedObjectArray<btCompoundShapeChild> & ta = *(::btAlignedObjectArray<btCompoundShapeChild> *)a;
	o->m_children = ta;
}
void* btCompoundShape_m_children_get(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	return (void*)&(o->m_children);
}

//attribute: ::btVector3 btCompoundShape->m_localAabbMin
void btCompoundShape_m_localAabbMin_set(void *c,float* a) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localAabbMin = ta;
}
void btCompoundShape_m_localAabbMin_get(void *c,float* a) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	a[0]=(o->m_localAabbMin).m_floats[0];a[1]=(o->m_localAabbMin).m_floats[1];a[2]=(o->m_localAabbMin).m_floats[2];
}

//attribute: ::btVector3 btCompoundShape->m_localAabbMax
void btCompoundShape_m_localAabbMax_set(void *c,float* a) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localAabbMax = ta;
}
void btCompoundShape_m_localAabbMax_get(void *c,float* a) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	a[0]=(o->m_localAabbMax).m_floats[0];a[1]=(o->m_localAabbMax).m_floats[1];a[2]=(o->m_localAabbMax).m_floats[2];
}

//attribute: ::btDbvt * btCompoundShape->m_dynamicAabbTree
void btCompoundShape_m_dynamicAabbTree_set(void *c,void* a) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	::btDbvt * ta = (::btDbvt *)a;
	o->m_dynamicAabbTree = ta;
}
void* btCompoundShape_m_dynamicAabbTree_get(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	return (void*)(o->m_dynamicAabbTree);
}

//attribute: int btCompoundShape->m_updateRevision
void btCompoundShape_m_updateRevision_set(void *c,int a) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	o->m_updateRevision = a;
}
int btCompoundShape_m_updateRevision_get(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	return (int)(o->m_updateRevision);
}

//attribute: ::btScalar btCompoundShape->m_collisionMargin
void btCompoundShape_m_collisionMargin_set(void *c,float a) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	o->m_collisionMargin = a;
}
float btCompoundShape_m_collisionMargin_get(void *c) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	return (float)(o->m_collisionMargin);
}

//attribute: ::btVector3 btCompoundShape->m_localScaling
void btCompoundShape_m_localScaling_set(void *c,float* a) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localScaling = ta;
}
void btCompoundShape_m_localScaling_get(void *c,float* a) {
	::btCompoundShape *o = (::btCompoundShape*)c;
	a[0]=(o->m_localScaling).m_floats[0];a[1]=(o->m_localScaling).m_floats[1];a[2]=(o->m_localScaling).m_floats[2];
}


// ::btCompoundShapeChild
//constructor: btCompoundShapeChild  ( ::btCompoundShapeChild::* )(  ) 
void* btCompoundShapeChild_new() {
	::btCompoundShapeChild *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCompoundShapeChild),16);
	o = new (mem)::btCompoundShapeChild();
	return (void*)o;
}
void btCompoundShapeChild_free(void *c) {
	::btCompoundShapeChild *o = (::btCompoundShapeChild*)c;
	delete o;
}
//attribute: ::btScalar btCompoundShapeChild->m_childMargin
void btCompoundShapeChild_m_childMargin_set(void *c,float a) {
	::btCompoundShapeChild *o = (::btCompoundShapeChild*)c;
	o->m_childMargin = a;
}
float btCompoundShapeChild_m_childMargin_get(void *c) {
	::btCompoundShapeChild *o = (::btCompoundShapeChild*)c;
	return (float)(o->m_childMargin);
}

//attribute: ::btCollisionShape * btCompoundShapeChild->m_childShape
void btCompoundShapeChild_m_childShape_set(void *c,void* a) {
	::btCompoundShapeChild *o = (::btCompoundShapeChild*)c;
	::btCollisionShape * ta = (::btCollisionShape *)a;
	o->m_childShape = ta;
}
void* btCompoundShapeChild_m_childShape_get(void *c) {
	::btCompoundShapeChild *o = (::btCompoundShapeChild*)c;
	return (void*)(o->m_childShape);
}

//attribute: int btCompoundShapeChild->m_childShapeType
void btCompoundShapeChild_m_childShapeType_set(void *c,int a) {
	::btCompoundShapeChild *o = (::btCompoundShapeChild*)c;
	o->m_childShapeType = a;
}
int btCompoundShapeChild_m_childShapeType_get(void *c) {
	::btCompoundShapeChild *o = (::btCompoundShapeChild*)c;
	return (int)(o->m_childShapeType);
}

//attribute: ::btDbvtNode * btCompoundShapeChild->m_node
void btCompoundShapeChild_m_node_set(void *c,void* a) {
	::btCompoundShapeChild *o = (::btCompoundShapeChild*)c;
	::btDbvtNode * ta = (::btDbvtNode *)a;
	o->m_node = ta;
}
void* btCompoundShapeChild_m_node_get(void *c) {
	::btCompoundShapeChild *o = (::btCompoundShapeChild*)c;
	return (void*)(o->m_node);
}

//attribute: ::btTransform btCompoundShapeChild->m_transform
void btCompoundShapeChild_m_transform_set(void *c,float* a) {
	::btCompoundShapeChild *o = (::btCompoundShapeChild*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_transform = ta;
}
void btCompoundShapeChild_m_transform_get(void *c,float* a) {
	::btCompoundShapeChild *o = (::btCompoundShapeChild*)c;
	a[0]=(o->m_transform).getBasis().getRow(0).m_floats[0];a[1]=(o->m_transform).getBasis().getRow(0).m_floats[1];a[2]=(o->m_transform).getBasis().getRow(0).m_floats[2];a[3]=(o->m_transform).getBasis().getRow(1).m_floats[0];a[4]=(o->m_transform).getBasis().getRow(1).m_floats[1];a[5]=(o->m_transform).getBasis().getRow(1).m_floats[2];a[6]=(o->m_transform).getBasis().getRow(2).m_floats[0];a[7]=(o->m_transform).getBasis().getRow(2).m_floats[1];a[8]=(o->m_transform).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_transform).getOrigin().m_floats[0];a[10]=(o->m_transform).getOrigin().m_floats[1];a[11]=(o->m_transform).getOrigin().m_floats[2];
}


// ::btCompoundShapeChildData
//constructor: btCompoundShapeChildData  ( ::btCompoundShapeChildData::* )(  ) 
void* btCompoundShapeChildData_new() {
	::btCompoundShapeChildData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCompoundShapeChildData),16);
	o = new (mem)::btCompoundShapeChildData();
	return (void*)o;
}
void btCompoundShapeChildData_free(void *c) {
	::btCompoundShapeChildData *o = (::btCompoundShapeChildData*)c;
	delete o;
}
//attribute: ::btTransformFloatData btCompoundShapeChildData->m_transform
void btCompoundShapeChildData_m_transform_set(void *c,void* a) {
	::btCompoundShapeChildData *o = (::btCompoundShapeChildData*)c;
	::btTransformFloatData & ta = *(::btTransformFloatData *)a;
	o->m_transform = ta;
}
void* btCompoundShapeChildData_m_transform_get(void *c) {
	::btCompoundShapeChildData *o = (::btCompoundShapeChildData*)c;
	return (void*)&(o->m_transform);
}

//attribute: ::btCollisionShapeData * btCompoundShapeChildData->m_childShape
void btCompoundShapeChildData_m_childShape_set(void *c,void* a) {
	::btCompoundShapeChildData *o = (::btCompoundShapeChildData*)c;
	::btCollisionShapeData * ta = (::btCollisionShapeData *)a;
	o->m_childShape = ta;
}
void* btCompoundShapeChildData_m_childShape_get(void *c) {
	::btCompoundShapeChildData *o = (::btCompoundShapeChildData*)c;
	return (void*)(o->m_childShape);
}

//attribute: int btCompoundShapeChildData->m_childShapeType
void btCompoundShapeChildData_m_childShapeType_set(void *c,int a) {
	::btCompoundShapeChildData *o = (::btCompoundShapeChildData*)c;
	o->m_childShapeType = a;
}
int btCompoundShapeChildData_m_childShapeType_get(void *c) {
	::btCompoundShapeChildData *o = (::btCompoundShapeChildData*)c;
	return (int)(o->m_childShapeType);
}

//attribute: float btCompoundShapeChildData->m_childMargin
void btCompoundShapeChildData_m_childMargin_set(void *c,float a) {
	::btCompoundShapeChildData *o = (::btCompoundShapeChildData*)c;
	o->m_childMargin = a;
}
float btCompoundShapeChildData_m_childMargin_get(void *c) {
	::btCompoundShapeChildData *o = (::btCompoundShapeChildData*)c;
	return (float)(o->m_childMargin);
}


// ::btCompoundShapeData
//constructor: btCompoundShapeData  ( ::btCompoundShapeData::* )(  ) 
void* btCompoundShapeData_new() {
	::btCompoundShapeData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCompoundShapeData),16);
	o = new (mem)::btCompoundShapeData();
	return (void*)o;
}
void btCompoundShapeData_free(void *c) {
	::btCompoundShapeData *o = (::btCompoundShapeData*)c;
	delete o;
}
//attribute: ::btCollisionShapeData btCompoundShapeData->m_collisionShapeData
void btCompoundShapeData_m_collisionShapeData_set(void *c,void* a) {
	::btCompoundShapeData *o = (::btCompoundShapeData*)c;
	::btCollisionShapeData & ta = *(::btCollisionShapeData *)a;
	o->m_collisionShapeData = ta;
}
void* btCompoundShapeData_m_collisionShapeData_get(void *c) {
	::btCompoundShapeData *o = (::btCompoundShapeData*)c;
	return (void*)&(o->m_collisionShapeData);
}

//attribute: ::btCompoundShapeChildData * btCompoundShapeData->m_childShapePtr
void btCompoundShapeData_m_childShapePtr_set(void *c,void* a) {
	::btCompoundShapeData *o = (::btCompoundShapeData*)c;
	::btCompoundShapeChildData * ta = (::btCompoundShapeChildData *)a;
	o->m_childShapePtr = ta;
}
void* btCompoundShapeData_m_childShapePtr_get(void *c) {
	::btCompoundShapeData *o = (::btCompoundShapeData*)c;
	return (void*)(o->m_childShapePtr);
}

//attribute: int btCompoundShapeData->m_numChildShapes
void btCompoundShapeData_m_numChildShapes_set(void *c,int a) {
	::btCompoundShapeData *o = (::btCompoundShapeData*)c;
	o->m_numChildShapes = a;
}
int btCompoundShapeData_m_numChildShapes_get(void *c) {
	::btCompoundShapeData *o = (::btCompoundShapeData*)c;
	return (int)(o->m_numChildShapes);
}

//attribute: float btCompoundShapeData->m_collisionMargin
void btCompoundShapeData_m_collisionMargin_set(void *c,float a) {
	::btCompoundShapeData *o = (::btCompoundShapeData*)c;
	o->m_collisionMargin = a;
}
float btCompoundShapeData_m_collisionMargin_get(void *c) {
	::btCompoundShapeData *o = (::btCompoundShapeData*)c;
	return (float)(o->m_collisionMargin);
}


// ::btConcaveShape
//method: processAllTriangles void ( ::btConcaveShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
void btConcaveShape_processAllTriangles(void *c,void* p0,float* p1,float* p2) {
	::btConcaveShape *o = (::btConcaveShape*)c;
	::btTriangleCallback * tp0 = (::btTriangleCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->processAllTriangles(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: setMargin void ( ::btConcaveShape::* )( ::btScalar ) 
void btConcaveShape_setMargin(void *c,float p0) {
	::btConcaveShape *o = (::btConcaveShape*)c;
	o->setMargin(p0);
}
//method: getMargin ::btScalar ( ::btConcaveShape::* )(  ) const
float btConcaveShape_getMargin(void *c) {
	::btConcaveShape *o = (::btConcaveShape*)c;
	float retVal = (float)o->getMargin();
	return retVal;
}
//attribute: ::btScalar btConcaveShape->m_collisionMargin
void btConcaveShape_m_collisionMargin_set(void *c,float a) {
	::btConcaveShape *o = (::btConcaveShape*)c;
	o->m_collisionMargin = a;
}
float btConcaveShape_m_collisionMargin_get(void *c) {
	::btConcaveShape *o = (::btConcaveShape*)c;
	return (float)(o->m_collisionMargin);
}


// ::btConeShape
//constructor: btConeShape  ( ::btConeShape::* )( ::btScalar,::btScalar ) 
void* btConeShape_new(float p0,float p1) {
	::btConeShape *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btConeShape),16);
	o = new (mem)::btConeShape(p0,p1);
	return (void*)o;
}
void btConeShape_free(void *c) {
	::btConeShape *o = (::btConeShape*)c;
	delete o;
}
//method: calculateLocalInertia void ( ::btConeShape::* )( ::btScalar,::btVector3 & ) const
void btConeShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btConeShape *o = (::btConeShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: localGetSupportingVertex ::btVector3 ( ::btConeShape::* )( ::btVector3 const & ) const
void btConeShape_localGetSupportingVertex(void *c,float* p0,float* ret) {
	::btConeShape *o = (::btConeShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertex(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btConeShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

//method: getConeUpIndex int ( ::btConeShape::* )(  ) const
int btConeShape_getConeUpIndex(void *c) {
	::btConeShape *o = (::btConeShape*)c;
	int retVal = (int)o->getConeUpIndex();
	return retVal;
}
//method: getName char const * ( ::btConeShape::* )(  ) const
char const * btConeShape_getName(void *c) {
	::btConeShape *o = (::btConeShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: getHeight ::btScalar ( ::btConeShape::* )(  ) const
float btConeShape_getHeight(void *c) {
	::btConeShape *o = (::btConeShape*)c;
	float retVal = (float)o->getHeight();
	return retVal;
}
//method: setConeUpIndex void ( ::btConeShape::* )( int ) 
void btConeShape_setConeUpIndex(void *c,int p0) {
	::btConeShape *o = (::btConeShape*)c;
	o->setConeUpIndex(p0);
}
//method: setLocalScaling void ( ::btConeShape::* )( ::btVector3 const & ) 
void btConeShape_setLocalScaling(void *c,float* p0) {
	::btConeShape *o = (::btConeShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btConeShape::* )( ::btVector3 const & ) const
void btConeShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret) {
	::btConeShape *o = (::btConeShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertexWithoutMargin(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getRadius ::btScalar ( ::btConeShape::* )(  ) const
float btConeShape_getRadius(void *c) {
	::btConeShape *o = (::btConeShape*)c;
	float retVal = (float)o->getRadius();
	return retVal;
}

// ::btConeShapeX
//constructor: btConeShapeX  ( ::btConeShapeX::* )( ::btScalar,::btScalar ) 
void* btConeShapeX_new(float p0,float p1) {
	::btConeShapeX *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btConeShapeX),16);
	o = new (mem)::btConeShapeX(p0,p1);
	return (void*)o;
}
void btConeShapeX_free(void *c) {
	::btConeShapeX *o = (::btConeShapeX*)c;
	delete o;
}

// ::btConeShapeZ
//constructor: btConeShapeZ  ( ::btConeShapeZ::* )( ::btScalar,::btScalar ) 
void* btConeShapeZ_new(float p0,float p1) {
	::btConeShapeZ *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btConeShapeZ),16);
	o = new (mem)::btConeShapeZ(p0,p1);
	return (void*)o;
}
void btConeShapeZ_free(void *c) {
	::btConeShapeZ *o = (::btConeShapeZ*)c;
	delete o;
}

// ::btConvexHullShape
//not supported constructor: btConvexHullShape  ( ::btConvexHullShape::* )( ::btScalar const *,int,int ) 
// error:  - unsupported, int - ok, int - ok

void btConvexHullShape_free(void *c) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	delete o;
}
//method: addPoint void ( ::btConvexHullShape::* )( ::btVector3 const & ) 
void btConvexHullShape_addPoint(void *c,float* p0) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->addPoint(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: localGetSupportingVertex ::btVector3 ( ::btConvexHullShape::* )( ::btVector3 const & ) const
void btConvexHullShape_localGetSupportingVertex(void *c,float* p0,float* ret) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertex(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: calculateSerializeBufferSize int ( ::btConvexHullShape::* )(  ) const
int btConvexHullShape_calculateSerializeBufferSize(void *c) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btConvexHullShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

//method: getScaledPoint ::btVector3 ( ::btConvexHullShape::* )( int ) const
void btConvexHullShape_getScaledPoint(void *c,int p0,float* ret) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getScaledPoint(p0);
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getNumPlanes int ( ::btConvexHullShape::* )(  ) const
int btConvexHullShape_getNumPlanes(void *c) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	int retVal = (int)o->getNumPlanes();
	return retVal;
}
//not supported method: getPoints ::btVector3 const * ( ::btConvexHullShape::* )(  ) const
// error:  - unsupported

//method: getNumEdges int ( ::btConvexHullShape::* )(  ) const
int btConvexHullShape_getNumEdges(void *c) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	int retVal = (int)o->getNumEdges();
	return retVal;
}
//method: getName char const * ( ::btConvexHullShape::* )(  ) const
char const * btConvexHullShape_getName(void *c) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: getVertex void ( ::btConvexHullShape::* )( int,::btVector3 & ) const
void btConvexHullShape_getVertex(void *c,int p0,float* p1) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getVertex(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getEdge void ( ::btConvexHullShape::* )( int,::btVector3 &,::btVector3 & ) const
void btConvexHullShape_getEdge(void *c,int p0,float* p1,float* p2) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getEdge(p0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btConvexHullShape::* )( ::btVector3 const & ) const
void btConvexHullShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertexWithoutMargin(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//not supported method: project void ( ::btConvexHullShape::* )( ::btTransform const &,::btVector3 const &,float &,float & ) const
// error: ::btTransform const & - ok, ::btVector3 const & - ok,  - unsupported,  - unsupported, void - ok

//method: isInside bool ( ::btConvexHullShape::* )( ::btVector3 const &,::btScalar ) const
int btConvexHullShape_isInside(void *c,float* p0,float p1) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	int retVal = (int)o->isInside(tp0,p1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return retVal;
}
//method: getPlane void ( ::btConvexHullShape::* )( ::btVector3 &,::btVector3 &,int ) const
void btConvexHullShape_getPlane(void *c,float* p0,float* p1,int p2) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getPlane(tp0,tp1,p2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: setLocalScaling void ( ::btConvexHullShape::* )( ::btVector3 const & ) 
void btConvexHullShape_setLocalScaling(void *c,float* p0) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getNumVertices int ( ::btConvexHullShape::* )(  ) const
int btConvexHullShape_getNumVertices(void *c) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	int retVal = (int)o->getNumVertices();
	return retVal;
}
//method: serialize char const * ( ::btConvexHullShape::* )( void *,::btSerializer * ) const
char const * btConvexHullShape_serialize(void *c,void* p0,void* p1) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: getNumPoints int ( ::btConvexHullShape::* )(  ) const
int btConvexHullShape_getNumPoints(void *c) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	int retVal = (int)o->getNumPoints();
	return retVal;
}
//not supported method: getUnscaledPoints ::btVector3 * ( ::btConvexHullShape::* )(  ) 
// error:  - unsupported

//not supported method: getUnscaledPoints ::btVector3 * ( ::btConvexHullShape::* )(  ) 
// error:  - unsupported

//not supported method: getUnscaledPoints ::btVector3 const * ( ::btConvexHullShape::* )(  ) const
// error:  - unsupported

//attribute: ::btAlignedObjectArray<btVector3> btConvexHullShape->m_unscaledPoints
void btConvexHullShape_m_unscaledPoints_set(void *c,void* a) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	::btAlignedObjectArray<btVector3> & ta = *(::btAlignedObjectArray<btVector3> *)a;
	o->m_unscaledPoints = ta;
}
void* btConvexHullShape_m_unscaledPoints_get(void *c) {
	::btConvexHullShape *o = (::btConvexHullShape*)c;
	return (void*)&(o->m_unscaledPoints);
}


// ::btConvexHullShapeData
//constructor: btConvexHullShapeData  ( ::btConvexHullShapeData::* )(  ) 
void* btConvexHullShapeData_new() {
	::btConvexHullShapeData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btConvexHullShapeData),16);
	o = new (mem)::btConvexHullShapeData();
	return (void*)o;
}
void btConvexHullShapeData_free(void *c) {
	::btConvexHullShapeData *o = (::btConvexHullShapeData*)c;
	delete o;
}
//attribute: ::btConvexInternalShapeData btConvexHullShapeData->m_convexInternalShapeData
void btConvexHullShapeData_m_convexInternalShapeData_set(void *c,void* a) {
	::btConvexHullShapeData *o = (::btConvexHullShapeData*)c;
	::btConvexInternalShapeData & ta = *(::btConvexInternalShapeData *)a;
	o->m_convexInternalShapeData = ta;
}
void* btConvexHullShapeData_m_convexInternalShapeData_get(void *c) {
	::btConvexHullShapeData *o = (::btConvexHullShapeData*)c;
	return (void*)&(o->m_convexInternalShapeData);
}

//attribute: ::btVector3FloatData * btConvexHullShapeData->m_unscaledPointsFloatPtr
void btConvexHullShapeData_m_unscaledPointsFloatPtr_set(void *c,void* a) {
	::btConvexHullShapeData *o = (::btConvexHullShapeData*)c;
	::btVector3FloatData * ta = (::btVector3FloatData *)a;
	o->m_unscaledPointsFloatPtr = ta;
}
void* btConvexHullShapeData_m_unscaledPointsFloatPtr_get(void *c) {
	::btConvexHullShapeData *o = (::btConvexHullShapeData*)c;
	return (void*)(o->m_unscaledPointsFloatPtr);
}

//attribute: ::btVector3DoubleData * btConvexHullShapeData->m_unscaledPointsDoublePtr
void btConvexHullShapeData_m_unscaledPointsDoublePtr_set(void *c,void* a) {
	::btConvexHullShapeData *o = (::btConvexHullShapeData*)c;
	::btVector3DoubleData * ta = (::btVector3DoubleData *)a;
	o->m_unscaledPointsDoublePtr = ta;
}
void* btConvexHullShapeData_m_unscaledPointsDoublePtr_get(void *c) {
	::btConvexHullShapeData *o = (::btConvexHullShapeData*)c;
	return (void*)(o->m_unscaledPointsDoublePtr);
}

//attribute: int btConvexHullShapeData->m_numUnscaledPoints
void btConvexHullShapeData_m_numUnscaledPoints_set(void *c,int a) {
	::btConvexHullShapeData *o = (::btConvexHullShapeData*)c;
	o->m_numUnscaledPoints = a;
}
int btConvexHullShapeData_m_numUnscaledPoints_get(void *c) {
	::btConvexHullShapeData *o = (::btConvexHullShapeData*)c;
	return (int)(o->m_numUnscaledPoints);
}

//attribute: char[4] btConvexHullShapeData->m_padding3
// attribute not supported: //attribute: char[4] btConvexHullShapeData->m_padding3

// ::btConvexInternalAabbCachingShape
//method: setCachedLocalAabb void ( ::btConvexInternalAabbCachingShape::* )( ::btVector3 const &,::btVector3 const & ) 
void btConvexInternalAabbCachingShape_setCachedLocalAabb(void *c,float* p0,float* p1) {
	::btConvexInternalAabbCachingShape *o = (::btConvexInternalAabbCachingShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->setCachedLocalAabb(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: recalcLocalAabb void ( ::btConvexInternalAabbCachingShape::* )(  ) 
void btConvexInternalAabbCachingShape_recalcLocalAabb(void *c) {
	::btConvexInternalAabbCachingShape *o = (::btConvexInternalAabbCachingShape*)c;
	o->recalcLocalAabb();
}
//method: setLocalScaling void ( ::btConvexInternalAabbCachingShape::* )( ::btVector3 const & ) 
void btConvexInternalAabbCachingShape_setLocalScaling(void *c,float* p0) {
	::btConvexInternalAabbCachingShape *o = (::btConvexInternalAabbCachingShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getNonvirtualAabb void ( ::btConvexInternalAabbCachingShape::* )( ::btTransform const &,::btVector3 &,::btVector3 &,::btScalar ) const
void btConvexInternalAabbCachingShape_getNonvirtualAabb(void *c,float* p0,float* p1,float* p2,float p3) {
	::btConvexInternalAabbCachingShape *o = (::btConvexInternalAabbCachingShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getNonvirtualAabb(tp0,tp1,tp2,p3);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getCachedLocalAabb void ( ::btConvexInternalAabbCachingShape::* )( ::btVector3 &,::btVector3 & ) const
void btConvexInternalAabbCachingShape_getCachedLocalAabb(void *c,float* p0,float* p1) {
	::btConvexInternalAabbCachingShape *o = (::btConvexInternalAabbCachingShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getCachedLocalAabb(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getAabb void ( ::btConvexInternalAabbCachingShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btConvexInternalAabbCachingShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btConvexInternalAabbCachingShape *o = (::btConvexInternalAabbCachingShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//attribute: ::btVector3 btConvexInternalAabbCachingShape->m_localAabbMin
void btConvexInternalAabbCachingShape_m_localAabbMin_set(void *c,float* a) {
	::btConvexInternalAabbCachingShape *o = (::btConvexInternalAabbCachingShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localAabbMin = ta;
}
void btConvexInternalAabbCachingShape_m_localAabbMin_get(void *c,float* a) {
	::btConvexInternalAabbCachingShape *o = (::btConvexInternalAabbCachingShape*)c;
	a[0]=(o->m_localAabbMin).m_floats[0];a[1]=(o->m_localAabbMin).m_floats[1];a[2]=(o->m_localAabbMin).m_floats[2];
}

//attribute: ::btVector3 btConvexInternalAabbCachingShape->m_localAabbMax
void btConvexInternalAabbCachingShape_m_localAabbMax_set(void *c,float* a) {
	::btConvexInternalAabbCachingShape *o = (::btConvexInternalAabbCachingShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localAabbMax = ta;
}
void btConvexInternalAabbCachingShape_m_localAabbMax_get(void *c,float* a) {
	::btConvexInternalAabbCachingShape *o = (::btConvexInternalAabbCachingShape*)c;
	a[0]=(o->m_localAabbMax).m_floats[0];a[1]=(o->m_localAabbMax).m_floats[1];a[2]=(o->m_localAabbMax).m_floats[2];
}

//attribute: bool btConvexInternalAabbCachingShape->m_isLocalAabbValid
void btConvexInternalAabbCachingShape_m_isLocalAabbValid_set(void *c,int a) {
	::btConvexInternalAabbCachingShape *o = (::btConvexInternalAabbCachingShape*)c;
	o->m_isLocalAabbValid = a;
}
int btConvexInternalAabbCachingShape_m_isLocalAabbValid_get(void *c) {
	::btConvexInternalAabbCachingShape *o = (::btConvexInternalAabbCachingShape*)c;
	return (int)(o->m_isLocalAabbValid);
}


// ::btConvexInternalShape
//method: localGetSupportingVertex ::btVector3 ( ::btConvexInternalShape::* )( ::btVector3 const & ) const
void btConvexInternalShape_localGetSupportingVertex(void *c,float* p0,float* ret) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertex(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: calculateSerializeBufferSize int ( ::btConvexInternalShape::* )(  ) const
int btConvexInternalShape_calculateSerializeBufferSize(void *c) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: getImplicitShapeDimensions ::btVector3 const & ( ::btConvexInternalShape::* )(  ) const
void btConvexInternalShape_getImplicitShapeDimensions(void *c,float* ret) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getImplicitShapeDimensions();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: serialize char const * ( ::btConvexInternalShape::* )( void *,::btSerializer * ) const
char const * btConvexInternalShape_serialize(void *c,void* p0,void* p1) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: getLocalScalingNV ::btVector3 const & ( ::btConvexInternalShape::* )(  ) const
void btConvexInternalShape_getLocalScalingNV(void *c,float* ret) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLocalScalingNV();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getAabbSlow void ( ::btConvexInternalShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btConvexInternalShape_getAabbSlow(void *c,float* p0,float* p1,float* p2) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabbSlow(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getLocalScaling ::btVector3 const & ( ::btConvexInternalShape::* )(  ) const
void btConvexInternalShape_getLocalScaling(void *c,float* ret) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLocalScaling();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getPreferredPenetrationDirection void ( ::btConvexInternalShape::* )( int,::btVector3 & ) const
void btConvexInternalShape_getPreferredPenetrationDirection(void *c,int p0,float* p1) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getPreferredPenetrationDirection(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: setLocalScaling void ( ::btConvexInternalShape::* )( ::btVector3 const & ) 
void btConvexInternalShape_setLocalScaling(void *c,float* p0) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getNumPreferredPenetrationDirections int ( ::btConvexInternalShape::* )(  ) const
int btConvexInternalShape_getNumPreferredPenetrationDirections(void *c) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	int retVal = (int)o->getNumPreferredPenetrationDirections();
	return retVal;
}
//method: getAabb void ( ::btConvexInternalShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btConvexInternalShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: setMargin void ( ::btConvexInternalShape::* )( ::btScalar ) 
void btConvexInternalShape_setMargin(void *c,float p0) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	o->setMargin(p0);
}
//method: getMarginNV ::btScalar ( ::btConvexInternalShape::* )(  ) const
float btConvexInternalShape_getMarginNV(void *c) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	float retVal = (float)o->getMarginNV();
	return retVal;
}
//method: getMargin ::btScalar ( ::btConvexInternalShape::* )(  ) const
float btConvexInternalShape_getMargin(void *c) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	float retVal = (float)o->getMargin();
	return retVal;
}
//method: setSafeMargin void ( ::btConvexInternalShape::* )( ::btScalar,::btScalar ) 
void btConvexInternalShape_setSafeMargin(void *c,float p0,float p1) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	o->setSafeMargin(p0,p1);
}
//method: setSafeMargin void ( ::btConvexInternalShape::* )( ::btScalar,::btScalar ) 
void btConvexInternalShape_setSafeMargin0(void *c,float p0,float p1) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	o->setSafeMargin(p0,p1);
}
//method: setSafeMargin void ( ::btConvexInternalShape::* )( ::btVector3 const &,::btScalar ) 
void btConvexInternalShape_setSafeMargin1(void *c,float* p0,float p1) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setSafeMargin(tp0,p1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: setImplicitShapeDimensions void ( ::btConvexInternalShape::* )( ::btVector3 const & ) 
void btConvexInternalShape_setImplicitShapeDimensions(void *c,float* p0) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setImplicitShapeDimensions(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//attribute: ::btVector3 btConvexInternalShape->m_localScaling
void btConvexInternalShape_m_localScaling_set(void *c,float* a) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localScaling = ta;
}
void btConvexInternalShape_m_localScaling_get(void *c,float* a) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	a[0]=(o->m_localScaling).m_floats[0];a[1]=(o->m_localScaling).m_floats[1];a[2]=(o->m_localScaling).m_floats[2];
}

//attribute: ::btVector3 btConvexInternalShape->m_implicitShapeDimensions
void btConvexInternalShape_m_implicitShapeDimensions_set(void *c,float* a) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_implicitShapeDimensions = ta;
}
void btConvexInternalShape_m_implicitShapeDimensions_get(void *c,float* a) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	a[0]=(o->m_implicitShapeDimensions).m_floats[0];a[1]=(o->m_implicitShapeDimensions).m_floats[1];a[2]=(o->m_implicitShapeDimensions).m_floats[2];
}

//attribute: ::btScalar btConvexInternalShape->m_collisionMargin
void btConvexInternalShape_m_collisionMargin_set(void *c,float a) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	o->m_collisionMargin = a;
}
float btConvexInternalShape_m_collisionMargin_get(void *c) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	return (float)(o->m_collisionMargin);
}

//attribute: ::btScalar btConvexInternalShape->m_padding
void btConvexInternalShape_m_padding_set(void *c,float a) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	o->m_padding = a;
}
float btConvexInternalShape_m_padding_get(void *c) {
	::btConvexInternalShape *o = (::btConvexInternalShape*)c;
	return (float)(o->m_padding);
}


// ::btConvexInternalShapeData
//constructor: btConvexInternalShapeData  ( ::btConvexInternalShapeData::* )(  ) 
void* btConvexInternalShapeData_new() {
	::btConvexInternalShapeData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btConvexInternalShapeData),16);
	o = new (mem)::btConvexInternalShapeData();
	return (void*)o;
}
void btConvexInternalShapeData_free(void *c) {
	::btConvexInternalShapeData *o = (::btConvexInternalShapeData*)c;
	delete o;
}
//attribute: float btConvexInternalShapeData->m_collisionMargin
void btConvexInternalShapeData_m_collisionMargin_set(void *c,float a) {
	::btConvexInternalShapeData *o = (::btConvexInternalShapeData*)c;
	o->m_collisionMargin = a;
}
float btConvexInternalShapeData_m_collisionMargin_get(void *c) {
	::btConvexInternalShapeData *o = (::btConvexInternalShapeData*)c;
	return (float)(o->m_collisionMargin);
}

//attribute: ::btCollisionShapeData btConvexInternalShapeData->m_collisionShapeData
void btConvexInternalShapeData_m_collisionShapeData_set(void *c,void* a) {
	::btConvexInternalShapeData *o = (::btConvexInternalShapeData*)c;
	::btCollisionShapeData & ta = *(::btCollisionShapeData *)a;
	o->m_collisionShapeData = ta;
}
void* btConvexInternalShapeData_m_collisionShapeData_get(void *c) {
	::btConvexInternalShapeData *o = (::btConvexInternalShapeData*)c;
	return (void*)&(o->m_collisionShapeData);
}

//attribute: ::btVector3FloatData btConvexInternalShapeData->m_implicitShapeDimensions
void btConvexInternalShapeData_m_implicitShapeDimensions_set(void *c,void* a) {
	::btConvexInternalShapeData *o = (::btConvexInternalShapeData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_implicitShapeDimensions = ta;
}
void* btConvexInternalShapeData_m_implicitShapeDimensions_get(void *c) {
	::btConvexInternalShapeData *o = (::btConvexInternalShapeData*)c;
	return (void*)&(o->m_implicitShapeDimensions);
}

//attribute: ::btVector3FloatData btConvexInternalShapeData->m_localScaling
void btConvexInternalShapeData_m_localScaling_set(void *c,void* a) {
	::btConvexInternalShapeData *o = (::btConvexInternalShapeData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_localScaling = ta;
}
void* btConvexInternalShapeData_m_localScaling_get(void *c) {
	::btConvexInternalShapeData *o = (::btConvexInternalShapeData*)c;
	return (void*)&(o->m_localScaling);
}

//attribute: int btConvexInternalShapeData->m_padding
void btConvexInternalShapeData_m_padding_set(void *c,int a) {
	::btConvexInternalShapeData *o = (::btConvexInternalShapeData*)c;
	o->m_padding = a;
}
int btConvexInternalShapeData_m_padding_get(void *c) {
	::btConvexInternalShapeData *o = (::btConvexInternalShapeData*)c;
	return (int)(o->m_padding);
}


// ::btConvexShape
//method: getAabbNonVirtual void ( ::btConvexShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btConvexShape_getAabbNonVirtual(void *c,float* p0,float* p1,float* p2) {
	::btConvexShape *o = (::btConvexShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabbNonVirtual(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: localGetSupportingVertex ::btVector3 ( ::btConvexShape::* )( ::btVector3 const & ) const
void btConvexShape_localGetSupportingVertex(void *c,float* p0,float* ret) {
	::btConvexShape *o = (::btConvexShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertex(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btConvexShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

//method: getMargin ::btScalar ( ::btConvexShape::* )(  ) const
float btConvexShape_getMargin(void *c) {
	::btConvexShape *o = (::btConvexShape*)c;
	float retVal = (float)o->getMargin();
	return retVal;
}
//method: localGetSupportVertexWithoutMarginNonVirtual ::btVector3 ( ::btConvexShape::* )( ::btVector3 const & ) const
void btConvexShape_localGetSupportVertexWithoutMarginNonVirtual(void *c,float* p0,float* ret) {
	::btConvexShape *o = (::btConvexShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportVertexWithoutMarginNonVirtual(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getLocalScaling ::btVector3 const & ( ::btConvexShape::* )(  ) const
void btConvexShape_getLocalScaling(void *c,float* ret) {
	::btConvexShape *o = (::btConvexShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLocalScaling();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//not supported method: project void ( ::btConvexShape::* )( ::btTransform const &,::btVector3 const &,float &,float & ) const
// error: ::btTransform const & - ok, ::btVector3 const & - ok,  - unsupported,  - unsupported, void - ok

//method: getPreferredPenetrationDirection void ( ::btConvexShape::* )( int,::btVector3 & ) const
void btConvexShape_getPreferredPenetrationDirection(void *c,int p0,float* p1) {
	::btConvexShape *o = (::btConvexShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getPreferredPenetrationDirection(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: setLocalScaling void ( ::btConvexShape::* )( ::btVector3 const & ) 
void btConvexShape_setLocalScaling(void *c,float* p0) {
	::btConvexShape *o = (::btConvexShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getAabbSlow void ( ::btConvexShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btConvexShape_getAabbSlow(void *c,float* p0,float* p1,float* p2) {
	::btConvexShape *o = (::btConvexShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabbSlow(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getAabb void ( ::btConvexShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btConvexShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btConvexShape *o = (::btConvexShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: setMargin void ( ::btConvexShape::* )( ::btScalar ) 
void btConvexShape_setMargin(void *c,float p0) {
	::btConvexShape *o = (::btConvexShape*)c;
	o->setMargin(p0);
}
//method: getNumPreferredPenetrationDirections int ( ::btConvexShape::* )(  ) const
int btConvexShape_getNumPreferredPenetrationDirections(void *c) {
	::btConvexShape *o = (::btConvexShape*)c;
	int retVal = (int)o->getNumPreferredPenetrationDirections();
	return retVal;
}
//method: localGetSupportVertexNonVirtual ::btVector3 ( ::btConvexShape::* )( ::btVector3 const & ) const
void btConvexShape_localGetSupportVertexNonVirtual(void *c,float* p0,float* ret) {
	::btConvexShape *o = (::btConvexShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportVertexNonVirtual(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btConvexShape::* )( ::btVector3 const & ) const
void btConvexShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret) {
	::btConvexShape *o = (::btConvexShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertexWithoutMargin(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getMarginNonVirtual ::btScalar ( ::btConvexShape::* )(  ) const
float btConvexShape_getMarginNonVirtual(void *c) {
	::btConvexShape *o = (::btConvexShape*)c;
	float retVal = (float)o->getMarginNonVirtual();
	return retVal;
}

// ::btConvexTriangleMeshShape
//constructor: btConvexTriangleMeshShape  ( ::btConvexTriangleMeshShape::* )( ::btStridingMeshInterface *,bool ) 
void* btConvexTriangleMeshShape_new(void* p0,int p1) {
	::btConvexTriangleMeshShape *o = 0;
	 void *mem = 0;
	::btStridingMeshInterface * tp0 = (::btStridingMeshInterface *)p0;
	mem = btAlignedAlloc(sizeof(::btConvexTriangleMeshShape),16);
	o = new (mem)::btConvexTriangleMeshShape(tp0,p1);
	return (void*)o;
}
void btConvexTriangleMeshShape_free(void *c) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	delete o;
}
//method: getNumPlanes int ( ::btConvexTriangleMeshShape::* )(  ) const
int btConvexTriangleMeshShape_getNumPlanes(void *c) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	int retVal = (int)o->getNumPlanes();
	return retVal;
}
//method: localGetSupportingVertex ::btVector3 ( ::btConvexTriangleMeshShape::* )( ::btVector3 const & ) const
void btConvexTriangleMeshShape_localGetSupportingVertex(void *c,float* p0,float* ret) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertex(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btConvexTriangleMeshShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

//method: getNumEdges int ( ::btConvexTriangleMeshShape::* )(  ) const
int btConvexTriangleMeshShape_getNumEdges(void *c) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	int retVal = (int)o->getNumEdges();
	return retVal;
}
//method: getName char const * ( ::btConvexTriangleMeshShape::* )(  ) const
char const * btConvexTriangleMeshShape_getName(void *c) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: getVertex void ( ::btConvexTriangleMeshShape::* )( int,::btVector3 & ) const
void btConvexTriangleMeshShape_getVertex(void *c,int p0,float* p1) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getVertex(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getEdge void ( ::btConvexTriangleMeshShape::* )( int,::btVector3 &,::btVector3 & ) const
void btConvexTriangleMeshShape_getEdge(void *c,int p0,float* p1,float* p2) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getEdge(p0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getLocalScaling ::btVector3 const & ( ::btConvexTriangleMeshShape::* )(  ) const
void btConvexTriangleMeshShape_getLocalScaling(void *c,float* ret) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLocalScaling();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: isInside bool ( ::btConvexTriangleMeshShape::* )( ::btVector3 const &,::btScalar ) const
int btConvexTriangleMeshShape_isInside(void *c,float* p0,float p1) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	int retVal = (int)o->isInside(tp0,p1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return retVal;
}
//method: getPlane void ( ::btConvexTriangleMeshShape::* )( ::btVector3 &,::btVector3 &,int ) const
void btConvexTriangleMeshShape_getPlane(void *c,float* p0,float* p1,int p2) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getPlane(tp0,tp1,p2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: setLocalScaling void ( ::btConvexTriangleMeshShape::* )( ::btVector3 const & ) 
void btConvexTriangleMeshShape_setLocalScaling(void *c,float* p0) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getMeshInterface ::btStridingMeshInterface * ( ::btConvexTriangleMeshShape::* )(  ) 
void* btConvexTriangleMeshShape_getMeshInterface(void *c) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	void* retVal = (void*) o->getMeshInterface();
	return retVal;
}
//method: getMeshInterface ::btStridingMeshInterface * ( ::btConvexTriangleMeshShape::* )(  ) 
void* btConvexTriangleMeshShape_getMeshInterface0(void *c) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	void* retVal = (void*) o->getMeshInterface();
	return retVal;
}
//method: getMeshInterface ::btStridingMeshInterface const * ( ::btConvexTriangleMeshShape::* )(  ) const
void* btConvexTriangleMeshShape_getMeshInterface1(void *c) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	void* retVal = (void*) o->getMeshInterface();
	return retVal;
}
//method: getNumVertices int ( ::btConvexTriangleMeshShape::* )(  ) const
int btConvexTriangleMeshShape_getNumVertices(void *c) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	int retVal = (int)o->getNumVertices();
	return retVal;
}
//not supported method: calculatePrincipalAxisTransform void ( ::btConvexTriangleMeshShape::* )( ::btTransform &,::btVector3 &,::btScalar & ) const
// error: ::btTransform & - ok, ::btVector3 & - ok,  - unsupported, void - ok

//method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btConvexTriangleMeshShape::* )( ::btVector3 const & ) const
void btConvexTriangleMeshShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertexWithoutMargin(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//attribute: ::btStridingMeshInterface * btConvexTriangleMeshShape->m_stridingMesh
void btConvexTriangleMeshShape_m_stridingMesh_set(void *c,void* a) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	::btStridingMeshInterface * ta = (::btStridingMeshInterface *)a;
	o->m_stridingMesh = ta;
}
void* btConvexTriangleMeshShape_m_stridingMesh_get(void *c) {
	::btConvexTriangleMeshShape *o = (::btConvexTriangleMeshShape*)c;
	return (void*)(o->m_stridingMesh);
}


// ::btCylinderShape
//constructor: btCylinderShape  ( ::btCylinderShape::* )( ::btVector3 const & ) 
void* btCylinderShape_new(float* p0) {
	::btCylinderShape *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	mem = btAlignedAlloc(sizeof(::btCylinderShape),16);
	o = new (mem)::btCylinderShape(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return (void*)o;
}
void btCylinderShape_free(void *c) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	delete o;
}
//method: calculateLocalInertia void ( ::btCylinderShape::* )( ::btScalar,::btVector3 & ) const
void btCylinderShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: localGetSupportingVertex ::btVector3 ( ::btCylinderShape::* )( ::btVector3 const & ) const
void btCylinderShape_localGetSupportingVertex(void *c,float* p0,float* ret) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertex(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: calculateSerializeBufferSize int ( ::btCylinderShape::* )(  ) const
int btCylinderShape_calculateSerializeBufferSize(void *c) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btCylinderShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

//method: setLocalScaling void ( ::btCylinderShape::* )( ::btVector3 const & ) 
void btCylinderShape_setLocalScaling(void *c,float* p0) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getUpAxis int ( ::btCylinderShape::* )(  ) const
int btCylinderShape_getUpAxis(void *c) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	int retVal = (int)o->getUpAxis();
	return retVal;
}
//method: getName char const * ( ::btCylinderShape::* )(  ) const
char const * btCylinderShape_getName(void *c) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: serialize char const * ( ::btCylinderShape::* )( void *,::btSerializer * ) const
char const * btCylinderShape_serialize(void *c,void* p0,void* p1) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: getHalfExtentsWithoutMargin ::btVector3 const & ( ::btCylinderShape::* )(  ) const
void btCylinderShape_getHalfExtentsWithoutMargin(void *c,float* ret) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getHalfExtentsWithoutMargin();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getAabb void ( ::btCylinderShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btCylinderShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: setMargin void ( ::btCylinderShape::* )( ::btScalar ) 
void btCylinderShape_setMargin(void *c,float p0) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	o->setMargin(p0);
}
//method: getHalfExtentsWithMargin ::btVector3 ( ::btCylinderShape::* )(  ) const
void btCylinderShape_getHalfExtentsWithMargin(void *c,float* ret) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getHalfExtentsWithMargin();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btCylinderShape::* )( ::btVector3 const & ) const
void btCylinderShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertexWithoutMargin(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getRadius ::btScalar ( ::btCylinderShape::* )(  ) const
float btCylinderShape_getRadius(void *c) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	float retVal = (float)o->getRadius();
	return retVal;
}
//attribute: int btCylinderShape->m_upAxis
void btCylinderShape_m_upAxis_set(void *c,int a) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	o->m_upAxis = a;
}
int btCylinderShape_m_upAxis_get(void *c) {
	::btCylinderShape *o = (::btCylinderShape*)c;
	return (int)(o->m_upAxis);
}


// ::btCylinderShapeData
//constructor: btCylinderShapeData  ( ::btCylinderShapeData::* )(  ) 
void* btCylinderShapeData_new() {
	::btCylinderShapeData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCylinderShapeData),16);
	o = new (mem)::btCylinderShapeData();
	return (void*)o;
}
void btCylinderShapeData_free(void *c) {
	::btCylinderShapeData *o = (::btCylinderShapeData*)c;
	delete o;
}
//attribute: ::btConvexInternalShapeData btCylinderShapeData->m_convexInternalShapeData
void btCylinderShapeData_m_convexInternalShapeData_set(void *c,void* a) {
	::btCylinderShapeData *o = (::btCylinderShapeData*)c;
	::btConvexInternalShapeData & ta = *(::btConvexInternalShapeData *)a;
	o->m_convexInternalShapeData = ta;
}
void* btCylinderShapeData_m_convexInternalShapeData_get(void *c) {
	::btCylinderShapeData *o = (::btCylinderShapeData*)c;
	return (void*)&(o->m_convexInternalShapeData);
}

//attribute: int btCylinderShapeData->m_upAxis
void btCylinderShapeData_m_upAxis_set(void *c,int a) {
	::btCylinderShapeData *o = (::btCylinderShapeData*)c;
	o->m_upAxis = a;
}
int btCylinderShapeData_m_upAxis_get(void *c) {
	::btCylinderShapeData *o = (::btCylinderShapeData*)c;
	return (int)(o->m_upAxis);
}

//attribute: char[4] btCylinderShapeData->m_padding
// attribute not supported: //attribute: char[4] btCylinderShapeData->m_padding

// ::btCylinderShapeX
//constructor: btCylinderShapeX  ( ::btCylinderShapeX::* )( ::btVector3 const & ) 
void* btCylinderShapeX_new(float* p0) {
	::btCylinderShapeX *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	mem = btAlignedAlloc(sizeof(::btCylinderShapeX),16);
	o = new (mem)::btCylinderShapeX(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return (void*)o;
}
void btCylinderShapeX_free(void *c) {
	::btCylinderShapeX *o = (::btCylinderShapeX*)c;
	delete o;
}
//method: getName char const * ( ::btCylinderShapeX::* )(  ) const
char const * btCylinderShapeX_getName(void *c) {
	::btCylinderShapeX *o = (::btCylinderShapeX*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btCylinderShapeX::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

//method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btCylinderShapeX::* )( ::btVector3 const & ) const
void btCylinderShapeX_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret) {
	::btCylinderShapeX *o = (::btCylinderShapeX*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertexWithoutMargin(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getRadius ::btScalar ( ::btCylinderShapeX::* )(  ) const
float btCylinderShapeX_getRadius(void *c) {
	::btCylinderShapeX *o = (::btCylinderShapeX*)c;
	float retVal = (float)o->getRadius();
	return retVal;
}

// ::btCylinderShapeZ
//constructor: btCylinderShapeZ  ( ::btCylinderShapeZ::* )( ::btVector3 const & ) 
void* btCylinderShapeZ_new(float* p0) {
	::btCylinderShapeZ *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	mem = btAlignedAlloc(sizeof(::btCylinderShapeZ),16);
	o = new (mem)::btCylinderShapeZ(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return (void*)o;
}
void btCylinderShapeZ_free(void *c) {
	::btCylinderShapeZ *o = (::btCylinderShapeZ*)c;
	delete o;
}
//method: getName char const * ( ::btCylinderShapeZ::* )(  ) const
char const * btCylinderShapeZ_getName(void *c) {
	::btCylinderShapeZ *o = (::btCylinderShapeZ*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btCylinderShapeZ::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

//method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btCylinderShapeZ::* )( ::btVector3 const & ) const
void btCylinderShapeZ_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret) {
	::btCylinderShapeZ *o = (::btCylinderShapeZ*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertexWithoutMargin(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getRadius ::btScalar ( ::btCylinderShapeZ::* )(  ) const
float btCylinderShapeZ_getRadius(void *c) {
	::btCylinderShapeZ *o = (::btCylinderShapeZ*)c;
	float retVal = (float)o->getRadius();
	return retVal;
}

// ::btEmptyShape
//constructor: btEmptyShape  ( ::btEmptyShape::* )(  ) 
void* btEmptyShape_new() {
	::btEmptyShape *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btEmptyShape),16);
	o = new (mem)::btEmptyShape();
	return (void*)o;
}
void btEmptyShape_free(void *c) {
	::btEmptyShape *o = (::btEmptyShape*)c;
	delete o;
}
//method: calculateLocalInertia void ( ::btEmptyShape::* )( ::btScalar,::btVector3 & ) const
void btEmptyShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btEmptyShape *o = (::btEmptyShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getName char const * ( ::btEmptyShape::* )(  ) const
char const * btEmptyShape_getName(void *c) {
	::btEmptyShape *o = (::btEmptyShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: getLocalScaling ::btVector3 const & ( ::btEmptyShape::* )(  ) const
void btEmptyShape_getLocalScaling(void *c,float* ret) {
	::btEmptyShape *o = (::btEmptyShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLocalScaling();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: setLocalScaling void ( ::btEmptyShape::* )( ::btVector3 const & ) 
void btEmptyShape_setLocalScaling(void *c,float* p0) {
	::btEmptyShape *o = (::btEmptyShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getAabb void ( ::btEmptyShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btEmptyShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btEmptyShape *o = (::btEmptyShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: processAllTriangles void ( ::btEmptyShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
void btEmptyShape_processAllTriangles(void *c,void* p0,float* p1,float* p2) {
	::btEmptyShape *o = (::btEmptyShape*)c;
	::btTriangleCallback * tp0 = (::btTriangleCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->processAllTriangles(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//attribute: ::btVector3 btEmptyShape->m_localScaling
void btEmptyShape_m_localScaling_set(void *c,float* a) {
	::btEmptyShape *o = (::btEmptyShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localScaling = ta;
}
void btEmptyShape_m_localScaling_get(void *c,float* a) {
	::btEmptyShape *o = (::btEmptyShape*)c;
	a[0]=(o->m_localScaling).m_floats[0];a[1]=(o->m_localScaling).m_floats[1];a[2]=(o->m_localScaling).m_floats[2];
}


// ::btIndexedMesh
//constructor: btIndexedMesh  ( ::btIndexedMesh::* )(  ) 
void* btIndexedMesh_new() {
	::btIndexedMesh *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btIndexedMesh),16);
	o = new (mem)::btIndexedMesh();
	return (void*)o;
}
void btIndexedMesh_free(void *c) {
	::btIndexedMesh *o = (::btIndexedMesh*)c;
	delete o;
}
//attribute: ::PHY_ScalarType btIndexedMesh->m_indexType
// attribute not supported: //attribute: ::PHY_ScalarType btIndexedMesh->m_indexType
//attribute: int btIndexedMesh->m_numTriangles
void btIndexedMesh_m_numTriangles_set(void *c,int a) {
	::btIndexedMesh *o = (::btIndexedMesh*)c;
	o->m_numTriangles = a;
}
int btIndexedMesh_m_numTriangles_get(void *c) {
	::btIndexedMesh *o = (::btIndexedMesh*)c;
	return (int)(o->m_numTriangles);
}

//attribute: int btIndexedMesh->m_numVertices
void btIndexedMesh_m_numVertices_set(void *c,int a) {
	::btIndexedMesh *o = (::btIndexedMesh*)c;
	o->m_numVertices = a;
}
int btIndexedMesh_m_numVertices_get(void *c) {
	::btIndexedMesh *o = (::btIndexedMesh*)c;
	return (int)(o->m_numVertices);
}

//attribute: unsigned char const * btIndexedMesh->m_triangleIndexBase
// attribute not supported: //attribute: unsigned char const * btIndexedMesh->m_triangleIndexBase
//attribute: int btIndexedMesh->m_triangleIndexStride
void btIndexedMesh_m_triangleIndexStride_set(void *c,int a) {
	::btIndexedMesh *o = (::btIndexedMesh*)c;
	o->m_triangleIndexStride = a;
}
int btIndexedMesh_m_triangleIndexStride_get(void *c) {
	::btIndexedMesh *o = (::btIndexedMesh*)c;
	return (int)(o->m_triangleIndexStride);
}

//attribute: unsigned char const * btIndexedMesh->m_vertexBase
// attribute not supported: //attribute: unsigned char const * btIndexedMesh->m_vertexBase
//attribute: int btIndexedMesh->m_vertexStride
void btIndexedMesh_m_vertexStride_set(void *c,int a) {
	::btIndexedMesh *o = (::btIndexedMesh*)c;
	o->m_vertexStride = a;
}
int btIndexedMesh_m_vertexStride_get(void *c) {
	::btIndexedMesh *o = (::btIndexedMesh*)c;
	return (int)(o->m_vertexStride);
}

//attribute: ::PHY_ScalarType btIndexedMesh->m_vertexType
// attribute not supported: //attribute: ::PHY_ScalarType btIndexedMesh->m_vertexType

// ::btIntIndexData
//constructor: btIntIndexData  ( ::btIntIndexData::* )(  ) 
void* btIntIndexData_new() {
	::btIntIndexData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btIntIndexData),16);
	o = new (mem)::btIntIndexData();
	return (void*)o;
}
void btIntIndexData_free(void *c) {
	::btIntIndexData *o = (::btIntIndexData*)c;
	delete o;
}
//attribute: int btIntIndexData->m_value
void btIntIndexData_m_value_set(void *c,int a) {
	::btIntIndexData *o = (::btIntIndexData*)c;
	o->m_value = a;
}
int btIntIndexData_m_value_get(void *c) {
	::btIntIndexData *o = (::btIntIndexData*)c;
	return (int)(o->m_value);
}


// ::btInternalTriangleIndexCallback
//not supported method: internalProcessTriangleIndex void ( ::btInternalTriangleIndexCallback::* )( ::btVector3 *,int,int ) 
// error:  - unsupported, int - ok, int - ok, void - ok


// ::btMeshPartData
//constructor: btMeshPartData  ( ::btMeshPartData::* )(  ) 
void* btMeshPartData_new() {
	::btMeshPartData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btMeshPartData),16);
	o = new (mem)::btMeshPartData();
	return (void*)o;
}
void btMeshPartData_free(void *c) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	delete o;
}
//attribute: ::btVector3FloatData * btMeshPartData->m_vertices3f
void btMeshPartData_m_vertices3f_set(void *c,void* a) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	::btVector3FloatData * ta = (::btVector3FloatData *)a;
	o->m_vertices3f = ta;
}
void* btMeshPartData_m_vertices3f_get(void *c) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	return (void*)(o->m_vertices3f);
}

//attribute: ::btVector3DoubleData * btMeshPartData->m_vertices3d
void btMeshPartData_m_vertices3d_set(void *c,void* a) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	::btVector3DoubleData * ta = (::btVector3DoubleData *)a;
	o->m_vertices3d = ta;
}
void* btMeshPartData_m_vertices3d_get(void *c) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	return (void*)(o->m_vertices3d);
}

//attribute: ::btIntIndexData * btMeshPartData->m_indices32
void btMeshPartData_m_indices32_set(void *c,void* a) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	::btIntIndexData * ta = (::btIntIndexData *)a;
	o->m_indices32 = ta;
}
void* btMeshPartData_m_indices32_get(void *c) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	return (void*)(o->m_indices32);
}

//attribute: ::btShortIntIndexTripletData * btMeshPartData->m_3indices16
void btMeshPartData_m_3indices16_set(void *c,void* a) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	::btShortIntIndexTripletData * ta = (::btShortIntIndexTripletData *)a;
	o->m_3indices16 = ta;
}
void* btMeshPartData_m_3indices16_get(void *c) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	return (void*)(o->m_3indices16);
}

//attribute: ::btCharIndexTripletData * btMeshPartData->m_3indices8
void btMeshPartData_m_3indices8_set(void *c,void* a) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	::btCharIndexTripletData * ta = (::btCharIndexTripletData *)a;
	o->m_3indices8 = ta;
}
void* btMeshPartData_m_3indices8_get(void *c) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	return (void*)(o->m_3indices8);
}

//attribute: ::btShortIntIndexData * btMeshPartData->m_indices16
void btMeshPartData_m_indices16_set(void *c,void* a) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	::btShortIntIndexData * ta = (::btShortIntIndexData *)a;
	o->m_indices16 = ta;
}
void* btMeshPartData_m_indices16_get(void *c) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	return (void*)(o->m_indices16);
}

//attribute: int btMeshPartData->m_numTriangles
void btMeshPartData_m_numTriangles_set(void *c,int a) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	o->m_numTriangles = a;
}
int btMeshPartData_m_numTriangles_get(void *c) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	return (int)(o->m_numTriangles);
}

//attribute: int btMeshPartData->m_numVertices
void btMeshPartData_m_numVertices_set(void *c,int a) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	o->m_numVertices = a;
}
int btMeshPartData_m_numVertices_get(void *c) {
	::btMeshPartData *o = (::btMeshPartData*)c;
	return (int)(o->m_numVertices);
}


// ::btMultiSphereShape
//not supported constructor: btMultiSphereShape  ( ::btMultiSphereShape::* )( ::btVector3 const *,::btScalar const *,int ) 
// error:  - unsupported,  - unsupported, int - ok

void btMultiSphereShape_free(void *c) {
	::btMultiSphereShape *o = (::btMultiSphereShape*)c;
	delete o;
}
//method: calculateLocalInertia void ( ::btMultiSphereShape::* )( ::btScalar,::btVector3 & ) const
void btMultiSphereShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btMultiSphereShape *o = (::btMultiSphereShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: calculateSerializeBufferSize int ( ::btMultiSphereShape::* )(  ) const
int btMultiSphereShape_calculateSerializeBufferSize(void *c) {
	::btMultiSphereShape *o = (::btMultiSphereShape*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btMultiSphereShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

//method: getSphereCount int ( ::btMultiSphereShape::* )(  ) const
int btMultiSphereShape_getSphereCount(void *c) {
	::btMultiSphereShape *o = (::btMultiSphereShape*)c;
	int retVal = (int)o->getSphereCount();
	return retVal;
}
//method: getName char const * ( ::btMultiSphereShape::* )(  ) const
char const * btMultiSphereShape_getName(void *c) {
	::btMultiSphereShape *o = (::btMultiSphereShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: serialize char const * ( ::btMultiSphereShape::* )( void *,::btSerializer * ) const
char const * btMultiSphereShape_serialize(void *c,void* p0,void* p1) {
	::btMultiSphereShape *o = (::btMultiSphereShape*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: getSpherePosition ::btVector3 const & ( ::btMultiSphereShape::* )( int ) const
void btMultiSphereShape_getSpherePosition(void *c,int p0,float* ret) {
	::btMultiSphereShape *o = (::btMultiSphereShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getSpherePosition(p0);
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getSphereRadius ::btScalar ( ::btMultiSphereShape::* )( int ) const
float btMultiSphereShape_getSphereRadius(void *c,int p0) {
	::btMultiSphereShape *o = (::btMultiSphereShape*)c;
	float retVal = (float)o->getSphereRadius(p0);
	return retVal;
}
//method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btMultiSphereShape::* )( ::btVector3 const & ) const
void btMultiSphereShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret) {
	::btMultiSphereShape *o = (::btMultiSphereShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertexWithoutMargin(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//attribute: ::btAlignedObjectArray<btVector3> btMultiSphereShape->m_localPositionArray
void btMultiSphereShape_m_localPositionArray_set(void *c,void* a) {
	::btMultiSphereShape *o = (::btMultiSphereShape*)c;
	::btAlignedObjectArray<btVector3> & ta = *(::btAlignedObjectArray<btVector3> *)a;
	o->m_localPositionArray = ta;
}
void* btMultiSphereShape_m_localPositionArray_get(void *c) {
	::btMultiSphereShape *o = (::btMultiSphereShape*)c;
	return (void*)&(o->m_localPositionArray);
}

//attribute: ::btAlignedObjectArray<float> btMultiSphereShape->m_radiArray
void btMultiSphereShape_m_radiArray_set(void *c,void* a) {
	::btMultiSphereShape *o = (::btMultiSphereShape*)c;
	::btAlignedObjectArray<float> & ta = *(::btAlignedObjectArray<float> *)a;
	o->m_radiArray = ta;
}
void* btMultiSphereShape_m_radiArray_get(void *c) {
	::btMultiSphereShape *o = (::btMultiSphereShape*)c;
	return (void*)&(o->m_radiArray);
}


// ::btMultiSphereShapeData
//constructor: btMultiSphereShapeData  ( ::btMultiSphereShapeData::* )(  ) 
void* btMultiSphereShapeData_new() {
	::btMultiSphereShapeData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btMultiSphereShapeData),16);
	o = new (mem)::btMultiSphereShapeData();
	return (void*)o;
}
void btMultiSphereShapeData_free(void *c) {
	::btMultiSphereShapeData *o = (::btMultiSphereShapeData*)c;
	delete o;
}
//attribute: ::btConvexInternalShapeData btMultiSphereShapeData->m_convexInternalShapeData
void btMultiSphereShapeData_m_convexInternalShapeData_set(void *c,void* a) {
	::btMultiSphereShapeData *o = (::btMultiSphereShapeData*)c;
	::btConvexInternalShapeData & ta = *(::btConvexInternalShapeData *)a;
	o->m_convexInternalShapeData = ta;
}
void* btMultiSphereShapeData_m_convexInternalShapeData_get(void *c) {
	::btMultiSphereShapeData *o = (::btMultiSphereShapeData*)c;
	return (void*)&(o->m_convexInternalShapeData);
}

//attribute: ::btPositionAndRadius * btMultiSphereShapeData->m_localPositionArrayPtr
void btMultiSphereShapeData_m_localPositionArrayPtr_set(void *c,void* a) {
	::btMultiSphereShapeData *o = (::btMultiSphereShapeData*)c;
	::btPositionAndRadius * ta = (::btPositionAndRadius *)a;
	o->m_localPositionArrayPtr = ta;
}
void* btMultiSphereShapeData_m_localPositionArrayPtr_get(void *c) {
	::btMultiSphereShapeData *o = (::btMultiSphereShapeData*)c;
	return (void*)(o->m_localPositionArrayPtr);
}

//attribute: int btMultiSphereShapeData->m_localPositionArraySize
void btMultiSphereShapeData_m_localPositionArraySize_set(void *c,int a) {
	::btMultiSphereShapeData *o = (::btMultiSphereShapeData*)c;
	o->m_localPositionArraySize = a;
}
int btMultiSphereShapeData_m_localPositionArraySize_get(void *c) {
	::btMultiSphereShapeData *o = (::btMultiSphereShapeData*)c;
	return (int)(o->m_localPositionArraySize);
}

//attribute: char[4] btMultiSphereShapeData->m_padding
// attribute not supported: //attribute: char[4] btMultiSphereShapeData->m_padding

// ::btOptimizedBvh
//constructor: btOptimizedBvh  ( ::btOptimizedBvh::* )(  ) 
void* btOptimizedBvh_new() {
	::btOptimizedBvh *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btOptimizedBvh),16);
	o = new (mem)::btOptimizedBvh();
	return (void*)o;
}
void btOptimizedBvh_free(void *c) {
	::btOptimizedBvh *o = (::btOptimizedBvh*)c;
	delete o;
}
//method: updateBvhNodes void ( ::btOptimizedBvh::* )( ::btStridingMeshInterface *,int,int,int ) 
void btOptimizedBvh_updateBvhNodes(void *c,void* p0,int p1,int p2,int p3) {
	::btOptimizedBvh *o = (::btOptimizedBvh*)c;
	::btStridingMeshInterface * tp0 = (::btStridingMeshInterface *)p0;
	o->updateBvhNodes(tp0,p1,p2,p3);
}
//method: serializeInPlace bool ( ::btOptimizedBvh::* )( void *,unsigned int,bool ) const
int btOptimizedBvh_serializeInPlace(void *c,void* p0,unsigned int p1,int p2) {
	::btOptimizedBvh *o = (::btOptimizedBvh*)c;
	void * tp0 = (void *)p0;
	int retVal = (int)o->serializeInPlace(tp0,p1,p2);
	return retVal;
}
//method: refit void ( ::btOptimizedBvh::* )( ::btStridingMeshInterface *,::btVector3 const &,::btVector3 const & ) 
void btOptimizedBvh_refit(void *c,void* p0,float* p1,float* p2) {
	::btOptimizedBvh *o = (::btOptimizedBvh*)c;
	::btStridingMeshInterface * tp0 = (::btStridingMeshInterface *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->refit(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: build void ( ::btOptimizedBvh::* )( ::btStridingMeshInterface *,bool,::btVector3 const &,::btVector3 const & ) 
void btOptimizedBvh_build(void *c,void* p0,int p1,float* p2,float* p3) {
	::btOptimizedBvh *o = (::btOptimizedBvh*)c;
	::btStridingMeshInterface * tp0 = (::btStridingMeshInterface *)p0;
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	o->build(tp0,p1,tp2,tp3);
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
}
//method: refitPartial void ( ::btOptimizedBvh::* )( ::btStridingMeshInterface *,::btVector3 const &,::btVector3 const & ) 
void btOptimizedBvh_refitPartial(void *c,void* p0,float* p1,float* p2) {
	::btOptimizedBvh *o = (::btOptimizedBvh*)c;
	::btStridingMeshInterface * tp0 = (::btStridingMeshInterface *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->refitPartial(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: deSerializeInPlace ::btOptimizedBvh * (*)( void *,unsigned int,bool )
void* btOptimizedBvh_deSerializeInPlace(void* p0,unsigned int p1,int p2) {
	void * tp0 = (void *)p0;
	void* retVal = (void*) ::btOptimizedBvh::deSerializeInPlace(tp0,p1,p2);
	return retVal;
}

// ::btPolyhedralConvexAabbCachingShape
//method: setCachedLocalAabb void ( ::btPolyhedralConvexAabbCachingShape::* )( ::btVector3 const &,::btVector3 const & ) 
void btPolyhedralConvexAabbCachingShape_setCachedLocalAabb(void *c,float* p0,float* p1) {
	::btPolyhedralConvexAabbCachingShape *o = (::btPolyhedralConvexAabbCachingShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->setCachedLocalAabb(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: recalcLocalAabb void ( ::btPolyhedralConvexAabbCachingShape::* )(  ) 
void btPolyhedralConvexAabbCachingShape_recalcLocalAabb(void *c) {
	::btPolyhedralConvexAabbCachingShape *o = (::btPolyhedralConvexAabbCachingShape*)c;
	o->recalcLocalAabb();
}
//method: setLocalScaling void ( ::btPolyhedralConvexAabbCachingShape::* )( ::btVector3 const & ) 
void btPolyhedralConvexAabbCachingShape_setLocalScaling(void *c,float* p0) {
	::btPolyhedralConvexAabbCachingShape *o = (::btPolyhedralConvexAabbCachingShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getNonvirtualAabb void ( ::btPolyhedralConvexAabbCachingShape::* )( ::btTransform const &,::btVector3 &,::btVector3 &,::btScalar ) const
void btPolyhedralConvexAabbCachingShape_getNonvirtualAabb(void *c,float* p0,float* p1,float* p2,float p3) {
	::btPolyhedralConvexAabbCachingShape *o = (::btPolyhedralConvexAabbCachingShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getNonvirtualAabb(tp0,tp1,tp2,p3);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getCachedLocalAabb void ( ::btPolyhedralConvexAabbCachingShape::* )( ::btVector3 &,::btVector3 & ) const
void btPolyhedralConvexAabbCachingShape_getCachedLocalAabb(void *c,float* p0,float* p1) {
	::btPolyhedralConvexAabbCachingShape *o = (::btPolyhedralConvexAabbCachingShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getCachedLocalAabb(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getAabb void ( ::btPolyhedralConvexAabbCachingShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btPolyhedralConvexAabbCachingShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btPolyhedralConvexAabbCachingShape *o = (::btPolyhedralConvexAabbCachingShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//attribute: ::btVector3 btPolyhedralConvexAabbCachingShape->m_localAabbMin
void btPolyhedralConvexAabbCachingShape_m_localAabbMin_set(void *c,float* a) {
	::btPolyhedralConvexAabbCachingShape *o = (::btPolyhedralConvexAabbCachingShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localAabbMin = ta;
}
void btPolyhedralConvexAabbCachingShape_m_localAabbMin_get(void *c,float* a) {
	::btPolyhedralConvexAabbCachingShape *o = (::btPolyhedralConvexAabbCachingShape*)c;
	a[0]=(o->m_localAabbMin).m_floats[0];a[1]=(o->m_localAabbMin).m_floats[1];a[2]=(o->m_localAabbMin).m_floats[2];
}

//attribute: ::btVector3 btPolyhedralConvexAabbCachingShape->m_localAabbMax
void btPolyhedralConvexAabbCachingShape_m_localAabbMax_set(void *c,float* a) {
	::btPolyhedralConvexAabbCachingShape *o = (::btPolyhedralConvexAabbCachingShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localAabbMax = ta;
}
void btPolyhedralConvexAabbCachingShape_m_localAabbMax_get(void *c,float* a) {
	::btPolyhedralConvexAabbCachingShape *o = (::btPolyhedralConvexAabbCachingShape*)c;
	a[0]=(o->m_localAabbMax).m_floats[0];a[1]=(o->m_localAabbMax).m_floats[1];a[2]=(o->m_localAabbMax).m_floats[2];
}

//attribute: bool btPolyhedralConvexAabbCachingShape->m_isLocalAabbValid
void btPolyhedralConvexAabbCachingShape_m_isLocalAabbValid_set(void *c,int a) {
	::btPolyhedralConvexAabbCachingShape *o = (::btPolyhedralConvexAabbCachingShape*)c;
	o->m_isLocalAabbValid = a;
}
int btPolyhedralConvexAabbCachingShape_m_isLocalAabbValid_get(void *c) {
	::btPolyhedralConvexAabbCachingShape *o = (::btPolyhedralConvexAabbCachingShape*)c;
	return (int)(o->m_isLocalAabbValid);
}


// ::btPolyhedralConvexShape
//method: calculateLocalInertia void ( ::btPolyhedralConvexShape::* )( ::btScalar,::btVector3 & ) const
void btPolyhedralConvexShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btPolyhedralConvexShape *o = (::btPolyhedralConvexShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getNumPlanes int ( ::btPolyhedralConvexShape::* )(  ) const
int btPolyhedralConvexShape_getNumPlanes(void *c) {
	::btPolyhedralConvexShape *o = (::btPolyhedralConvexShape*)c;
	int retVal = (int)o->getNumPlanes();
	return retVal;
}
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btPolyhedralConvexShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

//method: getNumEdges int ( ::btPolyhedralConvexShape::* )(  ) const
int btPolyhedralConvexShape_getNumEdges(void *c) {
	::btPolyhedralConvexShape *o = (::btPolyhedralConvexShape*)c;
	int retVal = (int)o->getNumEdges();
	return retVal;
}
//method: getVertex void ( ::btPolyhedralConvexShape::* )( int,::btVector3 & ) const
void btPolyhedralConvexShape_getVertex(void *c,int p0,float* p1) {
	::btPolyhedralConvexShape *o = (::btPolyhedralConvexShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getVertex(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getEdge void ( ::btPolyhedralConvexShape::* )( int,::btVector3 &,::btVector3 & ) const
void btPolyhedralConvexShape_getEdge(void *c,int p0,float* p1,float* p2) {
	::btPolyhedralConvexShape *o = (::btPolyhedralConvexShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getEdge(p0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: isInside bool ( ::btPolyhedralConvexShape::* )( ::btVector3 const &,::btScalar ) const
int btPolyhedralConvexShape_isInside(void *c,float* p0,float p1) {
	::btPolyhedralConvexShape *o = (::btPolyhedralConvexShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	int retVal = (int)o->isInside(tp0,p1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return retVal;
}
//method: getPlane void ( ::btPolyhedralConvexShape::* )( ::btVector3 &,::btVector3 &,int ) const
void btPolyhedralConvexShape_getPlane(void *c,float* p0,float* p1,int p2) {
	::btPolyhedralConvexShape *o = (::btPolyhedralConvexShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getPlane(tp0,tp1,p2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//not supported method: getConvexPolyhedron ::btConvexPolyhedron const * ( ::btPolyhedralConvexShape::* )(  ) const
// error:  - unsupported

//method: initializePolyhedralFeatures bool ( ::btPolyhedralConvexShape::* )(  ) 
int btPolyhedralConvexShape_initializePolyhedralFeatures(void *c) {
	::btPolyhedralConvexShape *o = (::btPolyhedralConvexShape*)c;
	int retVal = (int)o->initializePolyhedralFeatures();
	return retVal;
}
//method: getNumVertices int ( ::btPolyhedralConvexShape::* )(  ) const
int btPolyhedralConvexShape_getNumVertices(void *c) {
	::btPolyhedralConvexShape *o = (::btPolyhedralConvexShape*)c;
	int retVal = (int)o->getNumVertices();
	return retVal;
}
//method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btPolyhedralConvexShape::* )( ::btVector3 const & ) const
void btPolyhedralConvexShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret) {
	::btPolyhedralConvexShape *o = (::btPolyhedralConvexShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertexWithoutMargin(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//attribute: ::btConvexPolyhedron * btPolyhedralConvexShape->m_polyhedron
// attribute not supported: //attribute: ::btConvexPolyhedron * btPolyhedralConvexShape->m_polyhedron

// ::btPositionAndRadius
//constructor: btPositionAndRadius  ( ::btPositionAndRadius::* )(  ) 
void* btPositionAndRadius_new() {
	::btPositionAndRadius *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btPositionAndRadius),16);
	o = new (mem)::btPositionAndRadius();
	return (void*)o;
}
void btPositionAndRadius_free(void *c) {
	::btPositionAndRadius *o = (::btPositionAndRadius*)c;
	delete o;
}
//attribute: ::btVector3FloatData btPositionAndRadius->m_pos
void btPositionAndRadius_m_pos_set(void *c,void* a) {
	::btPositionAndRadius *o = (::btPositionAndRadius*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_pos = ta;
}
void* btPositionAndRadius_m_pos_get(void *c) {
	::btPositionAndRadius *o = (::btPositionAndRadius*)c;
	return (void*)&(o->m_pos);
}

//attribute: float btPositionAndRadius->m_radius
void btPositionAndRadius_m_radius_set(void *c,float a) {
	::btPositionAndRadius *o = (::btPositionAndRadius*)c;
	o->m_radius = a;
}
float btPositionAndRadius_m_radius_get(void *c) {
	::btPositionAndRadius *o = (::btPositionAndRadius*)c;
	return (float)(o->m_radius);
}


// ::btScaledBvhTriangleMeshShape
//constructor: btScaledBvhTriangleMeshShape  ( ::btScaledBvhTriangleMeshShape::* )( ::btBvhTriangleMeshShape *,::btVector3 const & ) 
void* btScaledBvhTriangleMeshShape_new(void* p0,float* p1) {
	::btScaledBvhTriangleMeshShape *o = 0;
	 void *mem = 0;
	::btBvhTriangleMeshShape * tp0 = (::btBvhTriangleMeshShape *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	mem = btAlignedAlloc(sizeof(::btScaledBvhTriangleMeshShape),16);
	o = new (mem)::btScaledBvhTriangleMeshShape(tp0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return (void*)o;
}
void btScaledBvhTriangleMeshShape_free(void *c) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	delete o;
}
//method: calculateLocalInertia void ( ::btScaledBvhTriangleMeshShape::* )( ::btScalar,::btVector3 & ) const
void btScaledBvhTriangleMeshShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getChildShape ::btBvhTriangleMeshShape * ( ::btScaledBvhTriangleMeshShape::* )(  ) 
void* btScaledBvhTriangleMeshShape_getChildShape(void *c) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	void* retVal = (void*) o->getChildShape();
	return retVal;
}
//method: getChildShape ::btBvhTriangleMeshShape * ( ::btScaledBvhTriangleMeshShape::* )(  ) 
void* btScaledBvhTriangleMeshShape_getChildShape0(void *c) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	void* retVal = (void*) o->getChildShape();
	return retVal;
}
//method: getChildShape ::btBvhTriangleMeshShape const * ( ::btScaledBvhTriangleMeshShape::* )(  ) const
void* btScaledBvhTriangleMeshShape_getChildShape1(void *c) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	void* retVal = (void*) o->getChildShape();
	return retVal;
}
//method: calculateSerializeBufferSize int ( ::btScaledBvhTriangleMeshShape::* )(  ) const
int btScaledBvhTriangleMeshShape_calculateSerializeBufferSize(void *c) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: getName char const * ( ::btScaledBvhTriangleMeshShape::* )(  ) const
char const * btScaledBvhTriangleMeshShape_getName(void *c) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: serialize char const * ( ::btScaledBvhTriangleMeshShape::* )( void *,::btSerializer * ) const
char const * btScaledBvhTriangleMeshShape_serialize(void *c,void* p0,void* p1) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: getLocalScaling ::btVector3 const & ( ::btScaledBvhTriangleMeshShape::* )(  ) const
void btScaledBvhTriangleMeshShape_getLocalScaling(void *c,float* ret) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLocalScaling();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: setLocalScaling void ( ::btScaledBvhTriangleMeshShape::* )( ::btVector3 const & ) 
void btScaledBvhTriangleMeshShape_setLocalScaling(void *c,float* p0) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getAabb void ( ::btScaledBvhTriangleMeshShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btScaledBvhTriangleMeshShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: processAllTriangles void ( ::btScaledBvhTriangleMeshShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
void btScaledBvhTriangleMeshShape_processAllTriangles(void *c,void* p0,float* p1,float* p2) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	::btTriangleCallback * tp0 = (::btTriangleCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->processAllTriangles(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//attribute: ::btVector3 btScaledBvhTriangleMeshShape->m_localScaling
void btScaledBvhTriangleMeshShape_m_localScaling_set(void *c,float* a) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localScaling = ta;
}
void btScaledBvhTriangleMeshShape_m_localScaling_get(void *c,float* a) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	a[0]=(o->m_localScaling).m_floats[0];a[1]=(o->m_localScaling).m_floats[1];a[2]=(o->m_localScaling).m_floats[2];
}

//attribute: ::btBvhTriangleMeshShape * btScaledBvhTriangleMeshShape->m_bvhTriMeshShape
void btScaledBvhTriangleMeshShape_m_bvhTriMeshShape_set(void *c,void* a) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	::btBvhTriangleMeshShape * ta = (::btBvhTriangleMeshShape *)a;
	o->m_bvhTriMeshShape = ta;
}
void* btScaledBvhTriangleMeshShape_m_bvhTriMeshShape_get(void *c) {
	::btScaledBvhTriangleMeshShape *o = (::btScaledBvhTriangleMeshShape*)c;
	return (void*)(o->m_bvhTriMeshShape);
}


// ::btScaledTriangleMeshShapeData
//constructor: btScaledTriangleMeshShapeData  ( ::btScaledTriangleMeshShapeData::* )(  ) 
void* btScaledTriangleMeshShapeData_new() {
	::btScaledTriangleMeshShapeData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btScaledTriangleMeshShapeData),16);
	o = new (mem)::btScaledTriangleMeshShapeData();
	return (void*)o;
}
void btScaledTriangleMeshShapeData_free(void *c) {
	::btScaledTriangleMeshShapeData *o = (::btScaledTriangleMeshShapeData*)c;
	delete o;
}
//attribute: ::btTriangleMeshShapeData btScaledTriangleMeshShapeData->m_trimeshShapeData
void btScaledTriangleMeshShapeData_m_trimeshShapeData_set(void *c,void* a) {
	::btScaledTriangleMeshShapeData *o = (::btScaledTriangleMeshShapeData*)c;
	::btTriangleMeshShapeData & ta = *(::btTriangleMeshShapeData *)a;
	o->m_trimeshShapeData = ta;
}
void* btScaledTriangleMeshShapeData_m_trimeshShapeData_get(void *c) {
	::btScaledTriangleMeshShapeData *o = (::btScaledTriangleMeshShapeData*)c;
	return (void*)&(o->m_trimeshShapeData);
}

//attribute: ::btVector3FloatData btScaledTriangleMeshShapeData->m_localScaling
void btScaledTriangleMeshShapeData_m_localScaling_set(void *c,void* a) {
	::btScaledTriangleMeshShapeData *o = (::btScaledTriangleMeshShapeData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_localScaling = ta;
}
void* btScaledTriangleMeshShapeData_m_localScaling_get(void *c) {
	::btScaledTriangleMeshShapeData *o = (::btScaledTriangleMeshShapeData*)c;
	return (void*)&(o->m_localScaling);
}


// ::btShortIntIndexData
//constructor: btShortIntIndexData  ( ::btShortIntIndexData::* )(  ) 
void* btShortIntIndexData_new() {
	::btShortIntIndexData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btShortIntIndexData),16);
	o = new (mem)::btShortIntIndexData();
	return (void*)o;
}
void btShortIntIndexData_free(void *c) {
	::btShortIntIndexData *o = (::btShortIntIndexData*)c;
	delete o;
}
//attribute: char[2] btShortIntIndexData->m_pad
// attribute not supported: //attribute: char[2] btShortIntIndexData->m_pad
//attribute: short int btShortIntIndexData->m_value
void btShortIntIndexData_m_value_set(void *c,short int a) {
	::btShortIntIndexData *o = (::btShortIntIndexData*)c;
	o->m_value = a;
}
short int btShortIntIndexData_m_value_get(void *c) {
	::btShortIntIndexData *o = (::btShortIntIndexData*)c;
	return (short int)(o->m_value);
}


// ::btShortIntIndexTripletData
//constructor: btShortIntIndexTripletData  ( ::btShortIntIndexTripletData::* )(  ) 
void* btShortIntIndexTripletData_new() {
	::btShortIntIndexTripletData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btShortIntIndexTripletData),16);
	o = new (mem)::btShortIntIndexTripletData();
	return (void*)o;
}
void btShortIntIndexTripletData_free(void *c) {
	::btShortIntIndexTripletData *o = (::btShortIntIndexTripletData*)c;
	delete o;
}
//attribute: char[2] btShortIntIndexTripletData->m_pad
// attribute not supported: //attribute: char[2] btShortIntIndexTripletData->m_pad
//attribute: short int[3] btShortIntIndexTripletData->m_values
// attribute not supported: //attribute: short int[3] btShortIntIndexTripletData->m_values

// ::btSphereShape
//constructor: btSphereShape  ( ::btSphereShape::* )( ::btScalar ) 
void* btSphereShape_new(float p0) {
	::btSphereShape *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSphereShape),16);
	o = new (mem)::btSphereShape(p0);
	return (void*)o;
}
void btSphereShape_free(void *c) {
	::btSphereShape *o = (::btSphereShape*)c;
	delete o;
}
//method: calculateLocalInertia void ( ::btSphereShape::* )( ::btScalar,::btVector3 & ) const
void btSphereShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btSphereShape *o = (::btSphereShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: localGetSupportingVertex ::btVector3 ( ::btSphereShape::* )( ::btVector3 const & ) const
void btSphereShape_localGetSupportingVertex(void *c,float* p0,float* ret) {
	::btSphereShape *o = (::btSphereShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertex(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btSphereShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

//method: getName char const * ( ::btSphereShape::* )(  ) const
char const * btSphereShape_getName(void *c) {
	::btSphereShape *o = (::btSphereShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: getMargin ::btScalar ( ::btSphereShape::* )(  ) const
float btSphereShape_getMargin(void *c) {
	::btSphereShape *o = (::btSphereShape*)c;
	float retVal = (float)o->getMargin();
	return retVal;
}
//method: setMargin void ( ::btSphereShape::* )( ::btScalar ) 
void btSphereShape_setMargin(void *c,float p0) {
	::btSphereShape *o = (::btSphereShape*)c;
	o->setMargin(p0);
}
//method: getAabb void ( ::btSphereShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btSphereShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btSphereShape *o = (::btSphereShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: setUnscaledRadius void ( ::btSphereShape::* )( ::btScalar ) 
void btSphereShape_setUnscaledRadius(void *c,float p0) {
	::btSphereShape *o = (::btSphereShape*)c;
	o->setUnscaledRadius(p0);
}
//method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btSphereShape::* )( ::btVector3 const & ) const
void btSphereShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret) {
	::btSphereShape *o = (::btSphereShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertexWithoutMargin(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getRadius ::btScalar ( ::btSphereShape::* )(  ) const
float btSphereShape_getRadius(void *c) {
	::btSphereShape *o = (::btSphereShape*)c;
	float retVal = (float)o->getRadius();
	return retVal;
}

// ::btStaticPlaneShape
//constructor: btStaticPlaneShape  ( ::btStaticPlaneShape::* )( ::btVector3 const &,::btScalar ) 
void* btStaticPlaneShape_new(float* p0,float p1) {
	::btStaticPlaneShape *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	mem = btAlignedAlloc(sizeof(::btStaticPlaneShape),16);
	o = new (mem)::btStaticPlaneShape(tp0,p1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return (void*)o;
}
void btStaticPlaneShape_free(void *c) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	delete o;
}
//method: calculateLocalInertia void ( ::btStaticPlaneShape::* )( ::btScalar,::btVector3 & ) const
void btStaticPlaneShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: calculateSerializeBufferSize int ( ::btStaticPlaneShape::* )(  ) const
int btStaticPlaneShape_calculateSerializeBufferSize(void *c) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: getName char const * ( ::btStaticPlaneShape::* )(  ) const
char const * btStaticPlaneShape_getName(void *c) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: serialize char const * ( ::btStaticPlaneShape::* )( void *,::btSerializer * ) const
char const * btStaticPlaneShape_serialize(void *c,void* p0,void* p1) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: getLocalScaling ::btVector3 const & ( ::btStaticPlaneShape::* )(  ) const
void btStaticPlaneShape_getLocalScaling(void *c,float* ret) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLocalScaling();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getPlaneNormal ::btVector3 const & ( ::btStaticPlaneShape::* )(  ) const
void btStaticPlaneShape_getPlaneNormal(void *c,float* ret) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getPlaneNormal();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getPlaneConstant ::btScalar const & ( ::btStaticPlaneShape::* )(  ) const
float btStaticPlaneShape_getPlaneConstant(void *c) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	float retVal = (float)o->getPlaneConstant();
	return retVal;
}
//method: setLocalScaling void ( ::btStaticPlaneShape::* )( ::btVector3 const & ) 
void btStaticPlaneShape_setLocalScaling(void *c,float* p0) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getAabb void ( ::btStaticPlaneShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btStaticPlaneShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: processAllTriangles void ( ::btStaticPlaneShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
void btStaticPlaneShape_processAllTriangles(void *c,void* p0,float* p1,float* p2) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	::btTriangleCallback * tp0 = (::btTriangleCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->processAllTriangles(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//attribute: ::btVector3 btStaticPlaneShape->m_localAabbMin
void btStaticPlaneShape_m_localAabbMin_set(void *c,float* a) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localAabbMin = ta;
}
void btStaticPlaneShape_m_localAabbMin_get(void *c,float* a) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	a[0]=(o->m_localAabbMin).m_floats[0];a[1]=(o->m_localAabbMin).m_floats[1];a[2]=(o->m_localAabbMin).m_floats[2];
}

//attribute: ::btVector3 btStaticPlaneShape->m_localAabbMax
void btStaticPlaneShape_m_localAabbMax_set(void *c,float* a) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localAabbMax = ta;
}
void btStaticPlaneShape_m_localAabbMax_get(void *c,float* a) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	a[0]=(o->m_localAabbMax).m_floats[0];a[1]=(o->m_localAabbMax).m_floats[1];a[2]=(o->m_localAabbMax).m_floats[2];
}

//attribute: ::btVector3 btStaticPlaneShape->m_planeNormal
void btStaticPlaneShape_m_planeNormal_set(void *c,float* a) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_planeNormal = ta;
}
void btStaticPlaneShape_m_planeNormal_get(void *c,float* a) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	a[0]=(o->m_planeNormal).m_floats[0];a[1]=(o->m_planeNormal).m_floats[1];a[2]=(o->m_planeNormal).m_floats[2];
}

//attribute: ::btScalar btStaticPlaneShape->m_planeConstant
void btStaticPlaneShape_m_planeConstant_set(void *c,float a) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	o->m_planeConstant = a;
}
float btStaticPlaneShape_m_planeConstant_get(void *c) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	return (float)(o->m_planeConstant);
}

//attribute: ::btVector3 btStaticPlaneShape->m_localScaling
void btStaticPlaneShape_m_localScaling_set(void *c,float* a) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localScaling = ta;
}
void btStaticPlaneShape_m_localScaling_get(void *c,float* a) {
	::btStaticPlaneShape *o = (::btStaticPlaneShape*)c;
	a[0]=(o->m_localScaling).m_floats[0];a[1]=(o->m_localScaling).m_floats[1];a[2]=(o->m_localScaling).m_floats[2];
}


// ::btStaticPlaneShapeData
//constructor: btStaticPlaneShapeData  ( ::btStaticPlaneShapeData::* )(  ) 
void* btStaticPlaneShapeData_new() {
	::btStaticPlaneShapeData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btStaticPlaneShapeData),16);
	o = new (mem)::btStaticPlaneShapeData();
	return (void*)o;
}
void btStaticPlaneShapeData_free(void *c) {
	::btStaticPlaneShapeData *o = (::btStaticPlaneShapeData*)c;
	delete o;
}
//attribute: ::btCollisionShapeData btStaticPlaneShapeData->m_collisionShapeData
void btStaticPlaneShapeData_m_collisionShapeData_set(void *c,void* a) {
	::btStaticPlaneShapeData *o = (::btStaticPlaneShapeData*)c;
	::btCollisionShapeData & ta = *(::btCollisionShapeData *)a;
	o->m_collisionShapeData = ta;
}
void* btStaticPlaneShapeData_m_collisionShapeData_get(void *c) {
	::btStaticPlaneShapeData *o = (::btStaticPlaneShapeData*)c;
	return (void*)&(o->m_collisionShapeData);
}

//attribute: ::btVector3FloatData btStaticPlaneShapeData->m_localScaling
void btStaticPlaneShapeData_m_localScaling_set(void *c,void* a) {
	::btStaticPlaneShapeData *o = (::btStaticPlaneShapeData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_localScaling = ta;
}
void* btStaticPlaneShapeData_m_localScaling_get(void *c) {
	::btStaticPlaneShapeData *o = (::btStaticPlaneShapeData*)c;
	return (void*)&(o->m_localScaling);
}

//attribute: ::btVector3FloatData btStaticPlaneShapeData->m_planeNormal
void btStaticPlaneShapeData_m_planeNormal_set(void *c,void* a) {
	::btStaticPlaneShapeData *o = (::btStaticPlaneShapeData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_planeNormal = ta;
}
void* btStaticPlaneShapeData_m_planeNormal_get(void *c) {
	::btStaticPlaneShapeData *o = (::btStaticPlaneShapeData*)c;
	return (void*)&(o->m_planeNormal);
}

//attribute: float btStaticPlaneShapeData->m_planeConstant
void btStaticPlaneShapeData_m_planeConstant_set(void *c,float a) {
	::btStaticPlaneShapeData *o = (::btStaticPlaneShapeData*)c;
	o->m_planeConstant = a;
}
float btStaticPlaneShapeData_m_planeConstant_get(void *c) {
	::btStaticPlaneShapeData *o = (::btStaticPlaneShapeData*)c;
	return (float)(o->m_planeConstant);
}

//attribute: char[4] btStaticPlaneShapeData->m_pad
// attribute not supported: //attribute: char[4] btStaticPlaneShapeData->m_pad

// ::btStridingMeshInterface
//not supported method: getLockedReadOnlyVertexIndexBase void ( ::btStridingMeshInterface::* )( unsigned char const * *,int &,::PHY_ScalarType &,int &,unsigned char const * *,int &,int &,::PHY_ScalarType &,int ) const
// error:  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported, int - ok, void - ok

//method: calculateSerializeBufferSize int ( ::btStridingMeshInterface::* )(  ) const
int btStridingMeshInterface_calculateSerializeBufferSize(void *c) {
	::btStridingMeshInterface *o = (::btStridingMeshInterface*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: calculateAabbBruteForce void ( ::btStridingMeshInterface::* )( ::btVector3 &,::btVector3 & ) 
void btStridingMeshInterface_calculateAabbBruteForce(void *c,float* p0,float* p1) {
	::btStridingMeshInterface *o = (::btStridingMeshInterface*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateAabbBruteForce(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: serialize char const * ( ::btStridingMeshInterface::* )( void *,::btSerializer * ) const
char const * btStridingMeshInterface_serialize(void *c,void* p0,void* p1) {
	::btStridingMeshInterface *o = (::btStridingMeshInterface*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: preallocateVertices void ( ::btStridingMeshInterface::* )( int ) 
void btStridingMeshInterface_preallocateVertices(void *c,int p0) {
	::btStridingMeshInterface *o = (::btStridingMeshInterface*)c;
	o->preallocateVertices(p0);
}
//method: unLockVertexBase void ( ::btStridingMeshInterface::* )( int ) 
void btStridingMeshInterface_unLockVertexBase(void *c,int p0) {
	::btStridingMeshInterface *o = (::btStridingMeshInterface*)c;
	o->unLockVertexBase(p0);
}
//method: getScaling ::btVector3 const & ( ::btStridingMeshInterface::* )(  ) const
void btStridingMeshInterface_getScaling(void *c,float* ret) {
	::btStridingMeshInterface *o = (::btStridingMeshInterface*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getScaling();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: preallocateIndices void ( ::btStridingMeshInterface::* )( int ) 
void btStridingMeshInterface_preallocateIndices(void *c,int p0) {
	::btStridingMeshInterface *o = (::btStridingMeshInterface*)c;
	o->preallocateIndices(p0);
}
//method: setPremadeAabb void ( ::btStridingMeshInterface::* )( ::btVector3 const &,::btVector3 const & ) const
void btStridingMeshInterface_setPremadeAabb(void *c,float* p0,float* p1) {
	::btStridingMeshInterface *o = (::btStridingMeshInterface*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->setPremadeAabb(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: InternalProcessAllTriangles void ( ::btStridingMeshInterface::* )( ::btInternalTriangleIndexCallback *,::btVector3 const &,::btVector3 const & ) const
void btStridingMeshInterface_InternalProcessAllTriangles(void *c,void* p0,float* p1,float* p2) {
	::btStridingMeshInterface *o = (::btStridingMeshInterface*)c;
	::btInternalTriangleIndexCallback * tp0 = (::btInternalTriangleIndexCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->InternalProcessAllTriangles(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//not supported method: getPremadeAabb void ( ::btStridingMeshInterface::* )( ::btVector3 *,::btVector3 * ) const
// error:  - unsupported,  - unsupported, void - ok

//method: getNumSubParts int ( ::btStridingMeshInterface::* )(  ) const
int btStridingMeshInterface_getNumSubParts(void *c) {
	::btStridingMeshInterface *o = (::btStridingMeshInterface*)c;
	int retVal = (int)o->getNumSubParts();
	return retVal;
}
//not supported method: getLockedVertexIndexBase void ( ::btStridingMeshInterface::* )( unsigned char * *,int &,::PHY_ScalarType &,int &,unsigned char * *,int &,int &,::PHY_ScalarType &,int ) 
// error:  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported, int - ok, void - ok

//method: hasPremadeAabb bool ( ::btStridingMeshInterface::* )(  ) const
int btStridingMeshInterface_hasPremadeAabb(void *c) {
	::btStridingMeshInterface *o = (::btStridingMeshInterface*)c;
	int retVal = (int)o->hasPremadeAabb();
	return retVal;
}
//method: setScaling void ( ::btStridingMeshInterface::* )( ::btVector3 const & ) 
void btStridingMeshInterface_setScaling(void *c,float* p0) {
	::btStridingMeshInterface *o = (::btStridingMeshInterface*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: unLockReadOnlyVertexBase void ( ::btStridingMeshInterface::* )( int ) const
void btStridingMeshInterface_unLockReadOnlyVertexBase(void *c,int p0) {
	::btStridingMeshInterface *o = (::btStridingMeshInterface*)c;
	o->unLockReadOnlyVertexBase(p0);
}
//attribute: ::btVector3 btStridingMeshInterface->m_scaling
void btStridingMeshInterface_m_scaling_set(void *c,float* a) {
	::btStridingMeshInterface *o = (::btStridingMeshInterface*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_scaling = ta;
}
void btStridingMeshInterface_m_scaling_get(void *c,float* a) {
	::btStridingMeshInterface *o = (::btStridingMeshInterface*)c;
	a[0]=(o->m_scaling).m_floats[0];a[1]=(o->m_scaling).m_floats[1];a[2]=(o->m_scaling).m_floats[2];
}


// ::btStridingMeshInterfaceData
//constructor: btStridingMeshInterfaceData  ( ::btStridingMeshInterfaceData::* )(  ) 
void* btStridingMeshInterfaceData_new() {
	::btStridingMeshInterfaceData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btStridingMeshInterfaceData),16);
	o = new (mem)::btStridingMeshInterfaceData();
	return (void*)o;
}
void btStridingMeshInterfaceData_free(void *c) {
	::btStridingMeshInterfaceData *o = (::btStridingMeshInterfaceData*)c;
	delete o;
}
//attribute: ::btMeshPartData * btStridingMeshInterfaceData->m_meshPartsPtr
void btStridingMeshInterfaceData_m_meshPartsPtr_set(void *c,void* a) {
	::btStridingMeshInterfaceData *o = (::btStridingMeshInterfaceData*)c;
	::btMeshPartData * ta = (::btMeshPartData *)a;
	o->m_meshPartsPtr = ta;
}
void* btStridingMeshInterfaceData_m_meshPartsPtr_get(void *c) {
	::btStridingMeshInterfaceData *o = (::btStridingMeshInterfaceData*)c;
	return (void*)(o->m_meshPartsPtr);
}

//attribute: ::btVector3FloatData btStridingMeshInterfaceData->m_scaling
void btStridingMeshInterfaceData_m_scaling_set(void *c,void* a) {
	::btStridingMeshInterfaceData *o = (::btStridingMeshInterfaceData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_scaling = ta;
}
void* btStridingMeshInterfaceData_m_scaling_get(void *c) {
	::btStridingMeshInterfaceData *o = (::btStridingMeshInterfaceData*)c;
	return (void*)&(o->m_scaling);
}

//attribute: int btStridingMeshInterfaceData->m_numMeshParts
void btStridingMeshInterfaceData_m_numMeshParts_set(void *c,int a) {
	::btStridingMeshInterfaceData *o = (::btStridingMeshInterfaceData*)c;
	o->m_numMeshParts = a;
}
int btStridingMeshInterfaceData_m_numMeshParts_get(void *c) {
	::btStridingMeshInterfaceData *o = (::btStridingMeshInterfaceData*)c;
	return (int)(o->m_numMeshParts);
}

//attribute: char[4] btStridingMeshInterfaceData->m_padding
// attribute not supported: //attribute: char[4] btStridingMeshInterfaceData->m_padding

// ::btTriangleCallback
//not supported method: processTriangle void ( ::btTriangleCallback::* )( ::btVector3 *,int,int ) 
// error:  - unsupported, int - ok, int - ok, void - ok


// ::btTriangleIndexVertexArray
//constructor: btTriangleIndexVertexArray  ( ::btTriangleIndexVertexArray::* )(  ) 
void* btTriangleIndexVertexArray_new0() {
	::btTriangleIndexVertexArray *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTriangleIndexVertexArray),16);
	o = new (mem)::btTriangleIndexVertexArray();
	return (void*)o;
}
//not supported constructor: btTriangleIndexVertexArray  ( ::btTriangleIndexVertexArray::* )( int,int *,int,int,::btScalar *,int ) 
// error: int - ok,  - unsupported, int - ok, int - ok,  - unsupported, int - ok

void btTriangleIndexVertexArray_free(void *c) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	delete o;
}
//not supported method: getLockedReadOnlyVertexIndexBase void ( ::btTriangleIndexVertexArray::* )( unsigned char const * *,int &,::PHY_ScalarType &,int &,unsigned char const * *,int &,int &,::PHY_ScalarType &,int ) const
// error:  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported, int - ok, void - ok

//method: preallocateIndices void ( ::btTriangleIndexVertexArray::* )( int ) 
void btTriangleIndexVertexArray_preallocateIndices(void *c,int p0) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	o->preallocateIndices(p0);
}
//method: preallocateVertices void ( ::btTriangleIndexVertexArray::* )( int ) 
void btTriangleIndexVertexArray_preallocateVertices(void *c,int p0) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	o->preallocateVertices(p0);
}
//method: getIndexedMeshArray ::IndexedMeshArray & ( ::btTriangleIndexVertexArray::* )(  ) 
void* btTriangleIndexVertexArray_getIndexedMeshArray(void *c) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	void* retVal = (void*) &(o->getIndexedMeshArray());
	return retVal;
}
//method: getIndexedMeshArray ::IndexedMeshArray & ( ::btTriangleIndexVertexArray::* )(  ) 
void* btTriangleIndexVertexArray_getIndexedMeshArray0(void *c) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	void* retVal = (void*) &(o->getIndexedMeshArray());
	return retVal;
}
//method: getIndexedMeshArray ::IndexedMeshArray const & ( ::btTriangleIndexVertexArray::* )(  ) const
void* btTriangleIndexVertexArray_getIndexedMeshArray1(void *c) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	void* retVal = (void*) &(o->getIndexedMeshArray());
	return retVal;
}
//method: setPremadeAabb void ( ::btTriangleIndexVertexArray::* )( ::btVector3 const &,::btVector3 const & ) const
void btTriangleIndexVertexArray_setPremadeAabb(void *c,float* p0,float* p1) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->setPremadeAabb(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//not supported method: getPremadeAabb void ( ::btTriangleIndexVertexArray::* )( ::btVector3 *,::btVector3 * ) const
// error:  - unsupported,  - unsupported, void - ok

//not supported method: addIndexedMesh void ( ::btTriangleIndexVertexArray::* )( ::btIndexedMesh const &,::PHY_ScalarType ) 
// error: ::btIndexedMesh const & - ok,  - unsupported, void - ok

//method: getNumSubParts int ( ::btTriangleIndexVertexArray::* )(  ) const
int btTriangleIndexVertexArray_getNumSubParts(void *c) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	int retVal = (int)o->getNumSubParts();
	return retVal;
}
//not supported method: getLockedVertexIndexBase void ( ::btTriangleIndexVertexArray::* )( unsigned char * *,int &,::PHY_ScalarType &,int &,unsigned char * *,int &,int &,::PHY_ScalarType &,int ) 
// error:  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported, int - ok, void - ok

//method: hasPremadeAabb bool ( ::btTriangleIndexVertexArray::* )(  ) const
int btTriangleIndexVertexArray_hasPremadeAabb(void *c) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	int retVal = (int)o->hasPremadeAabb();
	return retVal;
}
//method: unLockVertexBase void ( ::btTriangleIndexVertexArray::* )( int ) 
void btTriangleIndexVertexArray_unLockVertexBase(void *c,int p0) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	o->unLockVertexBase(p0);
}
//method: unLockReadOnlyVertexBase void ( ::btTriangleIndexVertexArray::* )( int ) const
void btTriangleIndexVertexArray_unLockReadOnlyVertexBase(void *c,int p0) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	o->unLockReadOnlyVertexBase(p0);
}
//attribute: ::IndexedMeshArray btTriangleIndexVertexArray->m_indexedMeshes
void btTriangleIndexVertexArray_m_indexedMeshes_set(void *c,void* a) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	::IndexedMeshArray & ta = *(::btAlignedObjectArray<btIndexedMesh> *)a;
	o->m_indexedMeshes = ta;
}
void* btTriangleIndexVertexArray_m_indexedMeshes_get(void *c) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	return (void*)&(o->m_indexedMeshes);
}

//attribute: int[2] btTriangleIndexVertexArray->m_pad
// attribute not supported: //attribute: int[2] btTriangleIndexVertexArray->m_pad
//attribute: int btTriangleIndexVertexArray->m_hasAabb
void btTriangleIndexVertexArray_m_hasAabb_set(void *c,int a) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	o->m_hasAabb = a;
}
int btTriangleIndexVertexArray_m_hasAabb_get(void *c) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	return (int)(o->m_hasAabb);
}

//attribute: ::btVector3 btTriangleIndexVertexArray->m_aabbMin
void btTriangleIndexVertexArray_m_aabbMin_set(void *c,float* a) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_aabbMin = ta;
}
void btTriangleIndexVertexArray_m_aabbMin_get(void *c,float* a) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	a[0]=(o->m_aabbMin).m_floats[0];a[1]=(o->m_aabbMin).m_floats[1];a[2]=(o->m_aabbMin).m_floats[2];
}

//attribute: ::btVector3 btTriangleIndexVertexArray->m_aabbMax
void btTriangleIndexVertexArray_m_aabbMax_set(void *c,float* a) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_aabbMax = ta;
}
void btTriangleIndexVertexArray_m_aabbMax_get(void *c,float* a) {
	::btTriangleIndexVertexArray *o = (::btTriangleIndexVertexArray*)c;
	a[0]=(o->m_aabbMax).m_floats[0];a[1]=(o->m_aabbMax).m_floats[1];a[2]=(o->m_aabbMax).m_floats[2];
}


// ::btTriangleInfo
//constructor: btTriangleInfo  ( ::btTriangleInfo::* )(  ) 
void* btTriangleInfo_new() {
	::btTriangleInfo *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTriangleInfo),16);
	o = new (mem)::btTriangleInfo();
	return (void*)o;
}
void btTriangleInfo_free(void *c) {
	::btTriangleInfo *o = (::btTriangleInfo*)c;
	delete o;
}
//attribute: ::btScalar btTriangleInfo->m_edgeV0V1Angle
void btTriangleInfo_m_edgeV0V1Angle_set(void *c,float a) {
	::btTriangleInfo *o = (::btTriangleInfo*)c;
	o->m_edgeV0V1Angle = a;
}
float btTriangleInfo_m_edgeV0V1Angle_get(void *c) {
	::btTriangleInfo *o = (::btTriangleInfo*)c;
	return (float)(o->m_edgeV0V1Angle);
}

//attribute: ::btScalar btTriangleInfo->m_edgeV1V2Angle
void btTriangleInfo_m_edgeV1V2Angle_set(void *c,float a) {
	::btTriangleInfo *o = (::btTriangleInfo*)c;
	o->m_edgeV1V2Angle = a;
}
float btTriangleInfo_m_edgeV1V2Angle_get(void *c) {
	::btTriangleInfo *o = (::btTriangleInfo*)c;
	return (float)(o->m_edgeV1V2Angle);
}

//attribute: ::btScalar btTriangleInfo->m_edgeV2V0Angle
void btTriangleInfo_m_edgeV2V0Angle_set(void *c,float a) {
	::btTriangleInfo *o = (::btTriangleInfo*)c;
	o->m_edgeV2V0Angle = a;
}
float btTriangleInfo_m_edgeV2V0Angle_get(void *c) {
	::btTriangleInfo *o = (::btTriangleInfo*)c;
	return (float)(o->m_edgeV2V0Angle);
}

//attribute: int btTriangleInfo->m_flags
void btTriangleInfo_m_flags_set(void *c,int a) {
	::btTriangleInfo *o = (::btTriangleInfo*)c;
	o->m_flags = a;
}
int btTriangleInfo_m_flags_get(void *c) {
	::btTriangleInfo *o = (::btTriangleInfo*)c;
	return (int)(o->m_flags);
}


// ::btTriangleInfoData
//constructor: btTriangleInfoData  ( ::btTriangleInfoData::* )(  ) 
void* btTriangleInfoData_new() {
	::btTriangleInfoData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTriangleInfoData),16);
	o = new (mem)::btTriangleInfoData();
	return (void*)o;
}
void btTriangleInfoData_free(void *c) {
	::btTriangleInfoData *o = (::btTriangleInfoData*)c;
	delete o;
}
//attribute: int btTriangleInfoData->m_flags
void btTriangleInfoData_m_flags_set(void *c,int a) {
	::btTriangleInfoData *o = (::btTriangleInfoData*)c;
	o->m_flags = a;
}
int btTriangleInfoData_m_flags_get(void *c) {
	::btTriangleInfoData *o = (::btTriangleInfoData*)c;
	return (int)(o->m_flags);
}

//attribute: float btTriangleInfoData->m_edgeV0V1Angle
void btTriangleInfoData_m_edgeV0V1Angle_set(void *c,float a) {
	::btTriangleInfoData *o = (::btTriangleInfoData*)c;
	o->m_edgeV0V1Angle = a;
}
float btTriangleInfoData_m_edgeV0V1Angle_get(void *c) {
	::btTriangleInfoData *o = (::btTriangleInfoData*)c;
	return (float)(o->m_edgeV0V1Angle);
}

//attribute: float btTriangleInfoData->m_edgeV1V2Angle
void btTriangleInfoData_m_edgeV1V2Angle_set(void *c,float a) {
	::btTriangleInfoData *o = (::btTriangleInfoData*)c;
	o->m_edgeV1V2Angle = a;
}
float btTriangleInfoData_m_edgeV1V2Angle_get(void *c) {
	::btTriangleInfoData *o = (::btTriangleInfoData*)c;
	return (float)(o->m_edgeV1V2Angle);
}

//attribute: float btTriangleInfoData->m_edgeV2V0Angle
void btTriangleInfoData_m_edgeV2V0Angle_set(void *c,float a) {
	::btTriangleInfoData *o = (::btTriangleInfoData*)c;
	o->m_edgeV2V0Angle = a;
}
float btTriangleInfoData_m_edgeV2V0Angle_get(void *c) {
	::btTriangleInfoData *o = (::btTriangleInfoData*)c;
	return (float)(o->m_edgeV2V0Angle);
}


// ::btTriangleInfoMap
//constructor: btTriangleInfoMap  ( ::btTriangleInfoMap::* )(  ) 
void* btTriangleInfoMap_new() {
	::btTriangleInfoMap *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTriangleInfoMap),16);
	o = new (mem)::btTriangleInfoMap();
	return (void*)o;
}
void btTriangleInfoMap_free(void *c) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	delete o;
}
//method: serialize char const * ( ::btTriangleInfoMap::* )( void *,::btSerializer * ) const
char const * btTriangleInfoMap_serialize(void *c,void* p0,void* p1) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: calculateSerializeBufferSize int ( ::btTriangleInfoMap::* )(  ) const
int btTriangleInfoMap_calculateSerializeBufferSize(void *c) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: deSerialize void ( ::btTriangleInfoMap::* )( ::btTriangleInfoMapData & ) 
void btTriangleInfoMap_deSerialize(void *c,void* p0) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	::btTriangleInfoMapData & tp0 = *(::btTriangleInfoMapData *)p0;
	o->deSerialize(tp0);
}
//attribute: ::btScalar btTriangleInfoMap->m_convexEpsilon
void btTriangleInfoMap_m_convexEpsilon_set(void *c,float a) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	o->m_convexEpsilon = a;
}
float btTriangleInfoMap_m_convexEpsilon_get(void *c) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	return (float)(o->m_convexEpsilon);
}

//attribute: ::btScalar btTriangleInfoMap->m_edgeDistanceThreshold
void btTriangleInfoMap_m_edgeDistanceThreshold_set(void *c,float a) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	o->m_edgeDistanceThreshold = a;
}
float btTriangleInfoMap_m_edgeDistanceThreshold_get(void *c) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	return (float)(o->m_edgeDistanceThreshold);
}

//attribute: ::btScalar btTriangleInfoMap->m_equalVertexThreshold
void btTriangleInfoMap_m_equalVertexThreshold_set(void *c,float a) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	o->m_equalVertexThreshold = a;
}
float btTriangleInfoMap_m_equalVertexThreshold_get(void *c) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	return (float)(o->m_equalVertexThreshold);
}

//attribute: ::btScalar btTriangleInfoMap->m_maxEdgeAngleThreshold
void btTriangleInfoMap_m_maxEdgeAngleThreshold_set(void *c,float a) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	o->m_maxEdgeAngleThreshold = a;
}
float btTriangleInfoMap_m_maxEdgeAngleThreshold_get(void *c) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	return (float)(o->m_maxEdgeAngleThreshold);
}

//attribute: ::btScalar btTriangleInfoMap->m_planarEpsilon
void btTriangleInfoMap_m_planarEpsilon_set(void *c,float a) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	o->m_planarEpsilon = a;
}
float btTriangleInfoMap_m_planarEpsilon_get(void *c) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	return (float)(o->m_planarEpsilon);
}

//attribute: ::btScalar btTriangleInfoMap->m_zeroAreaThreshold
void btTriangleInfoMap_m_zeroAreaThreshold_set(void *c,float a) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	o->m_zeroAreaThreshold = a;
}
float btTriangleInfoMap_m_zeroAreaThreshold_get(void *c) {
	::btTriangleInfoMap *o = (::btTriangleInfoMap*)c;
	return (float)(o->m_zeroAreaThreshold);
}


// ::btTriangleInfoMapData
//constructor: btTriangleInfoMapData  ( ::btTriangleInfoMapData::* )(  ) 
void* btTriangleInfoMapData_new() {
	::btTriangleInfoMapData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTriangleInfoMapData),16);
	o = new (mem)::btTriangleInfoMapData();
	return (void*)o;
}
void btTriangleInfoMapData_free(void *c) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	delete o;
}
//attribute: float btTriangleInfoMapData->m_convexEpsilon
void btTriangleInfoMapData_m_convexEpsilon_set(void *c,float a) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	o->m_convexEpsilon = a;
}
float btTriangleInfoMapData_m_convexEpsilon_get(void *c) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	return (float)(o->m_convexEpsilon);
}

//attribute: float btTriangleInfoMapData->m_edgeDistanceThreshold
void btTriangleInfoMapData_m_edgeDistanceThreshold_set(void *c,float a) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	o->m_edgeDistanceThreshold = a;
}
float btTriangleInfoMapData_m_edgeDistanceThreshold_get(void *c) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	return (float)(o->m_edgeDistanceThreshold);
}

//attribute: float btTriangleInfoMapData->m_equalVertexThreshold
void btTriangleInfoMapData_m_equalVertexThreshold_set(void *c,float a) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	o->m_equalVertexThreshold = a;
}
float btTriangleInfoMapData_m_equalVertexThreshold_get(void *c) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	return (float)(o->m_equalVertexThreshold);
}

//attribute: int * btTriangleInfoMapData->m_hashTablePtr
// attribute not supported: //attribute: int * btTriangleInfoMapData->m_hashTablePtr
//attribute: int btTriangleInfoMapData->m_hashTableSize
void btTriangleInfoMapData_m_hashTableSize_set(void *c,int a) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	o->m_hashTableSize = a;
}
int btTriangleInfoMapData_m_hashTableSize_get(void *c) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	return (int)(o->m_hashTableSize);
}

//attribute: int * btTriangleInfoMapData->m_keyArrayPtr
// attribute not supported: //attribute: int * btTriangleInfoMapData->m_keyArrayPtr
//attribute: int * btTriangleInfoMapData->m_nextPtr
// attribute not supported: //attribute: int * btTriangleInfoMapData->m_nextPtr
//attribute: int btTriangleInfoMapData->m_nextSize
void btTriangleInfoMapData_m_nextSize_set(void *c,int a) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	o->m_nextSize = a;
}
int btTriangleInfoMapData_m_nextSize_get(void *c) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	return (int)(o->m_nextSize);
}

//attribute: int btTriangleInfoMapData->m_numKeys
void btTriangleInfoMapData_m_numKeys_set(void *c,int a) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	o->m_numKeys = a;
}
int btTriangleInfoMapData_m_numKeys_get(void *c) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	return (int)(o->m_numKeys);
}

//attribute: int btTriangleInfoMapData->m_numValues
void btTriangleInfoMapData_m_numValues_set(void *c,int a) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	o->m_numValues = a;
}
int btTriangleInfoMapData_m_numValues_get(void *c) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	return (int)(o->m_numValues);
}

//attribute: char[4] btTriangleInfoMapData->m_padding
// attribute not supported: //attribute: char[4] btTriangleInfoMapData->m_padding
//attribute: float btTriangleInfoMapData->m_planarEpsilon
void btTriangleInfoMapData_m_planarEpsilon_set(void *c,float a) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	o->m_planarEpsilon = a;
}
float btTriangleInfoMapData_m_planarEpsilon_get(void *c) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	return (float)(o->m_planarEpsilon);
}

//attribute: ::btTriangleInfoData * btTriangleInfoMapData->m_valueArrayPtr
void btTriangleInfoMapData_m_valueArrayPtr_set(void *c,void* a) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	::btTriangleInfoData * ta = (::btTriangleInfoData *)a;
	o->m_valueArrayPtr = ta;
}
void* btTriangleInfoMapData_m_valueArrayPtr_get(void *c) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	return (void*)(o->m_valueArrayPtr);
}

//attribute: float btTriangleInfoMapData->m_zeroAreaThreshold
void btTriangleInfoMapData_m_zeroAreaThreshold_set(void *c,float a) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	o->m_zeroAreaThreshold = a;
}
float btTriangleInfoMapData_m_zeroAreaThreshold_get(void *c) {
	::btTriangleInfoMapData *o = (::btTriangleInfoMapData*)c;
	return (float)(o->m_zeroAreaThreshold);
}


// ::btTriangleMesh
//constructor: btTriangleMesh  ( ::btTriangleMesh::* )( bool,bool ) 
void* btTriangleMesh_new(int p0,int p1) {
	::btTriangleMesh *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTriangleMesh),16);
	o = new (mem)::btTriangleMesh(p0,p1);
	return (void*)o;
}
void btTriangleMesh_free(void *c) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	delete o;
}
//method: preallocateIndices void ( ::btTriangleMesh::* )( int ) 
void btTriangleMesh_preallocateIndices(void *c,int p0) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	o->preallocateIndices(p0);
}
//method: getNumTriangles int ( ::btTriangleMesh::* )(  ) const
int btTriangleMesh_getNumTriangles(void *c) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	int retVal = (int)o->getNumTriangles();
	return retVal;
}
//method: getUse32bitIndices bool ( ::btTriangleMesh::* )(  ) const
int btTriangleMesh_getUse32bitIndices(void *c) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	int retVal = (int)o->getUse32bitIndices();
	return retVal;
}
//method: addIndex void ( ::btTriangleMesh::* )( int ) 
void btTriangleMesh_addIndex(void *c,int p0) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	o->addIndex(p0);
}
//method: preallocateVertices void ( ::btTriangleMesh::* )( int ) 
void btTriangleMesh_preallocateVertices(void *c,int p0) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	o->preallocateVertices(p0);
}
//method: findOrAddVertex int ( ::btTriangleMesh::* )( ::btVector3 const &,bool ) 
int btTriangleMesh_findOrAddVertex(void *c,float* p0,int p1) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	int retVal = (int)o->findOrAddVertex(tp0,p1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return retVal;
}
//method: getUse4componentVertices bool ( ::btTriangleMesh::* )(  ) const
int btTriangleMesh_getUse4componentVertices(void *c) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	int retVal = (int)o->getUse4componentVertices();
	return retVal;
}
//method: addTriangle void ( ::btTriangleMesh::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,bool ) 
void btTriangleMesh_addTriangle(void *c,float* p0,float* p1,float* p2,int p3) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->addTriangle(tp0,tp1,tp2,p3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//attribute: ::btAlignedObjectArray<btVector3> btTriangleMesh->m_4componentVertices
void btTriangleMesh_m_4componentVertices_set(void *c,void* a) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	::btAlignedObjectArray<btVector3> & ta = *(::btAlignedObjectArray<btVector3> *)a;
	o->m_4componentVertices = ta;
}
void* btTriangleMesh_m_4componentVertices_get(void *c) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	return (void*)&(o->m_4componentVertices);
}

//attribute: ::btAlignedObjectArray<float> btTriangleMesh->m_3componentVertices
void btTriangleMesh_m_3componentVertices_set(void *c,void* a) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	::btAlignedObjectArray<float> & ta = *(::btAlignedObjectArray<float> *)a;
	o->m_3componentVertices = ta;
}
void* btTriangleMesh_m_3componentVertices_get(void *c) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	return (void*)&(o->m_3componentVertices);
}

//attribute: ::btAlignedObjectArray<unsigned int> btTriangleMesh->m_32bitIndices
void btTriangleMesh_m_32bitIndices_set(void *c,void* a) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	::btAlignedObjectArray<unsigned int> & ta = *(::btAlignedObjectArray<unsigned int> *)a;
	o->m_32bitIndices = ta;
}
void* btTriangleMesh_m_32bitIndices_get(void *c) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	return (void*)&(o->m_32bitIndices);
}

//attribute: ::btAlignedObjectArray<unsigned short> btTriangleMesh->m_16bitIndices
void btTriangleMesh_m_16bitIndices_set(void *c,void* a) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	::btAlignedObjectArray<unsigned short> & ta = *(::btAlignedObjectArray<unsigned short> *)a;
	o->m_16bitIndices = ta;
}
void* btTriangleMesh_m_16bitIndices_get(void *c) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	return (void*)&(o->m_16bitIndices);
}

//attribute: bool btTriangleMesh->m_use32bitIndices
void btTriangleMesh_m_use32bitIndices_set(void *c,int a) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	o->m_use32bitIndices = a;
}
int btTriangleMesh_m_use32bitIndices_get(void *c) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	return (int)(o->m_use32bitIndices);
}

//attribute: bool btTriangleMesh->m_use4componentVertices
void btTriangleMesh_m_use4componentVertices_set(void *c,int a) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	o->m_use4componentVertices = a;
}
int btTriangleMesh_m_use4componentVertices_get(void *c) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	return (int)(o->m_use4componentVertices);
}

//attribute: ::btScalar btTriangleMesh->m_weldingThreshold
void btTriangleMesh_m_weldingThreshold_set(void *c,float a) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	o->m_weldingThreshold = a;
}
float btTriangleMesh_m_weldingThreshold_get(void *c) {
	::btTriangleMesh *o = (::btTriangleMesh*)c;
	return (float)(o->m_weldingThreshold);
}


// ::btTriangleMeshShape
//constructor: btTriangleMeshShape  ( ::btTriangleMeshShape::* )( ::btStridingMeshInterface * ) 
void* btTriangleMeshShape_new(void* p0) {
	::btTriangleMeshShape *o = 0;
	 void *mem = 0;
	::btStridingMeshInterface * tp0 = (::btStridingMeshInterface *)p0;
	mem = btAlignedAlloc(sizeof(::btTriangleMeshShape),16);
	o = new (mem)::btTriangleMeshShape(tp0);
	return (void*)o;
}
void btTriangleMeshShape_free(void *c) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	delete o;
}
//method: calculateLocalInertia void ( ::btTriangleMeshShape::* )( ::btScalar,::btVector3 & ) const
void btTriangleMeshShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getLocalAabbMax ::btVector3 const & ( ::btTriangleMeshShape::* )(  ) const
void btTriangleMeshShape_getLocalAabbMax(void *c,float* ret) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLocalAabbMax();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: localGetSupportingVertex ::btVector3 ( ::btTriangleMeshShape::* )( ::btVector3 const & ) const
void btTriangleMeshShape_localGetSupportingVertex(void *c,float* p0,float* ret) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertex(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getName char const * ( ::btTriangleMeshShape::* )(  ) const
char const * btTriangleMeshShape_getName(void *c) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: getLocalScaling ::btVector3 const & ( ::btTriangleMeshShape::* )(  ) const
void btTriangleMeshShape_getLocalScaling(void *c,float* ret) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLocalScaling();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: recalcLocalAabb void ( ::btTriangleMeshShape::* )(  ) 
void btTriangleMeshShape_recalcLocalAabb(void *c) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	o->recalcLocalAabb();
}
//method: setLocalScaling void ( ::btTriangleMeshShape::* )( ::btVector3 const & ) 
void btTriangleMeshShape_setLocalScaling(void *c,float* p0) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getMeshInterface ::btStridingMeshInterface * ( ::btTriangleMeshShape::* )(  ) 
void* btTriangleMeshShape_getMeshInterface(void *c) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	void* retVal = (void*) o->getMeshInterface();
	return retVal;
}
//method: getMeshInterface ::btStridingMeshInterface * ( ::btTriangleMeshShape::* )(  ) 
void* btTriangleMeshShape_getMeshInterface0(void *c) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	void* retVal = (void*) o->getMeshInterface();
	return retVal;
}
//method: getMeshInterface ::btStridingMeshInterface const * ( ::btTriangleMeshShape::* )(  ) const
void* btTriangleMeshShape_getMeshInterface1(void *c) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	void* retVal = (void*) o->getMeshInterface();
	return retVal;
}
//method: getAabb void ( ::btTriangleMeshShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btTriangleMeshShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: processAllTriangles void ( ::btTriangleMeshShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
void btTriangleMeshShape_processAllTriangles(void *c,void* p0,float* p1,float* p2) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	::btTriangleCallback * tp0 = (::btTriangleCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->processAllTriangles(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btTriangleMeshShape::* )( ::btVector3 const & ) const
void btTriangleMeshShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertexWithoutMargin(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getLocalAabbMin ::btVector3 const & ( ::btTriangleMeshShape::* )(  ) const
void btTriangleMeshShape_getLocalAabbMin(void *c,float* ret) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLocalAabbMin();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//attribute: ::btVector3 btTriangleMeshShape->m_localAabbMin
void btTriangleMeshShape_m_localAabbMin_set(void *c,float* a) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localAabbMin = ta;
}
void btTriangleMeshShape_m_localAabbMin_get(void *c,float* a) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	a[0]=(o->m_localAabbMin).m_floats[0];a[1]=(o->m_localAabbMin).m_floats[1];a[2]=(o->m_localAabbMin).m_floats[2];
}

//attribute: ::btVector3 btTriangleMeshShape->m_localAabbMax
void btTriangleMeshShape_m_localAabbMax_set(void *c,float* a) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localAabbMax = ta;
}
void btTriangleMeshShape_m_localAabbMax_get(void *c,float* a) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	a[0]=(o->m_localAabbMax).m_floats[0];a[1]=(o->m_localAabbMax).m_floats[1];a[2]=(o->m_localAabbMax).m_floats[2];
}

//attribute: ::btStridingMeshInterface * btTriangleMeshShape->m_meshInterface
void btTriangleMeshShape_m_meshInterface_set(void *c,void* a) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	::btStridingMeshInterface * ta = (::btStridingMeshInterface *)a;
	o->m_meshInterface = ta;
}
void* btTriangleMeshShape_m_meshInterface_get(void *c) {
	::btTriangleMeshShape *o = (::btTriangleMeshShape*)c;
	return (void*)(o->m_meshInterface);
}


// ::btTriangleMeshShapeData
//constructor: btTriangleMeshShapeData  ( ::btTriangleMeshShapeData::* )(  ) 
void* btTriangleMeshShapeData_new() {
	::btTriangleMeshShapeData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTriangleMeshShapeData),16);
	o = new (mem)::btTriangleMeshShapeData();
	return (void*)o;
}
void btTriangleMeshShapeData_free(void *c) {
	::btTriangleMeshShapeData *o = (::btTriangleMeshShapeData*)c;
	delete o;
}
//attribute: float btTriangleMeshShapeData->m_collisionMargin
void btTriangleMeshShapeData_m_collisionMargin_set(void *c,float a) {
	::btTriangleMeshShapeData *o = (::btTriangleMeshShapeData*)c;
	o->m_collisionMargin = a;
}
float btTriangleMeshShapeData_m_collisionMargin_get(void *c) {
	::btTriangleMeshShapeData *o = (::btTriangleMeshShapeData*)c;
	return (float)(o->m_collisionMargin);
}

//attribute: ::btCollisionShapeData btTriangleMeshShapeData->m_collisionShapeData
void btTriangleMeshShapeData_m_collisionShapeData_set(void *c,void* a) {
	::btTriangleMeshShapeData *o = (::btTriangleMeshShapeData*)c;
	::btCollisionShapeData & ta = *(::btCollisionShapeData *)a;
	o->m_collisionShapeData = ta;
}
void* btTriangleMeshShapeData_m_collisionShapeData_get(void *c) {
	::btTriangleMeshShapeData *o = (::btTriangleMeshShapeData*)c;
	return (void*)&(o->m_collisionShapeData);
}

//attribute: ::btStridingMeshInterfaceData btTriangleMeshShapeData->m_meshInterface
void btTriangleMeshShapeData_m_meshInterface_set(void *c,void* a) {
	::btTriangleMeshShapeData *o = (::btTriangleMeshShapeData*)c;
	::btStridingMeshInterfaceData & ta = *(::btStridingMeshInterfaceData *)a;
	o->m_meshInterface = ta;
}
void* btTriangleMeshShapeData_m_meshInterface_get(void *c) {
	::btTriangleMeshShapeData *o = (::btTriangleMeshShapeData*)c;
	return (void*)&(o->m_meshInterface);
}

//attribute: char[4] btTriangleMeshShapeData->m_pad3
// attribute not supported: //attribute: char[4] btTriangleMeshShapeData->m_pad3
//attribute: ::btQuantizedBvhDoubleData * btTriangleMeshShapeData->m_quantizedDoubleBvh
void btTriangleMeshShapeData_m_quantizedDoubleBvh_set(void *c,void* a) {
	::btTriangleMeshShapeData *o = (::btTriangleMeshShapeData*)c;
	::btQuantizedBvhDoubleData * ta = (::btQuantizedBvhDoubleData *)a;
	o->m_quantizedDoubleBvh = ta;
}
void* btTriangleMeshShapeData_m_quantizedDoubleBvh_get(void *c) {
	::btTriangleMeshShapeData *o = (::btTriangleMeshShapeData*)c;
	return (void*)(o->m_quantizedDoubleBvh);
}

//attribute: ::btQuantizedBvhFloatData * btTriangleMeshShapeData->m_quantizedFloatBvh
void btTriangleMeshShapeData_m_quantizedFloatBvh_set(void *c,void* a) {
	::btTriangleMeshShapeData *o = (::btTriangleMeshShapeData*)c;
	::btQuantizedBvhFloatData * ta = (::btQuantizedBvhFloatData *)a;
	o->m_quantizedFloatBvh = ta;
}
void* btTriangleMeshShapeData_m_quantizedFloatBvh_get(void *c) {
	::btTriangleMeshShapeData *o = (::btTriangleMeshShapeData*)c;
	return (void*)(o->m_quantizedFloatBvh);
}

//attribute: ::btTriangleInfoMapData * btTriangleMeshShapeData->m_triangleInfoMap
void btTriangleMeshShapeData_m_triangleInfoMap_set(void *c,void* a) {
	::btTriangleMeshShapeData *o = (::btTriangleMeshShapeData*)c;
	::btTriangleInfoMapData * ta = (::btTriangleInfoMapData *)a;
	o->m_triangleInfoMap = ta;
}
void* btTriangleMeshShapeData_m_triangleInfoMap_get(void *c) {
	::btTriangleMeshShapeData *o = (::btTriangleMeshShapeData*)c;
	return (void*)(o->m_triangleInfoMap);
}


// ::btTriangleShape
//constructor: btTriangleShape  ( ::btTriangleShape::* )(  ) 
void* btTriangleShape_new0() {
	::btTriangleShape *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTriangleShape),16);
	o = new (mem)::btTriangleShape();
	return (void*)o;
}
//constructor: btTriangleShape  ( ::btTriangleShape::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void* btTriangleShape_new1(float* p0,float* p1,float* p2) {
	::btTriangleShape *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	mem = btAlignedAlloc(sizeof(::btTriangleShape),16);
	o = new (mem)::btTriangleShape(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	return (void*)o;
}
void btTriangleShape_free(void *c) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	delete o;
}
//method: getVertexPtr ::btVector3 & ( ::btTriangleShape::* )( int ) 
void btTriangleShape_getVertexPtr(void *c,int p0,float* ret) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getVertexPtr(p0);
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getVertexPtr ::btVector3 & ( ::btTriangleShape::* )( int ) 
void btTriangleShape_getVertexPtr0(void *c,int p0,float* ret) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getVertexPtr(p0);
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getVertexPtr ::btVector3 const & ( ::btTriangleShape::* )( int ) const
void btTriangleShape_getVertexPtr1(void *c,int p0,float* ret) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getVertexPtr(p0);
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getNumPlanes int ( ::btTriangleShape::* )(  ) const
int btTriangleShape_getNumPlanes(void *c) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	int retVal = (int)o->getNumPlanes();
	return retVal;
}
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btTriangleShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

//method: getPreferredPenetrationDirection void ( ::btTriangleShape::* )( int,::btVector3 & ) const
void btTriangleShape_getPreferredPenetrationDirection(void *c,int p0,float* p1) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getPreferredPenetrationDirection(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getNumEdges int ( ::btTriangleShape::* )(  ) const
int btTriangleShape_getNumEdges(void *c) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	int retVal = (int)o->getNumEdges();
	return retVal;
}
//method: getName char const * ( ::btTriangleShape::* )(  ) const
char const * btTriangleShape_getName(void *c) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: getNumVertices int ( ::btTriangleShape::* )(  ) const
int btTriangleShape_getNumVertices(void *c) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	int retVal = (int)o->getNumVertices();
	return retVal;
}
//method: getEdge void ( ::btTriangleShape::* )( int,::btVector3 &,::btVector3 & ) const
void btTriangleShape_getEdge(void *c,int p0,float* p1,float* p2) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getEdge(p0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: isInside bool ( ::btTriangleShape::* )( ::btVector3 const &,::btScalar ) const
int btTriangleShape_isInside(void *c,float* p0,float p1) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	int retVal = (int)o->isInside(tp0,p1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return retVal;
}
//method: getPlane void ( ::btTriangleShape::* )( ::btVector3 &,::btVector3 &,int ) const
void btTriangleShape_getPlane(void *c,float* p0,float* p1,int p2) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getPlane(tp0,tp1,p2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getNumPreferredPenetrationDirections int ( ::btTriangleShape::* )(  ) const
int btTriangleShape_getNumPreferredPenetrationDirections(void *c) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	int retVal = (int)o->getNumPreferredPenetrationDirections();
	return retVal;
}
//method: getAabb void ( ::btTriangleShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btTriangleShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getVertex void ( ::btTriangleShape::* )( int,::btVector3 & ) const
void btTriangleShape_getVertex(void *c,int p0,float* p1) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getVertex(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: calcNormal void ( ::btTriangleShape::* )( ::btVector3 & ) const
void btTriangleShape_calcNormal(void *c,float* p0) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->calcNormal(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: calculateLocalInertia void ( ::btTriangleShape::* )( ::btScalar,::btVector3 & ) const
void btTriangleShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getPlaneEquation void ( ::btTriangleShape::* )( int,::btVector3 &,::btVector3 & ) const
void btTriangleShape_getPlaneEquation(void *c,int p0,float* p1,float* p2) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getPlaneEquation(p0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btTriangleShape::* )( ::btVector3 const & ) const
void btTriangleShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret) {
	::btTriangleShape *o = (::btTriangleShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertexWithoutMargin(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//attribute: ::btVector3[3] btTriangleShape->m_vertices1
// attribute not supported: //attribute: ::btVector3[3] btTriangleShape->m_vertices1

// ::btUniformScalingShape
//constructor: btUniformScalingShape  ( ::btUniformScalingShape::* )( ::btConvexShape *,::btScalar ) 
void* btUniformScalingShape_new(void* p0,float p1) {
	::btUniformScalingShape *o = 0;
	 void *mem = 0;
	::btConvexShape * tp0 = (::btConvexShape *)p0;
	mem = btAlignedAlloc(sizeof(::btUniformScalingShape),16);
	o = new (mem)::btUniformScalingShape(tp0,p1);
	return (void*)o;
}
void btUniformScalingShape_free(void *c) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	delete o;
}
//method: calculateLocalInertia void ( ::btUniformScalingShape::* )( ::btScalar,::btVector3 & ) const
void btUniformScalingShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getUniformScalingFactor ::btScalar ( ::btUniformScalingShape::* )(  ) const
float btUniformScalingShape_getUniformScalingFactor(void *c) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	float retVal = (float)o->getUniformScalingFactor();
	return retVal;
}
//method: localGetSupportingVertex ::btVector3 ( ::btUniformScalingShape::* )( ::btVector3 const & ) const
void btUniformScalingShape_localGetSupportingVertex(void *c,float* p0,float* ret) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertex(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btUniformScalingShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

//method: getName char const * ( ::btUniformScalingShape::* )(  ) const
char const * btUniformScalingShape_getName(void *c) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: getAabbSlow void ( ::btUniformScalingShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btUniformScalingShape_getAabbSlow(void *c,float* p0,float* p1,float* p2) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabbSlow(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getLocalScaling ::btVector3 const & ( ::btUniformScalingShape::* )(  ) const
void btUniformScalingShape_getLocalScaling(void *c,float* ret) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLocalScaling();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getChildShape ::btConvexShape * ( ::btUniformScalingShape::* )(  ) 
void* btUniformScalingShape_getChildShape(void *c) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	void* retVal = (void*) o->getChildShape();
	return retVal;
}
//method: getChildShape ::btConvexShape * ( ::btUniformScalingShape::* )(  ) 
void* btUniformScalingShape_getChildShape0(void *c) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	void* retVal = (void*) o->getChildShape();
	return retVal;
}
//method: getChildShape ::btConvexShape const * ( ::btUniformScalingShape::* )(  ) const
void* btUniformScalingShape_getChildShape1(void *c) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	void* retVal = (void*) o->getChildShape();
	return retVal;
}
//method: getPreferredPenetrationDirection void ( ::btUniformScalingShape::* )( int,::btVector3 & ) const
void btUniformScalingShape_getPreferredPenetrationDirection(void *c,int p0,float* p1) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getPreferredPenetrationDirection(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: setLocalScaling void ( ::btUniformScalingShape::* )( ::btVector3 const & ) 
void btUniformScalingShape_setLocalScaling(void *c,float* p0) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getNumPreferredPenetrationDirections int ( ::btUniformScalingShape::* )(  ) const
int btUniformScalingShape_getNumPreferredPenetrationDirections(void *c) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	int retVal = (int)o->getNumPreferredPenetrationDirections();
	return retVal;
}
//method: getAabb void ( ::btUniformScalingShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btUniformScalingShape_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: setMargin void ( ::btUniformScalingShape::* )( ::btScalar ) 
void btUniformScalingShape_setMargin(void *c,float p0) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	o->setMargin(p0);
}
//method: getMargin ::btScalar ( ::btUniformScalingShape::* )(  ) const
float btUniformScalingShape_getMargin(void *c) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	float retVal = (float)o->getMargin();
	return retVal;
}
//method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btUniformScalingShape::* )( ::btVector3 const & ) const
void btUniformScalingShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->localGetSupportingVertexWithoutMargin(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//attribute: ::btConvexShape * btUniformScalingShape->m_childConvexShape
void btUniformScalingShape_m_childConvexShape_set(void *c,void* a) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	::btConvexShape * ta = (::btConvexShape *)a;
	o->m_childConvexShape = ta;
}
void* btUniformScalingShape_m_childConvexShape_get(void *c) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	return (void*)(o->m_childConvexShape);
}

//attribute: ::btScalar btUniformScalingShape->m_uniformScalingFactor
void btUniformScalingShape_m_uniformScalingFactor_set(void *c,float a) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	o->m_uniformScalingFactor = a;
}
float btUniformScalingShape_m_uniformScalingFactor_get(void *c) {
	::btUniformScalingShape *o = (::btUniformScalingShape*)c;
	return (float)(o->m_uniformScalingFactor);
}


// ::BT_BOX_BOX_TRANSFORM_CACHE
//constructor: BT_BOX_BOX_TRANSFORM_CACHE  ( ::BT_BOX_BOX_TRANSFORM_CACHE::* )(  ) 
void* bT_BOX_BOX_TRANSFORM_CACHE_new() {
	::BT_BOX_BOX_TRANSFORM_CACHE *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::BT_BOX_BOX_TRANSFORM_CACHE),16);
	o = new (mem)::BT_BOX_BOX_TRANSFORM_CACHE();
	return (void*)o;
}
void bT_BOX_BOX_TRANSFORM_CACHE_free(void *c) {
	::BT_BOX_BOX_TRANSFORM_CACHE *o = (::BT_BOX_BOX_TRANSFORM_CACHE*)c;
	delete o;
}
//method: calc_from_full_invert void ( ::BT_BOX_BOX_TRANSFORM_CACHE::* )( ::btTransform const &,::btTransform const & ) 
void bT_BOX_BOX_TRANSFORM_CACHE_calc_from_full_invert(void *c,float* p0,float* p1) {
	::BT_BOX_BOX_TRANSFORM_CACHE *o = (::BT_BOX_BOX_TRANSFORM_CACHE*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->calc_from_full_invert(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: calc_from_homogenic void ( ::BT_BOX_BOX_TRANSFORM_CACHE::* )( ::btTransform const &,::btTransform const & ) 
void bT_BOX_BOX_TRANSFORM_CACHE_calc_from_homogenic(void *c,float* p0,float* p1) {
	::BT_BOX_BOX_TRANSFORM_CACHE *o = (::BT_BOX_BOX_TRANSFORM_CACHE*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->calc_from_homogenic(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: transform ::btVector3 ( ::BT_BOX_BOX_TRANSFORM_CACHE::* )( ::btVector3 const & ) const
void bT_BOX_BOX_TRANSFORM_CACHE_transform(void *c,float* p0,float* ret) {
	::BT_BOX_BOX_TRANSFORM_CACHE *o = (::BT_BOX_BOX_TRANSFORM_CACHE*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->transform(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: calc_absolute_matrix void ( ::BT_BOX_BOX_TRANSFORM_CACHE::* )(  ) 
void bT_BOX_BOX_TRANSFORM_CACHE_calc_absolute_matrix(void *c) {
	::BT_BOX_BOX_TRANSFORM_CACHE *o = (::BT_BOX_BOX_TRANSFORM_CACHE*)c;
	o->calc_absolute_matrix();
}
//attribute: ::btVector3 bT_BOX_BOX_TRANSFORM_CACHE->m_T1to0
void bT_BOX_BOX_TRANSFORM_CACHE_m_T1to0_set(void *c,float* a) {
	::BT_BOX_BOX_TRANSFORM_CACHE *o = (::BT_BOX_BOX_TRANSFORM_CACHE*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_T1to0 = ta;
}
void bT_BOX_BOX_TRANSFORM_CACHE_m_T1to0_get(void *c,float* a) {
	::BT_BOX_BOX_TRANSFORM_CACHE *o = (::BT_BOX_BOX_TRANSFORM_CACHE*)c;
	a[0]=(o->m_T1to0).m_floats[0];a[1]=(o->m_T1to0).m_floats[1];a[2]=(o->m_T1to0).m_floats[2];
}

//attribute: ::btMatrix3x3 bT_BOX_BOX_TRANSFORM_CACHE->m_R1to0
void bT_BOX_BOX_TRANSFORM_CACHE_m_R1to0_set(void *c,float* a) {
	::BT_BOX_BOX_TRANSFORM_CACHE *o = (::BT_BOX_BOX_TRANSFORM_CACHE*)c;
	btMatrix3x3 ta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	o->m_R1to0 = ta;
}
void bT_BOX_BOX_TRANSFORM_CACHE_m_R1to0_get(void *c,float* a) {
	::BT_BOX_BOX_TRANSFORM_CACHE *o = (::BT_BOX_BOX_TRANSFORM_CACHE*)c;
	a[0]=(o->m_R1to0).getRow(0).m_floats[0];a[1]=(o->m_R1to0).getRow(0).m_floats[1];a[2]=(o->m_R1to0).getRow(0).m_floats[2];a[3]=(o->m_R1to0).getRow(1).m_floats[0];a[4]=(o->m_R1to0).getRow(1).m_floats[1];a[5]=(o->m_R1to0).getRow(1).m_floats[2];a[6]=(o->m_R1to0).getRow(2).m_floats[0];a[7]=(o->m_R1to0).getRow(2).m_floats[1];a[8]=(o->m_R1to0).getRow(2).m_floats[2];
}

//attribute: ::btMatrix3x3 bT_BOX_BOX_TRANSFORM_CACHE->m_AR
void bT_BOX_BOX_TRANSFORM_CACHE_m_AR_set(void *c,float* a) {
	::BT_BOX_BOX_TRANSFORM_CACHE *o = (::BT_BOX_BOX_TRANSFORM_CACHE*)c;
	btMatrix3x3 ta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	o->m_AR = ta;
}
void bT_BOX_BOX_TRANSFORM_CACHE_m_AR_get(void *c,float* a) {
	::BT_BOX_BOX_TRANSFORM_CACHE *o = (::BT_BOX_BOX_TRANSFORM_CACHE*)c;
	a[0]=(o->m_AR).getRow(0).m_floats[0];a[1]=(o->m_AR).getRow(0).m_floats[1];a[2]=(o->m_AR).getRow(0).m_floats[2];a[3]=(o->m_AR).getRow(1).m_floats[0];a[4]=(o->m_AR).getRow(1).m_floats[1];a[5]=(o->m_AR).getRow(1).m_floats[2];a[6]=(o->m_AR).getRow(2).m_floats[0];a[7]=(o->m_AR).getRow(2).m_floats[1];a[8]=(o->m_AR).getRow(2).m_floats[2];
}


// ::BT_QUANTIZED_BVH_NODE
//constructor: BT_QUANTIZED_BVH_NODE  ( ::BT_QUANTIZED_BVH_NODE::* )(  ) 
void* bT_QUANTIZED_BVH_NODE_new() {
	::BT_QUANTIZED_BVH_NODE *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::BT_QUANTIZED_BVH_NODE),16);
	o = new (mem)::BT_QUANTIZED_BVH_NODE();
	return (void*)o;
}
void bT_QUANTIZED_BVH_NODE_free(void *c) {
	::BT_QUANTIZED_BVH_NODE *o = (::BT_QUANTIZED_BVH_NODE*)c;
	delete o;
}
//method: getEscapeIndex int ( ::BT_QUANTIZED_BVH_NODE::* )(  ) const
int bT_QUANTIZED_BVH_NODE_getEscapeIndex(void *c) {
	::BT_QUANTIZED_BVH_NODE *o = (::BT_QUANTIZED_BVH_NODE*)c;
	int retVal = (int)o->getEscapeIndex();
	return retVal;
}
//method: getDataIndex int ( ::BT_QUANTIZED_BVH_NODE::* )(  ) const
int bT_QUANTIZED_BVH_NODE_getDataIndex(void *c) {
	::BT_QUANTIZED_BVH_NODE *o = (::BT_QUANTIZED_BVH_NODE*)c;
	int retVal = (int)o->getDataIndex();
	return retVal;
}
//method: setEscapeIndex void ( ::BT_QUANTIZED_BVH_NODE::* )( int ) 
void bT_QUANTIZED_BVH_NODE_setEscapeIndex(void *c,int p0) {
	::BT_QUANTIZED_BVH_NODE *o = (::BT_QUANTIZED_BVH_NODE*)c;
	o->setEscapeIndex(p0);
}
//method: setDataIndex void ( ::BT_QUANTIZED_BVH_NODE::* )( int ) 
void bT_QUANTIZED_BVH_NODE_setDataIndex(void *c,int p0) {
	::BT_QUANTIZED_BVH_NODE *o = (::BT_QUANTIZED_BVH_NODE*)c;
	o->setDataIndex(p0);
}
//method: isLeafNode bool ( ::BT_QUANTIZED_BVH_NODE::* )(  ) const
int bT_QUANTIZED_BVH_NODE_isLeafNode(void *c) {
	::BT_QUANTIZED_BVH_NODE *o = (::BT_QUANTIZED_BVH_NODE*)c;
	int retVal = (int)o->isLeafNode();
	return retVal;
}
//not supported method: testQuantizedBoxOverlapp bool ( ::BT_QUANTIZED_BVH_NODE::* )( short unsigned int *,short unsigned int * ) const
// error:  - unsupported,  - unsupported, bool - ok

//attribute: int bT_QUANTIZED_BVH_NODE->m_escapeIndexOrDataIndex
void bT_QUANTIZED_BVH_NODE_m_escapeIndexOrDataIndex_set(void *c,int a) {
	::BT_QUANTIZED_BVH_NODE *o = (::BT_QUANTIZED_BVH_NODE*)c;
	o->m_escapeIndexOrDataIndex = a;
}
int bT_QUANTIZED_BVH_NODE_m_escapeIndexOrDataIndex_get(void *c) {
	::BT_QUANTIZED_BVH_NODE *o = (::BT_QUANTIZED_BVH_NODE*)c;
	return (int)(o->m_escapeIndexOrDataIndex);
}

//attribute: short unsigned int[3] bT_QUANTIZED_BVH_NODE->m_quantizedAabbMax
// attribute not supported: //attribute: short unsigned int[3] bT_QUANTIZED_BVH_NODE->m_quantizedAabbMax
//attribute: short unsigned int[3] bT_QUANTIZED_BVH_NODE->m_quantizedAabbMin
// attribute not supported: //attribute: short unsigned int[3] bT_QUANTIZED_BVH_NODE->m_quantizedAabbMin

// ::btGImpactCompoundShape::CompoundPrimitiveManager
//constructor: CompoundPrimitiveManager  ( ::btGImpactCompoundShape::CompoundPrimitiveManager::* )( ::btGImpactCompoundShape * ) 
void* btGImpactCompoundShape_CompoundPrimitiveManager_new0(void* p0) {
	::btGImpactCompoundShape::CompoundPrimitiveManager *o = 0;
	 void *mem = 0;
	::btGImpactCompoundShape * tp0 = (::btGImpactCompoundShape *)p0;
	mem = btAlignedAlloc(sizeof(::btGImpactCompoundShape::CompoundPrimitiveManager),16);
	o = new (mem)::btGImpactCompoundShape::CompoundPrimitiveManager(tp0);
	return (void*)o;
}
//constructor: CompoundPrimitiveManager  ( ::btGImpactCompoundShape::CompoundPrimitiveManager::* )(  ) 
void* btGImpactCompoundShape_CompoundPrimitiveManager_new1() {
	::btGImpactCompoundShape::CompoundPrimitiveManager *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGImpactCompoundShape::CompoundPrimitiveManager),16);
	o = new (mem)::btGImpactCompoundShape::CompoundPrimitiveManager();
	return (void*)o;
}
void btGImpactCompoundShape_CompoundPrimitiveManager_free(void *c) {
	::btGImpactCompoundShape::CompoundPrimitiveManager *o = (::btGImpactCompoundShape::CompoundPrimitiveManager*)c;
	delete o;
}
//method: get_primitive_count int ( ::btGImpactCompoundShape::CompoundPrimitiveManager::* )(  ) const
int btGImpactCompoundShape_CompoundPrimitiveManager_get_primitive_count(void *c) {
	::btGImpactCompoundShape::CompoundPrimitiveManager *o = (::btGImpactCompoundShape::CompoundPrimitiveManager*)c;
	int retVal = (int)o->get_primitive_count();
	return retVal;
}
//method: get_primitive_triangle void ( ::btGImpactCompoundShape::CompoundPrimitiveManager::* )( int,::btPrimitiveTriangle & ) const
void btGImpactCompoundShape_CompoundPrimitiveManager_get_primitive_triangle(void *c,int p0,void* p1) {
	::btGImpactCompoundShape::CompoundPrimitiveManager *o = (::btGImpactCompoundShape::CompoundPrimitiveManager*)c;
	::btPrimitiveTriangle & tp1 = *(::btPrimitiveTriangle *)p1;
	o->get_primitive_triangle(p0,tp1);
}
//method: get_primitive_box void ( ::btGImpactCompoundShape::CompoundPrimitiveManager::* )( int,::btAABB & ) const
void btGImpactCompoundShape_CompoundPrimitiveManager_get_primitive_box(void *c,int p0,void* p1) {
	::btGImpactCompoundShape::CompoundPrimitiveManager *o = (::btGImpactCompoundShape::CompoundPrimitiveManager*)c;
	::btAABB & tp1 = *(::btAABB *)p1;
	o->get_primitive_box(p0,tp1);
}
//method: is_trimesh bool ( ::btGImpactCompoundShape::CompoundPrimitiveManager::* )(  ) const
int btGImpactCompoundShape_CompoundPrimitiveManager_is_trimesh(void *c) {
	::btGImpactCompoundShape::CompoundPrimitiveManager *o = (::btGImpactCompoundShape::CompoundPrimitiveManager*)c;
	int retVal = (int)o->is_trimesh();
	return retVal;
}
//attribute: ::btGImpactCompoundShape * btGImpactCompoundShape_CompoundPrimitiveManager->m_compoundShape
void btGImpactCompoundShape_CompoundPrimitiveManager_m_compoundShape_set(void *c,void* a) {
	::btGImpactCompoundShape::CompoundPrimitiveManager *o = (::btGImpactCompoundShape::CompoundPrimitiveManager*)c;
	::btGImpactCompoundShape * ta = (::btGImpactCompoundShape *)a;
	o->m_compoundShape = ta;
}
void* btGImpactCompoundShape_CompoundPrimitiveManager_m_compoundShape_get(void *c) {
	::btGImpactCompoundShape::CompoundPrimitiveManager *o = (::btGImpactCompoundShape::CompoundPrimitiveManager*)c;
	return (void*)(o->m_compoundShape);
}


// ::btGImpactCollisionAlgorithm::CreateFunc
//constructor: CreateFunc  ( ::btGImpactCollisionAlgorithm::CreateFunc::* )(  ) 
void* btGImpactCollisionAlgorithm_CreateFunc_new() {
	::btGImpactCollisionAlgorithm::CreateFunc *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGImpactCollisionAlgorithm::CreateFunc),16);
	o = new (mem)::btGImpactCollisionAlgorithm::CreateFunc();
	return (void*)o;
}
void btGImpactCollisionAlgorithm_CreateFunc_free(void *c) {
	::btGImpactCollisionAlgorithm::CreateFunc *o = (::btGImpactCollisionAlgorithm::CreateFunc*)c;
	delete o;
}
//method: CreateCollisionAlgorithm ::btCollisionAlgorithm * ( ::btGImpactCollisionAlgorithm::CreateFunc::* )( ::btCollisionAlgorithmConstructionInfo &,::btCollisionObject *,::btCollisionObject * ) 
void* btGImpactCollisionAlgorithm_CreateFunc_CreateCollisionAlgorithm(void *c,void* p0,void* p1,void* p2) {
	::btGImpactCollisionAlgorithm::CreateFunc *o = (::btGImpactCollisionAlgorithm::CreateFunc*)c;
	::btCollisionAlgorithmConstructionInfo & tp0 = *(::btCollisionAlgorithmConstructionInfo *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btCollisionObject * tp2 = (::btCollisionObject *)p2;
	void* retVal = (void*) o->CreateCollisionAlgorithm(tp0,tp1,tp2);
	return retVal;
}

// ::GIM_BVH_DATA
//constructor: GIM_BVH_DATA  ( ::GIM_BVH_DATA::* )(  ) 
void* gIM_BVH_DATA_new() {
	::GIM_BVH_DATA *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::GIM_BVH_DATA),16);
	o = new (mem)::GIM_BVH_DATA();
	return (void*)o;
}
void gIM_BVH_DATA_free(void *c) {
	::GIM_BVH_DATA *o = (::GIM_BVH_DATA*)c;
	delete o;
}
//attribute: ::btAABB gIM_BVH_DATA->m_bound
void gIM_BVH_DATA_m_bound_set(void *c,void* a) {
	::GIM_BVH_DATA *o = (::GIM_BVH_DATA*)c;
	::btAABB & ta = *(::btAABB *)a;
	o->m_bound = ta;
}
void* gIM_BVH_DATA_m_bound_get(void *c) {
	::GIM_BVH_DATA *o = (::GIM_BVH_DATA*)c;
	return (void*)&(o->m_bound);
}

//attribute: int gIM_BVH_DATA->m_data
void gIM_BVH_DATA_m_data_set(void *c,int a) {
	::GIM_BVH_DATA *o = (::GIM_BVH_DATA*)c;
	o->m_data = a;
}
int gIM_BVH_DATA_m_data_get(void *c) {
	::GIM_BVH_DATA *o = (::GIM_BVH_DATA*)c;
	return (int)(o->m_data);
}


// ::GIM_BVH_DATA_ARRAY
//constructor: GIM_BVH_DATA_ARRAY  ( ::GIM_BVH_DATA_ARRAY::* )(  ) 
void* gIM_BVH_DATA_ARRAY_new() {
	::GIM_BVH_DATA_ARRAY *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::GIM_BVH_DATA_ARRAY),16);
	o = new (mem)::GIM_BVH_DATA_ARRAY();
	return (void*)o;
}
void gIM_BVH_DATA_ARRAY_free(void *c) {
	::GIM_BVH_DATA_ARRAY *o = (::GIM_BVH_DATA_ARRAY*)c;
	delete o;
}

// ::GIM_BVH_TREE_NODE
//constructor: GIM_BVH_TREE_NODE  ( ::GIM_BVH_TREE_NODE::* )(  ) 
void* gIM_BVH_TREE_NODE_new() {
	::GIM_BVH_TREE_NODE *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::GIM_BVH_TREE_NODE),16);
	o = new (mem)::GIM_BVH_TREE_NODE();
	return (void*)o;
}
void gIM_BVH_TREE_NODE_free(void *c) {
	::GIM_BVH_TREE_NODE *o = (::GIM_BVH_TREE_NODE*)c;
	delete o;
}
//method: setDataIndex void ( ::GIM_BVH_TREE_NODE::* )( int ) 
void gIM_BVH_TREE_NODE_setDataIndex(void *c,int p0) {
	::GIM_BVH_TREE_NODE *o = (::GIM_BVH_TREE_NODE*)c;
	o->setDataIndex(p0);
}
//method: getEscapeIndex int ( ::GIM_BVH_TREE_NODE::* )(  ) const
int gIM_BVH_TREE_NODE_getEscapeIndex(void *c) {
	::GIM_BVH_TREE_NODE *o = (::GIM_BVH_TREE_NODE*)c;
	int retVal = (int)o->getEscapeIndex();
	return retVal;
}
//method: getDataIndex int ( ::GIM_BVH_TREE_NODE::* )(  ) const
int gIM_BVH_TREE_NODE_getDataIndex(void *c) {
	::GIM_BVH_TREE_NODE *o = (::GIM_BVH_TREE_NODE*)c;
	int retVal = (int)o->getDataIndex();
	return retVal;
}
//method: setEscapeIndex void ( ::GIM_BVH_TREE_NODE::* )( int ) 
void gIM_BVH_TREE_NODE_setEscapeIndex(void *c,int p0) {
	::GIM_BVH_TREE_NODE *o = (::GIM_BVH_TREE_NODE*)c;
	o->setEscapeIndex(p0);
}
//method: isLeafNode bool ( ::GIM_BVH_TREE_NODE::* )(  ) const
int gIM_BVH_TREE_NODE_isLeafNode(void *c) {
	::GIM_BVH_TREE_NODE *o = (::GIM_BVH_TREE_NODE*)c;
	int retVal = (int)o->isLeafNode();
	return retVal;
}
//attribute: ::btAABB gIM_BVH_TREE_NODE->m_bound
void gIM_BVH_TREE_NODE_m_bound_set(void *c,void* a) {
	::GIM_BVH_TREE_NODE *o = (::GIM_BVH_TREE_NODE*)c;
	::btAABB & ta = *(::btAABB *)a;
	o->m_bound = ta;
}
void* gIM_BVH_TREE_NODE_m_bound_get(void *c) {
	::GIM_BVH_TREE_NODE *o = (::GIM_BVH_TREE_NODE*)c;
	return (void*)&(o->m_bound);
}

//attribute: int gIM_BVH_TREE_NODE->m_escapeIndexOrDataIndex
void gIM_BVH_TREE_NODE_m_escapeIndexOrDataIndex_set(void *c,int a) {
	::GIM_BVH_TREE_NODE *o = (::GIM_BVH_TREE_NODE*)c;
	o->m_escapeIndexOrDataIndex = a;
}
int gIM_BVH_TREE_NODE_m_escapeIndexOrDataIndex_get(void *c) {
	::GIM_BVH_TREE_NODE *o = (::GIM_BVH_TREE_NODE*)c;
	return (int)(o->m_escapeIndexOrDataIndex);
}


// ::GIM_BVH_TREE_NODE_ARRAY
//constructor: GIM_BVH_TREE_NODE_ARRAY  ( ::GIM_BVH_TREE_NODE_ARRAY::* )(  ) 
void* gIM_BVH_TREE_NODE_ARRAY_new() {
	::GIM_BVH_TREE_NODE_ARRAY *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::GIM_BVH_TREE_NODE_ARRAY),16);
	o = new (mem)::GIM_BVH_TREE_NODE_ARRAY();
	return (void*)o;
}
void gIM_BVH_TREE_NODE_ARRAY_free(void *c) {
	::GIM_BVH_TREE_NODE_ARRAY *o = (::GIM_BVH_TREE_NODE_ARRAY*)c;
	delete o;
}

// ::GIM_PAIR
//constructor: GIM_PAIR  ( ::GIM_PAIR::* )(  ) 
void* gIM_PAIR_new0() {
	::GIM_PAIR *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::GIM_PAIR),16);
	o = new (mem)::GIM_PAIR();
	return (void*)o;
}
//constructor: GIM_PAIR  ( ::GIM_PAIR::* )( int,int ) 
void* gIM_PAIR_new1(int p0,int p1) {
	::GIM_PAIR *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::GIM_PAIR),16);
	o = new (mem)::GIM_PAIR(p0,p1);
	return (void*)o;
}
void gIM_PAIR_free(void *c) {
	::GIM_PAIR *o = (::GIM_PAIR*)c;
	delete o;
}
//attribute: int gIM_PAIR->m_index1
void gIM_PAIR_m_index1_set(void *c,int a) {
	::GIM_PAIR *o = (::GIM_PAIR*)c;
	o->m_index1 = a;
}
int gIM_PAIR_m_index1_get(void *c) {
	::GIM_PAIR *o = (::GIM_PAIR*)c;
	return (int)(o->m_index1);
}

//attribute: int gIM_PAIR->m_index2
void gIM_PAIR_m_index2_set(void *c,int a) {
	::GIM_PAIR *o = (::GIM_PAIR*)c;
	o->m_index2 = a;
}
int gIM_PAIR_m_index2_get(void *c) {
	::GIM_PAIR *o = (::GIM_PAIR*)c;
	return (int)(o->m_index2);
}


// ::GIM_QUANTIZED_BVH_NODE_ARRAY
//constructor: GIM_QUANTIZED_BVH_NODE_ARRAY  ( ::GIM_QUANTIZED_BVH_NODE_ARRAY::* )(  ) 
void* gIM_QUANTIZED_BVH_NODE_ARRAY_new() {
	::GIM_QUANTIZED_BVH_NODE_ARRAY *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::GIM_QUANTIZED_BVH_NODE_ARRAY),16);
	o = new (mem)::GIM_QUANTIZED_BVH_NODE_ARRAY();
	return (void*)o;
}
void gIM_QUANTIZED_BVH_NODE_ARRAY_free(void *c) {
	::GIM_QUANTIZED_BVH_NODE_ARRAY *o = (::GIM_QUANTIZED_BVH_NODE_ARRAY*)c;
	delete o;
}

// ::GIM_TRIANGLE_CONTACT
//constructor: GIM_TRIANGLE_CONTACT  ( ::GIM_TRIANGLE_CONTACT::* )(  ) 
void* gIM_TRIANGLE_CONTACT_new() {
	::GIM_TRIANGLE_CONTACT *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::GIM_TRIANGLE_CONTACT),16);
	o = new (mem)::GIM_TRIANGLE_CONTACT();
	return (void*)o;
}
void gIM_TRIANGLE_CONTACT_free(void *c) {
	::GIM_TRIANGLE_CONTACT *o = (::GIM_TRIANGLE_CONTACT*)c;
	delete o;
}
//not supported method: merge_points void ( ::GIM_TRIANGLE_CONTACT::* )( ::btVector4 const &,::btScalar,::btVector3 const *,int ) 
// error: ::btVector4 const & - ok, ::btScalar - ok,  - unsupported, int - ok, void - ok

//method: copy_from void ( ::GIM_TRIANGLE_CONTACT::* )( ::GIM_TRIANGLE_CONTACT const & ) 
void gIM_TRIANGLE_CONTACT_copy_from(void *c,void* p0) {
	::GIM_TRIANGLE_CONTACT *o = (::GIM_TRIANGLE_CONTACT*)c;
	::GIM_TRIANGLE_CONTACT const & tp0 = *(::GIM_TRIANGLE_CONTACT const *)p0;
	o->copy_from(tp0);
}
//attribute: ::btScalar gIM_TRIANGLE_CONTACT->m_penetration_depth
void gIM_TRIANGLE_CONTACT_m_penetration_depth_set(void *c,float a) {
	::GIM_TRIANGLE_CONTACT *o = (::GIM_TRIANGLE_CONTACT*)c;
	o->m_penetration_depth = a;
}
float gIM_TRIANGLE_CONTACT_m_penetration_depth_get(void *c) {
	::GIM_TRIANGLE_CONTACT *o = (::GIM_TRIANGLE_CONTACT*)c;
	return (float)(o->m_penetration_depth);
}

//attribute: int gIM_TRIANGLE_CONTACT->m_point_count
void gIM_TRIANGLE_CONTACT_m_point_count_set(void *c,int a) {
	::GIM_TRIANGLE_CONTACT *o = (::GIM_TRIANGLE_CONTACT*)c;
	o->m_point_count = a;
}
int gIM_TRIANGLE_CONTACT_m_point_count_get(void *c) {
	::GIM_TRIANGLE_CONTACT *o = (::GIM_TRIANGLE_CONTACT*)c;
	return (int)(o->m_point_count);
}

//attribute: ::btVector3[16] gIM_TRIANGLE_CONTACT->m_points
// attribute not supported: //attribute: ::btVector3[16] gIM_TRIANGLE_CONTACT->m_points
//attribute: ::btVector4 gIM_TRIANGLE_CONTACT->m_separating_normal
void gIM_TRIANGLE_CONTACT_m_separating_normal_set(void *c,float* a) {
	::GIM_TRIANGLE_CONTACT *o = (::GIM_TRIANGLE_CONTACT*)c;
	btVector4 ta(a[0],a[1],a[2],a[3]);
	o->m_separating_normal = ta;
}
void gIM_TRIANGLE_CONTACT_m_separating_normal_get(void *c,float* a) {
	::GIM_TRIANGLE_CONTACT *o = (::GIM_TRIANGLE_CONTACT*)c;
	a[0]=(o->m_separating_normal).getX();a[1]=(o->m_separating_normal).getY();a[2]=(o->m_separating_normal).getZ();a[3]=(o->m_separating_normal).getW();
}


// ::btGImpactMeshShapePart::TrimeshPrimitiveManager
//constructor: TrimeshPrimitiveManager  ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )(  ) 
void* btGImpactMeshShapePart_TrimeshPrimitiveManager_new0() {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGImpactMeshShapePart::TrimeshPrimitiveManager),16);
	o = new (mem)::btGImpactMeshShapePart::TrimeshPrimitiveManager();
	return (void*)o;
}
//constructor: TrimeshPrimitiveManager  ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )( ::btStridingMeshInterface *,int ) 
void* btGImpactMeshShapePart_TrimeshPrimitiveManager_new1(void* p0,int p1) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = 0;
	 void *mem = 0;
	::btStridingMeshInterface * tp0 = (::btStridingMeshInterface *)p0;
	mem = btAlignedAlloc(sizeof(::btGImpactMeshShapePart::TrimeshPrimitiveManager),16);
	o = new (mem)::btGImpactMeshShapePart::TrimeshPrimitiveManager(tp0,p1);
	return (void*)o;
}
void btGImpactMeshShapePart_TrimeshPrimitiveManager_free(void *c) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	delete o;
}
//method: get_vertex_count int ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )(  ) const
int btGImpactMeshShapePart_TrimeshPrimitiveManager_get_vertex_count(void *c) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	int retVal = (int)o->get_vertex_count();
	return retVal;
}
//method: get_vertex void ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )( int,::btVector3 & ) const
void btGImpactMeshShapePart_TrimeshPrimitiveManager_get_vertex(void *c,int p0,float* p1) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->get_vertex(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: is_trimesh bool ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )(  ) const
int btGImpactMeshShapePart_TrimeshPrimitiveManager_is_trimesh(void *c) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	int retVal = (int)o->is_trimesh();
	return retVal;
}
//method: lock void ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )(  ) 
void btGImpactMeshShapePart_TrimeshPrimitiveManager_lock(void *c) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	o->lock();
}
//method: get_primitive_box void ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )( int,::btAABB & ) const
void btGImpactMeshShapePart_TrimeshPrimitiveManager_get_primitive_box(void *c,int p0,void* p1) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	::btAABB & tp1 = *(::btAABB *)p1;
	o->get_primitive_box(p0,tp1);
}
//method: get_primitive_triangle void ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )( int,::btPrimitiveTriangle & ) const
void btGImpactMeshShapePart_TrimeshPrimitiveManager_get_primitive_triangle(void *c,int p0,void* p1) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	::btPrimitiveTriangle & tp1 = *(::btPrimitiveTriangle *)p1;
	o->get_primitive_triangle(p0,tp1);
}
//method: unlock void ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )(  ) 
void btGImpactMeshShapePart_TrimeshPrimitiveManager_unlock(void *c) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	o->unlock();
}
//method: get_bullet_triangle void ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )( int,::btTriangleShapeEx & ) const
void btGImpactMeshShapePart_TrimeshPrimitiveManager_get_bullet_triangle(void *c,int p0,void* p1) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	::btTriangleShapeEx & tp1 = *(::btTriangleShapeEx *)p1;
	o->get_bullet_triangle(p0,tp1);
}
//method: get_primitive_count int ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )(  ) const
int btGImpactMeshShapePart_TrimeshPrimitiveManager_get_primitive_count(void *c) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	int retVal = (int)o->get_primitive_count();
	return retVal;
}
//not supported method: get_indices void ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )( int,int &,int &,int & ) const
// error: int - ok,  - unsupported,  - unsupported,  - unsupported, void - ok

//attribute: ::btScalar btGImpactMeshShapePart_TrimeshPrimitiveManager->m_margin
void btGImpactMeshShapePart_TrimeshPrimitiveManager_m_margin_set(void *c,float a) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	o->m_margin = a;
}
float btGImpactMeshShapePart_TrimeshPrimitiveManager_m_margin_get(void *c) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	return (float)(o->m_margin);
}

//attribute: ::btStridingMeshInterface * btGImpactMeshShapePart_TrimeshPrimitiveManager->m_meshInterface
void btGImpactMeshShapePart_TrimeshPrimitiveManager_m_meshInterface_set(void *c,void* a) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	::btStridingMeshInterface * ta = (::btStridingMeshInterface *)a;
	o->m_meshInterface = ta;
}
void* btGImpactMeshShapePart_TrimeshPrimitiveManager_m_meshInterface_get(void *c) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	return (void*)(o->m_meshInterface);
}

//attribute: ::btVector3 btGImpactMeshShapePart_TrimeshPrimitiveManager->m_scale
void btGImpactMeshShapePart_TrimeshPrimitiveManager_m_scale_set(void *c,float* a) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_scale = ta;
}
void btGImpactMeshShapePart_TrimeshPrimitiveManager_m_scale_get(void *c,float* a) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	a[0]=(o->m_scale).m_floats[0];a[1]=(o->m_scale).m_floats[1];a[2]=(o->m_scale).m_floats[2];
}

//attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->m_part
void btGImpactMeshShapePart_TrimeshPrimitiveManager_m_part_set(void *c,int a) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	o->m_part = a;
}
int btGImpactMeshShapePart_TrimeshPrimitiveManager_m_part_get(void *c) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	return (int)(o->m_part);
}

//attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->m_lock_count
void btGImpactMeshShapePart_TrimeshPrimitiveManager_m_lock_count_set(void *c,int a) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	o->m_lock_count = a;
}
int btGImpactMeshShapePart_TrimeshPrimitiveManager_m_lock_count_get(void *c) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	return (int)(o->m_lock_count);
}

//attribute: unsigned char const * btGImpactMeshShapePart_TrimeshPrimitiveManager->vertexbase
// attribute not supported: //attribute: unsigned char const * btGImpactMeshShapePart_TrimeshPrimitiveManager->vertexbase
//attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->numverts
void btGImpactMeshShapePart_TrimeshPrimitiveManager_numverts_set(void *c,int a) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	o->numverts = a;
}
int btGImpactMeshShapePart_TrimeshPrimitiveManager_numverts_get(void *c) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	return (int)(o->numverts);
}

//attribute: ::PHY_ScalarType btGImpactMeshShapePart_TrimeshPrimitiveManager->type
// attribute not supported: //attribute: ::PHY_ScalarType btGImpactMeshShapePart_TrimeshPrimitiveManager->type
//attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->stride
void btGImpactMeshShapePart_TrimeshPrimitiveManager_stride_set(void *c,int a) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	o->stride = a;
}
int btGImpactMeshShapePart_TrimeshPrimitiveManager_stride_get(void *c) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	return (int)(o->stride);
}

//attribute: unsigned char const * btGImpactMeshShapePart_TrimeshPrimitiveManager->indexbase
// attribute not supported: //attribute: unsigned char const * btGImpactMeshShapePart_TrimeshPrimitiveManager->indexbase
//attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->indexstride
void btGImpactMeshShapePart_TrimeshPrimitiveManager_indexstride_set(void *c,int a) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	o->indexstride = a;
}
int btGImpactMeshShapePart_TrimeshPrimitiveManager_indexstride_get(void *c) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	return (int)(o->indexstride);
}

//attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->numfaces
void btGImpactMeshShapePart_TrimeshPrimitiveManager_numfaces_set(void *c,int a) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	o->numfaces = a;
}
int btGImpactMeshShapePart_TrimeshPrimitiveManager_numfaces_get(void *c) {
	::btGImpactMeshShapePart::TrimeshPrimitiveManager *o = (::btGImpactMeshShapePart::TrimeshPrimitiveManager*)c;
	return (int)(o->numfaces);
}

//attribute: ::PHY_ScalarType btGImpactMeshShapePart_TrimeshPrimitiveManager->indicestype
// attribute not supported: //attribute: ::PHY_ScalarType btGImpactMeshShapePart_TrimeshPrimitiveManager->indicestype

// ::btAABB
//constructor: btAABB  ( ::btAABB::* )(  ) 
void* btAABB_new0() {
	::btAABB *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btAABB),16);
	o = new (mem)::btAABB();
	return (void*)o;
}
//constructor: btAABB  ( ::btAABB::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void* btAABB_new1(float* p0,float* p1,float* p2) {
	::btAABB *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	mem = btAlignedAlloc(sizeof(::btAABB),16);
	o = new (mem)::btAABB(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	return (void*)o;
}
//constructor: btAABB  ( ::btAABB::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
void* btAABB_new2(float* p0,float* p1,float* p2,float p3) {
	::btAABB *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	mem = btAlignedAlloc(sizeof(::btAABB),16);
	o = new (mem)::btAABB(tp0,tp1,tp2,p3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	return (void*)o;
}
//constructor: btAABB  ( ::btAABB::* )( ::btAABB const &,::btScalar ) 
void* btAABB_new3(void* p0,float p1) {
	::btAABB *o = 0;
	 void *mem = 0;
	::btAABB const & tp0 = *(::btAABB const *)p0;
	mem = btAlignedAlloc(sizeof(::btAABB),16);
	o = new (mem)::btAABB(tp0,p1);
	return (void*)o;
}
void btAABB_free(void *c) {
	::btAABB *o = (::btAABB*)c;
	delete o;
}
//method: overlapping_trans_conservative bool ( ::btAABB::* )( ::btAABB const &,::btTransform & ) const
int btAABB_overlapping_trans_conservative(void *c,void* p0,float* p1) {
	::btAABB *o = (::btAABB*)c;
	::btAABB const & tp0 = *(::btAABB const *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	int retVal = (int)o->overlapping_trans_conservative(tp0,tp1);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	return retVal;
}
//method: appy_transform void ( ::btAABB::* )( ::btTransform const & ) 
void btAABB_appy_transform(void *c,float* p0) {
	::btAABB *o = (::btAABB*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	o->appy_transform(tp0);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//method: find_intersection void ( ::btAABB::* )( ::btAABB const &,::btAABB & ) const
void btAABB_find_intersection(void *c,void* p0,void* p1) {
	::btAABB *o = (::btAABB*)c;
	::btAABB const & tp0 = *(::btAABB const *)p0;
	::btAABB & tp1 = *(::btAABB *)p1;
	o->find_intersection(tp0,tp1);
}
//method: collide_ray bool ( ::btAABB::* )( ::btVector3 const &,::btVector3 const & ) const
int btAABB_collide_ray(void *c,float* p0,float* p1) {
	::btAABB *o = (::btAABB*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	int retVal = (int)o->collide_ray(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//method: overlapping_trans_cache bool ( ::btAABB::* )( ::btAABB const &,::BT_BOX_BOX_TRANSFORM_CACHE const &,bool ) const
int btAABB_overlapping_trans_cache(void *c,void* p0,void* p1,int p2) {
	::btAABB *o = (::btAABB*)c;
	::btAABB const & tp0 = *(::btAABB const *)p0;
	::BT_BOX_BOX_TRANSFORM_CACHE const & tp1 = *(::BT_BOX_BOX_TRANSFORM_CACHE const *)p1;
	int retVal = (int)o->overlapping_trans_cache(tp0,tp1,p2);
	return retVal;
}
//method: get_center_extend void ( ::btAABB::* )( ::btVector3 &,::btVector3 & ) const
void btAABB_get_center_extend(void *c,float* p0,float* p1) {
	::btAABB *o = (::btAABB*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->get_center_extend(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: invalidate void ( ::btAABB::* )(  ) 
void btAABB_invalidate(void *c) {
	::btAABB *o = (::btAABB*)c;
	o->invalidate();
}
//method: has_collision bool ( ::btAABB::* )( ::btAABB const & ) const
int btAABB_has_collision(void *c,void* p0) {
	::btAABB *o = (::btAABB*)c;
	::btAABB const & tp0 = *(::btAABB const *)p0;
	int retVal = (int)o->has_collision(tp0);
	return retVal;
}
//not supported method: projection_interval void ( ::btAABB::* )( ::btVector3 const &,::btScalar &,::btScalar & ) const
// error: ::btVector3 const & - ok,  - unsupported,  - unsupported, void - ok

//method: appy_transform_trans_cache void ( ::btAABB::* )( ::BT_BOX_BOX_TRANSFORM_CACHE const & ) 
void btAABB_appy_transform_trans_cache(void *c,void* p0) {
	::btAABB *o = (::btAABB*)c;
	::BT_BOX_BOX_TRANSFORM_CACHE const & tp0 = *(::BT_BOX_BOX_TRANSFORM_CACHE const *)p0;
	o->appy_transform_trans_cache(tp0);
}
//method: calc_from_triangle_margin void ( ::btAABB::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
void btAABB_calc_from_triangle_margin(void *c,float* p0,float* p1,float* p2,float p3) {
	::btAABB *o = (::btAABB*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->calc_from_triangle_margin(tp0,tp1,tp2,p3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: increment_margin void ( ::btAABB::* )( ::btScalar ) 
void btAABB_increment_margin(void *c,float p0) {
	::btAABB *o = (::btAABB*)c;
	o->increment_margin(p0);
}
//method: merge void ( ::btAABB::* )( ::btAABB const & ) 
void btAABB_merge(void *c,void* p0) {
	::btAABB *o = (::btAABB*)c;
	::btAABB const & tp0 = *(::btAABB const *)p0;
	o->merge(tp0);
}
//method: collide_plane bool ( ::btAABB::* )( ::btVector4 const & ) const
int btAABB_collide_plane(void *c,float* p0) {
	::btAABB *o = (::btAABB*)c;
	btVector4 tp0(p0[0],p0[1],p0[2],p0[3]);
	int retVal = (int)o->collide_plane(tp0);
	p0[0]=tp0.getX();p0[1]=tp0.getY();p0[2]=tp0.getZ();p0[3]=tp0.getW();
	return retVal;
}
//not supported method: plane_classify ::eBT_PLANE_INTERSECTION_TYPE ( ::btAABB::* )( ::btVector4 const & ) const
// error: ::btVector4 const & - ok,  - unsupported

//method: overlapping_trans_conservative2 bool ( ::btAABB::* )( ::btAABB const &,::BT_BOX_BOX_TRANSFORM_CACHE const & ) const
int btAABB_overlapping_trans_conservative2(void *c,void* p0,void* p1) {
	::btAABB *o = (::btAABB*)c;
	::btAABB const & tp0 = *(::btAABB const *)p0;
	::BT_BOX_BOX_TRANSFORM_CACHE const & tp1 = *(::BT_BOX_BOX_TRANSFORM_CACHE const *)p1;
	int retVal = (int)o->overlapping_trans_conservative2(tp0,tp1);
	return retVal;
}
//method: copy_with_margin void ( ::btAABB::* )( ::btAABB const &,::btScalar ) 
void btAABB_copy_with_margin(void *c,void* p0,float p1) {
	::btAABB *o = (::btAABB*)c;
	::btAABB const & tp0 = *(::btAABB const *)p0;
	o->copy_with_margin(tp0,p1);
}
//method: collide_triangle_exact bool ( ::btAABB::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector4 const & ) const
int btAABB_collide_triangle_exact(void *c,float* p0,float* p1,float* p2,float* p3) {
	::btAABB *o = (::btAABB*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector4 tp3(p3[0],p3[1],p3[2],p3[3]);
	int retVal = (int)o->collide_triangle_exact(tp0,tp1,tp2,tp3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.getX();p3[1]=tp3.getY();p3[2]=tp3.getZ();p3[3]=tp3.getW();
	return retVal;
}
//attribute: ::btVector3 btAABB->m_max
void btAABB_m_max_set(void *c,float* a) {
	::btAABB *o = (::btAABB*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_max = ta;
}
void btAABB_m_max_get(void *c,float* a) {
	::btAABB *o = (::btAABB*)c;
	a[0]=(o->m_max).m_floats[0];a[1]=(o->m_max).m_floats[1];a[2]=(o->m_max).m_floats[2];
}

//attribute: ::btVector3 btAABB->m_min
void btAABB_m_min_set(void *c,float* a) {
	::btAABB *o = (::btAABB*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_min = ta;
}
void btAABB_m_min_get(void *c,float* a) {
	::btAABB *o = (::btAABB*)c;
	a[0]=(o->m_min).m_floats[0];a[1]=(o->m_min).m_floats[1];a[2]=(o->m_min).m_floats[2];
}


// ::btBvhTree
//constructor: btBvhTree  ( ::btBvhTree::* )(  ) 
void* btBvhTree_new() {
	::btBvhTree *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btBvhTree),16);
	o = new (mem)::btBvhTree();
	return (void*)o;
}
void btBvhTree_free(void *c) {
	::btBvhTree *o = (::btBvhTree*)c;
	delete o;
}
//method: getNodeCount int ( ::btBvhTree::* )(  ) const
int btBvhTree_getNodeCount(void *c) {
	::btBvhTree *o = (::btBvhTree*)c;
	int retVal = (int)o->getNodeCount();
	return retVal;
}
//method: build_tree void ( ::btBvhTree::* )( ::GIM_BVH_DATA_ARRAY & ) 
void btBvhTree_build_tree(void *c,void* p0) {
	::btBvhTree *o = (::btBvhTree*)c;
	::GIM_BVH_DATA_ARRAY & tp0 = *(::GIM_BVH_DATA_ARRAY *)p0;
	o->build_tree(tp0);
}
//method: setNodeBound void ( ::btBvhTree::* )( int,::btAABB const & ) 
void btBvhTree_setNodeBound(void *c,int p0,void* p1) {
	::btBvhTree *o = (::btBvhTree*)c;
	::btAABB const & tp1 = *(::btAABB const *)p1;
	o->setNodeBound(p0,tp1);
}
//method: getLeftNode int ( ::btBvhTree::* )( int ) const
int btBvhTree_getLeftNode(void *c,int p0) {
	::btBvhTree *o = (::btBvhTree*)c;
	int retVal = (int)o->getLeftNode(p0);
	return retVal;
}
//method: _build_sub_tree void ( ::btBvhTree::* )( ::GIM_BVH_DATA_ARRAY &,int,int ) 
void btBvhTree__build_sub_tree(void *c,void* p0,int p1,int p2) {
	::btBvhTree *o = (::btBvhTree*)c;
	::GIM_BVH_DATA_ARRAY & tp0 = *(::GIM_BVH_DATA_ARRAY *)p0;
	o->_build_sub_tree(tp0,p1,p2);
}
//method: clearNodes void ( ::btBvhTree::* )(  ) 
void btBvhTree_clearNodes(void *c) {
	::btBvhTree *o = (::btBvhTree*)c;
	o->clearNodes();
}
//method: _sort_and_calc_splitting_index int ( ::btBvhTree::* )( ::GIM_BVH_DATA_ARRAY &,int,int,int ) 
int btBvhTree__sort_and_calc_splitting_index(void *c,void* p0,int p1,int p2,int p3) {
	::btBvhTree *o = (::btBvhTree*)c;
	::GIM_BVH_DATA_ARRAY & tp0 = *(::GIM_BVH_DATA_ARRAY *)p0;
	int retVal = (int)o->_sort_and_calc_splitting_index(tp0,p1,p2,p3);
	return retVal;
}
//method: getEscapeNodeIndex int ( ::btBvhTree::* )( int ) const
int btBvhTree_getEscapeNodeIndex(void *c,int p0) {
	::btBvhTree *o = (::btBvhTree*)c;
	int retVal = (int)o->getEscapeNodeIndex(p0);
	return retVal;
}
//method: isLeafNode bool ( ::btBvhTree::* )( int ) const
int btBvhTree_isLeafNode(void *c,int p0) {
	::btBvhTree *o = (::btBvhTree*)c;
	int retVal = (int)o->isLeafNode(p0);
	return retVal;
}
//method: get_node_pointer ::GIM_BVH_TREE_NODE const * ( ::btBvhTree::* )( int ) const
void* btBvhTree_get_node_pointer(void *c,int p0) {
	::btBvhTree *o = (::btBvhTree*)c;
	void* retVal = (void*) o->get_node_pointer(p0);
	return retVal;
}
//method: getNodeData int ( ::btBvhTree::* )( int ) const
int btBvhTree_getNodeData(void *c,int p0) {
	::btBvhTree *o = (::btBvhTree*)c;
	int retVal = (int)o->getNodeData(p0);
	return retVal;
}
//method: getNodeBound void ( ::btBvhTree::* )( int,::btAABB & ) const
void btBvhTree_getNodeBound(void *c,int p0,void* p1) {
	::btBvhTree *o = (::btBvhTree*)c;
	::btAABB & tp1 = *(::btAABB *)p1;
	o->getNodeBound(p0,tp1);
}
//method: getRightNode int ( ::btBvhTree::* )( int ) const
int btBvhTree_getRightNode(void *c,int p0) {
	::btBvhTree *o = (::btBvhTree*)c;
	int retVal = (int)o->getRightNode(p0);
	return retVal;
}
//method: _calc_splitting_axis int ( ::btBvhTree::* )( ::GIM_BVH_DATA_ARRAY &,int,int ) 
int btBvhTree__calc_splitting_axis(void *c,void* p0,int p1,int p2) {
	::btBvhTree *o = (::btBvhTree*)c;
	::GIM_BVH_DATA_ARRAY & tp0 = *(::GIM_BVH_DATA_ARRAY *)p0;
	int retVal = (int)o->_calc_splitting_axis(tp0,p1,p2);
	return retVal;
}
//attribute: int btBvhTree->m_num_nodes
void btBvhTree_m_num_nodes_set(void *c,int a) {
	::btBvhTree *o = (::btBvhTree*)c;
	o->m_num_nodes = a;
}
int btBvhTree_m_num_nodes_get(void *c) {
	::btBvhTree *o = (::btBvhTree*)c;
	return (int)(o->m_num_nodes);
}

//attribute: ::GIM_BVH_TREE_NODE_ARRAY btBvhTree->m_node_array
void btBvhTree_m_node_array_set(void *c,void* a) {
	::btBvhTree *o = (::btBvhTree*)c;
	::GIM_BVH_TREE_NODE_ARRAY & ta = *(::GIM_BVH_TREE_NODE_ARRAY *)a;
	o->m_node_array = ta;
}
void* btBvhTree_m_node_array_get(void *c) {
	::btBvhTree *o = (::btBvhTree*)c;
	return (void*)&(o->m_node_array);
}


// ::btGImpactBvh
//constructor: btGImpactBvh  ( ::btGImpactBvh::* )(  ) 
void* btGImpactBvh_new0() {
	::btGImpactBvh *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGImpactBvh),16);
	o = new (mem)::btGImpactBvh();
	return (void*)o;
}
//constructor: btGImpactBvh  ( ::btGImpactBvh::* )( ::btPrimitiveManagerBase * ) 
void* btGImpactBvh_new1(void* p0) {
	::btGImpactBvh *o = 0;
	 void *mem = 0;
	::btPrimitiveManagerBase * tp0 = (::btPrimitiveManagerBase *)p0;
	mem = btAlignedAlloc(sizeof(::btGImpactBvh),16);
	o = new (mem)::btGImpactBvh(tp0);
	return (void*)o;
}
void btGImpactBvh_free(void *c) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	delete o;
}
//method: setNodeBound void ( ::btGImpactBvh::* )( int,::btAABB const & ) 
void btGImpactBvh_setNodeBound(void *c,int p0,void* p1) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	::btAABB const & tp1 = *(::btAABB const *)p1;
	o->setNodeBound(p0,tp1);
}
//method: getEscapeNodeIndex int ( ::btGImpactBvh::* )( int ) const
int btGImpactBvh_getEscapeNodeIndex(void *c,int p0) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	int retVal = (int)o->getEscapeNodeIndex(p0);
	return retVal;
}
//method: isLeafNode bool ( ::btGImpactBvh::* )( int ) const
int btGImpactBvh_isLeafNode(void *c,int p0) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	int retVal = (int)o->isLeafNode(p0);
	return retVal;
}
//method: getPrimitiveManager ::btPrimitiveManagerBase * ( ::btGImpactBvh::* )(  ) const
void* btGImpactBvh_getPrimitiveManager(void *c) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	void* retVal = (void*) o->getPrimitiveManager();
	return retVal;
}
//method: getNodeBound void ( ::btGImpactBvh::* )( int,::btAABB & ) const
void btGImpactBvh_getNodeBound(void *c,int p0,void* p1) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	::btAABB & tp1 = *(::btAABB *)p1;
	o->getNodeBound(p0,tp1);
}
//method: getRightNode int ( ::btGImpactBvh::* )( int ) const
int btGImpactBvh_getRightNode(void *c,int p0) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	int retVal = (int)o->getRightNode(p0);
	return retVal;
}
//method: getLeftNode int ( ::btGImpactBvh::* )( int ) const
int btGImpactBvh_getLeftNode(void *c,int p0) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	int retVal = (int)o->getLeftNode(p0);
	return retVal;
}
//method: setPrimitiveManager void ( ::btGImpactBvh::* )( ::btPrimitiveManagerBase * ) 
void btGImpactBvh_setPrimitiveManager(void *c,void* p0) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	::btPrimitiveManagerBase * tp0 = (::btPrimitiveManagerBase *)p0;
	o->setPrimitiveManager(tp0);
}
//method: buildSet void ( ::btGImpactBvh::* )(  ) 
void btGImpactBvh_buildSet(void *c) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	o->buildSet();
}
//method: getNodeTriangle void ( ::btGImpactBvh::* )( int,::btPrimitiveTriangle & ) const
void btGImpactBvh_getNodeTriangle(void *c,int p0,void* p1) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	::btPrimitiveTriangle & tp1 = *(::btPrimitiveTriangle *)p1;
	o->getNodeTriangle(p0,tp1);
}
//method: getNodeCount int ( ::btGImpactBvh::* )(  ) const
int btGImpactBvh_getNodeCount(void *c) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	int retVal = (int)o->getNodeCount();
	return retVal;
}
//method: hasHierarchy bool ( ::btGImpactBvh::* )(  ) const
int btGImpactBvh_hasHierarchy(void *c) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	int retVal = (int)o->hasHierarchy();
	return retVal;
}
//method: rayQuery bool ( ::btGImpactBvh::* )( ::btVector3 const &,::btVector3 const &,::btAlignedObjectArray<int> & ) const
int btGImpactBvh_rayQuery(void *c,float* p0,float* p1,void* p2) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btAlignedObjectArray<int> & tp2 = *(::btAlignedObjectArray<int> *)p2;
	int retVal = (int)o->rayQuery(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//method: update void ( ::btGImpactBvh::* )(  ) 
void btGImpactBvh_update(void *c) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	o->update();
}
//method: refit void ( ::btGImpactBvh::* )(  ) 
void btGImpactBvh_refit(void *c) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	o->refit();
}
//method: isTrimesh bool ( ::btGImpactBvh::* )(  ) const
int btGImpactBvh_isTrimesh(void *c) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	int retVal = (int)o->isTrimesh();
	return retVal;
}
//method: boxQuery bool ( ::btGImpactBvh::* )( ::btAABB const &,::btAlignedObjectArray<int> & ) const
int btGImpactBvh_boxQuery(void *c,void* p0,void* p1) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	::btAABB const & tp0 = *(::btAABB const *)p0;
	::btAlignedObjectArray<int> & tp1 = *(::btAlignedObjectArray<int> *)p1;
	int retVal = (int)o->boxQuery(tp0,tp1);
	return retVal;
}
//method: find_collision void (*)( ::btGImpactBvh *,::btTransform const &,::btGImpactBvh *,::btTransform const &,::btPairSet & )
void btGImpactBvh_find_collision(void* p0,float* p1,void* p2,float* p3,void* p4) {
	::btGImpactBvh * tp0 = (::btGImpactBvh *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	::btGImpactBvh * tp2 = (::btGImpactBvh *)p2;
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	::btPairSet & tp4 = *(::btPairSet *)p4;
	::btGImpactBvh::find_collision(tp0,tp1,tp2,tp3,tp4);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
}
//method: get_node_pointer ::GIM_BVH_TREE_NODE const * ( ::btGImpactBvh::* )( int ) const
void* btGImpactBvh_get_node_pointer(void *c,int p0) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	void* retVal = (void*) o->get_node_pointer(p0);
	return retVal;
}
//method: boxQueryTrans bool ( ::btGImpactBvh::* )( ::btAABB const &,::btTransform const &,::btAlignedObjectArray<int> & ) const
int btGImpactBvh_boxQueryTrans(void *c,void* p0,float* p1,void* p2) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	::btAABB const & tp0 = *(::btAABB const *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	::btAlignedObjectArray<int> & tp2 = *(::btAlignedObjectArray<int> *)p2;
	int retVal = (int)o->boxQueryTrans(tp0,tp1,tp2);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	return retVal;
}
//not supported method: getGlobalBox ::btAABB ( ::btGImpactBvh::* )(  ) const
// error:  - unsupported

//method: getNodeData int ( ::btGImpactBvh::* )( int ) const
int btGImpactBvh_getNodeData(void *c,int p0) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	int retVal = (int)o->getNodeData(p0);
	return retVal;
}
//attribute: ::btBvhTree btGImpactBvh->m_box_tree
void btGImpactBvh_m_box_tree_set(void *c,void* a) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	::btBvhTree & ta = *(::btBvhTree *)a;
	o->m_box_tree = ta;
}
void* btGImpactBvh_m_box_tree_get(void *c) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	return (void*)&(o->m_box_tree);
}

//attribute: ::btPrimitiveManagerBase * btGImpactBvh->m_primitive_manager
void btGImpactBvh_m_primitive_manager_set(void *c,void* a) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	::btPrimitiveManagerBase * ta = (::btPrimitiveManagerBase *)a;
	o->m_primitive_manager = ta;
}
void* btGImpactBvh_m_primitive_manager_get(void *c) {
	::btGImpactBvh *o = (::btGImpactBvh*)c;
	return (void*)(o->m_primitive_manager);
}


// ::btGImpactCollisionAlgorithm
//constructor: btGImpactCollisionAlgorithm  ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionAlgorithmConstructionInfo const &,::btCollisionObject *,::btCollisionObject * ) 
void* btGImpactCollisionAlgorithm_new(void* p0,void* p1,void* p2) {
	::btGImpactCollisionAlgorithm *o = 0;
	 void *mem = 0;
	::btCollisionAlgorithmConstructionInfo const & tp0 = *(::btCollisionAlgorithmConstructionInfo const *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btCollisionObject * tp2 = (::btCollisionObject *)p2;
	mem = btAlignedAlloc(sizeof(::btGImpactCollisionAlgorithm),16);
	o = new (mem)::btGImpactCollisionAlgorithm(tp0,tp1,tp2);
	return (void*)o;
}
void btGImpactCollisionAlgorithm_free(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	delete o;
}
//method: getFace1 int ( ::btGImpactCollisionAlgorithm::* )(  ) 
int btGImpactCollisionAlgorithm_getFace1(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	int retVal = (int)o->getFace1();
	return retVal;
}
//method: getFace0 int ( ::btGImpactCollisionAlgorithm::* )(  ) 
int btGImpactCollisionAlgorithm_getFace0(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	int retVal = (int)o->getFace0();
	return retVal;
}
//method: gimpact_vs_compoundshape void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btGImpactShapeInterface *,::btCompoundShape *,bool ) 
void btGImpactCollisionAlgorithm_gimpact_vs_compoundshape(void *c,void* p0,void* p1,void* p2,void* p3,int p4) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btGImpactShapeInterface * tp2 = (::btGImpactShapeInterface *)p2;
	::btCompoundShape * tp3 = (::btCompoundShape *)p3;
	o->gimpact_vs_compoundshape(tp0,tp1,tp2,tp3,p4);
}
//method: gimpact_vs_shape void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btGImpactShapeInterface *,::btCollisionShape *,bool ) 
void btGImpactCollisionAlgorithm_gimpact_vs_shape(void *c,void* p0,void* p1,void* p2,void* p3,int p4) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btGImpactShapeInterface * tp2 = (::btGImpactShapeInterface *)p2;
	::btCollisionShape * tp3 = (::btCollisionShape *)p3;
	o->gimpact_vs_shape(tp0,tp1,tp2,tp3,p4);
}
//method: convex_vs_convex_collision void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btCollisionShape *,::btCollisionShape * ) 
void btGImpactCollisionAlgorithm_convex_vs_convex_collision(void *c,void* p0,void* p1,void* p2,void* p3) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btCollisionShape * tp2 = (::btCollisionShape *)p2;
	::btCollisionShape * tp3 = (::btCollisionShape *)p3;
	o->convex_vs_convex_collision(tp0,tp1,tp2,tp3);
}
//method: setFace0 void ( ::btGImpactCollisionAlgorithm::* )( int ) 
void btGImpactCollisionAlgorithm_setFace0(void *c,int p0) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	o->setFace0(p0);
}
//method: setFace1 void ( ::btGImpactCollisionAlgorithm::* )( int ) 
void btGImpactCollisionAlgorithm_setFace1(void *c,int p0) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	o->setFace1(p0);
}
//method: checkManifold void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject * ) 
void btGImpactCollisionAlgorithm_checkManifold(void *c,void* p0,void* p1) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	o->checkManifold(tp0,tp1);
}
//not supported method: collide_gjk_triangles void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btGImpactMeshShapePart *,::btGImpactMeshShapePart *,int const *,int ) 
// error: ::btCollisionObject * - ok, ::btCollisionObject * - ok, ::btGImpactMeshShapePart * - ok, ::btGImpactMeshShapePart * - ok,  - unsupported, int - ok, void - ok

//method: newContactManifold ::btPersistentManifold * ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject * ) 
void* btGImpactCollisionAlgorithm_newContactManifold(void *c,void* p0,void* p1) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	void* retVal = (void*) o->newContactManifold(tp0,tp1);
	return retVal;
}
//method: addContactPoint void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btVector3 const &,::btVector3 const &,::btScalar ) 
void btGImpactCollisionAlgorithm_addContactPoint(void *c,void* p0,void* p1,float* p2,float* p3,float p4) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	o->addContactPoint(tp0,tp1,tp2,tp3,p4);
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
}
//method: gimpacttrimeshpart_vs_plane_collision void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btGImpactMeshShapePart *,::btStaticPlaneShape *,bool ) 
void btGImpactCollisionAlgorithm_gimpacttrimeshpart_vs_plane_collision(void *c,void* p0,void* p1,void* p2,void* p3,int p4) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btGImpactMeshShapePart * tp2 = (::btGImpactMeshShapePart *)p2;
	::btStaticPlaneShape * tp3 = (::btStaticPlaneShape *)p3;
	o->gimpacttrimeshpart_vs_plane_collision(tp0,tp1,tp2,tp3,p4);
}
//method: registerAlgorithm void (*)( ::btCollisionDispatcher * )
void btGImpactCollisionAlgorithm_registerAlgorithm(void* p0) {
	::btCollisionDispatcher * tp0 = (::btCollisionDispatcher *)p0;
	::btGImpactCollisionAlgorithm::registerAlgorithm(tp0);
}
//method: processCollision void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
void btGImpactCollisionAlgorithm_processCollision(void *c,void* p0,void* p1,void* p2,void* p3) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btDispatcherInfo const & tp2 = *(::btDispatcherInfo const *)p2;
	::btManifoldResult * tp3 = (::btManifoldResult *)p3;
	o->processCollision(tp0,tp1,tp2,tp3);
}
//method: destroyContactManifolds void ( ::btGImpactCollisionAlgorithm::* )(  ) 
void btGImpactCollisionAlgorithm_destroyContactManifolds(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	o->destroyContactManifolds();
}
//not supported method: collide_sat_triangles void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btGImpactMeshShapePart *,::btGImpactMeshShapePart *,int const *,int ) 
// error: ::btCollisionObject * - ok, ::btCollisionObject * - ok, ::btGImpactMeshShapePart * - ok, ::btGImpactMeshShapePart * - ok,  - unsupported, int - ok, void - ok

//method: gimpact_vs_gimpact_find_pairs void ( ::btGImpactCollisionAlgorithm::* )( ::btTransform const &,::btTransform const &,::btGImpactShapeInterface *,::btGImpactShapeInterface *,::btPairSet & ) 
void btGImpactCollisionAlgorithm_gimpact_vs_gimpact_find_pairs(void *c,float* p0,float* p1,void* p2,void* p3,void* p4) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	::btGImpactShapeInterface * tp2 = (::btGImpactShapeInterface *)p2;
	::btGImpactShapeInterface * tp3 = (::btGImpactShapeInterface *)p3;
	::btPairSet & tp4 = *(::btPairSet *)p4;
	o->gimpact_vs_gimpact_find_pairs(tp0,tp1,tp2,tp3,tp4);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: getLastManifold ::btPersistentManifold * ( ::btGImpactCollisionAlgorithm::* )(  ) 
void* btGImpactCollisionAlgorithm_getLastManifold(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	void* retVal = (void*) o->getLastManifold();
	return retVal;
}
//method: gimpact_vs_shape_find_pairs void ( ::btGImpactCollisionAlgorithm::* )( ::btTransform const &,::btTransform const &,::btGImpactShapeInterface *,::btCollisionShape *,::btAlignedObjectArray<int> & ) 
void btGImpactCollisionAlgorithm_gimpact_vs_shape_find_pairs(void *c,float* p0,float* p1,void* p2,void* p3,void* p4) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	::btGImpactShapeInterface * tp2 = (::btGImpactShapeInterface *)p2;
	::btCollisionShape * tp3 = (::btCollisionShape *)p3;
	::btAlignedObjectArray<int> & tp4 = *(::btAlignedObjectArray<int> *)p4;
	o->gimpact_vs_shape_find_pairs(tp0,tp1,tp2,tp3,tp4);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: destroyConvexAlgorithm void ( ::btGImpactCollisionAlgorithm::* )(  ) 
void btGImpactCollisionAlgorithm_destroyConvexAlgorithm(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	o->destroyConvexAlgorithm();
}
//method: checkConvexAlgorithm void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject * ) 
void btGImpactCollisionAlgorithm_checkConvexAlgorithm(void *c,void* p0,void* p1) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	o->checkConvexAlgorithm(tp0,tp1);
}
//method: newAlgorithm ::btCollisionAlgorithm * ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject * ) 
void* btGImpactCollisionAlgorithm_newAlgorithm(void *c,void* p0,void* p1) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	void* retVal = (void*) o->newAlgorithm(tp0,tp1);
	return retVal;
}
//method: shape_vs_shape_collision void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btCollisionShape *,::btCollisionShape * ) 
void btGImpactCollisionAlgorithm_shape_vs_shape_collision(void *c,void* p0,void* p1,void* p2,void* p3) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btCollisionShape * tp2 = (::btCollisionShape *)p2;
	::btCollisionShape * tp3 = (::btCollisionShape *)p3;
	o->shape_vs_shape_collision(tp0,tp1,tp2,tp3);
}
//method: setPart1 void ( ::btGImpactCollisionAlgorithm::* )( int ) 
void btGImpactCollisionAlgorithm_setPart1(void *c,int p0) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	o->setPart1(p0);
}
//method: setPart0 void ( ::btGImpactCollisionAlgorithm::* )( int ) 
void btGImpactCollisionAlgorithm_setPart0(void *c,int p0) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	o->setPart0(p0);
}
//method: clearCache void ( ::btGImpactCollisionAlgorithm::* )(  ) 
void btGImpactCollisionAlgorithm_clearCache(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	o->clearCache();
}
//method: getPart1 int ( ::btGImpactCollisionAlgorithm::* )(  ) 
int btGImpactCollisionAlgorithm_getPart1(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	int retVal = (int)o->getPart1();
	return retVal;
}
//method: getPart0 int ( ::btGImpactCollisionAlgorithm::* )(  ) 
int btGImpactCollisionAlgorithm_getPart0(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	int retVal = (int)o->getPart0();
	return retVal;
}
//method: gimpact_vs_concave void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btGImpactShapeInterface *,::btConcaveShape *,bool ) 
void btGImpactCollisionAlgorithm_gimpact_vs_concave(void *c,void* p0,void* p1,void* p2,void* p3,int p4) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btGImpactShapeInterface * tp2 = (::btGImpactShapeInterface *)p2;
	::btConcaveShape * tp3 = (::btConcaveShape *)p3;
	o->gimpact_vs_concave(tp0,tp1,tp2,tp3,p4);
}
//method: calculateTimeOfImpact ::btScalar ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
float btGImpactCollisionAlgorithm_calculateTimeOfImpact(void *c,void* p0,void* p1,void* p2,void* p3) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btDispatcherInfo const & tp2 = *(::btDispatcherInfo const *)p2;
	::btManifoldResult * tp3 = (::btManifoldResult *)p3;
	float retVal = (float)o->calculateTimeOfImpact(tp0,tp1,tp2,tp3);
	return retVal;
}
//method: gimpact_vs_gimpact void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btGImpactShapeInterface *,::btGImpactShapeInterface * ) 
void btGImpactCollisionAlgorithm_gimpact_vs_gimpact(void *c,void* p0,void* p1,void* p2,void* p3) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btGImpactShapeInterface * tp2 = (::btGImpactShapeInterface *)p2;
	::btGImpactShapeInterface * tp3 = (::btGImpactShapeInterface *)p3;
	o->gimpact_vs_gimpact(tp0,tp1,tp2,tp3);
}
//method: getAllContactManifolds void ( ::btGImpactCollisionAlgorithm::* )( ::btManifoldArray & ) 
void btGImpactCollisionAlgorithm_getAllContactManifolds(void *c,void* p0) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btManifoldArray & tp0 = *(::btAlignedObjectArray<btPersistentManifold*> *)p0;
	o->getAllContactManifolds(tp0);
}
//attribute: ::btCollisionAlgorithm * btGImpactCollisionAlgorithm->m_convex_algorithm
void btGImpactCollisionAlgorithm_m_convex_algorithm_set(void *c,void* a) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btCollisionAlgorithm * ta = (::btCollisionAlgorithm *)a;
	o->m_convex_algorithm = ta;
}
void* btGImpactCollisionAlgorithm_m_convex_algorithm_get(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	return (void*)(o->m_convex_algorithm);
}

//attribute: ::btPersistentManifold * btGImpactCollisionAlgorithm->m_manifoldPtr
void btGImpactCollisionAlgorithm_m_manifoldPtr_set(void *c,void* a) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btPersistentManifold * ta = (::btPersistentManifold *)a;
	o->m_manifoldPtr = ta;
}
void* btGImpactCollisionAlgorithm_m_manifoldPtr_get(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	return (void*)(o->m_manifoldPtr);
}

//attribute: ::btManifoldResult * btGImpactCollisionAlgorithm->m_resultOut
void btGImpactCollisionAlgorithm_m_resultOut_set(void *c,void* a) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btManifoldResult * ta = (::btManifoldResult *)a;
	o->m_resultOut = ta;
}
void* btGImpactCollisionAlgorithm_m_resultOut_get(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	return (void*)(o->m_resultOut);
}

//attribute: ::btDispatcherInfo const * btGImpactCollisionAlgorithm->m_dispatchInfo
void btGImpactCollisionAlgorithm_m_dispatchInfo_set(void *c,void* a) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	::btDispatcherInfo const * ta = (::btDispatcherInfo const *)a;
	o->m_dispatchInfo = ta;
}
void* btGImpactCollisionAlgorithm_m_dispatchInfo_get(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	return (void*)(o->m_dispatchInfo);
}

//attribute: int btGImpactCollisionAlgorithm->m_triface0
void btGImpactCollisionAlgorithm_m_triface0_set(void *c,int a) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	o->m_triface0 = a;
}
int btGImpactCollisionAlgorithm_m_triface0_get(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	return (int)(o->m_triface0);
}

//attribute: int btGImpactCollisionAlgorithm->m_part0
void btGImpactCollisionAlgorithm_m_part0_set(void *c,int a) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	o->m_part0 = a;
}
int btGImpactCollisionAlgorithm_m_part0_get(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	return (int)(o->m_part0);
}

//attribute: int btGImpactCollisionAlgorithm->m_triface1
void btGImpactCollisionAlgorithm_m_triface1_set(void *c,int a) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	o->m_triface1 = a;
}
int btGImpactCollisionAlgorithm_m_triface1_get(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	return (int)(o->m_triface1);
}

//attribute: int btGImpactCollisionAlgorithm->m_part1
void btGImpactCollisionAlgorithm_m_part1_set(void *c,int a) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	o->m_part1 = a;
}
int btGImpactCollisionAlgorithm_m_part1_get(void *c) {
	::btGImpactCollisionAlgorithm *o = (::btGImpactCollisionAlgorithm*)c;
	return (int)(o->m_part1);
}


// ::btGImpactCompoundShape
//constructor: btGImpactCompoundShape  ( ::btGImpactCompoundShape::* )( bool ) 
void* btGImpactCompoundShape_new(int p0) {
	::btGImpactCompoundShape *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGImpactCompoundShape),16);
	o = new (mem)::btGImpactCompoundShape(p0);
	return (void*)o;
}
void btGImpactCompoundShape_free(void *c) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	delete o;
}
//method: calculateLocalInertia void ( ::btGImpactCompoundShape::* )( ::btScalar,::btVector3 & ) const
void btGImpactCompoundShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: addChildShape void ( ::btGImpactCompoundShape::* )( ::btTransform const &,::btCollisionShape * ) 
void btGImpactCompoundShape_addChildShape(void *c,float* p0,void* p1) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	::btCollisionShape * tp1 = (::btCollisionShape *)p1;
	o->addChildShape(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//method: addChildShape void ( ::btGImpactCompoundShape::* )( ::btTransform const &,::btCollisionShape * ) 
void btGImpactCompoundShape_addChildShape0(void *c,float* p0,void* p1) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	::btCollisionShape * tp1 = (::btCollisionShape *)p1;
	o->addChildShape(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//method: addChildShape void ( ::btGImpactCompoundShape::* )( ::btCollisionShape * ) 
void btGImpactCompoundShape_addChildShape1(void *c,void* p0) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	::btCollisionShape * tp0 = (::btCollisionShape *)p0;
	o->addChildShape(tp0);
}
//method: getCompoundPrimitiveManager ::btGImpactCompoundShape::CompoundPrimitiveManager * ( ::btGImpactCompoundShape::* )(  ) 
void* btGImpactCompoundShape_getCompoundPrimitiveManager(void *c) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	void* retVal = (void*) o->getCompoundPrimitiveManager();
	return retVal;
}
//method: setChildTransform void ( ::btGImpactCompoundShape::* )( int,::btTransform const & ) 
void btGImpactCompoundShape_setChildTransform(void *c,int p0,float* p1) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->setChildTransform(p0,tp1);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: getChildTransform ::btTransform ( ::btGImpactCompoundShape::* )( int ) const
void btGImpactCompoundShape_getChildTransform(void *c,int p0,float* ret) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getChildTransform(p0);
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getBulletTetrahedron void ( ::btGImpactCompoundShape::* )( int,::btTetrahedronShapeEx & ) const
void btGImpactCompoundShape_getBulletTetrahedron(void *c,int p0,void* p1) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	::btTetrahedronShapeEx & tp1 = *(::btTetrahedronShapeEx *)p1;
	o->getBulletTetrahedron(p0,tp1);
}
//method: getName char const * ( ::btGImpactCompoundShape::* )(  ) const
char const * btGImpactCompoundShape_getName(void *c) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: needsRetrieveTetrahedrons bool ( ::btGImpactCompoundShape::* )(  ) const
int btGImpactCompoundShape_needsRetrieveTetrahedrons(void *c) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	int retVal = (int)o->needsRetrieveTetrahedrons();
	return retVal;
}
//method: getChildShape ::btCollisionShape * ( ::btGImpactCompoundShape::* )( int ) 
void* btGImpactCompoundShape_getChildShape(void *c,int p0) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	void* retVal = (void*) o->getChildShape(p0);
	return retVal;
}
//method: getChildShape ::btCollisionShape * ( ::btGImpactCompoundShape::* )( int ) 
void* btGImpactCompoundShape_getChildShape0(void *c,int p0) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	void* retVal = (void*) o->getChildShape(p0);
	return retVal;
}
//method: getChildShape ::btCollisionShape const * ( ::btGImpactCompoundShape::* )( int ) const
void* btGImpactCompoundShape_getChildShape1(void *c,int p0) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	void* retVal = (void*) o->getChildShape(p0);
	return retVal;
}
//method: getBulletTriangle void ( ::btGImpactCompoundShape::* )( int,::btTriangleShapeEx & ) const
void btGImpactCompoundShape_getBulletTriangle(void *c,int p0,void* p1) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	::btTriangleShapeEx & tp1 = *(::btTriangleShapeEx *)p1;
	o->getBulletTriangle(p0,tp1);
}
//method: needsRetrieveTriangles bool ( ::btGImpactCompoundShape::* )(  ) const
int btGImpactCompoundShape_needsRetrieveTriangles(void *c) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	int retVal = (int)o->needsRetrieveTriangles();
	return retVal;
}
//method: childrenHasTransform bool ( ::btGImpactCompoundShape::* )(  ) const
int btGImpactCompoundShape_childrenHasTransform(void *c) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	int retVal = (int)o->childrenHasTransform();
	return retVal;
}
//method: getNumChildShapes int ( ::btGImpactCompoundShape::* )(  ) const
int btGImpactCompoundShape_getNumChildShapes(void *c) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	int retVal = (int)o->getNumChildShapes();
	return retVal;
}
//method: getPrimitiveManager ::btPrimitiveManagerBase const * ( ::btGImpactCompoundShape::* )(  ) const
void* btGImpactCompoundShape_getPrimitiveManager(void *c) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	void* retVal = (void*) o->getPrimitiveManager();
	return retVal;
}
//method: getChildAabb void ( ::btGImpactCompoundShape::* )( int,::btTransform const &,::btVector3 &,::btVector3 & ) const
void btGImpactCompoundShape_getChildAabb(void *c,int p0,float* p1,float* p2,float* p3) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	o->getChildAabb(p0,tp1,tp2,tp3);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
}
//not supported method: getGImpactShapeType ::eGIMPACT_SHAPE_TYPE ( ::btGImpactCompoundShape::* )(  ) const
// error:  - unsupported

//attribute: ::btAlignedObjectArray<btCollisionShape*> btGImpactCompoundShape->m_childShapes
void btGImpactCompoundShape_m_childShapes_set(void *c,void* a) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	::btAlignedObjectArray<btCollisionShape*> & ta = *(::btAlignedObjectArray<btCollisionShape*> *)a;
	o->m_childShapes = ta;
}
void* btGImpactCompoundShape_m_childShapes_get(void *c) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	return (void*)&(o->m_childShapes);
}

//attribute: ::btAlignedObjectArray<btTransform> btGImpactCompoundShape->m_childTransforms
void btGImpactCompoundShape_m_childTransforms_set(void *c,void* a) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	::btAlignedObjectArray<btTransform> & ta = *(::btAlignedObjectArray<btTransform> *)a;
	o->m_childTransforms = ta;
}
void* btGImpactCompoundShape_m_childTransforms_get(void *c) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	return (void*)&(o->m_childTransforms);
}

//attribute: ::btGImpactCompoundShape::CompoundPrimitiveManager btGImpactCompoundShape->m_primitive_manager
void btGImpactCompoundShape_m_primitive_manager_set(void *c,void* a) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	::btGImpactCompoundShape::CompoundPrimitiveManager & ta = *(::btGImpactCompoundShape::CompoundPrimitiveManager *)a;
	o->m_primitive_manager = ta;
}
void* btGImpactCompoundShape_m_primitive_manager_get(void *c) {
	::btGImpactCompoundShape *o = (::btGImpactCompoundShape*)c;
	return (void*)&(o->m_primitive_manager);
}


// ::btGImpactMeshShape
//constructor: btGImpactMeshShape  ( ::btGImpactMeshShape::* )( ::btStridingMeshInterface * ) 
void* btGImpactMeshShape_new(void* p0) {
	::btGImpactMeshShape *o = 0;
	 void *mem = 0;
	::btStridingMeshInterface * tp0 = (::btStridingMeshInterface *)p0;
	mem = btAlignedAlloc(sizeof(::btGImpactMeshShape),16);
	o = new (mem)::btGImpactMeshShape(tp0);
	return (void*)o;
}
void btGImpactMeshShape_free(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	delete o;
}
//method: calculateLocalInertia void ( ::btGImpactMeshShape::* )( ::btScalar,::btVector3 & ) const
void btGImpactMeshShape_calculateLocalInertia(void *c,float p0,float* p1) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: setChildTransform void ( ::btGImpactMeshShape::* )( int,::btTransform const & ) 
void btGImpactMeshShape_setChildTransform(void *c,int p0,float* p1) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->setChildTransform(p0,tp1);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: getMeshInterface ::btStridingMeshInterface * ( ::btGImpactMeshShape::* )(  ) 
void* btGImpactMeshShape_getMeshInterface(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	void* retVal = (void*) o->getMeshInterface();
	return retVal;
}
//method: getMeshInterface ::btStridingMeshInterface * ( ::btGImpactMeshShape::* )(  ) 
void* btGImpactMeshShape_getMeshInterface0(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	void* retVal = (void*) o->getMeshInterface();
	return retVal;
}
//method: getMeshInterface ::btStridingMeshInterface const * ( ::btGImpactMeshShape::* )(  ) const
void* btGImpactMeshShape_getMeshInterface1(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	void* retVal = (void*) o->getMeshInterface();
	return retVal;
}
//method: getPrimitiveManager ::btPrimitiveManagerBase const * ( ::btGImpactMeshShape::* )(  ) const
void* btGImpactMeshShape_getPrimitiveManager(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	void* retVal = (void*) o->getPrimitiveManager();
	return retVal;
}
//method: processAllTriangles void ( ::btGImpactMeshShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
void btGImpactMeshShape_processAllTriangles(void *c,void* p0,float* p1,float* p2) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	::btTriangleCallback * tp0 = (::btTriangleCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->processAllTriangles(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getMeshPartCount int ( ::btGImpactMeshShape::* )(  ) const
int btGImpactMeshShape_getMeshPartCount(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	int retVal = (int)o->getMeshPartCount();
	return retVal;
}
//method: calculateSerializeBufferSize int ( ::btGImpactMeshShape::* )(  ) const
int btGImpactMeshShape_calculateSerializeBufferSize(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: rayTest void ( ::btGImpactMeshShape::* )( ::btVector3 const &,::btVector3 const &,::btCollisionWorld::RayResultCallback & ) const
void btGImpactMeshShape_rayTest(void *c,float* p0,float* p1,void* p2) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btCollisionWorld::RayResultCallback & tp2 = *(::btCollisionWorld::RayResultCallback *)p2;
	o->rayTest(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: buildMeshParts void ( ::btGImpactMeshShape::* )( ::btStridingMeshInterface * ) 
void btGImpactMeshShape_buildMeshParts(void *c,void* p0) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	::btStridingMeshInterface * tp0 = (::btStridingMeshInterface *)p0;
	o->buildMeshParts(tp0);
}
//method: getName char const * ( ::btGImpactMeshShape::* )(  ) const
char const * btGImpactMeshShape_getName(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: getBulletTriangle void ( ::btGImpactMeshShape::* )( int,::btTriangleShapeEx & ) const
void btGImpactMeshShape_getBulletTriangle(void *c,int p0,void* p1) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	::btTriangleShapeEx & tp1 = *(::btTriangleShapeEx *)p1;
	o->getBulletTriangle(p0,tp1);
}
//method: setLocalScaling void ( ::btGImpactMeshShape::* )( ::btVector3 const & ) 
void btGImpactMeshShape_setLocalScaling(void *c,float* p0) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: needsRetrieveTriangles bool ( ::btGImpactMeshShape::* )(  ) const
int btGImpactMeshShape_needsRetrieveTriangles(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	int retVal = (int)o->needsRetrieveTriangles();
	return retVal;
}
//method: childrenHasTransform bool ( ::btGImpactMeshShape::* )(  ) const
int btGImpactMeshShape_childrenHasTransform(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	int retVal = (int)o->childrenHasTransform();
	return retVal;
}
//method: getChildShape ::btCollisionShape * ( ::btGImpactMeshShape::* )( int ) 
void* btGImpactMeshShape_getChildShape(void *c,int p0) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	void* retVal = (void*) o->getChildShape(p0);
	return retVal;
}
//method: getChildShape ::btCollisionShape * ( ::btGImpactMeshShape::* )( int ) 
void* btGImpactMeshShape_getChildShape0(void *c,int p0) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	void* retVal = (void*) o->getChildShape(p0);
	return retVal;
}
//method: getChildShape ::btCollisionShape const * ( ::btGImpactMeshShape::* )( int ) const
void* btGImpactMeshShape_getChildShape1(void *c,int p0) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	void* retVal = (void*) o->getChildShape(p0);
	return retVal;
}
//method: calcLocalAABB void ( ::btGImpactMeshShape::* )(  ) 
void btGImpactMeshShape_calcLocalAABB(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	o->calcLocalAABB();
}
//method: getChildTransform ::btTransform ( ::btGImpactMeshShape::* )( int ) const
void btGImpactMeshShape_getChildTransform(void *c,int p0,float* ret) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getChildTransform(p0);
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: serialize char const * ( ::btGImpactMeshShape::* )( void *,::btSerializer * ) const
char const * btGImpactMeshShape_serialize(void *c,void* p0,void* p1) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: lockChildShapes void ( ::btGImpactMeshShape::* )(  ) const
void btGImpactMeshShape_lockChildShapes(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	o->lockChildShapes();
}
//method: setMargin void ( ::btGImpactMeshShape::* )( ::btScalar ) 
void btGImpactMeshShape_setMargin(void *c,float p0) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	o->setMargin(p0);
}
//method: getNumChildShapes int ( ::btGImpactMeshShape::* )(  ) const
int btGImpactMeshShape_getNumChildShapes(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	int retVal = (int)o->getNumChildShapes();
	return retVal;
}
//method: getChildAabb void ( ::btGImpactMeshShape::* )( int,::btTransform const &,::btVector3 &,::btVector3 & ) const
void btGImpactMeshShape_getChildAabb(void *c,int p0,float* p1,float* p2,float* p3) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	o->getChildAabb(p0,tp1,tp2,tp3);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
}
//method: getBulletTetrahedron void ( ::btGImpactMeshShape::* )( int,::btTetrahedronShapeEx & ) const
void btGImpactMeshShape_getBulletTetrahedron(void *c,int p0,void* p1) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	::btTetrahedronShapeEx & tp1 = *(::btTetrahedronShapeEx *)p1;
	o->getBulletTetrahedron(p0,tp1);
}
//method: needsRetrieveTetrahedrons bool ( ::btGImpactMeshShape::* )(  ) const
int btGImpactMeshShape_needsRetrieveTetrahedrons(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	int retVal = (int)o->needsRetrieveTetrahedrons();
	return retVal;
}
//method: unlockChildShapes void ( ::btGImpactMeshShape::* )(  ) const
void btGImpactMeshShape_unlockChildShapes(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	o->unlockChildShapes();
}
//method: getMeshPart ::btGImpactMeshShapePart * ( ::btGImpactMeshShape::* )( int ) 
void* btGImpactMeshShape_getMeshPart(void *c,int p0) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	void* retVal = (void*) o->getMeshPart(p0);
	return retVal;
}
//method: getMeshPart ::btGImpactMeshShapePart * ( ::btGImpactMeshShape::* )( int ) 
void* btGImpactMeshShape_getMeshPart0(void *c,int p0) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	void* retVal = (void*) o->getMeshPart(p0);
	return retVal;
}
//method: getMeshPart ::btGImpactMeshShapePart const * ( ::btGImpactMeshShape::* )( int ) const
void* btGImpactMeshShape_getMeshPart1(void *c,int p0) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	void* retVal = (void*) o->getMeshPart(p0);
	return retVal;
}
//method: postUpdate void ( ::btGImpactMeshShape::* )(  ) 
void btGImpactMeshShape_postUpdate(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	o->postUpdate();
}
//not supported method: getGImpactShapeType ::eGIMPACT_SHAPE_TYPE ( ::btGImpactMeshShape::* )(  ) const
// error:  - unsupported

//attribute: ::btStridingMeshInterface * btGImpactMeshShape->m_meshInterface
void btGImpactMeshShape_m_meshInterface_set(void *c,void* a) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	::btStridingMeshInterface * ta = (::btStridingMeshInterface *)a;
	o->m_meshInterface = ta;
}
void* btGImpactMeshShape_m_meshInterface_get(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	return (void*)(o->m_meshInterface);
}

//attribute: ::btAlignedObjectArray<btGImpactMeshShapePart*> btGImpactMeshShape->m_mesh_parts
void btGImpactMeshShape_m_mesh_parts_set(void *c,void* a) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	::btAlignedObjectArray<btGImpactMeshShapePart*> & ta = *(::btAlignedObjectArray<btGImpactMeshShapePart*> *)a;
	o->m_mesh_parts = ta;
}
void* btGImpactMeshShape_m_mesh_parts_get(void *c) {
	::btGImpactMeshShape *o = (::btGImpactMeshShape*)c;
	return (void*)&(o->m_mesh_parts);
}


// ::btGImpactMeshShapeData
//constructor: btGImpactMeshShapeData  ( ::btGImpactMeshShapeData::* )(  ) 
void* btGImpactMeshShapeData_new() {
	::btGImpactMeshShapeData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGImpactMeshShapeData),16);
	o = new (mem)::btGImpactMeshShapeData();
	return (void*)o;
}
void btGImpactMeshShapeData_free(void *c) {
	::btGImpactMeshShapeData *o = (::btGImpactMeshShapeData*)c;
	delete o;
}
//attribute: ::btCollisionShapeData btGImpactMeshShapeData->m_collisionShapeData
void btGImpactMeshShapeData_m_collisionShapeData_set(void *c,void* a) {
	::btGImpactMeshShapeData *o = (::btGImpactMeshShapeData*)c;
	::btCollisionShapeData & ta = *(::btCollisionShapeData *)a;
	o->m_collisionShapeData = ta;
}
void* btGImpactMeshShapeData_m_collisionShapeData_get(void *c) {
	::btGImpactMeshShapeData *o = (::btGImpactMeshShapeData*)c;
	return (void*)&(o->m_collisionShapeData);
}

//attribute: ::btStridingMeshInterfaceData btGImpactMeshShapeData->m_meshInterface
void btGImpactMeshShapeData_m_meshInterface_set(void *c,void* a) {
	::btGImpactMeshShapeData *o = (::btGImpactMeshShapeData*)c;
	::btStridingMeshInterfaceData & ta = *(::btStridingMeshInterfaceData *)a;
	o->m_meshInterface = ta;
}
void* btGImpactMeshShapeData_m_meshInterface_get(void *c) {
	::btGImpactMeshShapeData *o = (::btGImpactMeshShapeData*)c;
	return (void*)&(o->m_meshInterface);
}

//attribute: ::btVector3FloatData btGImpactMeshShapeData->m_localScaling
void btGImpactMeshShapeData_m_localScaling_set(void *c,void* a) {
	::btGImpactMeshShapeData *o = (::btGImpactMeshShapeData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_localScaling = ta;
}
void* btGImpactMeshShapeData_m_localScaling_get(void *c) {
	::btGImpactMeshShapeData *o = (::btGImpactMeshShapeData*)c;
	return (void*)&(o->m_localScaling);
}

//attribute: float btGImpactMeshShapeData->m_collisionMargin
void btGImpactMeshShapeData_m_collisionMargin_set(void *c,float a) {
	::btGImpactMeshShapeData *o = (::btGImpactMeshShapeData*)c;
	o->m_collisionMargin = a;
}
float btGImpactMeshShapeData_m_collisionMargin_get(void *c) {
	::btGImpactMeshShapeData *o = (::btGImpactMeshShapeData*)c;
	return (float)(o->m_collisionMargin);
}

//attribute: int btGImpactMeshShapeData->m_gimpactSubType
void btGImpactMeshShapeData_m_gimpactSubType_set(void *c,int a) {
	::btGImpactMeshShapeData *o = (::btGImpactMeshShapeData*)c;
	o->m_gimpactSubType = a;
}
int btGImpactMeshShapeData_m_gimpactSubType_get(void *c) {
	::btGImpactMeshShapeData *o = (::btGImpactMeshShapeData*)c;
	return (int)(o->m_gimpactSubType);
}


// ::btGImpactMeshShapePart
//constructor: btGImpactMeshShapePart  ( ::btGImpactMeshShapePart::* )(  ) 
void* btGImpactMeshShapePart_new0() {
	::btGImpactMeshShapePart *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGImpactMeshShapePart),16);
	o = new (mem)::btGImpactMeshShapePart();
	return (void*)o;
}
//constructor: btGImpactMeshShapePart  ( ::btGImpactMeshShapePart::* )( ::btStridingMeshInterface *,int ) 
void* btGImpactMeshShapePart_new1(void* p0,int p1) {
	::btGImpactMeshShapePart *o = 0;
	 void *mem = 0;
	::btStridingMeshInterface * tp0 = (::btStridingMeshInterface *)p0;
	mem = btAlignedAlloc(sizeof(::btGImpactMeshShapePart),16);
	o = new (mem)::btGImpactMeshShapePart(tp0,p1);
	return (void*)o;
}
void btGImpactMeshShapePart_free(void *c) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	delete o;
}
//method: calculateLocalInertia void ( ::btGImpactMeshShapePart::* )( ::btScalar,::btVector3 & ) const
void btGImpactMeshShapePart_calculateLocalInertia(void *c,float p0,float* p1) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->calculateLocalInertia(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: setChildTransform void ( ::btGImpactMeshShapePart::* )( int,::btTransform const & ) 
void btGImpactMeshShapePart_setChildTransform(void *c,int p0,float* p1) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->setChildTransform(p0,tp1);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: getLocalScaling ::btVector3 const & ( ::btGImpactMeshShapePart::* )(  ) const
void btGImpactMeshShapePart_getLocalScaling(void *c,float* ret) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLocalScaling();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getVertex void ( ::btGImpactMeshShapePart::* )( int,::btVector3 & ) const
void btGImpactMeshShapePart_getVertex(void *c,int p0,float* p1) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getVertex(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: processAllTriangles void ( ::btGImpactMeshShapePart::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
void btGImpactMeshShapePart_processAllTriangles(void *c,void* p0,float* p1,float* p2) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	::btTriangleCallback * tp0 = (::btTriangleCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->processAllTriangles(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getName char const * ( ::btGImpactMeshShapePart::* )(  ) const
char const * btGImpactMeshShapePart_getName(void *c) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	char const * retVal = (char const *)o->getName();
	return retVal;
}
//method: getBulletTriangle void ( ::btGImpactMeshShapePart::* )( int,::btTriangleShapeEx & ) const
void btGImpactMeshShapePart_getBulletTriangle(void *c,int p0,void* p1) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	::btTriangleShapeEx & tp1 = *(::btTriangleShapeEx *)p1;
	o->getBulletTriangle(p0,tp1);
}
//method: setLocalScaling void ( ::btGImpactMeshShapePart::* )( ::btVector3 const & ) 
void btGImpactMeshShapePart_setLocalScaling(void *c,float* p0) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getPart int ( ::btGImpactMeshShapePart::* )(  ) const
int btGImpactMeshShapePart_getPart(void *c) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	int retVal = (int)o->getPart();
	return retVal;
}
//method: childrenHasTransform bool ( ::btGImpactMeshShapePart::* )(  ) const
int btGImpactMeshShapePart_childrenHasTransform(void *c) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	int retVal = (int)o->childrenHasTransform();
	return retVal;
}
//method: needsRetrieveTriangles bool ( ::btGImpactMeshShapePart::* )(  ) const
int btGImpactMeshShapePart_needsRetrieveTriangles(void *c) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	int retVal = (int)o->needsRetrieveTriangles();
	return retVal;
}
//method: getChildShape ::btCollisionShape * ( ::btGImpactMeshShapePart::* )( int ) 
void* btGImpactMeshShapePart_getChildShape(void *c,int p0) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	void* retVal = (void*) o->getChildShape(p0);
	return retVal;
}
//method: getChildShape ::btCollisionShape * ( ::btGImpactMeshShapePart::* )( int ) 
void* btGImpactMeshShapePart_getChildShape0(void *c,int p0) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	void* retVal = (void*) o->getChildShape(p0);
	return retVal;
}
//method: getChildShape ::btCollisionShape const * ( ::btGImpactMeshShapePart::* )( int ) const
void* btGImpactMeshShapePart_getChildShape1(void *c,int p0) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	void* retVal = (void*) o->getChildShape(p0);
	return retVal;
}
//method: getChildTransform ::btTransform ( ::btGImpactMeshShapePart::* )( int ) const
void btGImpactMeshShapePart_getChildTransform(void *c,int p0,float* ret) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getChildTransform(p0);
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: lockChildShapes void ( ::btGImpactMeshShapePart::* )(  ) const
void btGImpactMeshShapePart_lockChildShapes(void *c) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	o->lockChildShapes();
}
//method: getMargin ::btScalar ( ::btGImpactMeshShapePart::* )(  ) const
float btGImpactMeshShapePart_getMargin(void *c) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	float retVal = (float)o->getMargin();
	return retVal;
}
//method: setMargin void ( ::btGImpactMeshShapePart::* )( ::btScalar ) 
void btGImpactMeshShapePart_setMargin(void *c,float p0) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	o->setMargin(p0);
}
//method: getPrimitiveManager ::btPrimitiveManagerBase const * ( ::btGImpactMeshShapePart::* )(  ) const
void* btGImpactMeshShapePart_getPrimitiveManager(void *c) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	void* retVal = (void*) o->getPrimitiveManager();
	return retVal;
}
//method: getNumChildShapes int ( ::btGImpactMeshShapePart::* )(  ) const
int btGImpactMeshShapePart_getNumChildShapes(void *c) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	int retVal = (int)o->getNumChildShapes();
	return retVal;
}
//method: getBulletTetrahedron void ( ::btGImpactMeshShapePart::* )( int,::btTetrahedronShapeEx & ) const
void btGImpactMeshShapePart_getBulletTetrahedron(void *c,int p0,void* p1) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	::btTetrahedronShapeEx & tp1 = *(::btTetrahedronShapeEx *)p1;
	o->getBulletTetrahedron(p0,tp1);
}
//method: getTrimeshPrimitiveManager ::btGImpactMeshShapePart::TrimeshPrimitiveManager * ( ::btGImpactMeshShapePart::* )(  ) 
void* btGImpactMeshShapePart_getTrimeshPrimitiveManager(void *c) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	void* retVal = (void*) o->getTrimeshPrimitiveManager();
	return retVal;
}
//method: needsRetrieveTetrahedrons bool ( ::btGImpactMeshShapePart::* )(  ) const
int btGImpactMeshShapePart_needsRetrieveTetrahedrons(void *c) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	int retVal = (int)o->needsRetrieveTetrahedrons();
	return retVal;
}
//method: unlockChildShapes void ( ::btGImpactMeshShapePart::* )(  ) const
void btGImpactMeshShapePart_unlockChildShapes(void *c) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	o->unlockChildShapes();
}
//not supported method: getGImpactShapeType ::eGIMPACT_SHAPE_TYPE ( ::btGImpactMeshShapePart::* )(  ) const
// error:  - unsupported

//method: getVertexCount int ( ::btGImpactMeshShapePart::* )(  ) const
int btGImpactMeshShapePart_getVertexCount(void *c) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	int retVal = (int)o->getVertexCount();
	return retVal;
}
//attribute: ::btGImpactMeshShapePart::TrimeshPrimitiveManager btGImpactMeshShapePart->m_primitive_manager
void btGImpactMeshShapePart_m_primitive_manager_set(void *c,void* a) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	::btGImpactMeshShapePart::TrimeshPrimitiveManager & ta = *(::btGImpactMeshShapePart::TrimeshPrimitiveManager *)a;
	o->m_primitive_manager = ta;
}
void* btGImpactMeshShapePart_m_primitive_manager_get(void *c) {
	::btGImpactMeshShapePart *o = (::btGImpactMeshShapePart*)c;
	return (void*)&(o->m_primitive_manager);
}


// ::btGImpactQuantizedBvh
//constructor: btGImpactQuantizedBvh  ( ::btGImpactQuantizedBvh::* )(  ) 
void* btGImpactQuantizedBvh_new0() {
	::btGImpactQuantizedBvh *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGImpactQuantizedBvh),16);
	o = new (mem)::btGImpactQuantizedBvh();
	return (void*)o;
}
//constructor: btGImpactQuantizedBvh  ( ::btGImpactQuantizedBvh::* )( ::btPrimitiveManagerBase * ) 
void* btGImpactQuantizedBvh_new1(void* p0) {
	::btGImpactQuantizedBvh *o = 0;
	 void *mem = 0;
	::btPrimitiveManagerBase * tp0 = (::btPrimitiveManagerBase *)p0;
	mem = btAlignedAlloc(sizeof(::btGImpactQuantizedBvh),16);
	o = new (mem)::btGImpactQuantizedBvh(tp0);
	return (void*)o;
}
void btGImpactQuantizedBvh_free(void *c) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	delete o;
}
//method: setNodeBound void ( ::btGImpactQuantizedBvh::* )( int,::btAABB const & ) 
void btGImpactQuantizedBvh_setNodeBound(void *c,int p0,void* p1) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	::btAABB const & tp1 = *(::btAABB const *)p1;
	o->setNodeBound(p0,tp1);
}
//method: getEscapeNodeIndex int ( ::btGImpactQuantizedBvh::* )( int ) const
int btGImpactQuantizedBvh_getEscapeNodeIndex(void *c,int p0) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	int retVal = (int)o->getEscapeNodeIndex(p0);
	return retVal;
}
//method: isLeafNode bool ( ::btGImpactQuantizedBvh::* )( int ) const
int btGImpactQuantizedBvh_isLeafNode(void *c,int p0) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	int retVal = (int)o->isLeafNode(p0);
	return retVal;
}
//method: getPrimitiveManager ::btPrimitiveManagerBase * ( ::btGImpactQuantizedBvh::* )(  ) const
void* btGImpactQuantizedBvh_getPrimitiveManager(void *c) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	void* retVal = (void*) o->getPrimitiveManager();
	return retVal;
}
//method: getNodeBound void ( ::btGImpactQuantizedBvh::* )( int,::btAABB & ) const
void btGImpactQuantizedBvh_getNodeBound(void *c,int p0,void* p1) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	::btAABB & tp1 = *(::btAABB *)p1;
	o->getNodeBound(p0,tp1);
}
//method: getRightNode int ( ::btGImpactQuantizedBvh::* )( int ) const
int btGImpactQuantizedBvh_getRightNode(void *c,int p0) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	int retVal = (int)o->getRightNode(p0);
	return retVal;
}
//method: getLeftNode int ( ::btGImpactQuantizedBvh::* )( int ) const
int btGImpactQuantizedBvh_getLeftNode(void *c,int p0) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	int retVal = (int)o->getLeftNode(p0);
	return retVal;
}
//method: setPrimitiveManager void ( ::btGImpactQuantizedBvh::* )( ::btPrimitiveManagerBase * ) 
void btGImpactQuantizedBvh_setPrimitiveManager(void *c,void* p0) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	::btPrimitiveManagerBase * tp0 = (::btPrimitiveManagerBase *)p0;
	o->setPrimitiveManager(tp0);
}
//method: buildSet void ( ::btGImpactQuantizedBvh::* )(  ) 
void btGImpactQuantizedBvh_buildSet(void *c) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	o->buildSet();
}
//method: getNodeTriangle void ( ::btGImpactQuantizedBvh::* )( int,::btPrimitiveTriangle & ) const
void btGImpactQuantizedBvh_getNodeTriangle(void *c,int p0,void* p1) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	::btPrimitiveTriangle & tp1 = *(::btPrimitiveTriangle *)p1;
	o->getNodeTriangle(p0,tp1);
}
//method: getNodeCount int ( ::btGImpactQuantizedBvh::* )(  ) const
int btGImpactQuantizedBvh_getNodeCount(void *c) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	int retVal = (int)o->getNodeCount();
	return retVal;
}
//method: hasHierarchy bool ( ::btGImpactQuantizedBvh::* )(  ) const
int btGImpactQuantizedBvh_hasHierarchy(void *c) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	int retVal = (int)o->hasHierarchy();
	return retVal;
}
//method: rayQuery bool ( ::btGImpactQuantizedBvh::* )( ::btVector3 const &,::btVector3 const &,::btAlignedObjectArray<int> & ) const
int btGImpactQuantizedBvh_rayQuery(void *c,float* p0,float* p1,void* p2) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btAlignedObjectArray<int> & tp2 = *(::btAlignedObjectArray<int> *)p2;
	int retVal = (int)o->rayQuery(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//method: update void ( ::btGImpactQuantizedBvh::* )(  ) 
void btGImpactQuantizedBvh_update(void *c) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	o->update();
}
//method: refit void ( ::btGImpactQuantizedBvh::* )(  ) 
void btGImpactQuantizedBvh_refit(void *c) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	o->refit();
}
//method: isTrimesh bool ( ::btGImpactQuantizedBvh::* )(  ) const
int btGImpactQuantizedBvh_isTrimesh(void *c) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	int retVal = (int)o->isTrimesh();
	return retVal;
}
//method: boxQuery bool ( ::btGImpactQuantizedBvh::* )( ::btAABB const &,::btAlignedObjectArray<int> & ) const
int btGImpactQuantizedBvh_boxQuery(void *c,void* p0,void* p1) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	::btAABB const & tp0 = *(::btAABB const *)p0;
	::btAlignedObjectArray<int> & tp1 = *(::btAlignedObjectArray<int> *)p1;
	int retVal = (int)o->boxQuery(tp0,tp1);
	return retVal;
}
//method: find_collision void (*)( ::btGImpactQuantizedBvh *,::btTransform const &,::btGImpactQuantizedBvh *,::btTransform const &,::btPairSet & )
void btGImpactQuantizedBvh_find_collision(void* p0,float* p1,void* p2,float* p3,void* p4) {
	::btGImpactQuantizedBvh * tp0 = (::btGImpactQuantizedBvh *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	::btGImpactQuantizedBvh * tp2 = (::btGImpactQuantizedBvh *)p2;
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	::btPairSet & tp4 = *(::btPairSet *)p4;
	::btGImpactQuantizedBvh::find_collision(tp0,tp1,tp2,tp3,tp4);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
}
//method: get_node_pointer ::BT_QUANTIZED_BVH_NODE const * ( ::btGImpactQuantizedBvh::* )( int ) const
void* btGImpactQuantizedBvh_get_node_pointer(void *c,int p0) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	void* retVal = (void*) o->get_node_pointer(p0);
	return retVal;
}
//method: boxQueryTrans bool ( ::btGImpactQuantizedBvh::* )( ::btAABB const &,::btTransform const &,::btAlignedObjectArray<int> & ) const
int btGImpactQuantizedBvh_boxQueryTrans(void *c,void* p0,float* p1,void* p2) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	::btAABB const & tp0 = *(::btAABB const *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	::btAlignedObjectArray<int> & tp2 = *(::btAlignedObjectArray<int> *)p2;
	int retVal = (int)o->boxQueryTrans(tp0,tp1,tp2);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	return retVal;
}
//not supported method: getGlobalBox ::btAABB ( ::btGImpactQuantizedBvh::* )(  ) const
// error:  - unsupported

//method: getNodeData int ( ::btGImpactQuantizedBvh::* )( int ) const
int btGImpactQuantizedBvh_getNodeData(void *c,int p0) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	int retVal = (int)o->getNodeData(p0);
	return retVal;
}
//attribute: ::btQuantizedBvhTree btGImpactQuantizedBvh->m_box_tree
void btGImpactQuantizedBvh_m_box_tree_set(void *c,void* a) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	::btQuantizedBvhTree & ta = *(::btQuantizedBvhTree *)a;
	o->m_box_tree = ta;
}
void* btGImpactQuantizedBvh_m_box_tree_get(void *c) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	return (void*)&(o->m_box_tree);
}

//attribute: ::btPrimitiveManagerBase * btGImpactQuantizedBvh->m_primitive_manager
void btGImpactQuantizedBvh_m_primitive_manager_set(void *c,void* a) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	::btPrimitiveManagerBase * ta = (::btPrimitiveManagerBase *)a;
	o->m_primitive_manager = ta;
}
void* btGImpactQuantizedBvh_m_primitive_manager_get(void *c) {
	::btGImpactQuantizedBvh *o = (::btGImpactQuantizedBvh*)c;
	return (void*)(o->m_primitive_manager);
}


// ::btGImpactShapeInterface
//method: getPrimitiveTriangle void ( ::btGImpactShapeInterface::* )( int,::btPrimitiveTriangle & ) const
void btGImpactShapeInterface_getPrimitiveTriangle(void *c,int p0,void* p1) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	::btPrimitiveTriangle & tp1 = *(::btPrimitiveTriangle *)p1;
	o->getPrimitiveTriangle(p0,tp1);
}
//method: setChildTransform void ( ::btGImpactShapeInterface::* )( int,::btTransform const & ) 
void btGImpactShapeInterface_setChildTransform(void *c,int p0,float* p1) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->setChildTransform(p0,tp1);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: getLocalScaling ::btVector3 const & ( ::btGImpactShapeInterface::* )(  ) const
void btGImpactShapeInterface_getLocalScaling(void *c,float* ret) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getLocalScaling();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getLocalBox ::btAABB const & ( ::btGImpactShapeInterface::* )(  ) 
void* btGImpactShapeInterface_getLocalBox(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	void* retVal = (void*) &(o->getLocalBox());
	return retVal;
}
//method: getPrimitiveManager ::btPrimitiveManagerBase const * ( ::btGImpactShapeInterface::* )(  ) const
void* btGImpactShapeInterface_getPrimitiveManager(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	void* retVal = (void*) o->getPrimitiveManager();
	return retVal;
}
//method: processAllTriangles void ( ::btGImpactShapeInterface::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
void btGImpactShapeInterface_processAllTriangles(void *c,void* p0,float* p1,float* p2) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	::btTriangleCallback * tp0 = (::btTriangleCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->processAllTriangles(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: hasBoxSet bool ( ::btGImpactShapeInterface::* )(  ) const
int btGImpactShapeInterface_hasBoxSet(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	int retVal = (int)o->hasBoxSet();
	return retVal;
}
//method: rayTest void ( ::btGImpactShapeInterface::* )( ::btVector3 const &,::btVector3 const &,::btCollisionWorld::RayResultCallback & ) const
void btGImpactShapeInterface_rayTest(void *c,float* p0,float* p1,void* p2) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btCollisionWorld::RayResultCallback & tp2 = *(::btCollisionWorld::RayResultCallback *)p2;
	o->rayTest(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getBoxSet ::btGImpactBoxSet * ( ::btGImpactShapeInterface::* )(  ) 
void* btGImpactShapeInterface_getBoxSet(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	void* retVal = (void*) o->getBoxSet();
	return retVal;
}
//method: getBulletTriangle void ( ::btGImpactShapeInterface::* )( int,::btTriangleShapeEx & ) const
void btGImpactShapeInterface_getBulletTriangle(void *c,int p0,void* p1) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	::btTriangleShapeEx & tp1 = *(::btTriangleShapeEx *)p1;
	o->getBulletTriangle(p0,tp1);
}
//method: setLocalScaling void ( ::btGImpactShapeInterface::* )( ::btVector3 const & ) 
void btGImpactShapeInterface_setLocalScaling(void *c,float* p0) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setLocalScaling(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: needsRetrieveTriangles bool ( ::btGImpactShapeInterface::* )(  ) const
int btGImpactShapeInterface_needsRetrieveTriangles(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	int retVal = (int)o->needsRetrieveTriangles();
	return retVal;
}
//method: childrenHasTransform bool ( ::btGImpactShapeInterface::* )(  ) const
int btGImpactShapeInterface_childrenHasTransform(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	int retVal = (int)o->childrenHasTransform();
	return retVal;
}
//method: getAabb void ( ::btGImpactShapeInterface::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btGImpactShapeInterface_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getChildShape ::btCollisionShape * ( ::btGImpactShapeInterface::* )( int ) 
void* btGImpactShapeInterface_getChildShape(void *c,int p0) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	void* retVal = (void*) o->getChildShape(p0);
	return retVal;
}
//method: getChildShape ::btCollisionShape * ( ::btGImpactShapeInterface::* )( int ) 
void* btGImpactShapeInterface_getChildShape0(void *c,int p0) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	void* retVal = (void*) o->getChildShape(p0);
	return retVal;
}
//method: getChildShape ::btCollisionShape const * ( ::btGImpactShapeInterface::* )( int ) const
void* btGImpactShapeInterface_getChildShape1(void *c,int p0) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	void* retVal = (void*) o->getChildShape(p0);
	return retVal;
}
//method: calcLocalAABB void ( ::btGImpactShapeInterface::* )(  ) 
void btGImpactShapeInterface_calcLocalAABB(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	o->calcLocalAABB();
}
//method: getChildTransform ::btTransform ( ::btGImpactShapeInterface::* )( int ) const
void btGImpactShapeInterface_getChildTransform(void *c,int p0,float* ret) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getChildTransform(p0);
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: lockChildShapes void ( ::btGImpactShapeInterface::* )(  ) const
void btGImpactShapeInterface_lockChildShapes(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	o->lockChildShapes();
}
//method: setMargin void ( ::btGImpactShapeInterface::* )( ::btScalar ) 
void btGImpactShapeInterface_setMargin(void *c,float p0) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	o->setMargin(p0);
}
//method: getNumChildShapes int ( ::btGImpactShapeInterface::* )(  ) const
int btGImpactShapeInterface_getNumChildShapes(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	int retVal = (int)o->getNumChildShapes();
	return retVal;
}
//method: getChildAabb void ( ::btGImpactShapeInterface::* )( int,::btTransform const &,::btVector3 &,::btVector3 & ) const
void btGImpactShapeInterface_getChildAabb(void *c,int p0,float* p1,float* p2,float* p3) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	o->getChildAabb(p0,tp1,tp2,tp3);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
}
//method: getShapeType int ( ::btGImpactShapeInterface::* )(  ) const
int btGImpactShapeInterface_getShapeType(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	int retVal = (int)o->getShapeType();
	return retVal;
}
//method: getBulletTetrahedron void ( ::btGImpactShapeInterface::* )( int,::btTetrahedronShapeEx & ) const
void btGImpactShapeInterface_getBulletTetrahedron(void *c,int p0,void* p1) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	::btTetrahedronShapeEx & tp1 = *(::btTetrahedronShapeEx *)p1;
	o->getBulletTetrahedron(p0,tp1);
}
//method: needsRetrieveTetrahedrons bool ( ::btGImpactShapeInterface::* )(  ) const
int btGImpactShapeInterface_needsRetrieveTetrahedrons(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	int retVal = (int)o->needsRetrieveTetrahedrons();
	return retVal;
}
//method: unlockChildShapes void ( ::btGImpactShapeInterface::* )(  ) const
void btGImpactShapeInterface_unlockChildShapes(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	o->unlockChildShapes();
}
//method: postUpdate void ( ::btGImpactShapeInterface::* )(  ) 
void btGImpactShapeInterface_postUpdate(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	o->postUpdate();
}
//method: updateBound void ( ::btGImpactShapeInterface::* )(  ) 
void btGImpactShapeInterface_updateBound(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	o->updateBound();
}
//not supported method: getGImpactShapeType ::eGIMPACT_SHAPE_TYPE ( ::btGImpactShapeInterface::* )(  ) const
// error:  - unsupported

//attribute: ::btVector3 btGImpactShapeInterface->localScaling
void btGImpactShapeInterface_localScaling_set(void *c,float* a) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->localScaling = ta;
}
void btGImpactShapeInterface_localScaling_get(void *c,float* a) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	a[0]=(o->localScaling).m_floats[0];a[1]=(o->localScaling).m_floats[1];a[2]=(o->localScaling).m_floats[2];
}

//attribute: ::btGImpactBoxSet btGImpactShapeInterface->m_box_set
void btGImpactShapeInterface_m_box_set_set(void *c,void* a) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	::btGImpactBoxSet & ta = *(::btGImpactQuantizedBvh *)a;
	o->m_box_set = ta;
}
void* btGImpactShapeInterface_m_box_set_get(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	return (void*)&(o->m_box_set);
}

//attribute: ::btAABB btGImpactShapeInterface->m_localAABB
void btGImpactShapeInterface_m_localAABB_set(void *c,void* a) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	::btAABB & ta = *(::btAABB *)a;
	o->m_localAABB = ta;
}
void* btGImpactShapeInterface_m_localAABB_get(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	return (void*)&(o->m_localAABB);
}

//attribute: bool btGImpactShapeInterface->m_needs_update
void btGImpactShapeInterface_m_needs_update_set(void *c,int a) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	o->m_needs_update = a;
}
int btGImpactShapeInterface_m_needs_update_get(void *c) {
	::btGImpactShapeInterface *o = (::btGImpactShapeInterface*)c;
	return (int)(o->m_needs_update);
}


// ::btPairSet
//constructor: btPairSet  ( ::btPairSet::* )(  ) 
void* btPairSet_new() {
	::btPairSet *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btPairSet),16);
	o = new (mem)::btPairSet();
	return (void*)o;
}
void btPairSet_free(void *c) {
	::btPairSet *o = (::btPairSet*)c;
	delete o;
}
//method: push_pair_inv void ( ::btPairSet::* )( int,int ) 
void btPairSet_push_pair_inv(void *c,int p0,int p1) {
	::btPairSet *o = (::btPairSet*)c;
	o->push_pair_inv(p0,p1);
}
//method: push_pair void ( ::btPairSet::* )( int,int ) 
void btPairSet_push_pair(void *c,int p0,int p1) {
	::btPairSet *o = (::btPairSet*)c;
	o->push_pair(p0,p1);
}

// ::btPrimitiveManagerBase
//method: get_primitive_box void ( ::btPrimitiveManagerBase::* )( int,::btAABB & ) const
void btPrimitiveManagerBase_get_primitive_box(void *c,int p0,void* p1) {
	::btPrimitiveManagerBase *o = (::btPrimitiveManagerBase*)c;
	::btAABB & tp1 = *(::btAABB *)p1;
	o->get_primitive_box(p0,tp1);
}
//method: get_primitive_triangle void ( ::btPrimitiveManagerBase::* )( int,::btPrimitiveTriangle & ) const
void btPrimitiveManagerBase_get_primitive_triangle(void *c,int p0,void* p1) {
	::btPrimitiveManagerBase *o = (::btPrimitiveManagerBase*)c;
	::btPrimitiveTriangle & tp1 = *(::btPrimitiveTriangle *)p1;
	o->get_primitive_triangle(p0,tp1);
}
//method: is_trimesh bool ( ::btPrimitiveManagerBase::* )(  ) const
int btPrimitiveManagerBase_is_trimesh(void *c) {
	::btPrimitiveManagerBase *o = (::btPrimitiveManagerBase*)c;
	int retVal = (int)o->is_trimesh();
	return retVal;
}
//method: get_primitive_count int ( ::btPrimitiveManagerBase::* )(  ) const
int btPrimitiveManagerBase_get_primitive_count(void *c) {
	::btPrimitiveManagerBase *o = (::btPrimitiveManagerBase*)c;
	int retVal = (int)o->get_primitive_count();
	return retVal;
}

// ::btPrimitiveTriangle
//constructor: btPrimitiveTriangle  ( ::btPrimitiveTriangle::* )(  ) 
void* btPrimitiveTriangle_new() {
	::btPrimitiveTriangle *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btPrimitiveTriangle),16);
	o = new (mem)::btPrimitiveTriangle();
	return (void*)o;
}
void btPrimitiveTriangle_free(void *c) {
	::btPrimitiveTriangle *o = (::btPrimitiveTriangle*)c;
	delete o;
}
//not supported method: clip_triangle int ( ::btPrimitiveTriangle::* )( ::btPrimitiveTriangle &,::btVector3 * ) 
// error: ::btPrimitiveTriangle & - ok,  - unsupported, int - ok

//method: get_edge_plane void ( ::btPrimitiveTriangle::* )( int,::btVector4 & ) const
void btPrimitiveTriangle_get_edge_plane(void *c,int p0,float* p1) {
	::btPrimitiveTriangle *o = (::btPrimitiveTriangle*)c;
	btVector4 tp1(p1[0],p1[1],p1[2],p1[3]);
	o->get_edge_plane(p0,tp1);
	p1[0]=tp1.getX();p1[1]=tp1.getY();p1[2]=tp1.getZ();p1[3]=tp1.getW();
}
//method: overlap_test_conservative bool ( ::btPrimitiveTriangle::* )( ::btPrimitiveTriangle const & ) 
int btPrimitiveTriangle_overlap_test_conservative(void *c,void* p0) {
	::btPrimitiveTriangle *o = (::btPrimitiveTriangle*)c;
	::btPrimitiveTriangle const & tp0 = *(::btPrimitiveTriangle const *)p0;
	int retVal = (int)o->overlap_test_conservative(tp0);
	return retVal;
}
//method: buildTriPlane void ( ::btPrimitiveTriangle::* )(  ) 
void btPrimitiveTriangle_buildTriPlane(void *c) {
	::btPrimitiveTriangle *o = (::btPrimitiveTriangle*)c;
	o->buildTriPlane();
}
//method: applyTransform void ( ::btPrimitiveTriangle::* )( ::btTransform const & ) 
void btPrimitiveTriangle_applyTransform(void *c,float* p0) {
	::btPrimitiveTriangle *o = (::btPrimitiveTriangle*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	o->applyTransform(tp0);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//method: find_triangle_collision_clip_method bool ( ::btPrimitiveTriangle::* )( ::btPrimitiveTriangle &,::GIM_TRIANGLE_CONTACT & ) 
int btPrimitiveTriangle_find_triangle_collision_clip_method(void *c,void* p0,void* p1) {
	::btPrimitiveTriangle *o = (::btPrimitiveTriangle*)c;
	::btPrimitiveTriangle & tp0 = *(::btPrimitiveTriangle *)p0;
	::GIM_TRIANGLE_CONTACT & tp1 = *(::GIM_TRIANGLE_CONTACT *)p1;
	int retVal = (int)o->find_triangle_collision_clip_method(tp0,tp1);
	return retVal;
}
//attribute: ::btScalar btPrimitiveTriangle->m_dummy
void btPrimitiveTriangle_m_dummy_set(void *c,float a) {
	::btPrimitiveTriangle *o = (::btPrimitiveTriangle*)c;
	o->m_dummy = a;
}
float btPrimitiveTriangle_m_dummy_get(void *c) {
	::btPrimitiveTriangle *o = (::btPrimitiveTriangle*)c;
	return (float)(o->m_dummy);
}

//attribute: ::btScalar btPrimitiveTriangle->m_margin
void btPrimitiveTriangle_m_margin_set(void *c,float a) {
	::btPrimitiveTriangle *o = (::btPrimitiveTriangle*)c;
	o->m_margin = a;
}
float btPrimitiveTriangle_m_margin_get(void *c) {
	::btPrimitiveTriangle *o = (::btPrimitiveTriangle*)c;
	return (float)(o->m_margin);
}

//attribute: ::btVector4 btPrimitiveTriangle->m_plane
void btPrimitiveTriangle_m_plane_set(void *c,float* a) {
	::btPrimitiveTriangle *o = (::btPrimitiveTriangle*)c;
	btVector4 ta(a[0],a[1],a[2],a[3]);
	o->m_plane = ta;
}
void btPrimitiveTriangle_m_plane_get(void *c,float* a) {
	::btPrimitiveTriangle *o = (::btPrimitiveTriangle*)c;
	a[0]=(o->m_plane).getX();a[1]=(o->m_plane).getY();a[2]=(o->m_plane).getZ();a[3]=(o->m_plane).getW();
}

//attribute: ::btVector3[3] btPrimitiveTriangle->m_vertices
// attribute not supported: //attribute: ::btVector3[3] btPrimitiveTriangle->m_vertices

// ::btQuantizedBvhTree
//constructor: btQuantizedBvhTree  ( ::btQuantizedBvhTree::* )(  ) 
void* btQuantizedBvhTree_new() {
	::btQuantizedBvhTree *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btQuantizedBvhTree),16);
	o = new (mem)::btQuantizedBvhTree();
	return (void*)o;
}
void btQuantizedBvhTree_free(void *c) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	delete o;
}
//method: getNodeCount int ( ::btQuantizedBvhTree::* )(  ) const
int btQuantizedBvhTree_getNodeCount(void *c) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	int retVal = (int)o->getNodeCount();
	return retVal;
}
//method: calc_quantization void ( ::btQuantizedBvhTree::* )( ::GIM_BVH_DATA_ARRAY &,::btScalar ) 
void btQuantizedBvhTree_calc_quantization(void *c,void* p0,float p1) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	::GIM_BVH_DATA_ARRAY & tp0 = *(::GIM_BVH_DATA_ARRAY *)p0;
	o->calc_quantization(tp0,p1);
}
//method: build_tree void ( ::btQuantizedBvhTree::* )( ::GIM_BVH_DATA_ARRAY & ) 
void btQuantizedBvhTree_build_tree(void *c,void* p0) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	::GIM_BVH_DATA_ARRAY & tp0 = *(::GIM_BVH_DATA_ARRAY *)p0;
	o->build_tree(tp0);
}
//method: setNodeBound void ( ::btQuantizedBvhTree::* )( int,::btAABB const & ) 
void btQuantizedBvhTree_setNodeBound(void *c,int p0,void* p1) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	::btAABB const & tp1 = *(::btAABB const *)p1;
	o->setNodeBound(p0,tp1);
}
//method: getLeftNode int ( ::btQuantizedBvhTree::* )( int ) const
int btQuantizedBvhTree_getLeftNode(void *c,int p0) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	int retVal = (int)o->getLeftNode(p0);
	return retVal;
}
//method: _build_sub_tree void ( ::btQuantizedBvhTree::* )( ::GIM_BVH_DATA_ARRAY &,int,int ) 
void btQuantizedBvhTree__build_sub_tree(void *c,void* p0,int p1,int p2) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	::GIM_BVH_DATA_ARRAY & tp0 = *(::GIM_BVH_DATA_ARRAY *)p0;
	o->_build_sub_tree(tp0,p1,p2);
}
//method: clearNodes void ( ::btQuantizedBvhTree::* )(  ) 
void btQuantizedBvhTree_clearNodes(void *c) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	o->clearNodes();
}
//method: _sort_and_calc_splitting_index int ( ::btQuantizedBvhTree::* )( ::GIM_BVH_DATA_ARRAY &,int,int,int ) 
int btQuantizedBvhTree__sort_and_calc_splitting_index(void *c,void* p0,int p1,int p2,int p3) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	::GIM_BVH_DATA_ARRAY & tp0 = *(::GIM_BVH_DATA_ARRAY *)p0;
	int retVal = (int)o->_sort_and_calc_splitting_index(tp0,p1,p2,p3);
	return retVal;
}
//not supported method: quantizePoint void ( ::btQuantizedBvhTree::* )( short unsigned int *,::btVector3 const & ) const
// error:  - unsupported, ::btVector3 const & - ok, void - ok

//method: getEscapeNodeIndex int ( ::btQuantizedBvhTree::* )( int ) const
int btQuantizedBvhTree_getEscapeNodeIndex(void *c,int p0) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	int retVal = (int)o->getEscapeNodeIndex(p0);
	return retVal;
}
//method: isLeafNode bool ( ::btQuantizedBvhTree::* )( int ) const
int btQuantizedBvhTree_isLeafNode(void *c,int p0) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	int retVal = (int)o->isLeafNode(p0);
	return retVal;
}
//method: get_node_pointer ::BT_QUANTIZED_BVH_NODE const * ( ::btQuantizedBvhTree::* )( int ) const
void* btQuantizedBvhTree_get_node_pointer(void *c,int p0) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	void* retVal = (void*) o->get_node_pointer(p0);
	return retVal;
}
//not supported method: testQuantizedBoxOverlapp bool ( ::btQuantizedBvhTree::* )( int,short unsigned int *,short unsigned int * ) const
// error: int - ok,  - unsupported,  - unsupported, bool - ok

//method: getNodeData int ( ::btQuantizedBvhTree::* )( int ) const
int btQuantizedBvhTree_getNodeData(void *c,int p0) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	int retVal = (int)o->getNodeData(p0);
	return retVal;
}
//method: getNodeBound void ( ::btQuantizedBvhTree::* )( int,::btAABB & ) const
void btQuantizedBvhTree_getNodeBound(void *c,int p0,void* p1) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	::btAABB & tp1 = *(::btAABB *)p1;
	o->getNodeBound(p0,tp1);
}
//method: getRightNode int ( ::btQuantizedBvhTree::* )( int ) const
int btQuantizedBvhTree_getRightNode(void *c,int p0) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	int retVal = (int)o->getRightNode(p0);
	return retVal;
}
//method: _calc_splitting_axis int ( ::btQuantizedBvhTree::* )( ::GIM_BVH_DATA_ARRAY &,int,int ) 
int btQuantizedBvhTree__calc_splitting_axis(void *c,void* p0,int p1,int p2) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	::GIM_BVH_DATA_ARRAY & tp0 = *(::GIM_BVH_DATA_ARRAY *)p0;
	int retVal = (int)o->_calc_splitting_axis(tp0,p1,p2);
	return retVal;
}
//attribute: ::btVector3 btQuantizedBvhTree->m_bvhQuantization
void btQuantizedBvhTree_m_bvhQuantization_set(void *c,float* a) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_bvhQuantization = ta;
}
void btQuantizedBvhTree_m_bvhQuantization_get(void *c,float* a) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	a[0]=(o->m_bvhQuantization).m_floats[0];a[1]=(o->m_bvhQuantization).m_floats[1];a[2]=(o->m_bvhQuantization).m_floats[2];
}

//attribute: ::btAABB btQuantizedBvhTree->m_global_bound
void btQuantizedBvhTree_m_global_bound_set(void *c,void* a) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	::btAABB & ta = *(::btAABB *)a;
	o->m_global_bound = ta;
}
void* btQuantizedBvhTree_m_global_bound_get(void *c) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	return (void*)&(o->m_global_bound);
}

//attribute: ::GIM_QUANTIZED_BVH_NODE_ARRAY btQuantizedBvhTree->m_node_array
void btQuantizedBvhTree_m_node_array_set(void *c,void* a) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	::GIM_QUANTIZED_BVH_NODE_ARRAY & ta = *(::GIM_QUANTIZED_BVH_NODE_ARRAY *)a;
	o->m_node_array = ta;
}
void* btQuantizedBvhTree_m_node_array_get(void *c) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	return (void*)&(o->m_node_array);
}

//attribute: int btQuantizedBvhTree->m_num_nodes
void btQuantizedBvhTree_m_num_nodes_set(void *c,int a) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	o->m_num_nodes = a;
}
int btQuantizedBvhTree_m_num_nodes_get(void *c) {
	::btQuantizedBvhTree *o = (::btQuantizedBvhTree*)c;
	return (int)(o->m_num_nodes);
}


// ::btTetrahedronShapeEx
//constructor: btTetrahedronShapeEx  ( ::btTetrahedronShapeEx::* )(  ) 
void* btTetrahedronShapeEx_new() {
	::btTetrahedronShapeEx *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTetrahedronShapeEx),16);
	o = new (mem)::btTetrahedronShapeEx();
	return (void*)o;
}
void btTetrahedronShapeEx_free(void *c) {
	::btTetrahedronShapeEx *o = (::btTetrahedronShapeEx*)c;
	delete o;
}
//method: setVertices void ( ::btTetrahedronShapeEx::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btTetrahedronShapeEx_setVertices(void *c,float* p0,float* p1,float* p2,float* p3) {
	::btTetrahedronShapeEx *o = (::btTetrahedronShapeEx*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	o->setVertices(tp0,tp1,tp2,tp3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
}

// ::btTriangleShapeEx
//constructor: btTriangleShapeEx  ( ::btTriangleShapeEx::* )(  ) 
void* btTriangleShapeEx_new0() {
	::btTriangleShapeEx *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btTriangleShapeEx),16);
	o = new (mem)::btTriangleShapeEx();
	return (void*)o;
}
//constructor: btTriangleShapeEx  ( ::btTriangleShapeEx::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void* btTriangleShapeEx_new1(float* p0,float* p1,float* p2) {
	::btTriangleShapeEx *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	mem = btAlignedAlloc(sizeof(::btTriangleShapeEx),16);
	o = new (mem)::btTriangleShapeEx(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	return (void*)o;
}
void btTriangleShapeEx_free(void *c) {
	::btTriangleShapeEx *o = (::btTriangleShapeEx*)c;
	delete o;
}
//method: overlap_test_conservative bool ( ::btTriangleShapeEx::* )( ::btTriangleShapeEx const & ) 
int btTriangleShapeEx_overlap_test_conservative(void *c,void* p0) {
	::btTriangleShapeEx *o = (::btTriangleShapeEx*)c;
	::btTriangleShapeEx const & tp0 = *(::btTriangleShapeEx const *)p0;
	int retVal = (int)o->overlap_test_conservative(tp0);
	return retVal;
}
//method: buildTriPlane void ( ::btTriangleShapeEx::* )( ::btVector4 & ) const
void btTriangleShapeEx_buildTriPlane(void *c,float* p0) {
	::btTriangleShapeEx *o = (::btTriangleShapeEx*)c;
	btVector4 tp0(p0[0],p0[1],p0[2],p0[3]);
	o->buildTriPlane(tp0);
	p0[0]=tp0.getX();p0[1]=tp0.getY();p0[2]=tp0.getZ();p0[3]=tp0.getW();
}
//method: applyTransform void ( ::btTriangleShapeEx::* )( ::btTransform const & ) 
void btTriangleShapeEx_applyTransform(void *c,float* p0) {
	::btTriangleShapeEx *o = (::btTriangleShapeEx*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	o->applyTransform(tp0);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//method: getAabb void ( ::btTriangleShapeEx::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btTriangleShapeEx_getAabb(void *c,float* p0,float* p1,float* p2) {
	::btTriangleShapeEx *o = (::btTriangleShapeEx*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}

// ::btDbvt::IClone
//constructor: IClone  ( ::btDbvt::IClone::* )(  ) 
void* btDbvt_IClone_new() {
	::btDbvt::IClone *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btDbvt::IClone),16);
	o = new (mem)::btDbvt::IClone();
	return (void*)o;
}
void btDbvt_IClone_free(void *c) {
	::btDbvt::IClone *o = (::btDbvt::IClone*)c;
	delete o;
}
//method: CloneLeaf void ( ::btDbvt::IClone::* )( ::btDbvtNode * ) 
void btDbvt_IClone_CloneLeaf(void *c,void* p0) {
	::btDbvt::IClone *o = (::btDbvt::IClone*)c;
	::btDbvtNode * tp0 = (::btDbvtNode *)p0;
	o->CloneLeaf(tp0);
}

// ::btDbvt::ICollide
//constructor: ICollide  ( ::btDbvt::ICollide::* )(  ) 
void* btDbvt_ICollide_new() {
	::btDbvt::ICollide *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btDbvt::ICollide),16);
	o = new (mem)::btDbvt::ICollide();
	return (void*)o;
}
void btDbvt_ICollide_free(void *c) {
	::btDbvt::ICollide *o = (::btDbvt::ICollide*)c;
	delete o;
}
//method: Process void ( ::btDbvt::ICollide::* )( ::btDbvtNode const *,::btDbvtNode const * ) 
void btDbvt_ICollide_Process(void *c,void* p0,void* p1) {
	::btDbvt::ICollide *o = (::btDbvt::ICollide*)c;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	::btDbvtNode const * tp1 = (::btDbvtNode const *)p1;
	o->Process(tp0,tp1);
}
//method: Process void ( ::btDbvt::ICollide::* )( ::btDbvtNode const *,::btDbvtNode const * ) 
void btDbvt_ICollide_Process0(void *c,void* p0,void* p1) {
	::btDbvt::ICollide *o = (::btDbvt::ICollide*)c;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	::btDbvtNode const * tp1 = (::btDbvtNode const *)p1;
	o->Process(tp0,tp1);
}
//method: Process void ( ::btDbvt::ICollide::* )( ::btDbvtNode const * ) 
void btDbvt_ICollide_Process1(void *c,void* p0) {
	::btDbvt::ICollide *o = (::btDbvt::ICollide*)c;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	o->Process(tp0);
}
//method: Process void ( ::btDbvt::ICollide::* )( ::btDbvtNode const *,::btScalar ) 
void btDbvt_ICollide_Process2(void *c,void* p0,float p1) {
	::btDbvt::ICollide *o = (::btDbvt::ICollide*)c;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	o->Process(tp0,p1);
}
//method: AllLeaves bool ( ::btDbvt::ICollide::* )( ::btDbvtNode const * ) 
int btDbvt_ICollide_AllLeaves(void *c,void* p0) {
	::btDbvt::ICollide *o = (::btDbvt::ICollide*)c;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	int retVal = (int)o->AllLeaves(tp0);
	return retVal;
}
//method: Descent bool ( ::btDbvt::ICollide::* )( ::btDbvtNode const * ) 
int btDbvt_ICollide_Descent(void *c,void* p0) {
	::btDbvt::ICollide *o = (::btDbvt::ICollide*)c;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	int retVal = (int)o->Descent(tp0);
	return retVal;
}

// ::btDbvt::IWriter
//method: WriteLeaf void ( ::btDbvt::IWriter::* )( ::btDbvtNode const *,int,int ) 
void btDbvt_IWriter_WriteLeaf(void *c,void* p0,int p1,int p2) {
	::btDbvt::IWriter *o = (::btDbvt::IWriter*)c;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	o->WriteLeaf(tp0,p1,p2);
}
//method: WriteNode void ( ::btDbvt::IWriter::* )( ::btDbvtNode const *,int,int,int,int ) 
void btDbvt_IWriter_WriteNode(void *c,void* p0,int p1,int p2,int p3,int p4) {
	::btDbvt::IWriter *o = (::btDbvt::IWriter*)c;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	o->WriteNode(tp0,p1,p2,p3,p4);
}
//method: Prepare void ( ::btDbvt::IWriter::* )( ::btDbvtNode const *,int ) 
void btDbvt_IWriter_Prepare(void *c,void* p0,int p1) {
	::btDbvt::IWriter *o = (::btDbvt::IWriter*)c;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	o->Prepare(tp0,p1);
}

// ::bt32BitAxisSweep3
//constructor: bt32BitAxisSweep3  ( ::bt32BitAxisSweep3::* )( ::btVector3 const &,::btVector3 const &,unsigned int,::btOverlappingPairCache *,bool ) 
void* bt32BitAxisSweep3_new(float* p0,float* p1,unsigned int p2,void* p3,int p4) {
	::bt32BitAxisSweep3 *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btOverlappingPairCache * tp3 = (::btOverlappingPairCache *)p3;
	mem = btAlignedAlloc(sizeof(::bt32BitAxisSweep3),16);
	o = new (mem)::bt32BitAxisSweep3(tp0,tp1,p2,tp3,p4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return (void*)o;
}
void bt32BitAxisSweep3_free(void *c) {
	::bt32BitAxisSweep3 *o = (::bt32BitAxisSweep3*)c;
	delete o;
}

// ::btAxisSweep3
//constructor: btAxisSweep3  ( ::btAxisSweep3::* )( ::btVector3 const &,::btVector3 const &,short unsigned int,::btOverlappingPairCache *,bool ) 
void* btAxisSweep3_new(float* p0,float* p1,short unsigned int p2,void* p3,int p4) {
	::btAxisSweep3 *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btOverlappingPairCache * tp3 = (::btOverlappingPairCache *)p3;
	mem = btAlignedAlloc(sizeof(::btAxisSweep3),16);
	o = new (mem)::btAxisSweep3(tp0,tp1,p2,tp3,p4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return (void*)o;
}
void btAxisSweep3_free(void *c) {
	::btAxisSweep3 *o = (::btAxisSweep3*)c;
	delete o;
}

// ::btAxisSweep3Internal< unsigned int >
//constructor: btAxisSweep3Internal  ( ::btAxisSweep3Internal<unsigned int>::* )( ::btVector3 const &,::btVector3 const &,unsigned int,unsigned int,unsigned int,::btOverlappingPairCache *,bool ) 
void* btAxisSweep3Internal_unsignedint__new(float* p0,float* p1,unsigned int p2,unsigned int p3,unsigned int p4,void* p5,int p6) {
	::btAxisSweep3Internal< unsigned int > *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btOverlappingPairCache * tp5 = (::btOverlappingPairCache *)p5;
	mem = btAlignedAlloc(sizeof(::btAxisSweep3Internal< unsigned int >),16);
	o = new (mem)::btAxisSweep3Internal< unsigned int >(tp0,tp1,p2,p3,p4,tp5,p6);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return (void*)o;
}
void btAxisSweep3Internal_unsignedint__free(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	delete o;
}
//method: sortMinUp void ( ::btAxisSweep3Internal<unsigned int>::* )( int,unsigned int,::btDispatcher *,bool ) 
void btAxisSweep3Internal_unsignedint__sortMinUp(void *c,int p0,unsigned int p1,void* p2,int p3) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btDispatcher * tp2 = (::btDispatcher *)p2;
	o->sortMinUp(p0,p1,tp2,p3);
}
//method: allocHandle unsigned int ( ::btAxisSweep3Internal<unsigned int>::* )(  ) 
unsigned int btAxisSweep3Internal_unsignedint__allocHandle(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	unsigned int retVal = (unsigned int)o->allocHandle();
	return retVal;
}
//method: getNumHandles unsigned int ( ::btAxisSweep3Internal<unsigned int>::* )(  ) const
unsigned int btAxisSweep3Internal_unsignedint__getNumHandles(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	unsigned int retVal = (unsigned int)o->getNumHandles();
	return retVal;
}
//method: addHandle unsigned int ( ::btAxisSweep3Internal<unsigned int>::* )( ::btVector3 const &,::btVector3 const &,void *,short int,short int,::btDispatcher *,void * ) 
unsigned int btAxisSweep3Internal_unsignedint__addHandle(void *c,float* p0,float* p1,void* p2,short int p3,short int p4,void* p5,void* p6) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	void * tp2 = (void *)p2;
	::btDispatcher * tp5 = (::btDispatcher *)p5;
	void * tp6 = (void *)p6;
	unsigned int retVal = (unsigned int)o->addHandle(tp0,tp1,tp2,p3,p4,tp5,tp6);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//not supported method: quantize void ( ::btAxisSweep3Internal<unsigned int>::* )( unsigned int *,::btVector3 const &,int ) const
// error:  - unsupported, ::btVector3 const & - ok, int - ok, void - ok

//method: sortMaxUp void ( ::btAxisSweep3Internal<unsigned int>::* )( int,unsigned int,::btDispatcher *,bool ) 
void btAxisSweep3Internal_unsignedint__sortMaxUp(void *c,int p0,unsigned int p1,void* p2,int p3) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btDispatcher * tp2 = (::btDispatcher *)p2;
	o->sortMaxUp(p0,p1,tp2,p3);
}
//method: removeHandle void ( ::btAxisSweep3Internal<unsigned int>::* )( unsigned int,::btDispatcher * ) 
void btAxisSweep3Internal_unsignedint__removeHandle(void *c,unsigned int p0,void* p1) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->removeHandle(p0,tp1);
}
//method: getOverlappingPairUserCallback ::btOverlappingPairCallback const * ( ::btAxisSweep3Internal<unsigned int>::* )(  ) const
void* btAxisSweep3Internal_unsignedint__getOverlappingPairUserCallback(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	void* retVal = (void*) o->getOverlappingPairUserCallback();
	return retVal;
}
//method: sortMaxDown void ( ::btAxisSweep3Internal<unsigned int>::* )( int,unsigned int,::btDispatcher *,bool ) 
void btAxisSweep3Internal_unsignedint__sortMaxDown(void *c,int p0,unsigned int p1,void* p2,int p3) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btDispatcher * tp2 = (::btDispatcher *)p2;
	o->sortMaxDown(p0,p1,tp2,p3);
}
//method: rayTest void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseRayCallback &,::btVector3 const &,::btVector3 const & ) 
void btAxisSweep3Internal_unsignedint__rayTest(void *c,float* p0,float* p1,void* p2,float* p3,float* p4) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btBroadphaseRayCallback & tp2 = *(::btBroadphaseRayCallback *)p2;
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->rayTest(tp0,tp1,tp2,tp3,tp4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: setAabb void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btBroadphaseProxy *,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btAxisSweep3Internal_unsignedint__setAabb(void *c,void* p0,float* p1,float* p2,void* p3) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	::btDispatcher * tp3 = (::btDispatcher *)p3;
	o->setAabb(tp0,tp1,tp2,tp3);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: resetPool void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btDispatcher * ) 
void btAxisSweep3Internal_unsignedint__resetPool(void *c,void* p0) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->resetPool(tp0);
}
//method: testAabbOverlap bool ( ::btAxisSweep3Internal<unsigned int>::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
int btAxisSweep3Internal_unsignedint__testAabbOverlap(void *c,void* p0,void* p1) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	int retVal = (int)o->testAabbOverlap(tp0,tp1);
	return retVal;
}
//method: getAabb void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
void btAxisSweep3Internal_unsignedint__getAabb(void *c,void* p0,float* p1,float* p2) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//not supported method: testOverlap2D bool ( ::btAxisSweep3Internal<unsigned int>::* )( ::btAxisSweep3Internal<unsigned int>::Handle const *,::btAxisSweep3Internal<unsigned int>::Handle const *,int,int ) 
// error:  - unsupported,  - unsupported, int - ok, int - ok, bool - ok

//method: updateHandle void ( ::btAxisSweep3Internal<unsigned int>::* )( unsigned int,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btAxisSweep3Internal_unsignedint__updateHandle(void *c,unsigned int p0,float* p1,float* p2,void* p3) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	::btDispatcher * tp3 = (::btDispatcher *)p3;
	o->updateHandle(p0,tp1,tp2,tp3);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: freeHandle void ( ::btAxisSweep3Internal<unsigned int>::* )( unsigned int ) 
void btAxisSweep3Internal_unsignedint__freeHandle(void *c,unsigned int p0) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	o->freeHandle(p0);
}
//method: printStats void ( ::btAxisSweep3Internal<unsigned int>::* )(  ) 
void btAxisSweep3Internal_unsignedint__printStats(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	o->printStats();
}
//method: createProxy ::btBroadphaseProxy * ( ::btAxisSweep3Internal<unsigned int>::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int,::btDispatcher *,void * ) 
void* btAxisSweep3Internal_unsignedint__createProxy(void *c,float* p0,float* p1,int p2,void* p3,short int p4,short int p5,void* p6,void* p7) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	void * tp3 = (void *)p3;
	::btDispatcher * tp6 = (::btDispatcher *)p6;
	void * tp7 = (void *)p7;
	void* retVal = (void*) o->createProxy(tp0,tp1,p2,tp3,p4,p5,tp6,tp7);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//method: setOverlappingPairUserCallback void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btOverlappingPairCallback * ) 
void btAxisSweep3Internal_unsignedint__setOverlappingPairUserCallback(void *c,void* p0) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btOverlappingPairCallback * tp0 = (::btOverlappingPairCallback *)p0;
	o->setOverlappingPairUserCallback(tp0);
}
//method: calculateOverlappingPairs void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btDispatcher * ) 
void btAxisSweep3Internal_unsignedint__calculateOverlappingPairs(void *c,void* p0) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->calculateOverlappingPairs(tp0);
}
//method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btAxisSweep3Internal<unsigned int>::* )(  ) 
void* btAxisSweep3Internal_unsignedint__getOverlappingPairCache(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btAxisSweep3Internal<unsigned int>::* )(  ) 
void* btAxisSweep3Internal_unsignedint__getOverlappingPairCache0(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: getOverlappingPairCache ::btOverlappingPairCache const * ( ::btAxisSweep3Internal<unsigned int>::* )(  ) const
void* btAxisSweep3Internal_unsignedint__getOverlappingPairCache1(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: unQuantize void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
void btAxisSweep3Internal_unsignedint__unQuantize(void *c,void* p0,float* p1,float* p2) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->unQuantize(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: sortMinDown void ( ::btAxisSweep3Internal<unsigned int>::* )( int,unsigned int,::btDispatcher *,bool ) 
void btAxisSweep3Internal_unsignedint__sortMinDown(void *c,int p0,unsigned int p1,void* p2,int p3) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btDispatcher * tp2 = (::btDispatcher *)p2;
	o->sortMinDown(p0,p1,tp2,p3);
}
//method: aabbTest void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseAabbCallback & ) 
void btAxisSweep3Internal_unsignedint__aabbTest(void *c,float* p0,float* p1,void* p2) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btBroadphaseAabbCallback & tp2 = *(::btBroadphaseAabbCallback *)p2;
	o->aabbTest(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getBroadphaseAabb void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btVector3 &,::btVector3 & ) const
void btAxisSweep3Internal_unsignedint__getBroadphaseAabb(void *c,float* p0,float* p1) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getBroadphaseAabb(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: destroyProxy void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btAxisSweep3Internal_unsignedint__destroyProxy(void *c,void* p0,void* p1) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->destroyProxy(tp0,tp1);
}
//not supported method: getHandle ::btAxisSweep3Internal<unsigned int>::Handle * ( ::btAxisSweep3Internal<unsigned int>::* )( unsigned int ) const
// error: unsigned int - ok,  - unsupported

//attribute: unsigned int btAxisSweep3Internal_unsignedint_->m_bpHandleMask
void btAxisSweep3Internal_unsignedint__m_bpHandleMask_set(void *c,unsigned int a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	o->m_bpHandleMask = a;
}
unsigned int btAxisSweep3Internal_unsignedint__m_bpHandleMask_get(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	return (unsigned int)(o->m_bpHandleMask);
}

//attribute: unsigned int btAxisSweep3Internal_unsignedint_->m_handleSentinel
void btAxisSweep3Internal_unsignedint__m_handleSentinel_set(void *c,unsigned int a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	o->m_handleSentinel = a;
}
unsigned int btAxisSweep3Internal_unsignedint__m_handleSentinel_get(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	return (unsigned int)(o->m_handleSentinel);
}

//attribute: ::btVector3 btAxisSweep3Internal_unsignedint_->m_worldAabbMin
void btAxisSweep3Internal_unsignedint__m_worldAabbMin_set(void *c,float* a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_worldAabbMin = ta;
}
void btAxisSweep3Internal_unsignedint__m_worldAabbMin_get(void *c,float* a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	a[0]=(o->m_worldAabbMin).m_floats[0];a[1]=(o->m_worldAabbMin).m_floats[1];a[2]=(o->m_worldAabbMin).m_floats[2];
}

//attribute: ::btVector3 btAxisSweep3Internal_unsignedint_->m_worldAabbMax
void btAxisSweep3Internal_unsignedint__m_worldAabbMax_set(void *c,float* a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_worldAabbMax = ta;
}
void btAxisSweep3Internal_unsignedint__m_worldAabbMax_get(void *c,float* a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	a[0]=(o->m_worldAabbMax).m_floats[0];a[1]=(o->m_worldAabbMax).m_floats[1];a[2]=(o->m_worldAabbMax).m_floats[2];
}

//attribute: ::btVector3 btAxisSweep3Internal_unsignedint_->m_quantize
void btAxisSweep3Internal_unsignedint__m_quantize_set(void *c,float* a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_quantize = ta;
}
void btAxisSweep3Internal_unsignedint__m_quantize_get(void *c,float* a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	a[0]=(o->m_quantize).m_floats[0];a[1]=(o->m_quantize).m_floats[1];a[2]=(o->m_quantize).m_floats[2];
}

//attribute: unsigned int btAxisSweep3Internal_unsignedint_->m_numHandles
void btAxisSweep3Internal_unsignedint__m_numHandles_set(void *c,unsigned int a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	o->m_numHandles = a;
}
unsigned int btAxisSweep3Internal_unsignedint__m_numHandles_get(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	return (unsigned int)(o->m_numHandles);
}

//attribute: unsigned int btAxisSweep3Internal_unsignedint_->m_maxHandles
void btAxisSweep3Internal_unsignedint__m_maxHandles_set(void *c,unsigned int a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	o->m_maxHandles = a;
}
unsigned int btAxisSweep3Internal_unsignedint__m_maxHandles_get(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	return (unsigned int)(o->m_maxHandles);
}

//attribute: ::btAxisSweep3Internal<unsigned int>::Handle * btAxisSweep3Internal_unsignedint_->m_pHandles
// attribute not supported: //attribute: ::btAxisSweep3Internal<unsigned int>::Handle * btAxisSweep3Internal_unsignedint_->m_pHandles
//attribute: unsigned int btAxisSweep3Internal_unsignedint_->m_firstFreeHandle
void btAxisSweep3Internal_unsignedint__m_firstFreeHandle_set(void *c,unsigned int a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	o->m_firstFreeHandle = a;
}
unsigned int btAxisSweep3Internal_unsignedint__m_firstFreeHandle_get(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	return (unsigned int)(o->m_firstFreeHandle);
}

//attribute: ::btAxisSweep3Internal<unsigned int>::Edge *[3] btAxisSweep3Internal_unsignedint_->m_pEdges
// attribute not supported: //attribute: ::btAxisSweep3Internal<unsigned int>::Edge *[3] btAxisSweep3Internal_unsignedint_->m_pEdges
//attribute: void *[3] btAxisSweep3Internal_unsignedint_->m_pEdgesRawPtr
// attribute not supported: //attribute: void *[3] btAxisSweep3Internal_unsignedint_->m_pEdgesRawPtr
//attribute: ::btOverlappingPairCache * btAxisSweep3Internal_unsignedint_->m_pairCache
void btAxisSweep3Internal_unsignedint__m_pairCache_set(void *c,void* a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btOverlappingPairCache * ta = (::btOverlappingPairCache *)a;
	o->m_pairCache = ta;
}
void* btAxisSweep3Internal_unsignedint__m_pairCache_get(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	return (void*)(o->m_pairCache);
}

//attribute: ::btOverlappingPairCallback * btAxisSweep3Internal_unsignedint_->m_userPairCallback
void btAxisSweep3Internal_unsignedint__m_userPairCallback_set(void *c,void* a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btOverlappingPairCallback * ta = (::btOverlappingPairCallback *)a;
	o->m_userPairCallback = ta;
}
void* btAxisSweep3Internal_unsignedint__m_userPairCallback_get(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	return (void*)(o->m_userPairCallback);
}

//attribute: bool btAxisSweep3Internal_unsignedint_->m_ownsPairCache
void btAxisSweep3Internal_unsignedint__m_ownsPairCache_set(void *c,int a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	o->m_ownsPairCache = a;
}
int btAxisSweep3Internal_unsignedint__m_ownsPairCache_get(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	return (int)(o->m_ownsPairCache);
}

//attribute: int btAxisSweep3Internal_unsignedint_->m_invalidPair
void btAxisSweep3Internal_unsignedint__m_invalidPair_set(void *c,int a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	o->m_invalidPair = a;
}
int btAxisSweep3Internal_unsignedint__m_invalidPair_get(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	return (int)(o->m_invalidPair);
}

//attribute: ::btDbvtBroadphase * btAxisSweep3Internal_unsignedint_->m_raycastAccelerator
void btAxisSweep3Internal_unsignedint__m_raycastAccelerator_set(void *c,void* a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btDbvtBroadphase * ta = (::btDbvtBroadphase *)a;
	o->m_raycastAccelerator = ta;
}
void* btAxisSweep3Internal_unsignedint__m_raycastAccelerator_get(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	return (void*)(o->m_raycastAccelerator);
}

//attribute: ::btOverlappingPairCache * btAxisSweep3Internal_unsignedint_->m_nullPairCache
void btAxisSweep3Internal_unsignedint__m_nullPairCache_set(void *c,void* a) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	::btOverlappingPairCache * ta = (::btOverlappingPairCache *)a;
	o->m_nullPairCache = ta;
}
void* btAxisSweep3Internal_unsignedint__m_nullPairCache_get(void *c) {
	::btAxisSweep3Internal< unsigned int > *o = (::btAxisSweep3Internal< unsigned int >*)c;
	return (void*)(o->m_nullPairCache);
}


// ::btAxisSweep3Internal< unsigned short >
//constructor: btAxisSweep3Internal  ( ::btAxisSweep3Internal<unsigned short>::* )( ::btVector3 const &,::btVector3 const &,short unsigned int,short unsigned int,short unsigned int,::btOverlappingPairCache *,bool ) 
void* btAxisSweep3Internal_unsignedshort__new(float* p0,float* p1,short unsigned int p2,short unsigned int p3,short unsigned int p4,void* p5,int p6) {
	::btAxisSweep3Internal< unsigned short > *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btOverlappingPairCache * tp5 = (::btOverlappingPairCache *)p5;
	mem = btAlignedAlloc(sizeof(::btAxisSweep3Internal< unsigned short >),16);
	o = new (mem)::btAxisSweep3Internal< unsigned short >(tp0,tp1,p2,p3,p4,tp5,p6);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return (void*)o;
}
void btAxisSweep3Internal_unsignedshort__free(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	delete o;
}
//method: sortMinUp void ( ::btAxisSweep3Internal<unsigned short>::* )( int,short unsigned int,::btDispatcher *,bool ) 
void btAxisSweep3Internal_unsignedshort__sortMinUp(void *c,int p0,short unsigned int p1,void* p2,int p3) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btDispatcher * tp2 = (::btDispatcher *)p2;
	o->sortMinUp(p0,p1,tp2,p3);
}
//method: allocHandle short unsigned int ( ::btAxisSweep3Internal<unsigned short>::* )(  ) 
short unsigned int btAxisSweep3Internal_unsignedshort__allocHandle(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	short unsigned int retVal = (short unsigned int)o->allocHandle();
	return retVal;
}
//method: getNumHandles short unsigned int ( ::btAxisSweep3Internal<unsigned short>::* )(  ) const
short unsigned int btAxisSweep3Internal_unsignedshort__getNumHandles(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	short unsigned int retVal = (short unsigned int)o->getNumHandles();
	return retVal;
}
//method: addHandle short unsigned int ( ::btAxisSweep3Internal<unsigned short>::* )( ::btVector3 const &,::btVector3 const &,void *,short int,short int,::btDispatcher *,void * ) 
short unsigned int btAxisSweep3Internal_unsignedshort__addHandle(void *c,float* p0,float* p1,void* p2,short int p3,short int p4,void* p5,void* p6) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	void * tp2 = (void *)p2;
	::btDispatcher * tp5 = (::btDispatcher *)p5;
	void * tp6 = (void *)p6;
	short unsigned int retVal = (short unsigned int)o->addHandle(tp0,tp1,tp2,p3,p4,tp5,tp6);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//not supported method: quantize void ( ::btAxisSweep3Internal<unsigned short>::* )( short unsigned int *,::btVector3 const &,int ) const
// error:  - unsupported, ::btVector3 const & - ok, int - ok, void - ok

//method: sortMaxUp void ( ::btAxisSweep3Internal<unsigned short>::* )( int,short unsigned int,::btDispatcher *,bool ) 
void btAxisSweep3Internal_unsignedshort__sortMaxUp(void *c,int p0,short unsigned int p1,void* p2,int p3) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btDispatcher * tp2 = (::btDispatcher *)p2;
	o->sortMaxUp(p0,p1,tp2,p3);
}
//method: removeHandle void ( ::btAxisSweep3Internal<unsigned short>::* )( short unsigned int,::btDispatcher * ) 
void btAxisSweep3Internal_unsignedshort__removeHandle(void *c,short unsigned int p0,void* p1) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->removeHandle(p0,tp1);
}
//method: getOverlappingPairUserCallback ::btOverlappingPairCallback const * ( ::btAxisSweep3Internal<unsigned short>::* )(  ) const
void* btAxisSweep3Internal_unsignedshort__getOverlappingPairUserCallback(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	void* retVal = (void*) o->getOverlappingPairUserCallback();
	return retVal;
}
//method: sortMaxDown void ( ::btAxisSweep3Internal<unsigned short>::* )( int,short unsigned int,::btDispatcher *,bool ) 
void btAxisSweep3Internal_unsignedshort__sortMaxDown(void *c,int p0,short unsigned int p1,void* p2,int p3) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btDispatcher * tp2 = (::btDispatcher *)p2;
	o->sortMaxDown(p0,p1,tp2,p3);
}
//method: rayTest void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseRayCallback &,::btVector3 const &,::btVector3 const & ) 
void btAxisSweep3Internal_unsignedshort__rayTest(void *c,float* p0,float* p1,void* p2,float* p3,float* p4) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btBroadphaseRayCallback & tp2 = *(::btBroadphaseRayCallback *)p2;
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->rayTest(tp0,tp1,tp2,tp3,tp4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: setAabb void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btBroadphaseProxy *,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btAxisSweep3Internal_unsignedshort__setAabb(void *c,void* p0,float* p1,float* p2,void* p3) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	::btDispatcher * tp3 = (::btDispatcher *)p3;
	o->setAabb(tp0,tp1,tp2,tp3);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: resetPool void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btDispatcher * ) 
void btAxisSweep3Internal_unsignedshort__resetPool(void *c,void* p0) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->resetPool(tp0);
}
//method: testAabbOverlap bool ( ::btAxisSweep3Internal<unsigned short>::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
int btAxisSweep3Internal_unsignedshort__testAabbOverlap(void *c,void* p0,void* p1) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	int retVal = (int)o->testAabbOverlap(tp0,tp1);
	return retVal;
}
//method: getAabb void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
void btAxisSweep3Internal_unsignedshort__getAabb(void *c,void* p0,float* p1,float* p2) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//not supported method: testOverlap2D bool ( ::btAxisSweep3Internal<unsigned short>::* )( ::btAxisSweep3Internal<unsigned short>::Handle const *,::btAxisSweep3Internal<unsigned short>::Handle const *,int,int ) 
// error:  - unsupported,  - unsupported, int - ok, int - ok, bool - ok

//method: updateHandle void ( ::btAxisSweep3Internal<unsigned short>::* )( short unsigned int,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btAxisSweep3Internal_unsignedshort__updateHandle(void *c,short unsigned int p0,float* p1,float* p2,void* p3) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	::btDispatcher * tp3 = (::btDispatcher *)p3;
	o->updateHandle(p0,tp1,tp2,tp3);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: freeHandle void ( ::btAxisSweep3Internal<unsigned short>::* )( short unsigned int ) 
void btAxisSweep3Internal_unsignedshort__freeHandle(void *c,short unsigned int p0) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	o->freeHandle(p0);
}
//method: printStats void ( ::btAxisSweep3Internal<unsigned short>::* )(  ) 
void btAxisSweep3Internal_unsignedshort__printStats(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	o->printStats();
}
//method: createProxy ::btBroadphaseProxy * ( ::btAxisSweep3Internal<unsigned short>::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int,::btDispatcher *,void * ) 
void* btAxisSweep3Internal_unsignedshort__createProxy(void *c,float* p0,float* p1,int p2,void* p3,short int p4,short int p5,void* p6,void* p7) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	void * tp3 = (void *)p3;
	::btDispatcher * tp6 = (::btDispatcher *)p6;
	void * tp7 = (void *)p7;
	void* retVal = (void*) o->createProxy(tp0,tp1,p2,tp3,p4,p5,tp6,tp7);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//method: setOverlappingPairUserCallback void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btOverlappingPairCallback * ) 
void btAxisSweep3Internal_unsignedshort__setOverlappingPairUserCallback(void *c,void* p0) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btOverlappingPairCallback * tp0 = (::btOverlappingPairCallback *)p0;
	o->setOverlappingPairUserCallback(tp0);
}
//method: calculateOverlappingPairs void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btDispatcher * ) 
void btAxisSweep3Internal_unsignedshort__calculateOverlappingPairs(void *c,void* p0) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->calculateOverlappingPairs(tp0);
}
//method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btAxisSweep3Internal<unsigned short>::* )(  ) 
void* btAxisSweep3Internal_unsignedshort__getOverlappingPairCache(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btAxisSweep3Internal<unsigned short>::* )(  ) 
void* btAxisSweep3Internal_unsignedshort__getOverlappingPairCache0(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: getOverlappingPairCache ::btOverlappingPairCache const * ( ::btAxisSweep3Internal<unsigned short>::* )(  ) const
void* btAxisSweep3Internal_unsignedshort__getOverlappingPairCache1(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: unQuantize void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
void btAxisSweep3Internal_unsignedshort__unQuantize(void *c,void* p0,float* p1,float* p2) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->unQuantize(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: sortMinDown void ( ::btAxisSweep3Internal<unsigned short>::* )( int,short unsigned int,::btDispatcher *,bool ) 
void btAxisSweep3Internal_unsignedshort__sortMinDown(void *c,int p0,short unsigned int p1,void* p2,int p3) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btDispatcher * tp2 = (::btDispatcher *)p2;
	o->sortMinDown(p0,p1,tp2,p3);
}
//method: aabbTest void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseAabbCallback & ) 
void btAxisSweep3Internal_unsignedshort__aabbTest(void *c,float* p0,float* p1,void* p2) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btBroadphaseAabbCallback & tp2 = *(::btBroadphaseAabbCallback *)p2;
	o->aabbTest(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getBroadphaseAabb void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btVector3 &,::btVector3 & ) const
void btAxisSweep3Internal_unsignedshort__getBroadphaseAabb(void *c,float* p0,float* p1) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getBroadphaseAabb(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: destroyProxy void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btAxisSweep3Internal_unsignedshort__destroyProxy(void *c,void* p0,void* p1) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->destroyProxy(tp0,tp1);
}
//not supported method: getHandle ::btAxisSweep3Internal<unsigned short>::Handle * ( ::btAxisSweep3Internal<unsigned short>::* )( short unsigned int ) const
// error: short unsigned int - ok,  - unsupported

//attribute: short unsigned int btAxisSweep3Internal_unsignedshort_->m_bpHandleMask
void btAxisSweep3Internal_unsignedshort__m_bpHandleMask_set(void *c,short unsigned int a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	o->m_bpHandleMask = a;
}
short unsigned int btAxisSweep3Internal_unsignedshort__m_bpHandleMask_get(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	return (short unsigned int)(o->m_bpHandleMask);
}

//attribute: short unsigned int btAxisSweep3Internal_unsignedshort_->m_handleSentinel
void btAxisSweep3Internal_unsignedshort__m_handleSentinel_set(void *c,short unsigned int a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	o->m_handleSentinel = a;
}
short unsigned int btAxisSweep3Internal_unsignedshort__m_handleSentinel_get(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	return (short unsigned int)(o->m_handleSentinel);
}

//attribute: ::btVector3 btAxisSweep3Internal_unsignedshort_->m_worldAabbMin
void btAxisSweep3Internal_unsignedshort__m_worldAabbMin_set(void *c,float* a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_worldAabbMin = ta;
}
void btAxisSweep3Internal_unsignedshort__m_worldAabbMin_get(void *c,float* a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	a[0]=(o->m_worldAabbMin).m_floats[0];a[1]=(o->m_worldAabbMin).m_floats[1];a[2]=(o->m_worldAabbMin).m_floats[2];
}

//attribute: ::btVector3 btAxisSweep3Internal_unsignedshort_->m_worldAabbMax
void btAxisSweep3Internal_unsignedshort__m_worldAabbMax_set(void *c,float* a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_worldAabbMax = ta;
}
void btAxisSweep3Internal_unsignedshort__m_worldAabbMax_get(void *c,float* a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	a[0]=(o->m_worldAabbMax).m_floats[0];a[1]=(o->m_worldAabbMax).m_floats[1];a[2]=(o->m_worldAabbMax).m_floats[2];
}

//attribute: ::btVector3 btAxisSweep3Internal_unsignedshort_->m_quantize
void btAxisSweep3Internal_unsignedshort__m_quantize_set(void *c,float* a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_quantize = ta;
}
void btAxisSweep3Internal_unsignedshort__m_quantize_get(void *c,float* a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	a[0]=(o->m_quantize).m_floats[0];a[1]=(o->m_quantize).m_floats[1];a[2]=(o->m_quantize).m_floats[2];
}

//attribute: short unsigned int btAxisSweep3Internal_unsignedshort_->m_numHandles
void btAxisSweep3Internal_unsignedshort__m_numHandles_set(void *c,short unsigned int a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	o->m_numHandles = a;
}
short unsigned int btAxisSweep3Internal_unsignedshort__m_numHandles_get(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	return (short unsigned int)(o->m_numHandles);
}

//attribute: short unsigned int btAxisSweep3Internal_unsignedshort_->m_maxHandles
void btAxisSweep3Internal_unsignedshort__m_maxHandles_set(void *c,short unsigned int a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	o->m_maxHandles = a;
}
short unsigned int btAxisSweep3Internal_unsignedshort__m_maxHandles_get(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	return (short unsigned int)(o->m_maxHandles);
}

//attribute: ::btAxisSweep3Internal<unsigned short>::Handle * btAxisSweep3Internal_unsignedshort_->m_pHandles
// attribute not supported: //attribute: ::btAxisSweep3Internal<unsigned short>::Handle * btAxisSweep3Internal_unsignedshort_->m_pHandles
//attribute: short unsigned int btAxisSweep3Internal_unsignedshort_->m_firstFreeHandle
void btAxisSweep3Internal_unsignedshort__m_firstFreeHandle_set(void *c,short unsigned int a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	o->m_firstFreeHandle = a;
}
short unsigned int btAxisSweep3Internal_unsignedshort__m_firstFreeHandle_get(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	return (short unsigned int)(o->m_firstFreeHandle);
}

//attribute: ::btAxisSweep3Internal<unsigned short>::Edge *[3] btAxisSweep3Internal_unsignedshort_->m_pEdges
// attribute not supported: //attribute: ::btAxisSweep3Internal<unsigned short>::Edge *[3] btAxisSweep3Internal_unsignedshort_->m_pEdges
//attribute: void *[3] btAxisSweep3Internal_unsignedshort_->m_pEdgesRawPtr
// attribute not supported: //attribute: void *[3] btAxisSweep3Internal_unsignedshort_->m_pEdgesRawPtr
//attribute: ::btOverlappingPairCache * btAxisSweep3Internal_unsignedshort_->m_pairCache
void btAxisSweep3Internal_unsignedshort__m_pairCache_set(void *c,void* a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btOverlappingPairCache * ta = (::btOverlappingPairCache *)a;
	o->m_pairCache = ta;
}
void* btAxisSweep3Internal_unsignedshort__m_pairCache_get(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	return (void*)(o->m_pairCache);
}

//attribute: ::btOverlappingPairCallback * btAxisSweep3Internal_unsignedshort_->m_userPairCallback
void btAxisSweep3Internal_unsignedshort__m_userPairCallback_set(void *c,void* a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btOverlappingPairCallback * ta = (::btOverlappingPairCallback *)a;
	o->m_userPairCallback = ta;
}
void* btAxisSweep3Internal_unsignedshort__m_userPairCallback_get(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	return (void*)(o->m_userPairCallback);
}

//attribute: bool btAxisSweep3Internal_unsignedshort_->m_ownsPairCache
void btAxisSweep3Internal_unsignedshort__m_ownsPairCache_set(void *c,int a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	o->m_ownsPairCache = a;
}
int btAxisSweep3Internal_unsignedshort__m_ownsPairCache_get(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	return (int)(o->m_ownsPairCache);
}

//attribute: int btAxisSweep3Internal_unsignedshort_->m_invalidPair
void btAxisSweep3Internal_unsignedshort__m_invalidPair_set(void *c,int a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	o->m_invalidPair = a;
}
int btAxisSweep3Internal_unsignedshort__m_invalidPair_get(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	return (int)(o->m_invalidPair);
}

//attribute: ::btDbvtBroadphase * btAxisSweep3Internal_unsignedshort_->m_raycastAccelerator
void btAxisSweep3Internal_unsignedshort__m_raycastAccelerator_set(void *c,void* a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btDbvtBroadphase * ta = (::btDbvtBroadphase *)a;
	o->m_raycastAccelerator = ta;
}
void* btAxisSweep3Internal_unsignedshort__m_raycastAccelerator_get(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	return (void*)(o->m_raycastAccelerator);
}

//attribute: ::btOverlappingPairCache * btAxisSweep3Internal_unsignedshort_->m_nullPairCache
void btAxisSweep3Internal_unsignedshort__m_nullPairCache_set(void *c,void* a) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	::btOverlappingPairCache * ta = (::btOverlappingPairCache *)a;
	o->m_nullPairCache = ta;
}
void* btAxisSweep3Internal_unsignedshort__m_nullPairCache_get(void *c) {
	::btAxisSweep3Internal< unsigned short > *o = (::btAxisSweep3Internal< unsigned short >*)c;
	return (void*)(o->m_nullPairCache);
}


// ::btMultiSapBroadphase::btBridgeProxy
//constructor: btBridgeProxy  ( ::btMultiSapBroadphase::btBridgeProxy::* )(  ) 
void* btMultiSapBroadphase_btBridgeProxy_new() {
	::btMultiSapBroadphase::btBridgeProxy *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btMultiSapBroadphase::btBridgeProxy),16);
	o = new (mem)::btMultiSapBroadphase::btBridgeProxy();
	return (void*)o;
}
void btMultiSapBroadphase_btBridgeProxy_free(void *c) {
	::btMultiSapBroadphase::btBridgeProxy *o = (::btMultiSapBroadphase::btBridgeProxy*)c;
	delete o;
}
//attribute: ::btBroadphaseInterface * btMultiSapBroadphase_btBridgeProxy->m_childBroadphase
void btMultiSapBroadphase_btBridgeProxy_m_childBroadphase_set(void *c,void* a) {
	::btMultiSapBroadphase::btBridgeProxy *o = (::btMultiSapBroadphase::btBridgeProxy*)c;
	::btBroadphaseInterface * ta = (::btBroadphaseInterface *)a;
	o->m_childBroadphase = ta;
}
void* btMultiSapBroadphase_btBridgeProxy_m_childBroadphase_get(void *c) {
	::btMultiSapBroadphase::btBridgeProxy *o = (::btMultiSapBroadphase::btBridgeProxy*)c;
	return (void*)(o->m_childBroadphase);
}

//attribute: ::btBroadphaseProxy * btMultiSapBroadphase_btBridgeProxy->m_childProxy
void btMultiSapBroadphase_btBridgeProxy_m_childProxy_set(void *c,void* a) {
	::btMultiSapBroadphase::btBridgeProxy *o = (::btMultiSapBroadphase::btBridgeProxy*)c;
	::btBroadphaseProxy * ta = (::btBroadphaseProxy *)a;
	o->m_childProxy = ta;
}
void* btMultiSapBroadphase_btBridgeProxy_m_childProxy_get(void *c) {
	::btMultiSapBroadphase::btBridgeProxy *o = (::btMultiSapBroadphase::btBridgeProxy*)c;
	return (void*)(o->m_childProxy);
}


// ::btBroadphaseAabbCallback
//method: process bool ( ::btBroadphaseAabbCallback::* )( ::btBroadphaseProxy const * ) 
int btBroadphaseAabbCallback_process(void *c,void* p0) {
	::btBroadphaseAabbCallback *o = (::btBroadphaseAabbCallback*)c;
	::btBroadphaseProxy const * tp0 = (::btBroadphaseProxy const *)p0;
	int retVal = (int)o->process(tp0);
	return retVal;
}

// ::btBroadphaseInterface
//method: rayTest void ( ::btBroadphaseInterface::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseRayCallback &,::btVector3 const &,::btVector3 const & ) 
void btBroadphaseInterface_rayTest(void *c,float* p0,float* p1,void* p2,float* p3,float* p4) {
	::btBroadphaseInterface *o = (::btBroadphaseInterface*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btBroadphaseRayCallback & tp2 = *(::btBroadphaseRayCallback *)p2;
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->rayTest(tp0,tp1,tp2,tp3,tp4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: setAabb void ( ::btBroadphaseInterface::* )( ::btBroadphaseProxy *,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btBroadphaseInterface_setAabb(void *c,void* p0,float* p1,float* p2,void* p3) {
	::btBroadphaseInterface *o = (::btBroadphaseInterface*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	::btDispatcher * tp3 = (::btDispatcher *)p3;
	o->setAabb(tp0,tp1,tp2,tp3);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getBroadphaseAabb void ( ::btBroadphaseInterface::* )( ::btVector3 &,::btVector3 & ) const
void btBroadphaseInterface_getBroadphaseAabb(void *c,float* p0,float* p1) {
	::btBroadphaseInterface *o = (::btBroadphaseInterface*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getBroadphaseAabb(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: resetPool void ( ::btBroadphaseInterface::* )( ::btDispatcher * ) 
void btBroadphaseInterface_resetPool(void *c,void* p0) {
	::btBroadphaseInterface *o = (::btBroadphaseInterface*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->resetPool(tp0);
}
//method: calculateOverlappingPairs void ( ::btBroadphaseInterface::* )( ::btDispatcher * ) 
void btBroadphaseInterface_calculateOverlappingPairs(void *c,void* p0) {
	::btBroadphaseInterface *o = (::btBroadphaseInterface*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->calculateOverlappingPairs(tp0);
}
//method: printStats void ( ::btBroadphaseInterface::* )(  ) 
void btBroadphaseInterface_printStats(void *c) {
	::btBroadphaseInterface *o = (::btBroadphaseInterface*)c;
	o->printStats();
}
//method: getAabb void ( ::btBroadphaseInterface::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
void btBroadphaseInterface_getAabb(void *c,void* p0,float* p1,float* p2) {
	::btBroadphaseInterface *o = (::btBroadphaseInterface*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: aabbTest void ( ::btBroadphaseInterface::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseAabbCallback & ) 
void btBroadphaseInterface_aabbTest(void *c,float* p0,float* p1,void* p2) {
	::btBroadphaseInterface *o = (::btBroadphaseInterface*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btBroadphaseAabbCallback & tp2 = *(::btBroadphaseAabbCallback *)p2;
	o->aabbTest(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: createProxy ::btBroadphaseProxy * ( ::btBroadphaseInterface::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int,::btDispatcher *,void * ) 
void* btBroadphaseInterface_createProxy(void *c,float* p0,float* p1,int p2,void* p3,short int p4,short int p5,void* p6,void* p7) {
	::btBroadphaseInterface *o = (::btBroadphaseInterface*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	void * tp3 = (void *)p3;
	::btDispatcher * tp6 = (::btDispatcher *)p6;
	void * tp7 = (void *)p7;
	void* retVal = (void*) o->createProxy(tp0,tp1,p2,tp3,p4,p5,tp6,tp7);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btBroadphaseInterface::* )(  ) 
void* btBroadphaseInterface_getOverlappingPairCache(void *c) {
	::btBroadphaseInterface *o = (::btBroadphaseInterface*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btBroadphaseInterface::* )(  ) 
void* btBroadphaseInterface_getOverlappingPairCache0(void *c) {
	::btBroadphaseInterface *o = (::btBroadphaseInterface*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: getOverlappingPairCache ::btOverlappingPairCache const * ( ::btBroadphaseInterface::* )(  ) const
void* btBroadphaseInterface_getOverlappingPairCache1(void *c) {
	::btBroadphaseInterface *o = (::btBroadphaseInterface*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: destroyProxy void ( ::btBroadphaseInterface::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btBroadphaseInterface_destroyProxy(void *c,void* p0,void* p1) {
	::btBroadphaseInterface *o = (::btBroadphaseInterface*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->destroyProxy(tp0,tp1);
}

// ::btBroadphasePair
//constructor: btBroadphasePair  ( ::btBroadphasePair::* )(  ) 
void* btBroadphasePair_new0() {
	::btBroadphasePair *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btBroadphasePair),16);
	o = new (mem)::btBroadphasePair();
	return (void*)o;
}
//constructor: btBroadphasePair  ( ::btBroadphasePair::* )( ::btBroadphaseProxy &,::btBroadphaseProxy & ) 
void* btBroadphasePair_new1(void* p0,void* p1) {
	::btBroadphasePair *o = 0;
	 void *mem = 0;
	::btBroadphaseProxy & tp0 = *(::btBroadphaseProxy *)p0;
	::btBroadphaseProxy & tp1 = *(::btBroadphaseProxy *)p1;
	mem = btAlignedAlloc(sizeof(::btBroadphasePair),16);
	o = new (mem)::btBroadphasePair(tp0,tp1);
	return (void*)o;
}
void btBroadphasePair_free(void *c) {
	::btBroadphasePair *o = (::btBroadphasePair*)c;
	delete o;
}
//attribute: ::btBroadphasePair btBroadphasePair->
// attribute not supported: //attribute: ::btBroadphasePair btBroadphasePair->
//attribute: ::btCollisionAlgorithm * btBroadphasePair->m_algorithm
void btBroadphasePair_m_algorithm_set(void *c,void* a) {
	::btBroadphasePair *o = (::btBroadphasePair*)c;
	::btCollisionAlgorithm * ta = (::btCollisionAlgorithm *)a;
	o->m_algorithm = ta;
}
void* btBroadphasePair_m_algorithm_get(void *c) {
	::btBroadphasePair *o = (::btBroadphasePair*)c;
	return (void*)(o->m_algorithm);
}

//attribute: ::btBroadphaseProxy * btBroadphasePair->m_pProxy0
void btBroadphasePair_m_pProxy0_set(void *c,void* a) {
	::btBroadphasePair *o = (::btBroadphasePair*)c;
	::btBroadphaseProxy * ta = (::btBroadphaseProxy *)a;
	o->m_pProxy0 = ta;
}
void* btBroadphasePair_m_pProxy0_get(void *c) {
	::btBroadphasePair *o = (::btBroadphasePair*)c;
	return (void*)(o->m_pProxy0);
}

//attribute: ::btBroadphaseProxy * btBroadphasePair->m_pProxy1
void btBroadphasePair_m_pProxy1_set(void *c,void* a) {
	::btBroadphasePair *o = (::btBroadphasePair*)c;
	::btBroadphaseProxy * ta = (::btBroadphaseProxy *)a;
	o->m_pProxy1 = ta;
}
void* btBroadphasePair_m_pProxy1_get(void *c) {
	::btBroadphasePair *o = (::btBroadphasePair*)c;
	return (void*)(o->m_pProxy1);
}


// ::btBroadphasePairSortPredicate
//constructor: btBroadphasePairSortPredicate  ( ::btBroadphasePairSortPredicate::* )(  ) 
void* btBroadphasePairSortPredicate_new() {
	::btBroadphasePairSortPredicate *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btBroadphasePairSortPredicate),16);
	o = new (mem)::btBroadphasePairSortPredicate();
	return (void*)o;
}
void btBroadphasePairSortPredicate_free(void *c) {
	::btBroadphasePairSortPredicate *o = (::btBroadphasePairSortPredicate*)c;
	delete o;
}

// ::btBroadphaseProxy
//constructor: btBroadphaseProxy  ( ::btBroadphaseProxy::* )(  ) 
void* btBroadphaseProxy_new0() {
	::btBroadphaseProxy *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btBroadphaseProxy),16);
	o = new (mem)::btBroadphaseProxy();
	return (void*)o;
}
//constructor: btBroadphaseProxy  ( ::btBroadphaseProxy::* )( ::btVector3 const &,::btVector3 const &,void *,short int,short int,void * ) 
void* btBroadphaseProxy_new1(float* p0,float* p1,void* p2,short int p3,short int p4,void* p5) {
	::btBroadphaseProxy *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	void * tp2 = (void *)p2;
	void * tp5 = (void *)p5;
	mem = btAlignedAlloc(sizeof(::btBroadphaseProxy),16);
	o = new (mem)::btBroadphaseProxy(tp0,tp1,tp2,p3,p4,tp5);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return (void*)o;
}
void btBroadphaseProxy_free(void *c) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	delete o;
}
//method: isConvex bool (*)( int )
int btBroadphaseProxy_isConvex(int p0) {
	int retVal = (int)::btBroadphaseProxy::isConvex(p0);
	return retVal;
}
//method: isInfinite bool (*)( int )
int btBroadphaseProxy_isInfinite(int p0) {
	int retVal = (int)::btBroadphaseProxy::isInfinite(p0);
	return retVal;
}
//method: getUid int ( ::btBroadphaseProxy::* )(  ) const
int btBroadphaseProxy_getUid(void *c) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	int retVal = (int)o->getUid();
	return retVal;
}
//method: isConcave bool (*)( int )
int btBroadphaseProxy_isConcave(int p0) {
	int retVal = (int)::btBroadphaseProxy::isConcave(p0);
	return retVal;
}
//method: isNonMoving bool (*)( int )
int btBroadphaseProxy_isNonMoving(int p0) {
	int retVal = (int)::btBroadphaseProxy::isNonMoving(p0);
	return retVal;
}
//method: isCompound bool (*)( int )
int btBroadphaseProxy_isCompound(int p0) {
	int retVal = (int)::btBroadphaseProxy::isCompound(p0);
	return retVal;
}
//method: isPolyhedral bool (*)( int )
int btBroadphaseProxy_isPolyhedral(int p0) {
	int retVal = (int)::btBroadphaseProxy::isPolyhedral(p0);
	return retVal;
}
//method: isConvex2d bool (*)( int )
int btBroadphaseProxy_isConvex2d(int p0) {
	int retVal = (int)::btBroadphaseProxy::isConvex2d(p0);
	return retVal;
}
//method: isSoftBody bool (*)( int )
int btBroadphaseProxy_isSoftBody(int p0) {
	int retVal = (int)::btBroadphaseProxy::isSoftBody(p0);
	return retVal;
}
//attribute: ::btVector3 btBroadphaseProxy->m_aabbMax
void btBroadphaseProxy_m_aabbMax_set(void *c,float* a) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_aabbMax = ta;
}
void btBroadphaseProxy_m_aabbMax_get(void *c,float* a) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	a[0]=(o->m_aabbMax).m_floats[0];a[1]=(o->m_aabbMax).m_floats[1];a[2]=(o->m_aabbMax).m_floats[2];
}

//attribute: ::btVector3 btBroadphaseProxy->m_aabbMin
void btBroadphaseProxy_m_aabbMin_set(void *c,float* a) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_aabbMin = ta;
}
void btBroadphaseProxy_m_aabbMin_get(void *c,float* a) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	a[0]=(o->m_aabbMin).m_floats[0];a[1]=(o->m_aabbMin).m_floats[1];a[2]=(o->m_aabbMin).m_floats[2];
}

//attribute: void * btBroadphaseProxy->m_clientObject
void btBroadphaseProxy_m_clientObject_set(void *c,void* a) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	void * ta = (void *)a;
	o->m_clientObject = ta;
}
void* btBroadphaseProxy_m_clientObject_get(void *c) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	return (void*)(o->m_clientObject);
}

//attribute: short int btBroadphaseProxy->m_collisionFilterGroup
void btBroadphaseProxy_m_collisionFilterGroup_set(void *c,short int a) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	o->m_collisionFilterGroup = a;
}
short int btBroadphaseProxy_m_collisionFilterGroup_get(void *c) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	return (short int)(o->m_collisionFilterGroup);
}

//attribute: short int btBroadphaseProxy->m_collisionFilterMask
void btBroadphaseProxy_m_collisionFilterMask_set(void *c,short int a) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	o->m_collisionFilterMask = a;
}
short int btBroadphaseProxy_m_collisionFilterMask_get(void *c) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	return (short int)(o->m_collisionFilterMask);
}

//attribute: void * btBroadphaseProxy->m_multiSapParentProxy
void btBroadphaseProxy_m_multiSapParentProxy_set(void *c,void* a) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	void * ta = (void *)a;
	o->m_multiSapParentProxy = ta;
}
void* btBroadphaseProxy_m_multiSapParentProxy_get(void *c) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	return (void*)(o->m_multiSapParentProxy);
}

//attribute: int btBroadphaseProxy->m_uniqueId
void btBroadphaseProxy_m_uniqueId_set(void *c,int a) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	o->m_uniqueId = a;
}
int btBroadphaseProxy_m_uniqueId_get(void *c) {
	::btBroadphaseProxy *o = (::btBroadphaseProxy*)c;
	return (int)(o->m_uniqueId);
}


// ::btBroadphaseRayCallback
//attribute: ::btScalar btBroadphaseRayCallback->m_lambda_max
void btBroadphaseRayCallback_m_lambda_max_set(void *c,float a) {
	::btBroadphaseRayCallback *o = (::btBroadphaseRayCallback*)c;
	o->m_lambda_max = a;
}
float btBroadphaseRayCallback_m_lambda_max_get(void *c) {
	::btBroadphaseRayCallback *o = (::btBroadphaseRayCallback*)c;
	return (float)(o->m_lambda_max);
}

//attribute: ::btVector3 btBroadphaseRayCallback->m_rayDirectionInverse
void btBroadphaseRayCallback_m_rayDirectionInverse_set(void *c,float* a) {
	::btBroadphaseRayCallback *o = (::btBroadphaseRayCallback*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_rayDirectionInverse = ta;
}
void btBroadphaseRayCallback_m_rayDirectionInverse_get(void *c,float* a) {
	::btBroadphaseRayCallback *o = (::btBroadphaseRayCallback*)c;
	a[0]=(o->m_rayDirectionInverse).m_floats[0];a[1]=(o->m_rayDirectionInverse).m_floats[1];a[2]=(o->m_rayDirectionInverse).m_floats[2];
}

//attribute: unsigned int[3] btBroadphaseRayCallback->m_signs
// attribute not supported: //attribute: unsigned int[3] btBroadphaseRayCallback->m_signs

// ::btBvhSubtreeInfo
//constructor: btBvhSubtreeInfo  ( ::btBvhSubtreeInfo::* )(  ) 
void* btBvhSubtreeInfo_new() {
	::btBvhSubtreeInfo *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btBvhSubtreeInfo),16);
	o = new (mem)::btBvhSubtreeInfo();
	return (void*)o;
}
void btBvhSubtreeInfo_free(void *c) {
	::btBvhSubtreeInfo *o = (::btBvhSubtreeInfo*)c;
	delete o;
}
//method: setAabbFromQuantizeNode void ( ::btBvhSubtreeInfo::* )( ::btQuantizedBvhNode const & ) 
void btBvhSubtreeInfo_setAabbFromQuantizeNode(void *c,void* p0) {
	::btBvhSubtreeInfo *o = (::btBvhSubtreeInfo*)c;
	::btQuantizedBvhNode const & tp0 = *(::btQuantizedBvhNode const *)p0;
	o->setAabbFromQuantizeNode(tp0);
}
//attribute: int[3] btBvhSubtreeInfo->m_padding
// attribute not supported: //attribute: int[3] btBvhSubtreeInfo->m_padding
//attribute: short unsigned int[3] btBvhSubtreeInfo->m_quantizedAabbMax
// attribute not supported: //attribute: short unsigned int[3] btBvhSubtreeInfo->m_quantizedAabbMax
//attribute: short unsigned int[3] btBvhSubtreeInfo->m_quantizedAabbMin
// attribute not supported: //attribute: short unsigned int[3] btBvhSubtreeInfo->m_quantizedAabbMin
//attribute: int btBvhSubtreeInfo->m_rootNodeIndex
void btBvhSubtreeInfo_m_rootNodeIndex_set(void *c,int a) {
	::btBvhSubtreeInfo *o = (::btBvhSubtreeInfo*)c;
	o->m_rootNodeIndex = a;
}
int btBvhSubtreeInfo_m_rootNodeIndex_get(void *c) {
	::btBvhSubtreeInfo *o = (::btBvhSubtreeInfo*)c;
	return (int)(o->m_rootNodeIndex);
}

//attribute: int btBvhSubtreeInfo->m_subtreeSize
void btBvhSubtreeInfo_m_subtreeSize_set(void *c,int a) {
	::btBvhSubtreeInfo *o = (::btBvhSubtreeInfo*)c;
	o->m_subtreeSize = a;
}
int btBvhSubtreeInfo_m_subtreeSize_get(void *c) {
	::btBvhSubtreeInfo *o = (::btBvhSubtreeInfo*)c;
	return (int)(o->m_subtreeSize);
}


// ::btBvhSubtreeInfoData
//constructor: btBvhSubtreeInfoData  ( ::btBvhSubtreeInfoData::* )(  ) 
void* btBvhSubtreeInfoData_new() {
	::btBvhSubtreeInfoData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btBvhSubtreeInfoData),16);
	o = new (mem)::btBvhSubtreeInfoData();
	return (void*)o;
}
void btBvhSubtreeInfoData_free(void *c) {
	::btBvhSubtreeInfoData *o = (::btBvhSubtreeInfoData*)c;
	delete o;
}
//attribute: int btBvhSubtreeInfoData->m_rootNodeIndex
void btBvhSubtreeInfoData_m_rootNodeIndex_set(void *c,int a) {
	::btBvhSubtreeInfoData *o = (::btBvhSubtreeInfoData*)c;
	o->m_rootNodeIndex = a;
}
int btBvhSubtreeInfoData_m_rootNodeIndex_get(void *c) {
	::btBvhSubtreeInfoData *o = (::btBvhSubtreeInfoData*)c;
	return (int)(o->m_rootNodeIndex);
}

//attribute: int btBvhSubtreeInfoData->m_subtreeSize
void btBvhSubtreeInfoData_m_subtreeSize_set(void *c,int a) {
	::btBvhSubtreeInfoData *o = (::btBvhSubtreeInfoData*)c;
	o->m_subtreeSize = a;
}
int btBvhSubtreeInfoData_m_subtreeSize_get(void *c) {
	::btBvhSubtreeInfoData *o = (::btBvhSubtreeInfoData*)c;
	return (int)(o->m_subtreeSize);
}

//attribute: short unsigned int[3] btBvhSubtreeInfoData->m_quantizedAabbMin
// attribute not supported: //attribute: short unsigned int[3] btBvhSubtreeInfoData->m_quantizedAabbMin
//attribute: short unsigned int[3] btBvhSubtreeInfoData->m_quantizedAabbMax
// attribute not supported: //attribute: short unsigned int[3] btBvhSubtreeInfoData->m_quantizedAabbMax

// ::btCollisionAlgorithm
//method: getAllContactManifolds void ( ::btCollisionAlgorithm::* )( ::btManifoldArray & ) 
void btCollisionAlgorithm_getAllContactManifolds(void *c,void* p0) {
	::btCollisionAlgorithm *o = (::btCollisionAlgorithm*)c;
	::btManifoldArray & tp0 = *(::btAlignedObjectArray<btPersistentManifold*> *)p0;
	o->getAllContactManifolds(tp0);
}
//method: calculateTimeOfImpact ::btScalar ( ::btCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
float btCollisionAlgorithm_calculateTimeOfImpact(void *c,void* p0,void* p1,void* p2,void* p3) {
	::btCollisionAlgorithm *o = (::btCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btDispatcherInfo const & tp2 = *(::btDispatcherInfo const *)p2;
	::btManifoldResult * tp3 = (::btManifoldResult *)p3;
	float retVal = (float)o->calculateTimeOfImpact(tp0,tp1,tp2,tp3);
	return retVal;
}
//method: processCollision void ( ::btCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
void btCollisionAlgorithm_processCollision(void *c,void* p0,void* p1,void* p2,void* p3) {
	::btCollisionAlgorithm *o = (::btCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btDispatcherInfo const & tp2 = *(::btDispatcherInfo const *)p2;
	::btManifoldResult * tp3 = (::btManifoldResult *)p3;
	o->processCollision(tp0,tp1,tp2,tp3);
}
//attribute: ::btDispatcher * btCollisionAlgorithm->m_dispatcher
void btCollisionAlgorithm_m_dispatcher_set(void *c,void* a) {
	::btCollisionAlgorithm *o = (::btCollisionAlgorithm*)c;
	::btDispatcher * ta = (::btDispatcher *)a;
	o->m_dispatcher = ta;
}
void* btCollisionAlgorithm_m_dispatcher_get(void *c) {
	::btCollisionAlgorithm *o = (::btCollisionAlgorithm*)c;
	return (void*)(o->m_dispatcher);
}


// ::btCollisionAlgorithmConstructionInfo
//constructor: btCollisionAlgorithmConstructionInfo  ( ::btCollisionAlgorithmConstructionInfo::* )(  ) 
void* btCollisionAlgorithmConstructionInfo_new0() {
	::btCollisionAlgorithmConstructionInfo *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCollisionAlgorithmConstructionInfo),16);
	o = new (mem)::btCollisionAlgorithmConstructionInfo();
	return (void*)o;
}
//constructor: btCollisionAlgorithmConstructionInfo  ( ::btCollisionAlgorithmConstructionInfo::* )( ::btDispatcher *,int ) 
void* btCollisionAlgorithmConstructionInfo_new1(void* p0,int p1) {
	::btCollisionAlgorithmConstructionInfo *o = 0;
	 void *mem = 0;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	mem = btAlignedAlloc(sizeof(::btCollisionAlgorithmConstructionInfo),16);
	o = new (mem)::btCollisionAlgorithmConstructionInfo(tp0,p1);
	return (void*)o;
}
void btCollisionAlgorithmConstructionInfo_free(void *c) {
	::btCollisionAlgorithmConstructionInfo *o = (::btCollisionAlgorithmConstructionInfo*)c;
	delete o;
}
//attribute: ::btDispatcher * btCollisionAlgorithmConstructionInfo->m_dispatcher1
void btCollisionAlgorithmConstructionInfo_m_dispatcher1_set(void *c,void* a) {
	::btCollisionAlgorithmConstructionInfo *o = (::btCollisionAlgorithmConstructionInfo*)c;
	::btDispatcher * ta = (::btDispatcher *)a;
	o->m_dispatcher1 = ta;
}
void* btCollisionAlgorithmConstructionInfo_m_dispatcher1_get(void *c) {
	::btCollisionAlgorithmConstructionInfo *o = (::btCollisionAlgorithmConstructionInfo*)c;
	return (void*)(o->m_dispatcher1);
}

//attribute: ::btPersistentManifold * btCollisionAlgorithmConstructionInfo->m_manifold
void btCollisionAlgorithmConstructionInfo_m_manifold_set(void *c,void* a) {
	::btCollisionAlgorithmConstructionInfo *o = (::btCollisionAlgorithmConstructionInfo*)c;
	::btPersistentManifold * ta = (::btPersistentManifold *)a;
	o->m_manifold = ta;
}
void* btCollisionAlgorithmConstructionInfo_m_manifold_get(void *c) {
	::btCollisionAlgorithmConstructionInfo *o = (::btCollisionAlgorithmConstructionInfo*)c;
	return (void*)(o->m_manifold);
}


// ::btDbvt
//constructor: btDbvt  ( ::btDbvt::* )(  ) 
void* btDbvt_new() {
	::btDbvt *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btDbvt),16);
	o = new (mem)::btDbvt();
	return (void*)o;
}
void btDbvt_free(void *c) {
	::btDbvt *o = (::btDbvt*)c;
	delete o;
}
//not supported method: nearest int (*)( int const *,::btDbvt::sStkNPS const *,::btScalar,int,int )
// error:  - unsupported, ::btDbvt::sStkNPS const * - ok, ::btScalar - ok, int - ok, int - ok, int - ok

//method: enumLeaves void (*)( ::btDbvtNode const *,::btDbvt::ICollide & )
void btDbvt_enumLeaves(void* p0,void* p1) {
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	::btDbvt::ICollide & tp1 = *(::btDbvt::ICollide *)p1;
	::btDbvt::enumLeaves(tp0,tp1);
}
//method: optimizeIncremental void ( ::btDbvt::* )( int ) 
void btDbvt_optimizeIncremental(void *c,int p0) {
	::btDbvt *o = (::btDbvt*)c;
	o->optimizeIncremental(p0);
}
//method: rayTest void (*)( ::btDbvtNode const *,::btVector3 const &,::btVector3 const &,::btDbvt::ICollide & )
void btDbvt_rayTest(void* p0,float* p1,float* p2,void* p3) {
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	::btDbvt::ICollide & tp3 = *(::btDbvt::ICollide *)p3;
	::btDbvt::rayTest(tp0,tp1,tp2,tp3);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: optimizeTopDown void ( ::btDbvt::* )( int ) 
void btDbvt_optimizeTopDown(void *c,int p0) {
	::btDbvt *o = (::btDbvt*)c;
	o->optimizeTopDown(p0);
}
//method: enumNodes void (*)( ::btDbvtNode const *,::btDbvt::ICollide & )
void btDbvt_enumNodes(void* p0,void* p1) {
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	::btDbvt::ICollide & tp1 = *(::btDbvt::ICollide *)p1;
	::btDbvt::enumNodes(tp0,tp1);
}
//method: write void ( ::btDbvt::* )( ::btDbvt::IWriter * ) const
void btDbvt_write(void *c,void* p0) {
	::btDbvt *o = (::btDbvt*)c;
	::btDbvt::IWriter * tp0 = (::btDbvt::IWriter *)p0;
	o->write(tp0);
}
//method: allocate int (*)( ::btAlignedObjectArray<int> &,::btAlignedObjectArray<btDbvt::sStkNPS> &,::btDbvt::sStkNPS const & )
int btDbvt_allocate(void* p0,void* p1,void* p2) {
	::btAlignedObjectArray<int> & tp0 = *(::btAlignedObjectArray<int> *)p0;
	::btAlignedObjectArray<btDbvt::sStkNPS> & tp1 = *(::btAlignedObjectArray<btDbvt::sStkNPS> *)p1;
	::btDbvt::sStkNPS const & tp2 = *(::btDbvt::sStkNPS const *)p2;
	int retVal = (int)::btDbvt::allocate(tp0,tp1,tp2);
	return retVal;
}
//method: empty bool ( ::btDbvt::* )(  ) const
int btDbvt_empty(void *c) {
	::btDbvt *o = (::btDbvt*)c;
	int retVal = (int)o->empty();
	return retVal;
}
//method: collideTV void ( ::btDbvt::* )( ::btDbvtNode const *,::btDbvtVolume const &,::btDbvt::ICollide & ) 
void btDbvt_collideTV(void *c,void* p0,void* p1,void* p2) {
	::btDbvt *o = (::btDbvt*)c;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	::btDbvtVolume const & tp1 = *(::btDbvtAabbMm const *)p1;
	::btDbvt::ICollide & tp2 = *(::btDbvt::ICollide *)p2;
	o->collideTV(tp0,tp1,tp2);
}
//method: collideTU void (*)( ::btDbvtNode const *,::btDbvt::ICollide & )
void btDbvt_collideTU(void* p0,void* p1) {
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	::btDbvt::ICollide & tp1 = *(::btDbvt::ICollide *)p1;
	::btDbvt::collideTU(tp0,tp1);
}
//method: collideTT void ( ::btDbvt::* )( ::btDbvtNode const *,::btDbvtNode const *,::btDbvt::ICollide & ) 
void btDbvt_collideTT(void *c,void* p0,void* p1,void* p2) {
	::btDbvt *o = (::btDbvt*)c;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	::btDbvtNode const * tp1 = (::btDbvtNode const *)p1;
	::btDbvt::ICollide & tp2 = *(::btDbvt::ICollide *)p2;
	o->collideTT(tp0,tp1,tp2);
}
//method: collideTTpersistentStack void ( ::btDbvt::* )( ::btDbvtNode const *,::btDbvtNode const *,::btDbvt::ICollide & ) 
void btDbvt_collideTTpersistentStack(void *c,void* p0,void* p1,void* p2) {
	::btDbvt *o = (::btDbvt*)c;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	::btDbvtNode const * tp1 = (::btDbvtNode const *)p1;
	::btDbvt::ICollide & tp2 = *(::btDbvt::ICollide *)p2;
	o->collideTTpersistentStack(tp0,tp1,tp2);
}
//method: clone void ( ::btDbvt::* )( ::btDbvt &,::btDbvt::IClone * ) const
void btDbvt_clone(void *c,void* p0,void* p1) {
	::btDbvt *o = (::btDbvt*)c;
	::btDbvt & tp0 = *(::btDbvt *)p0;
	::btDbvt::IClone * tp1 = (::btDbvt::IClone *)p1;
	o->clone(tp0,tp1);
}
//method: benchmark void (*)(  )
void btDbvt_benchmark() {
	::btDbvt::benchmark();
}
//method: update void ( ::btDbvt::* )( ::btDbvtNode *,int ) 
void btDbvt_update(void *c,void* p0,int p1) {
	::btDbvt *o = (::btDbvt*)c;
	::btDbvtNode * tp0 = (::btDbvtNode *)p0;
	o->update(tp0,p1);
}
//method: update void ( ::btDbvt::* )( ::btDbvtNode *,int ) 
void btDbvt_update0(void *c,void* p0,int p1) {
	::btDbvt *o = (::btDbvt*)c;
	::btDbvtNode * tp0 = (::btDbvtNode *)p0;
	o->update(tp0,p1);
}
//method: update void ( ::btDbvt::* )( ::btDbvtNode *,::btDbvtVolume & ) 
void btDbvt_update1(void *c,void* p0,void* p1) {
	::btDbvt *o = (::btDbvt*)c;
	::btDbvtNode * tp0 = (::btDbvtNode *)p0;
	::btDbvtVolume & tp1 = *(::btDbvtAabbMm *)p1;
	o->update(tp0,tp1);
}
//method: update bool ( ::btDbvt::* )( ::btDbvtNode *,::btDbvtVolume &,::btVector3 const &,::btScalar ) 
int btDbvt_update2(void *c,void* p0,void* p1,float* p2,float p3) {
	::btDbvt *o = (::btDbvt*)c;
	::btDbvtNode * tp0 = (::btDbvtNode *)p0;
	::btDbvtVolume & tp1 = *(::btDbvtAabbMm *)p1;
	btVector3 tp2(p2[0],p2[1],p2[2]);
	int retVal = (int)o->update(tp0,tp1,tp2,p3);
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	return retVal;
}
//method: update bool ( ::btDbvt::* )( ::btDbvtNode *,::btDbvtVolume &,::btVector3 const & ) 
int btDbvt_update3(void *c,void* p0,void* p1,float* p2) {
	::btDbvt *o = (::btDbvt*)c;
	::btDbvtNode * tp0 = (::btDbvtNode *)p0;
	::btDbvtVolume & tp1 = *(::btDbvtAabbMm *)p1;
	btVector3 tp2(p2[0],p2[1],p2[2]);
	int retVal = (int)o->update(tp0,tp1,tp2);
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	return retVal;
}
//method: update bool ( ::btDbvt::* )( ::btDbvtNode *,::btDbvtVolume &,::btScalar ) 
int btDbvt_update4(void *c,void* p0,void* p1,float p2) {
	::btDbvt *o = (::btDbvt*)c;
	::btDbvtNode * tp0 = (::btDbvtNode *)p0;
	::btDbvtVolume & tp1 = *(::btDbvtAabbMm *)p1;
	int retVal = (int)o->update(tp0,tp1,p2);
	return retVal;
}
//method: countLeaves int (*)( ::btDbvtNode const * )
int btDbvt_countLeaves(void* p0) {
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	int retVal = (int)::btDbvt::countLeaves(tp0);
	return retVal;
}
//not supported method: collideOCL void (*)( ::btDbvtNode const *,::btVector3 const *,::btScalar const *,::btVector3 const &,int,::btDbvt::ICollide &,bool )
// error: ::btDbvtNode const * - ok,  - unsupported,  - unsupported, ::btVector3 const & - ok, int - ok, ::btDbvt::ICollide & - ok, bool - ok, void - ok

//method: insert ::btDbvtNode * ( ::btDbvt::* )( ::btDbvtVolume const &,void * ) 
void* btDbvt_insert(void *c,void* p0,void* p1) {
	::btDbvt *o = (::btDbvt*)c;
	::btDbvtVolume const & tp0 = *(::btDbvtAabbMm const *)p0;
	void * tp1 = (void *)p1;
	void* retVal = (void*) o->insert(tp0,tp1);
	return retVal;
}
//not supported method: collideKDOP void (*)( ::btDbvtNode const *,::btVector3 const *,::btScalar const *,int,::btDbvt::ICollide & )
// error: ::btDbvtNode const * - ok,  - unsupported,  - unsupported, int - ok, ::btDbvt::ICollide & - ok, void - ok

//method: extractLeaves void (*)( ::btDbvtNode const *,::btAlignedObjectArray<btDbvtNode const*> & )
void btDbvt_extractLeaves(void* p0,void* p1) {
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	::btAlignedObjectArray<btDbvtNode const*> & tp1 = *(::btAlignedObjectArray<btDbvtNode const*> *)p1;
	::btDbvt::extractLeaves(tp0,tp1);
}
//method: remove void ( ::btDbvt::* )( ::btDbvtNode * ) 
void btDbvt_remove(void *c,void* p0) {
	::btDbvt *o = (::btDbvt*)c;
	::btDbvtNode * tp0 = (::btDbvtNode *)p0;
	o->remove(tp0);
}
//not supported method: rayTestInternal void ( ::btDbvt::* )( ::btDbvtNode const *,::btVector3 const &,::btVector3 const &,::btVector3 const &,unsigned int *,::btScalar,::btVector3 const &,::btVector3 const &,::btDbvt::ICollide & ) const
// error: ::btDbvtNode const * - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported, ::btScalar - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btDbvt::ICollide & - ok, void - ok

//method: maxdepth int (*)( ::btDbvtNode const * )
int btDbvt_maxdepth(void* p0) {
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	int retVal = (int)::btDbvt::maxdepth(tp0);
	return retVal;
}
//method: clear void ( ::btDbvt::* )(  ) 
void btDbvt_clear(void *c) {
	::btDbvt *o = (::btDbvt*)c;
	o->clear();
}
//method: optimizeBottomUp void ( ::btDbvt::* )(  ) 
void btDbvt_optimizeBottomUp(void *c) {
	::btDbvt *o = (::btDbvt*)c;
	o->optimizeBottomUp();
}
//attribute: ::btDbvtNode * btDbvt->m_free
void btDbvt_m_free_set(void *c,void* a) {
	::btDbvt *o = (::btDbvt*)c;
	::btDbvtNode * ta = (::btDbvtNode *)a;
	o->m_free = ta;
}
void* btDbvt_m_free_get(void *c) {
	::btDbvt *o = (::btDbvt*)c;
	return (void*)(o->m_free);
}

//attribute: int btDbvt->m_leaves
void btDbvt_m_leaves_set(void *c,int a) {
	::btDbvt *o = (::btDbvt*)c;
	o->m_leaves = a;
}
int btDbvt_m_leaves_get(void *c) {
	::btDbvt *o = (::btDbvt*)c;
	return (int)(o->m_leaves);
}

//attribute: int btDbvt->m_lkhd
void btDbvt_m_lkhd_set(void *c,int a) {
	::btDbvt *o = (::btDbvt*)c;
	o->m_lkhd = a;
}
int btDbvt_m_lkhd_get(void *c) {
	::btDbvt *o = (::btDbvt*)c;
	return (int)(o->m_lkhd);
}

//attribute: unsigned int btDbvt->m_opath
void btDbvt_m_opath_set(void *c,unsigned int a) {
	::btDbvt *o = (::btDbvt*)c;
	o->m_opath = a;
}
unsigned int btDbvt_m_opath_get(void *c) {
	::btDbvt *o = (::btDbvt*)c;
	return (unsigned int)(o->m_opath);
}

//attribute: ::btDbvtNode * btDbvt->m_root
void btDbvt_m_root_set(void *c,void* a) {
	::btDbvt *o = (::btDbvt*)c;
	::btDbvtNode * ta = (::btDbvtNode *)a;
	o->m_root = ta;
}
void* btDbvt_m_root_get(void *c) {
	::btDbvt *o = (::btDbvt*)c;
	return (void*)(o->m_root);
}

//attribute: ::btAlignedObjectArray<btDbvt::sStkNN> btDbvt->m_stkStack
void btDbvt_m_stkStack_set(void *c,void* a) {
	::btDbvt *o = (::btDbvt*)c;
	::btAlignedObjectArray<btDbvt::sStkNN> & ta = *(::btAlignedObjectArray<btDbvt::sStkNN> *)a;
	o->m_stkStack = ta;
}
void* btDbvt_m_stkStack_get(void *c) {
	::btDbvt *o = (::btDbvt*)c;
	return (void*)&(o->m_stkStack);
}


// ::btDbvtAabbMm
//constructor: btDbvtAabbMm  ( ::btDbvtAabbMm::* )(  ) 
void* btDbvtAabbMm_new() {
	::btDbvtAabbMm *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btDbvtAabbMm),16);
	o = new (mem)::btDbvtAabbMm();
	return (void*)o;
}
void btDbvtAabbMm_free(void *c) {
	::btDbvtAabbMm *o = (::btDbvtAabbMm*)c;
	delete o;
}
//method: SignedExpand void ( ::btDbvtAabbMm::* )( ::btVector3 const & ) 
void btDbvtAabbMm_SignedExpand(void *c,float* p0) {
	::btDbvtAabbMm *o = (::btDbvtAabbMm*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->SignedExpand(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: Extents ::btVector3 ( ::btDbvtAabbMm::* )(  ) const
void btDbvtAabbMm_Extents(void *c,float* ret) {
	::btDbvtAabbMm *o = (::btDbvtAabbMm*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->Extents();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: Center ::btVector3 ( ::btDbvtAabbMm::* )(  ) const
void btDbvtAabbMm_Center(void *c,float* ret) {
	::btDbvtAabbMm *o = (::btDbvtAabbMm*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->Center();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: Lengths ::btVector3 ( ::btDbvtAabbMm::* )(  ) const
void btDbvtAabbMm_Lengths(void *c,float* ret) {
	::btDbvtAabbMm *o = (::btDbvtAabbMm*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->Lengths();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: Maxs ::btVector3 const & ( ::btDbvtAabbMm::* )(  ) const
void btDbvtAabbMm_Maxs(void *c,float* ret) {
	::btDbvtAabbMm *o = (::btDbvtAabbMm*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->Maxs();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//not supported method: FromCE ::btDbvtAabbMm (*)( ::btVector3 const &,::btVector3 const & )
// error: ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported

//not supported method: FromMM ::btDbvtAabbMm (*)( ::btVector3 const &,::btVector3 const & )
// error: ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported

//method: ProjectMinimum ::btScalar ( ::btDbvtAabbMm::* )( ::btVector3 const &,unsigned int ) const
float btDbvtAabbMm_ProjectMinimum(void *c,float* p0,unsigned int p1) {
	::btDbvtAabbMm *o = (::btDbvtAabbMm*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	float retVal = (float)o->ProjectMinimum(tp0,p1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return retVal;
}
//method: Classify int ( ::btDbvtAabbMm::* )( ::btVector3 const &,::btScalar,int ) const
int btDbvtAabbMm_Classify(void *c,float* p0,float p1,int p2) {
	::btDbvtAabbMm *o = (::btDbvtAabbMm*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	int retVal = (int)o->Classify(tp0,p1,p2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return retVal;
}
//method: Contain bool ( ::btDbvtAabbMm::* )( ::btDbvtAabbMm const & ) const
int btDbvtAabbMm_Contain(void *c,void* p0) {
	::btDbvtAabbMm *o = (::btDbvtAabbMm*)c;
	::btDbvtAabbMm const & tp0 = *(::btDbvtAabbMm const *)p0;
	int retVal = (int)o->Contain(tp0);
	return retVal;
}
//not supported method: AddSpan void ( ::btDbvtAabbMm::* )( ::btVector3 const &,::btScalar &,::btScalar & ) const
// error: ::btVector3 const & - ok,  - unsupported,  - unsupported, void - ok

//method: Mins ::btVector3 const & ( ::btDbvtAabbMm::* )(  ) const
void btDbvtAabbMm_Mins(void *c,float* ret) {
	::btDbvtAabbMm *o = (::btDbvtAabbMm*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->Mins();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//not supported method: FromCR ::btDbvtAabbMm (*)( ::btVector3 const &,::btScalar )
// error: ::btVector3 const & - ok, ::btScalar - ok,  - unsupported

//method: Expand void ( ::btDbvtAabbMm::* )( ::btVector3 const & ) 
void btDbvtAabbMm_Expand(void *c,float* p0) {
	::btDbvtAabbMm *o = (::btDbvtAabbMm*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->Expand(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//not supported method: FromPoints ::btDbvtAabbMm (*)( ::btVector3 const *,int )
// error:  - unsupported, int - ok,  - unsupported

//not supported method: FromPoints ::btDbvtAabbMm (*)( ::btVector3 const *,int )
// error:  - unsupported, int - ok,  - unsupported

//not supported method: FromPoints ::btDbvtAabbMm (*)( ::btVector3 const * *,int )
// error:  - unsupported, int - ok,  - unsupported

//attribute: ::btVector3 btDbvtAabbMm->mi
void btDbvtAabbMm_mi_set(void *c,float* a) {
	::btDbvtAabbMm *o = (::btDbvtAabbMm*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->mi = ta;
}
void btDbvtAabbMm_mi_get(void *c,float* a) {
	::btDbvtAabbMm *o = (::btDbvtAabbMm*)c;
	a[0]=(o->mi).m_floats[0];a[1]=(o->mi).m_floats[1];a[2]=(o->mi).m_floats[2];
}

//attribute: ::btVector3 btDbvtAabbMm->mx
void btDbvtAabbMm_mx_set(void *c,float* a) {
	::btDbvtAabbMm *o = (::btDbvtAabbMm*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->mx = ta;
}
void btDbvtAabbMm_mx_get(void *c,float* a) {
	::btDbvtAabbMm *o = (::btDbvtAabbMm*)c;
	a[0]=(o->mx).m_floats[0];a[1]=(o->mx).m_floats[1];a[2]=(o->mx).m_floats[2];
}


// ::btDbvtBroadphase
//constructor: btDbvtBroadphase  ( ::btDbvtBroadphase::* )( ::btOverlappingPairCache * ) 
void* btDbvtBroadphase_new(void* p0) {
	::btDbvtBroadphase *o = 0;
	 void *mem = 0;
	::btOverlappingPairCache * tp0 = (::btOverlappingPairCache *)p0;
	mem = btAlignedAlloc(sizeof(::btDbvtBroadphase),16);
	o = new (mem)::btDbvtBroadphase(tp0);
	return (void*)o;
}
void btDbvtBroadphase_free(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	delete o;
}
//method: setVelocityPrediction void ( ::btDbvtBroadphase::* )( ::btScalar ) 
void btDbvtBroadphase_setVelocityPrediction(void *c,float p0) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->setVelocityPrediction(p0);
}
//method: rayTest void ( ::btDbvtBroadphase::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseRayCallback &,::btVector3 const &,::btVector3 const & ) 
void btDbvtBroadphase_rayTest(void *c,float* p0,float* p1,void* p2,float* p3,float* p4) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btBroadphaseRayCallback & tp2 = *(::btBroadphaseRayCallback *)p2;
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->rayTest(tp0,tp1,tp2,tp3,tp4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: performDeferredRemoval void ( ::btDbvtBroadphase::* )( ::btDispatcher * ) 
void btDbvtBroadphase_performDeferredRemoval(void *c,void* p0) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->performDeferredRemoval(tp0);
}
//method: setAabb void ( ::btDbvtBroadphase::* )( ::btBroadphaseProxy *,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btDbvtBroadphase_setAabb(void *c,void* p0,float* p1,float* p2,void* p3) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	::btDispatcher * tp3 = (::btDispatcher *)p3;
	o->setAabb(tp0,tp1,tp2,tp3);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getBroadphaseAabb void ( ::btDbvtBroadphase::* )( ::btVector3 &,::btVector3 & ) const
void btDbvtBroadphase_getBroadphaseAabb(void *c,float* p0,float* p1) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getBroadphaseAabb(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getVelocityPrediction ::btScalar ( ::btDbvtBroadphase::* )(  ) const
float btDbvtBroadphase_getVelocityPrediction(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	float retVal = (float)o->getVelocityPrediction();
	return retVal;
}
//method: benchmark void (*)( ::btBroadphaseInterface * )
void btDbvtBroadphase_benchmark(void* p0) {
	::btBroadphaseInterface * tp0 = (::btBroadphaseInterface *)p0;
	::btDbvtBroadphase::benchmark(tp0);
}
//method: collide void ( ::btDbvtBroadphase::* )( ::btDispatcher * ) 
void btDbvtBroadphase_collide(void *c,void* p0) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->collide(tp0);
}
//method: resetPool void ( ::btDbvtBroadphase::* )( ::btDispatcher * ) 
void btDbvtBroadphase_resetPool(void *c,void* p0) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->resetPool(tp0);
}
//method: optimize void ( ::btDbvtBroadphase::* )(  ) 
void btDbvtBroadphase_optimize(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->optimize();
}
//method: calculateOverlappingPairs void ( ::btDbvtBroadphase::* )( ::btDispatcher * ) 
void btDbvtBroadphase_calculateOverlappingPairs(void *c,void* p0) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->calculateOverlappingPairs(tp0);
}
//method: setAabbForceUpdate void ( ::btDbvtBroadphase::* )( ::btBroadphaseProxy *,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btDbvtBroadphase_setAabbForceUpdate(void *c,void* p0,float* p1,float* p2,void* p3) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	::btDispatcher * tp3 = (::btDispatcher *)p3;
	o->setAabbForceUpdate(tp0,tp1,tp2,tp3);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: printStats void ( ::btDbvtBroadphase::* )(  ) 
void btDbvtBroadphase_printStats(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->printStats();
}
//method: getAabb void ( ::btDbvtBroadphase::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
void btDbvtBroadphase_getAabb(void *c,void* p0,float* p1,float* p2) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: aabbTest void ( ::btDbvtBroadphase::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseAabbCallback & ) 
void btDbvtBroadphase_aabbTest(void *c,float* p0,float* p1,void* p2) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btBroadphaseAabbCallback & tp2 = *(::btBroadphaseAabbCallback *)p2;
	o->aabbTest(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: createProxy ::btBroadphaseProxy * ( ::btDbvtBroadphase::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int,::btDispatcher *,void * ) 
void* btDbvtBroadphase_createProxy(void *c,float* p0,float* p1,int p2,void* p3,short int p4,short int p5,void* p6,void* p7) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	void * tp3 = (void *)p3;
	::btDispatcher * tp6 = (::btDispatcher *)p6;
	void * tp7 = (void *)p7;
	void* retVal = (void*) o->createProxy(tp0,tp1,p2,tp3,p4,p5,tp6,tp7);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btDbvtBroadphase::* )(  ) 
void* btDbvtBroadphase_getOverlappingPairCache(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btDbvtBroadphase::* )(  ) 
void* btDbvtBroadphase_getOverlappingPairCache0(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: getOverlappingPairCache ::btOverlappingPairCache const * ( ::btDbvtBroadphase::* )(  ) const
void* btDbvtBroadphase_getOverlappingPairCache1(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: destroyProxy void ( ::btDbvtBroadphase::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btDbvtBroadphase_destroyProxy(void *c,void* p0,void* p1) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->destroyProxy(tp0,tp1);
}
//attribute: int btDbvtBroadphase->m_cid
void btDbvtBroadphase_m_cid_set(void *c,int a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_cid = a;
}
int btDbvtBroadphase_m_cid_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (int)(o->m_cid);
}

//attribute: int btDbvtBroadphase->m_cupdates
void btDbvtBroadphase_m_cupdates_set(void *c,int a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_cupdates = a;
}
int btDbvtBroadphase_m_cupdates_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (int)(o->m_cupdates);
}

//attribute: bool btDbvtBroadphase->m_deferedcollide
void btDbvtBroadphase_m_deferedcollide_set(void *c,int a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_deferedcollide = a;
}
int btDbvtBroadphase_m_deferedcollide_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (int)(o->m_deferedcollide);
}

//attribute: int btDbvtBroadphase->m_dupdates
void btDbvtBroadphase_m_dupdates_set(void *c,int a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_dupdates = a;
}
int btDbvtBroadphase_m_dupdates_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (int)(o->m_dupdates);
}

//attribute: int btDbvtBroadphase->m_fixedleft
void btDbvtBroadphase_m_fixedleft_set(void *c,int a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_fixedleft = a;
}
int btDbvtBroadphase_m_fixedleft_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (int)(o->m_fixedleft);
}

//attribute: int btDbvtBroadphase->m_fupdates
void btDbvtBroadphase_m_fupdates_set(void *c,int a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_fupdates = a;
}
int btDbvtBroadphase_m_fupdates_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (int)(o->m_fupdates);
}

//attribute: int btDbvtBroadphase->m_gid
void btDbvtBroadphase_m_gid_set(void *c,int a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_gid = a;
}
int btDbvtBroadphase_m_gid_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (int)(o->m_gid);
}

//attribute: bool btDbvtBroadphase->m_needcleanup
void btDbvtBroadphase_m_needcleanup_set(void *c,int a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_needcleanup = a;
}
int btDbvtBroadphase_m_needcleanup_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (int)(o->m_needcleanup);
}

//attribute: int btDbvtBroadphase->m_newpairs
void btDbvtBroadphase_m_newpairs_set(void *c,int a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_newpairs = a;
}
int btDbvtBroadphase_m_newpairs_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (int)(o->m_newpairs);
}

//attribute: ::btOverlappingPairCache * btDbvtBroadphase->m_paircache
void btDbvtBroadphase_m_paircache_set(void *c,void* a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	::btOverlappingPairCache * ta = (::btOverlappingPairCache *)a;
	o->m_paircache = ta;
}
void* btDbvtBroadphase_m_paircache_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (void*)(o->m_paircache);
}

//attribute: int btDbvtBroadphase->m_pid
void btDbvtBroadphase_m_pid_set(void *c,int a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_pid = a;
}
int btDbvtBroadphase_m_pid_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (int)(o->m_pid);
}

//attribute: ::btScalar btDbvtBroadphase->m_prediction
void btDbvtBroadphase_m_prediction_set(void *c,float a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_prediction = a;
}
float btDbvtBroadphase_m_prediction_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (float)(o->m_prediction);
}

//attribute: bool btDbvtBroadphase->m_releasepaircache
void btDbvtBroadphase_m_releasepaircache_set(void *c,int a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_releasepaircache = a;
}
int btDbvtBroadphase_m_releasepaircache_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (int)(o->m_releasepaircache);
}

//attribute: ::btDbvt[2] btDbvtBroadphase->m_sets
// attribute not supported: //attribute: ::btDbvt[2] btDbvtBroadphase->m_sets
//attribute: int btDbvtBroadphase->m_stageCurrent
void btDbvtBroadphase_m_stageCurrent_set(void *c,int a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_stageCurrent = a;
}
int btDbvtBroadphase_m_stageCurrent_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (int)(o->m_stageCurrent);
}

//attribute: ::btDbvtProxy *[3] btDbvtBroadphase->m_stageRoots
// attribute not supported: //attribute: ::btDbvtProxy *[3] btDbvtBroadphase->m_stageRoots
//attribute: unsigned int btDbvtBroadphase->m_updates_call
void btDbvtBroadphase_m_updates_call_set(void *c,unsigned int a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_updates_call = a;
}
unsigned int btDbvtBroadphase_m_updates_call_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (unsigned int)(o->m_updates_call);
}

//attribute: unsigned int btDbvtBroadphase->m_updates_done
void btDbvtBroadphase_m_updates_done_set(void *c,unsigned int a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_updates_done = a;
}
unsigned int btDbvtBroadphase_m_updates_done_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (unsigned int)(o->m_updates_done);
}

//attribute: ::btScalar btDbvtBroadphase->m_updates_ratio
void btDbvtBroadphase_m_updates_ratio_set(void *c,float a) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	o->m_updates_ratio = a;
}
float btDbvtBroadphase_m_updates_ratio_get(void *c) {
	::btDbvtBroadphase *o = (::btDbvtBroadphase*)c;
	return (float)(o->m_updates_ratio);
}


// ::btDbvtNode
//constructor: btDbvtNode  ( ::btDbvtNode::* )(  ) 
void* btDbvtNode_new() {
	::btDbvtNode *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btDbvtNode),16);
	o = new (mem)::btDbvtNode();
	return (void*)o;
}
void btDbvtNode_free(void *c) {
	::btDbvtNode *o = (::btDbvtNode*)c;
	delete o;
}
//method: isinternal bool ( ::btDbvtNode::* )(  ) const
int btDbvtNode_isinternal(void *c) {
	::btDbvtNode *o = (::btDbvtNode*)c;
	int retVal = (int)o->isinternal();
	return retVal;
}
//method: isleaf bool ( ::btDbvtNode::* )(  ) const
int btDbvtNode_isleaf(void *c) {
	::btDbvtNode *o = (::btDbvtNode*)c;
	int retVal = (int)o->isleaf();
	return retVal;
}
//attribute: ::btDbvtNode btDbvtNode->
// attribute not supported: //attribute: ::btDbvtNode btDbvtNode->
//attribute: ::btDbvtNode * btDbvtNode->parent
void btDbvtNode_parent_set(void *c,void* a) {
	::btDbvtNode *o = (::btDbvtNode*)c;
	::btDbvtNode * ta = (::btDbvtNode *)a;
	o->parent = ta;
}
void* btDbvtNode_parent_get(void *c) {
	::btDbvtNode *o = (::btDbvtNode*)c;
	return (void*)(o->parent);
}

//attribute: ::btDbvtVolume btDbvtNode->volume
void btDbvtNode_volume_set(void *c,void* a) {
	::btDbvtNode *o = (::btDbvtNode*)c;
	::btDbvtVolume & ta = *(::btDbvtAabbMm *)a;
	o->volume = ta;
}
void* btDbvtNode_volume_get(void *c) {
	::btDbvtNode *o = (::btDbvtNode*)c;
	return (void*)&(o->volume);
}


// ::btDbvtProxy
//constructor: btDbvtProxy  ( ::btDbvtProxy::* )( ::btVector3 const &,::btVector3 const &,void *,short int,short int ) 
void* btDbvtProxy_new(float* p0,float* p1,void* p2,short int p3,short int p4) {
	::btDbvtProxy *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	void * tp2 = (void *)p2;
	mem = btAlignedAlloc(sizeof(::btDbvtProxy),16);
	o = new (mem)::btDbvtProxy(tp0,tp1,tp2,p3,p4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return (void*)o;
}
void btDbvtProxy_free(void *c) {
	::btDbvtProxy *o = (::btDbvtProxy*)c;
	delete o;
}
//attribute: ::btDbvtNode * btDbvtProxy->leaf
void btDbvtProxy_leaf_set(void *c,void* a) {
	::btDbvtProxy *o = (::btDbvtProxy*)c;
	::btDbvtNode * ta = (::btDbvtNode *)a;
	o->leaf = ta;
}
void* btDbvtProxy_leaf_get(void *c) {
	::btDbvtProxy *o = (::btDbvtProxy*)c;
	return (void*)(o->leaf);
}

//attribute: ::btDbvtProxy *[2] btDbvtProxy->links
// attribute not supported: //attribute: ::btDbvtProxy *[2] btDbvtProxy->links
//attribute: int btDbvtProxy->stage
void btDbvtProxy_stage_set(void *c,int a) {
	::btDbvtProxy *o = (::btDbvtProxy*)c;
	o->stage = a;
}
int btDbvtProxy_stage_get(void *c) {
	::btDbvtProxy *o = (::btDbvtProxy*)c;
	return (int)(o->stage);
}


// ::btDispatcher
//method: allocateCollisionAlgorithm void * ( ::btDispatcher::* )( int ) 
void* btDispatcher_allocateCollisionAlgorithm(void *c,int p0) {
	::btDispatcher *o = (::btDispatcher*)c;
	void* retVal = (void*) o->allocateCollisionAlgorithm(p0);
	return retVal;
}
//method: releaseManifold void ( ::btDispatcher::* )( ::btPersistentManifold * ) 
void btDispatcher_releaseManifold(void *c,void* p0) {
	::btDispatcher *o = (::btDispatcher*)c;
	::btPersistentManifold * tp0 = (::btPersistentManifold *)p0;
	o->releaseManifold(tp0);
}
//method: getNumManifolds int ( ::btDispatcher::* )(  ) const
int btDispatcher_getNumManifolds(void *c) {
	::btDispatcher *o = (::btDispatcher*)c;
	int retVal = (int)o->getNumManifolds();
	return retVal;
}
//method: clearManifold void ( ::btDispatcher::* )( ::btPersistentManifold * ) 
void btDispatcher_clearManifold(void *c,void* p0) {
	::btDispatcher *o = (::btDispatcher*)c;
	::btPersistentManifold * tp0 = (::btPersistentManifold *)p0;
	o->clearManifold(tp0);
}
//method: freeCollisionAlgorithm void ( ::btDispatcher::* )( void * ) 
void btDispatcher_freeCollisionAlgorithm(void *c,void* p0) {
	::btDispatcher *o = (::btDispatcher*)c;
	void * tp0 = (void *)p0;
	o->freeCollisionAlgorithm(tp0);
}
//not supported method: getInternalManifoldPointer ::btPersistentManifold * * ( ::btDispatcher::* )(  ) 
// error:  - unsupported

//method: findAlgorithm ::btCollisionAlgorithm * ( ::btDispatcher::* )( ::btCollisionObject *,::btCollisionObject *,::btPersistentManifold * ) 
void* btDispatcher_findAlgorithm(void *c,void* p0,void* p1,void* p2) {
	::btDispatcher *o = (::btDispatcher*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btPersistentManifold * tp2 = (::btPersistentManifold *)p2;
	void* retVal = (void*) o->findAlgorithm(tp0,tp1,tp2);
	return retVal;
}
//method: needsResponse bool ( ::btDispatcher::* )( ::btCollisionObject *,::btCollisionObject * ) 
int btDispatcher_needsResponse(void *c,void* p0,void* p1) {
	::btDispatcher *o = (::btDispatcher*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	int retVal = (int)o->needsResponse(tp0,tp1);
	return retVal;
}
//method: getNewManifold ::btPersistentManifold * ( ::btDispatcher::* )( void *,void * ) 
void* btDispatcher_getNewManifold(void *c,void* p0,void* p1) {
	::btDispatcher *o = (::btDispatcher*)c;
	void * tp0 = (void *)p0;
	void * tp1 = (void *)p1;
	void* retVal = (void*) o->getNewManifold(tp0,tp1);
	return retVal;
}
//method: dispatchAllCollisionPairs void ( ::btDispatcher::* )( ::btOverlappingPairCache *,::btDispatcherInfo const &,::btDispatcher * ) 
void btDispatcher_dispatchAllCollisionPairs(void *c,void* p0,void* p1,void* p2) {
	::btDispatcher *o = (::btDispatcher*)c;
	::btOverlappingPairCache * tp0 = (::btOverlappingPairCache *)p0;
	::btDispatcherInfo const & tp1 = *(::btDispatcherInfo const *)p1;
	::btDispatcher * tp2 = (::btDispatcher *)p2;
	o->dispatchAllCollisionPairs(tp0,tp1,tp2);
}
//not supported method: getInternalManifoldPool ::btPoolAllocator * ( ::btDispatcher::* )(  ) 
// error:  - unsupported

//not supported method: getInternalManifoldPool ::btPoolAllocator * ( ::btDispatcher::* )(  ) 
// error:  - unsupported

//not supported method: getInternalManifoldPool ::btPoolAllocator const * ( ::btDispatcher::* )(  ) const
// error:  - unsupported

//method: needsCollision bool ( ::btDispatcher::* )( ::btCollisionObject *,::btCollisionObject * ) 
int btDispatcher_needsCollision(void *c,void* p0,void* p1) {
	::btDispatcher *o = (::btDispatcher*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	int retVal = (int)o->needsCollision(tp0,tp1);
	return retVal;
}
//method: getManifoldByIndexInternal ::btPersistentManifold * ( ::btDispatcher::* )( int ) 
void* btDispatcher_getManifoldByIndexInternal(void *c,int p0) {
	::btDispatcher *o = (::btDispatcher*)c;
	void* retVal = (void*) o->getManifoldByIndexInternal(p0);
	return retVal;
}

// ::btDispatcherInfo
//constructor: btDispatcherInfo  ( ::btDispatcherInfo::* )(  ) 
void* btDispatcherInfo_new() {
	::btDispatcherInfo *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btDispatcherInfo),16);
	o = new (mem)::btDispatcherInfo();
	return (void*)o;
}
void btDispatcherInfo_free(void *c) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	delete o;
}
//attribute: ::btScalar btDispatcherInfo->m_allowedCcdPenetration
void btDispatcherInfo_m_allowedCcdPenetration_set(void *c,float a) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	o->m_allowedCcdPenetration = a;
}
float btDispatcherInfo_m_allowedCcdPenetration_get(void *c) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	return (float)(o->m_allowedCcdPenetration);
}

//attribute: ::btScalar btDispatcherInfo->m_convexConservativeDistanceThreshold
void btDispatcherInfo_m_convexConservativeDistanceThreshold_set(void *c,float a) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	o->m_convexConservativeDistanceThreshold = a;
}
float btDispatcherInfo_m_convexConservativeDistanceThreshold_get(void *c) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	return (float)(o->m_convexConservativeDistanceThreshold);
}

//attribute: ::btIDebugDraw * btDispatcherInfo->m_debugDraw
void btDispatcherInfo_m_debugDraw_set(void *c,void* a) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	::btIDebugDraw * ta = (::btIDebugDraw *)a;
	o->m_debugDraw = ta;
}
void* btDispatcherInfo_m_debugDraw_get(void *c) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	return (void*)(o->m_debugDraw);
}

//attribute: int btDispatcherInfo->m_dispatchFunc
void btDispatcherInfo_m_dispatchFunc_set(void *c,int a) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	o->m_dispatchFunc = a;
}
int btDispatcherInfo_m_dispatchFunc_get(void *c) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	return (int)(o->m_dispatchFunc);
}

//attribute: bool btDispatcherInfo->m_enableSPU
void btDispatcherInfo_m_enableSPU_set(void *c,int a) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	o->m_enableSPU = a;
}
int btDispatcherInfo_m_enableSPU_get(void *c) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	return (int)(o->m_enableSPU);
}

//attribute: bool btDispatcherInfo->m_enableSatConvex
void btDispatcherInfo_m_enableSatConvex_set(void *c,int a) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	o->m_enableSatConvex = a;
}
int btDispatcherInfo_m_enableSatConvex_get(void *c) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	return (int)(o->m_enableSatConvex);
}

//attribute: ::btStackAlloc * btDispatcherInfo->m_stackAllocator
void btDispatcherInfo_m_stackAllocator_set(void *c,void* a) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	::btStackAlloc * ta = (::btStackAlloc *)a;
	o->m_stackAllocator = ta;
}
void* btDispatcherInfo_m_stackAllocator_get(void *c) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	return (void*)(o->m_stackAllocator);
}

//attribute: int btDispatcherInfo->m_stepCount
void btDispatcherInfo_m_stepCount_set(void *c,int a) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	o->m_stepCount = a;
}
int btDispatcherInfo_m_stepCount_get(void *c) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	return (int)(o->m_stepCount);
}

//attribute: ::btScalar btDispatcherInfo->m_timeOfImpact
void btDispatcherInfo_m_timeOfImpact_set(void *c,float a) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	o->m_timeOfImpact = a;
}
float btDispatcherInfo_m_timeOfImpact_get(void *c) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	return (float)(o->m_timeOfImpact);
}

//attribute: ::btScalar btDispatcherInfo->m_timeStep
void btDispatcherInfo_m_timeStep_set(void *c,float a) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	o->m_timeStep = a;
}
float btDispatcherInfo_m_timeStep_get(void *c) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	return (float)(o->m_timeStep);
}

//attribute: bool btDispatcherInfo->m_useContinuous
void btDispatcherInfo_m_useContinuous_set(void *c,int a) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	o->m_useContinuous = a;
}
int btDispatcherInfo_m_useContinuous_get(void *c) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	return (int)(o->m_useContinuous);
}

//attribute: bool btDispatcherInfo->m_useConvexConservativeDistanceUtil
void btDispatcherInfo_m_useConvexConservativeDistanceUtil_set(void *c,int a) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	o->m_useConvexConservativeDistanceUtil = a;
}
int btDispatcherInfo_m_useConvexConservativeDistanceUtil_get(void *c) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	return (int)(o->m_useConvexConservativeDistanceUtil);
}

//attribute: bool btDispatcherInfo->m_useEpa
void btDispatcherInfo_m_useEpa_set(void *c,int a) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	o->m_useEpa = a;
}
int btDispatcherInfo_m_useEpa_get(void *c) {
	::btDispatcherInfo *o = (::btDispatcherInfo*)c;
	return (int)(o->m_useEpa);
}


// ::btHashedOverlappingPairCache
//constructor: btHashedOverlappingPairCache  ( ::btHashedOverlappingPairCache::* )(  ) 
void* btHashedOverlappingPairCache_new() {
	::btHashedOverlappingPairCache *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btHashedOverlappingPairCache),16);
	o = new (mem)::btHashedOverlappingPairCache();
	return (void*)o;
}
void btHashedOverlappingPairCache_free(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	delete o;
}
//method: sortOverlappingPairs void ( ::btHashedOverlappingPairCache::* )( ::btDispatcher * ) 
void btHashedOverlappingPairCache_sortOverlappingPairs(void *c,void* p0) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->sortOverlappingPairs(tp0);
}
//method: equalsPair bool ( ::btHashedOverlappingPairCache::* )( ::btBroadphasePair const &,int,int ) 
int btHashedOverlappingPairCache_equalsPair(void *c,void* p0,int p1,int p2) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btBroadphasePair const & tp0 = *(::btBroadphasePair const *)p0;
	int retVal = (int)o->equalsPair(tp0,p1,p2);
	return retVal;
}
//method: internalFindPair ::btBroadphasePair * ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy *,int ) 
void* btHashedOverlappingPairCache_internalFindPair(void *c,void* p0,void* p1,int p2) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	void* retVal = (void*) o->internalFindPair(tp0,tp1,p2);
	return retVal;
}
//method: getOverlappingPairArray ::btBroadphasePairArray & ( ::btHashedOverlappingPairCache::* )(  ) 
void* btHashedOverlappingPairCache_getOverlappingPairArray(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	void* retVal = (void*) &(o->getOverlappingPairArray());
	return retVal;
}
//method: getOverlappingPairArray ::btBroadphasePairArray & ( ::btHashedOverlappingPairCache::* )(  ) 
void* btHashedOverlappingPairCache_getOverlappingPairArray0(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	void* retVal = (void*) &(o->getOverlappingPairArray());
	return retVal;
}
//method: getOverlappingPairArray ::btBroadphasePairArray const & ( ::btHashedOverlappingPairCache::* )(  ) const
void* btHashedOverlappingPairCache_getOverlappingPairArray1(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	void* retVal = (void*) &(o->getOverlappingPairArray());
	return retVal;
}
//method: processAllOverlappingPairs void ( ::btHashedOverlappingPairCache::* )( ::btOverlapCallback *,::btDispatcher * ) 
void btHashedOverlappingPairCache_processAllOverlappingPairs(void *c,void* p0,void* p1) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btOverlapCallback * tp0 = (::btOverlapCallback *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->processAllOverlappingPairs(tp0,tp1);
}
//method: hasDeferredRemoval bool ( ::btHashedOverlappingPairCache::* )(  ) 
int btHashedOverlappingPairCache_hasDeferredRemoval(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	int retVal = (int)o->hasDeferredRemoval();
	return retVal;
}
//method: cleanProxyFromPairs void ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btHashedOverlappingPairCache_cleanProxyFromPairs(void *c,void* p0,void* p1) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->cleanProxyFromPairs(tp0,tp1);
}
//method: getNumOverlappingPairs int ( ::btHashedOverlappingPairCache::* )(  ) const
int btHashedOverlappingPairCache_getNumOverlappingPairs(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	int retVal = (int)o->getNumOverlappingPairs();
	return retVal;
}
//method: cleanOverlappingPair void ( ::btHashedOverlappingPairCache::* )( ::btBroadphasePair &,::btDispatcher * ) 
void btHashedOverlappingPairCache_cleanOverlappingPair(void *c,void* p0,void* p1) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btBroadphasePair & tp0 = *(::btBroadphasePair *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->cleanOverlappingPair(tp0,tp1);
}
//method: setOverlapFilterCallback void ( ::btHashedOverlappingPairCache::* )( ::btOverlapFilterCallback * ) 
void btHashedOverlappingPairCache_setOverlapFilterCallback(void *c,void* p0) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btOverlapFilterCallback * tp0 = (::btOverlapFilterCallback *)p0;
	o->setOverlapFilterCallback(tp0);
}
//method: setInternalGhostPairCallback void ( ::btHashedOverlappingPairCache::* )( ::btOverlappingPairCallback * ) 
void btHashedOverlappingPairCache_setInternalGhostPairCallback(void *c,void* p0) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btOverlappingPairCallback * tp0 = (::btOverlappingPairCallback *)p0;
	o->setInternalGhostPairCallback(tp0);
}
//method: addOverlappingPair ::btBroadphasePair * ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void* btHashedOverlappingPairCache_addOverlappingPair(void *c,void* p0,void* p1) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	void* retVal = (void*) o->addOverlappingPair(tp0,tp1);
	return retVal;
}
//method: needsBroadphaseCollision bool ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) const
int btHashedOverlappingPairCache_needsBroadphaseCollision(void *c,void* p0,void* p1) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	int retVal = (int)o->needsBroadphaseCollision(tp0,tp1);
	return retVal;
}
//method: findPair ::btBroadphasePair * ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void* btHashedOverlappingPairCache_findPair(void *c,void* p0,void* p1) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	void* retVal = (void*) o->findPair(tp0,tp1);
	return retVal;
}
//method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btHashedOverlappingPairCache::* )(  ) 
void* btHashedOverlappingPairCache_getOverlappingPairArrayPtr(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	void* retVal = (void*) o->getOverlappingPairArrayPtr();
	return retVal;
}
//method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btHashedOverlappingPairCache::* )(  ) 
void* btHashedOverlappingPairCache_getOverlappingPairArrayPtr0(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	void* retVal = (void*) o->getOverlappingPairArrayPtr();
	return retVal;
}
//method: getOverlappingPairArrayPtr ::btBroadphasePair const * ( ::btHashedOverlappingPairCache::* )(  ) const
void* btHashedOverlappingPairCache_getOverlappingPairArrayPtr1(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	void* retVal = (void*) o->getOverlappingPairArrayPtr();
	return retVal;
}
//method: getOverlapFilterCallback ::btOverlapFilterCallback * ( ::btHashedOverlappingPairCache::* )(  ) 
void* btHashedOverlappingPairCache_getOverlapFilterCallback(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	void* retVal = (void*) o->getOverlapFilterCallback();
	return retVal;
}
//method: removeOverlappingPairsContainingProxy void ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btHashedOverlappingPairCache_removeOverlappingPairsContainingProxy(void *c,void* p0,void* p1) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->removeOverlappingPairsContainingProxy(tp0,tp1);
}
//method: internalAddPair ::btBroadphasePair * ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void* btHashedOverlappingPairCache_internalAddPair(void *c,void* p0,void* p1) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	void* retVal = (void*) o->internalAddPair(tp0,tp1);
	return retVal;
}
//method: growTables void ( ::btHashedOverlappingPairCache::* )(  ) 
void btHashedOverlappingPairCache_growTables(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	o->growTables();
}
//method: removeOverlappingPair void * ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy *,::btDispatcher * ) 
void* btHashedOverlappingPairCache_removeOverlappingPair(void *c,void* p0,void* p1,void* p2) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	::btDispatcher * tp2 = (::btDispatcher *)p2;
	void* retVal = (void*) o->removeOverlappingPair(tp0,tp1,tp2);
	return retVal;
}
//method: GetCount int ( ::btHashedOverlappingPairCache::* )(  ) const
int btHashedOverlappingPairCache_GetCount(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	int retVal = (int)o->GetCount();
	return retVal;
}
//method: getHash unsigned int ( ::btHashedOverlappingPairCache::* )( unsigned int,unsigned int ) 
unsigned int btHashedOverlappingPairCache_getHash(void *c,unsigned int p0,unsigned int p1) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	unsigned int retVal = (unsigned int)o->getHash(p0,p1);
	return retVal;
}
//attribute: ::btBroadphasePairArray btHashedOverlappingPairCache->m_overlappingPairArray
void btHashedOverlappingPairCache_m_overlappingPairArray_set(void *c,void* a) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btBroadphasePairArray & ta = *(::btAlignedObjectArray<btBroadphasePair> *)a;
	o->m_overlappingPairArray = ta;
}
void* btHashedOverlappingPairCache_m_overlappingPairArray_get(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	return (void*)&(o->m_overlappingPairArray);
}

//attribute: ::btOverlapFilterCallback * btHashedOverlappingPairCache->m_overlapFilterCallback
void btHashedOverlappingPairCache_m_overlapFilterCallback_set(void *c,void* a) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btOverlapFilterCallback * ta = (::btOverlapFilterCallback *)a;
	o->m_overlapFilterCallback = ta;
}
void* btHashedOverlappingPairCache_m_overlapFilterCallback_get(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	return (void*)(o->m_overlapFilterCallback);
}

//attribute: bool btHashedOverlappingPairCache->m_blockedForChanges
void btHashedOverlappingPairCache_m_blockedForChanges_set(void *c,int a) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	o->m_blockedForChanges = a;
}
int btHashedOverlappingPairCache_m_blockedForChanges_get(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	return (int)(o->m_blockedForChanges);
}

//attribute: ::btAlignedObjectArray<int> btHashedOverlappingPairCache->m_hashTable
void btHashedOverlappingPairCache_m_hashTable_set(void *c,void* a) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_hashTable = ta;
}
void* btHashedOverlappingPairCache_m_hashTable_get(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	return (void*)&(o->m_hashTable);
}

//attribute: ::btAlignedObjectArray<int> btHashedOverlappingPairCache->m_next
void btHashedOverlappingPairCache_m_next_set(void *c,void* a) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btAlignedObjectArray<int> & ta = *(::btAlignedObjectArray<int> *)a;
	o->m_next = ta;
}
void* btHashedOverlappingPairCache_m_next_get(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	return (void*)&(o->m_next);
}

//attribute: ::btOverlappingPairCallback * btHashedOverlappingPairCache->m_ghostPairCallback
void btHashedOverlappingPairCache_m_ghostPairCallback_set(void *c,void* a) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	::btOverlappingPairCallback * ta = (::btOverlappingPairCallback *)a;
	o->m_ghostPairCallback = ta;
}
void* btHashedOverlappingPairCache_m_ghostPairCallback_get(void *c) {
	::btHashedOverlappingPairCache *o = (::btHashedOverlappingPairCache*)c;
	return (void*)(o->m_ghostPairCallback);
}


// ::btMultiSapBroadphase
//method: addToChildBroadphase void ( ::btMultiSapBroadphase::* )( ::btMultiSapBroadphase::btMultiSapProxy *,::btBroadphaseProxy *,::btBroadphaseInterface * ) 
void btMultiSapBroadphase_addToChildBroadphase(void *c,void* p0,void* p1,void* p2) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	::btMultiSapBroadphase::btMultiSapProxy * tp0 = (::btMultiSapBroadphase::btMultiSapProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	::btBroadphaseInterface * tp2 = (::btBroadphaseInterface *)p2;
	o->addToChildBroadphase(tp0,tp1,tp2);
}
//method: rayTest void ( ::btMultiSapBroadphase::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseRayCallback &,::btVector3 const &,::btVector3 const & ) 
void btMultiSapBroadphase_rayTest(void *c,float* p0,float* p1,void* p2,float* p3,float* p4) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btBroadphaseRayCallback & tp2 = *(::btBroadphaseRayCallback *)p2;
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->rayTest(tp0,tp1,tp2,tp3,tp4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: setAabb void ( ::btMultiSapBroadphase::* )( ::btBroadphaseProxy *,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btMultiSapBroadphase_setAabb(void *c,void* p0,float* p1,float* p2,void* p3) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	::btDispatcher * tp3 = (::btDispatcher *)p3;
	o->setAabb(tp0,tp1,tp2,tp3);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btMultiSapBroadphase::* )(  ) 
void* btMultiSapBroadphase_getOverlappingPairCache(void *c) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btMultiSapBroadphase::* )(  ) 
void* btMultiSapBroadphase_getOverlappingPairCache0(void *c) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: getOverlappingPairCache ::btOverlappingPairCache const * ( ::btMultiSapBroadphase::* )(  ) const
void* btMultiSapBroadphase_getOverlappingPairCache1(void *c) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: buildTree void ( ::btMultiSapBroadphase::* )( ::btVector3 const &,::btVector3 const & ) 
void btMultiSapBroadphase_buildTree(void *c,float* p0,float* p1) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->buildTree(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: resetPool void ( ::btMultiSapBroadphase::* )( ::btDispatcher * ) 
void btMultiSapBroadphase_resetPool(void *c,void* p0) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->resetPool(tp0);
}
//method: calculateOverlappingPairs void ( ::btMultiSapBroadphase::* )( ::btDispatcher * ) 
void btMultiSapBroadphase_calculateOverlappingPairs(void *c,void* p0) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->calculateOverlappingPairs(tp0);
}
//method: testAabbOverlap bool ( ::btMultiSapBroadphase::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
int btMultiSapBroadphase_testAabbOverlap(void *c,void* p0,void* p1) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	int retVal = (int)o->testAabbOverlap(tp0,tp1);
	return retVal;
}
//method: getAabb void ( ::btMultiSapBroadphase::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
void btMultiSapBroadphase_getAabb(void *c,void* p0,float* p1,float* p2) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: getBroadphaseArray ::btSapBroadphaseArray & ( ::btMultiSapBroadphase::* )(  ) 
void* btMultiSapBroadphase_getBroadphaseArray(void *c) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	void* retVal = (void*) &(o->getBroadphaseArray());
	return retVal;
}
//method: getBroadphaseArray ::btSapBroadphaseArray & ( ::btMultiSapBroadphase::* )(  ) 
void* btMultiSapBroadphase_getBroadphaseArray0(void *c) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	void* retVal = (void*) &(o->getBroadphaseArray());
	return retVal;
}
//method: getBroadphaseArray ::btSapBroadphaseArray const & ( ::btMultiSapBroadphase::* )(  ) const
void* btMultiSapBroadphase_getBroadphaseArray1(void *c) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	void* retVal = (void*) &(o->getBroadphaseArray());
	return retVal;
}
//method: createProxy ::btBroadphaseProxy * ( ::btMultiSapBroadphase::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int,::btDispatcher *,void * ) 
void* btMultiSapBroadphase_createProxy(void *c,float* p0,float* p1,int p2,void* p3,short int p4,short int p5,void* p6,void* p7) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	void * tp3 = (void *)p3;
	::btDispatcher * tp6 = (::btDispatcher *)p6;
	void * tp7 = (void *)p7;
	void* retVal = (void*) o->createProxy(tp0,tp1,p2,tp3,p4,p5,tp6,tp7);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//method: printStats void ( ::btMultiSapBroadphase::* )(  ) 
void btMultiSapBroadphase_printStats(void *c) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	o->printStats();
}
//method: getBroadphaseAabb void ( ::btMultiSapBroadphase::* )( ::btVector3 &,::btVector3 & ) const
void btMultiSapBroadphase_getBroadphaseAabb(void *c,float* p0,float* p1) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getBroadphaseAabb(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: destroyProxy void ( ::btMultiSapBroadphase::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btMultiSapBroadphase_destroyProxy(void *c,void* p0,void* p1) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->destroyProxy(tp0,tp1);
}
//attribute: ::btSapBroadphaseArray btMultiSapBroadphase->m_sapBroadphases
void btMultiSapBroadphase_m_sapBroadphases_set(void *c,void* a) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	::btSapBroadphaseArray & ta = *(::btAlignedObjectArray<btBroadphaseInterface*> *)a;
	o->m_sapBroadphases = ta;
}
void* btMultiSapBroadphase_m_sapBroadphases_get(void *c) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	return (void*)&(o->m_sapBroadphases);
}

//attribute: ::btSimpleBroadphase * btMultiSapBroadphase->m_simpleBroadphase
void btMultiSapBroadphase_m_simpleBroadphase_set(void *c,void* a) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	::btSimpleBroadphase * ta = (::btSimpleBroadphase *)a;
	o->m_simpleBroadphase = ta;
}
void* btMultiSapBroadphase_m_simpleBroadphase_get(void *c) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	return (void*)(o->m_simpleBroadphase);
}

//attribute: ::btOverlappingPairCache * btMultiSapBroadphase->m_overlappingPairs
void btMultiSapBroadphase_m_overlappingPairs_set(void *c,void* a) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	::btOverlappingPairCache * ta = (::btOverlappingPairCache *)a;
	o->m_overlappingPairs = ta;
}
void* btMultiSapBroadphase_m_overlappingPairs_get(void *c) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	return (void*)(o->m_overlappingPairs);
}

//attribute: ::btQuantizedBvh * btMultiSapBroadphase->m_optimizedAabbTree
void btMultiSapBroadphase_m_optimizedAabbTree_set(void *c,void* a) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	::btQuantizedBvh * ta = (::btQuantizedBvh *)a;
	o->m_optimizedAabbTree = ta;
}
void* btMultiSapBroadphase_m_optimizedAabbTree_get(void *c) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	return (void*)(o->m_optimizedAabbTree);
}

//attribute: bool btMultiSapBroadphase->m_ownsPairCache
void btMultiSapBroadphase_m_ownsPairCache_set(void *c,int a) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	o->m_ownsPairCache = a;
}
int btMultiSapBroadphase_m_ownsPairCache_get(void *c) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	return (int)(o->m_ownsPairCache);
}

//attribute: ::btOverlapFilterCallback * btMultiSapBroadphase->m_filterCallback
void btMultiSapBroadphase_m_filterCallback_set(void *c,void* a) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	::btOverlapFilterCallback * ta = (::btOverlapFilterCallback *)a;
	o->m_filterCallback = ta;
}
void* btMultiSapBroadphase_m_filterCallback_get(void *c) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	return (void*)(o->m_filterCallback);
}

//attribute: int btMultiSapBroadphase->m_invalidPair
void btMultiSapBroadphase_m_invalidPair_set(void *c,int a) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	o->m_invalidPair = a;
}
int btMultiSapBroadphase_m_invalidPair_get(void *c) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	return (int)(o->m_invalidPair);
}

//attribute: ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*> btMultiSapBroadphase->m_multiSapProxies
void btMultiSapBroadphase_m_multiSapProxies_set(void *c,void* a) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*> & ta = *(::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*> *)a;
	o->m_multiSapProxies = ta;
}
void* btMultiSapBroadphase_m_multiSapProxies_get(void *c) {
	::btMultiSapBroadphase *o = (::btMultiSapBroadphase*)c;
	return (void*)&(o->m_multiSapProxies);
}


// ::btMultiSapBroadphase::btMultiSapProxy
//constructor: btMultiSapProxy  ( ::btMultiSapBroadphase::btMultiSapProxy::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int ) 
void* btMultiSapBroadphase_btMultiSapProxy_new(float* p0,float* p1,int p2,void* p3,short int p4,short int p5) {
	::btMultiSapBroadphase::btMultiSapProxy *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	void * tp3 = (void *)p3;
	mem = btAlignedAlloc(sizeof(::btMultiSapBroadphase::btMultiSapProxy),16);
	o = new (mem)::btMultiSapBroadphase::btMultiSapProxy(tp0,tp1,p2,tp3,p4,p5);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return (void*)o;
}
void btMultiSapBroadphase_btMultiSapProxy_free(void *c) {
	::btMultiSapBroadphase::btMultiSapProxy *o = (::btMultiSapBroadphase::btMultiSapProxy*)c;
	delete o;
}
//attribute: ::btVector3 btMultiSapBroadphase_btMultiSapProxy->m_aabbMax
void btMultiSapBroadphase_btMultiSapProxy_m_aabbMax_set(void *c,float* a) {
	::btMultiSapBroadphase::btMultiSapProxy *o = (::btMultiSapBroadphase::btMultiSapProxy*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_aabbMax = ta;
}
void btMultiSapBroadphase_btMultiSapProxy_m_aabbMax_get(void *c,float* a) {
	::btMultiSapBroadphase::btMultiSapProxy *o = (::btMultiSapBroadphase::btMultiSapProxy*)c;
	a[0]=(o->m_aabbMax).m_floats[0];a[1]=(o->m_aabbMax).m_floats[1];a[2]=(o->m_aabbMax).m_floats[2];
}

//attribute: ::btVector3 btMultiSapBroadphase_btMultiSapProxy->m_aabbMin
void btMultiSapBroadphase_btMultiSapProxy_m_aabbMin_set(void *c,float* a) {
	::btMultiSapBroadphase::btMultiSapProxy *o = (::btMultiSapBroadphase::btMultiSapProxy*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_aabbMin = ta;
}
void btMultiSapBroadphase_btMultiSapProxy_m_aabbMin_get(void *c,float* a) {
	::btMultiSapBroadphase::btMultiSapProxy *o = (::btMultiSapBroadphase::btMultiSapProxy*)c;
	a[0]=(o->m_aabbMin).m_floats[0];a[1]=(o->m_aabbMin).m_floats[1];a[2]=(o->m_aabbMin).m_floats[2];
}

//attribute: ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*> btMultiSapBroadphase_btMultiSapProxy->m_bridgeProxies
void btMultiSapBroadphase_btMultiSapProxy_m_bridgeProxies_set(void *c,void* a) {
	::btMultiSapBroadphase::btMultiSapProxy *o = (::btMultiSapBroadphase::btMultiSapProxy*)c;
	::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*> & ta = *(::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*> *)a;
	o->m_bridgeProxies = ta;
}
void* btMultiSapBroadphase_btMultiSapProxy_m_bridgeProxies_get(void *c) {
	::btMultiSapBroadphase::btMultiSapProxy *o = (::btMultiSapBroadphase::btMultiSapProxy*)c;
	return (void*)&(o->m_bridgeProxies);
}

//attribute: int btMultiSapBroadphase_btMultiSapProxy->m_shapeType
void btMultiSapBroadphase_btMultiSapProxy_m_shapeType_set(void *c,int a) {
	::btMultiSapBroadphase::btMultiSapProxy *o = (::btMultiSapBroadphase::btMultiSapProxy*)c;
	o->m_shapeType = a;
}
int btMultiSapBroadphase_btMultiSapProxy_m_shapeType_get(void *c) {
	::btMultiSapBroadphase::btMultiSapProxy *o = (::btMultiSapBroadphase::btMultiSapProxy*)c;
	return (int)(o->m_shapeType);
}


// ::btNodeOverlapCallback
//method: processNode void ( ::btNodeOverlapCallback::* )( int,int ) 
void btNodeOverlapCallback_processNode(void *c,int p0,int p1) {
	::btNodeOverlapCallback *o = (::btNodeOverlapCallback*)c;
	o->processNode(p0,p1);
}

// ::btNullPairCache
//constructor: btNullPairCache  ( ::btNullPairCache::* )(  ) 
void* btNullPairCache_new() {
	::btNullPairCache *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btNullPairCache),16);
	o = new (mem)::btNullPairCache();
	return (void*)o;
}
void btNullPairCache_free(void *c) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	delete o;
}
//method: sortOverlappingPairs void ( ::btNullPairCache::* )( ::btDispatcher * ) 
void btNullPairCache_sortOverlappingPairs(void *c,void* p0) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->sortOverlappingPairs(tp0);
}
//method: setInternalGhostPairCallback void ( ::btNullPairCache::* )( ::btOverlappingPairCallback * ) 
void btNullPairCache_setInternalGhostPairCallback(void *c,void* p0) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	::btOverlappingPairCallback * tp0 = (::btOverlappingPairCallback *)p0;
	o->setInternalGhostPairCallback(tp0);
}
//method: addOverlappingPair ::btBroadphasePair * ( ::btNullPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void* btNullPairCache_addOverlappingPair(void *c,void* p0,void* p1) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	void* retVal = (void*) o->addOverlappingPair(tp0,tp1);
	return retVal;
}
//method: removeOverlappingPairsContainingProxy void ( ::btNullPairCache::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btNullPairCache_removeOverlappingPairsContainingProxy(void *c,void* p0,void* p1) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->removeOverlappingPairsContainingProxy(tp0,tp1);
}
//method: hasDeferredRemoval bool ( ::btNullPairCache::* )(  ) 
int btNullPairCache_hasDeferredRemoval(void *c) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	int retVal = (int)o->hasDeferredRemoval();
	return retVal;
}
//method: getOverlappingPairArray ::btBroadphasePairArray & ( ::btNullPairCache::* )(  ) 
void* btNullPairCache_getOverlappingPairArray(void *c) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	void* retVal = (void*) &(o->getOverlappingPairArray());
	return retVal;
}
//method: findPair ::btBroadphasePair * ( ::btNullPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void* btNullPairCache_findPair(void *c,void* p0,void* p1) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	void* retVal = (void*) o->findPair(tp0,tp1);
	return retVal;
}
//method: cleanProxyFromPairs void ( ::btNullPairCache::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btNullPairCache_cleanProxyFromPairs(void *c,void* p0,void* p1) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->cleanProxyFromPairs(tp0,tp1);
}
//method: cleanOverlappingPair void ( ::btNullPairCache::* )( ::btBroadphasePair &,::btDispatcher * ) 
void btNullPairCache_cleanOverlappingPair(void *c,void* p0,void* p1) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	::btBroadphasePair & tp0 = *(::btBroadphasePair *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->cleanOverlappingPair(tp0,tp1);
}
//method: getNumOverlappingPairs int ( ::btNullPairCache::* )(  ) const
int btNullPairCache_getNumOverlappingPairs(void *c) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	int retVal = (int)o->getNumOverlappingPairs();
	return retVal;
}
//method: removeOverlappingPair void * ( ::btNullPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy *,::btDispatcher * ) 
void* btNullPairCache_removeOverlappingPair(void *c,void* p0,void* p1,void* p2) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	::btDispatcher * tp2 = (::btDispatcher *)p2;
	void* retVal = (void*) o->removeOverlappingPair(tp0,tp1,tp2);
	return retVal;
}
//method: setOverlapFilterCallback void ( ::btNullPairCache::* )( ::btOverlapFilterCallback * ) 
void btNullPairCache_setOverlapFilterCallback(void *c,void* p0) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	::btOverlapFilterCallback * tp0 = (::btOverlapFilterCallback *)p0;
	o->setOverlapFilterCallback(tp0);
}
//method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btNullPairCache::* )(  ) 
void* btNullPairCache_getOverlappingPairArrayPtr(void *c) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	void* retVal = (void*) o->getOverlappingPairArrayPtr();
	return retVal;
}
//method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btNullPairCache::* )(  ) 
void* btNullPairCache_getOverlappingPairArrayPtr0(void *c) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	void* retVal = (void*) o->getOverlappingPairArrayPtr();
	return retVal;
}
//method: getOverlappingPairArrayPtr ::btBroadphasePair const * ( ::btNullPairCache::* )(  ) const
void* btNullPairCache_getOverlappingPairArrayPtr1(void *c) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	void* retVal = (void*) o->getOverlappingPairArrayPtr();
	return retVal;
}
//method: processAllOverlappingPairs void ( ::btNullPairCache::* )( ::btOverlapCallback *,::btDispatcher * ) 
void btNullPairCache_processAllOverlappingPairs(void *c,void* p0,void* p1) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	::btOverlapCallback * tp0 = (::btOverlapCallback *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->processAllOverlappingPairs(tp0,tp1);
}
//attribute: ::btBroadphasePairArray btNullPairCache->m_overlappingPairArray
void btNullPairCache_m_overlappingPairArray_set(void *c,void* a) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	::btBroadphasePairArray & ta = *(::btAlignedObjectArray<btBroadphasePair> *)a;
	o->m_overlappingPairArray = ta;
}
void* btNullPairCache_m_overlappingPairArray_get(void *c) {
	::btNullPairCache *o = (::btNullPairCache*)c;
	return (void*)&(o->m_overlappingPairArray);
}


// ::btOptimizedBvhNode
//constructor: btOptimizedBvhNode  ( ::btOptimizedBvhNode::* )(  ) 
void* btOptimizedBvhNode_new() {
	::btOptimizedBvhNode *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btOptimizedBvhNode),16);
	o = new (mem)::btOptimizedBvhNode();
	return (void*)o;
}
void btOptimizedBvhNode_free(void *c) {
	::btOptimizedBvhNode *o = (::btOptimizedBvhNode*)c;
	delete o;
}
//attribute: ::btVector3 btOptimizedBvhNode->m_aabbMaxOrg
void btOptimizedBvhNode_m_aabbMaxOrg_set(void *c,float* a) {
	::btOptimizedBvhNode *o = (::btOptimizedBvhNode*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_aabbMaxOrg = ta;
}
void btOptimizedBvhNode_m_aabbMaxOrg_get(void *c,float* a) {
	::btOptimizedBvhNode *o = (::btOptimizedBvhNode*)c;
	a[0]=(o->m_aabbMaxOrg).m_floats[0];a[1]=(o->m_aabbMaxOrg).m_floats[1];a[2]=(o->m_aabbMaxOrg).m_floats[2];
}

//attribute: ::btVector3 btOptimizedBvhNode->m_aabbMinOrg
void btOptimizedBvhNode_m_aabbMinOrg_set(void *c,float* a) {
	::btOptimizedBvhNode *o = (::btOptimizedBvhNode*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_aabbMinOrg = ta;
}
void btOptimizedBvhNode_m_aabbMinOrg_get(void *c,float* a) {
	::btOptimizedBvhNode *o = (::btOptimizedBvhNode*)c;
	a[0]=(o->m_aabbMinOrg).m_floats[0];a[1]=(o->m_aabbMinOrg).m_floats[1];a[2]=(o->m_aabbMinOrg).m_floats[2];
}

//attribute: int btOptimizedBvhNode->m_escapeIndex
void btOptimizedBvhNode_m_escapeIndex_set(void *c,int a) {
	::btOptimizedBvhNode *o = (::btOptimizedBvhNode*)c;
	o->m_escapeIndex = a;
}
int btOptimizedBvhNode_m_escapeIndex_get(void *c) {
	::btOptimizedBvhNode *o = (::btOptimizedBvhNode*)c;
	return (int)(o->m_escapeIndex);
}

//attribute: char[20] btOptimizedBvhNode->m_padding
// attribute not supported: //attribute: char[20] btOptimizedBvhNode->m_padding
//attribute: int btOptimizedBvhNode->m_subPart
void btOptimizedBvhNode_m_subPart_set(void *c,int a) {
	::btOptimizedBvhNode *o = (::btOptimizedBvhNode*)c;
	o->m_subPart = a;
}
int btOptimizedBvhNode_m_subPart_get(void *c) {
	::btOptimizedBvhNode *o = (::btOptimizedBvhNode*)c;
	return (int)(o->m_subPart);
}

//attribute: int btOptimizedBvhNode->m_triangleIndex
void btOptimizedBvhNode_m_triangleIndex_set(void *c,int a) {
	::btOptimizedBvhNode *o = (::btOptimizedBvhNode*)c;
	o->m_triangleIndex = a;
}
int btOptimizedBvhNode_m_triangleIndex_get(void *c) {
	::btOptimizedBvhNode *o = (::btOptimizedBvhNode*)c;
	return (int)(o->m_triangleIndex);
}


// ::btOptimizedBvhNodeDoubleData
//constructor: btOptimizedBvhNodeDoubleData  ( ::btOptimizedBvhNodeDoubleData::* )(  ) 
void* btOptimizedBvhNodeDoubleData_new() {
	::btOptimizedBvhNodeDoubleData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btOptimizedBvhNodeDoubleData),16);
	o = new (mem)::btOptimizedBvhNodeDoubleData();
	return (void*)o;
}
void btOptimizedBvhNodeDoubleData_free(void *c) {
	::btOptimizedBvhNodeDoubleData *o = (::btOptimizedBvhNodeDoubleData*)c;
	delete o;
}
//attribute: ::btVector3DoubleData btOptimizedBvhNodeDoubleData->m_aabbMinOrg
void btOptimizedBvhNodeDoubleData_m_aabbMinOrg_set(void *c,void* a) {
	::btOptimizedBvhNodeDoubleData *o = (::btOptimizedBvhNodeDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_aabbMinOrg = ta;
}
void* btOptimizedBvhNodeDoubleData_m_aabbMinOrg_get(void *c) {
	::btOptimizedBvhNodeDoubleData *o = (::btOptimizedBvhNodeDoubleData*)c;
	return (void*)&(o->m_aabbMinOrg);
}

//attribute: ::btVector3DoubleData btOptimizedBvhNodeDoubleData->m_aabbMaxOrg
void btOptimizedBvhNodeDoubleData_m_aabbMaxOrg_set(void *c,void* a) {
	::btOptimizedBvhNodeDoubleData *o = (::btOptimizedBvhNodeDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_aabbMaxOrg = ta;
}
void* btOptimizedBvhNodeDoubleData_m_aabbMaxOrg_get(void *c) {
	::btOptimizedBvhNodeDoubleData *o = (::btOptimizedBvhNodeDoubleData*)c;
	return (void*)&(o->m_aabbMaxOrg);
}

//attribute: int btOptimizedBvhNodeDoubleData->m_escapeIndex
void btOptimizedBvhNodeDoubleData_m_escapeIndex_set(void *c,int a) {
	::btOptimizedBvhNodeDoubleData *o = (::btOptimizedBvhNodeDoubleData*)c;
	o->m_escapeIndex = a;
}
int btOptimizedBvhNodeDoubleData_m_escapeIndex_get(void *c) {
	::btOptimizedBvhNodeDoubleData *o = (::btOptimizedBvhNodeDoubleData*)c;
	return (int)(o->m_escapeIndex);
}

//attribute: int btOptimizedBvhNodeDoubleData->m_subPart
void btOptimizedBvhNodeDoubleData_m_subPart_set(void *c,int a) {
	::btOptimizedBvhNodeDoubleData *o = (::btOptimizedBvhNodeDoubleData*)c;
	o->m_subPart = a;
}
int btOptimizedBvhNodeDoubleData_m_subPart_get(void *c) {
	::btOptimizedBvhNodeDoubleData *o = (::btOptimizedBvhNodeDoubleData*)c;
	return (int)(o->m_subPart);
}

//attribute: int btOptimizedBvhNodeDoubleData->m_triangleIndex
void btOptimizedBvhNodeDoubleData_m_triangleIndex_set(void *c,int a) {
	::btOptimizedBvhNodeDoubleData *o = (::btOptimizedBvhNodeDoubleData*)c;
	o->m_triangleIndex = a;
}
int btOptimizedBvhNodeDoubleData_m_triangleIndex_get(void *c) {
	::btOptimizedBvhNodeDoubleData *o = (::btOptimizedBvhNodeDoubleData*)c;
	return (int)(o->m_triangleIndex);
}

//attribute: char[4] btOptimizedBvhNodeDoubleData->m_pad
// attribute not supported: //attribute: char[4] btOptimizedBvhNodeDoubleData->m_pad

// ::btOptimizedBvhNodeFloatData
//constructor: btOptimizedBvhNodeFloatData  ( ::btOptimizedBvhNodeFloatData::* )(  ) 
void* btOptimizedBvhNodeFloatData_new() {
	::btOptimizedBvhNodeFloatData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btOptimizedBvhNodeFloatData),16);
	o = new (mem)::btOptimizedBvhNodeFloatData();
	return (void*)o;
}
void btOptimizedBvhNodeFloatData_free(void *c) {
	::btOptimizedBvhNodeFloatData *o = (::btOptimizedBvhNodeFloatData*)c;
	delete o;
}
//attribute: ::btVector3FloatData btOptimizedBvhNodeFloatData->m_aabbMinOrg
void btOptimizedBvhNodeFloatData_m_aabbMinOrg_set(void *c,void* a) {
	::btOptimizedBvhNodeFloatData *o = (::btOptimizedBvhNodeFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_aabbMinOrg = ta;
}
void* btOptimizedBvhNodeFloatData_m_aabbMinOrg_get(void *c) {
	::btOptimizedBvhNodeFloatData *o = (::btOptimizedBvhNodeFloatData*)c;
	return (void*)&(o->m_aabbMinOrg);
}

//attribute: ::btVector3FloatData btOptimizedBvhNodeFloatData->m_aabbMaxOrg
void btOptimizedBvhNodeFloatData_m_aabbMaxOrg_set(void *c,void* a) {
	::btOptimizedBvhNodeFloatData *o = (::btOptimizedBvhNodeFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_aabbMaxOrg = ta;
}
void* btOptimizedBvhNodeFloatData_m_aabbMaxOrg_get(void *c) {
	::btOptimizedBvhNodeFloatData *o = (::btOptimizedBvhNodeFloatData*)c;
	return (void*)&(o->m_aabbMaxOrg);
}

//attribute: int btOptimizedBvhNodeFloatData->m_escapeIndex
void btOptimizedBvhNodeFloatData_m_escapeIndex_set(void *c,int a) {
	::btOptimizedBvhNodeFloatData *o = (::btOptimizedBvhNodeFloatData*)c;
	o->m_escapeIndex = a;
}
int btOptimizedBvhNodeFloatData_m_escapeIndex_get(void *c) {
	::btOptimizedBvhNodeFloatData *o = (::btOptimizedBvhNodeFloatData*)c;
	return (int)(o->m_escapeIndex);
}

//attribute: int btOptimizedBvhNodeFloatData->m_subPart
void btOptimizedBvhNodeFloatData_m_subPart_set(void *c,int a) {
	::btOptimizedBvhNodeFloatData *o = (::btOptimizedBvhNodeFloatData*)c;
	o->m_subPart = a;
}
int btOptimizedBvhNodeFloatData_m_subPart_get(void *c) {
	::btOptimizedBvhNodeFloatData *o = (::btOptimizedBvhNodeFloatData*)c;
	return (int)(o->m_subPart);
}

//attribute: int btOptimizedBvhNodeFloatData->m_triangleIndex
void btOptimizedBvhNodeFloatData_m_triangleIndex_set(void *c,int a) {
	::btOptimizedBvhNodeFloatData *o = (::btOptimizedBvhNodeFloatData*)c;
	o->m_triangleIndex = a;
}
int btOptimizedBvhNodeFloatData_m_triangleIndex_get(void *c) {
	::btOptimizedBvhNodeFloatData *o = (::btOptimizedBvhNodeFloatData*)c;
	return (int)(o->m_triangleIndex);
}

//attribute: char[4] btOptimizedBvhNodeFloatData->m_pad
// attribute not supported: //attribute: char[4] btOptimizedBvhNodeFloatData->m_pad

// ::btOverlapCallback
//method: processOverlap bool ( ::btOverlapCallback::* )( ::btBroadphasePair & ) 
int btOverlapCallback_processOverlap(void *c,void* p0) {
	::btOverlapCallback *o = (::btOverlapCallback*)c;
	::btBroadphasePair & tp0 = *(::btBroadphasePair *)p0;
	int retVal = (int)o->processOverlap(tp0);
	return retVal;
}

// ::btOverlapFilterCallback
//method: needBroadphaseCollision bool ( ::btOverlapFilterCallback::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) const
int btOverlapFilterCallback_needBroadphaseCollision(void *c,void* p0,void* p1) {
	::btOverlapFilterCallback *o = (::btOverlapFilterCallback*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	int retVal = (int)o->needBroadphaseCollision(tp0,tp1);
	return retVal;
}

// ::btOverlappingPairCache
//method: sortOverlappingPairs void ( ::btOverlappingPairCache::* )( ::btDispatcher * ) 
void btOverlappingPairCache_sortOverlappingPairs(void *c,void* p0) {
	::btOverlappingPairCache *o = (::btOverlappingPairCache*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->sortOverlappingPairs(tp0);
}
//method: setInternalGhostPairCallback void ( ::btOverlappingPairCache::* )( ::btOverlappingPairCallback * ) 
void btOverlappingPairCache_setInternalGhostPairCallback(void *c,void* p0) {
	::btOverlappingPairCache *o = (::btOverlappingPairCache*)c;
	::btOverlappingPairCallback * tp0 = (::btOverlappingPairCallback *)p0;
	o->setInternalGhostPairCallback(tp0);
}
//method: setOverlapFilterCallback void ( ::btOverlappingPairCache::* )( ::btOverlapFilterCallback * ) 
void btOverlappingPairCache_setOverlapFilterCallback(void *c,void* p0) {
	::btOverlappingPairCache *o = (::btOverlappingPairCache*)c;
	::btOverlapFilterCallback * tp0 = (::btOverlapFilterCallback *)p0;
	o->setOverlapFilterCallback(tp0);
}
//method: getOverlappingPairArray ::btBroadphasePairArray & ( ::btOverlappingPairCache::* )(  ) 
void* btOverlappingPairCache_getOverlappingPairArray(void *c) {
	::btOverlappingPairCache *o = (::btOverlappingPairCache*)c;
	void* retVal = (void*) &(o->getOverlappingPairArray());
	return retVal;
}
//method: findPair ::btBroadphasePair * ( ::btOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void* btOverlappingPairCache_findPair(void *c,void* p0,void* p1) {
	::btOverlappingPairCache *o = (::btOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	void* retVal = (void*) o->findPair(tp0,tp1);
	return retVal;
}
//method: cleanProxyFromPairs void ( ::btOverlappingPairCache::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btOverlappingPairCache_cleanProxyFromPairs(void *c,void* p0,void* p1) {
	::btOverlappingPairCache *o = (::btOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->cleanProxyFromPairs(tp0,tp1);
}
//method: cleanOverlappingPair void ( ::btOverlappingPairCache::* )( ::btBroadphasePair &,::btDispatcher * ) 
void btOverlappingPairCache_cleanOverlappingPair(void *c,void* p0,void* p1) {
	::btOverlappingPairCache *o = (::btOverlappingPairCache*)c;
	::btBroadphasePair & tp0 = *(::btBroadphasePair *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->cleanOverlappingPair(tp0,tp1);
}
//method: getNumOverlappingPairs int ( ::btOverlappingPairCache::* )(  ) const
int btOverlappingPairCache_getNumOverlappingPairs(void *c) {
	::btOverlappingPairCache *o = (::btOverlappingPairCache*)c;
	int retVal = (int)o->getNumOverlappingPairs();
	return retVal;
}
//method: processAllOverlappingPairs void ( ::btOverlappingPairCache::* )( ::btOverlapCallback *,::btDispatcher * ) 
void btOverlappingPairCache_processAllOverlappingPairs(void *c,void* p0,void* p1) {
	::btOverlappingPairCache *o = (::btOverlappingPairCache*)c;
	::btOverlapCallback * tp0 = (::btOverlapCallback *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->processAllOverlappingPairs(tp0,tp1);
}
//method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btOverlappingPairCache::* )(  ) 
void* btOverlappingPairCache_getOverlappingPairArrayPtr(void *c) {
	::btOverlappingPairCache *o = (::btOverlappingPairCache*)c;
	void* retVal = (void*) o->getOverlappingPairArrayPtr();
	return retVal;
}
//method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btOverlappingPairCache::* )(  ) 
void* btOverlappingPairCache_getOverlappingPairArrayPtr0(void *c) {
	::btOverlappingPairCache *o = (::btOverlappingPairCache*)c;
	void* retVal = (void*) o->getOverlappingPairArrayPtr();
	return retVal;
}
//method: getOverlappingPairArrayPtr ::btBroadphasePair const * ( ::btOverlappingPairCache::* )(  ) const
void* btOverlappingPairCache_getOverlappingPairArrayPtr1(void *c) {
	::btOverlappingPairCache *o = (::btOverlappingPairCache*)c;
	void* retVal = (void*) o->getOverlappingPairArrayPtr();
	return retVal;
}
//method: hasDeferredRemoval bool ( ::btOverlappingPairCache::* )(  ) 
int btOverlappingPairCache_hasDeferredRemoval(void *c) {
	::btOverlappingPairCache *o = (::btOverlappingPairCache*)c;
	int retVal = (int)o->hasDeferredRemoval();
	return retVal;
}

// ::btOverlappingPairCallback
//method: addOverlappingPair ::btBroadphasePair * ( ::btOverlappingPairCallback::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void* btOverlappingPairCallback_addOverlappingPair(void *c,void* p0,void* p1) {
	::btOverlappingPairCallback *o = (::btOverlappingPairCallback*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	void* retVal = (void*) o->addOverlappingPair(tp0,tp1);
	return retVal;
}
//method: removeOverlappingPair void * ( ::btOverlappingPairCallback::* )( ::btBroadphaseProxy *,::btBroadphaseProxy *,::btDispatcher * ) 
void* btOverlappingPairCallback_removeOverlappingPair(void *c,void* p0,void* p1,void* p2) {
	::btOverlappingPairCallback *o = (::btOverlappingPairCallback*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	::btDispatcher * tp2 = (::btDispatcher *)p2;
	void* retVal = (void*) o->removeOverlappingPair(tp0,tp1,tp2);
	return retVal;
}
//method: removeOverlappingPairsContainingProxy void ( ::btOverlappingPairCallback::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btOverlappingPairCallback_removeOverlappingPairsContainingProxy(void *c,void* p0,void* p1) {
	::btOverlappingPairCallback *o = (::btOverlappingPairCallback*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->removeOverlappingPairsContainingProxy(tp0,tp1);
}

// ::btQuantizedBvh
//constructor: btQuantizedBvh  ( ::btQuantizedBvh::* )(  ) 
void* btQuantizedBvh_new0() {
	::btQuantizedBvh *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btQuantizedBvh),16);
	o = new (mem)::btQuantizedBvh();
	return (void*)o;
}
//constructor: btQuantizedBvh  ( ::btQuantizedBvh::* )( ::btQuantizedBvh &,bool ) 
void* btQuantizedBvh_new1(void* p0,int p1) {
	::btQuantizedBvh *o = 0;
	 void *mem = 0;
	::btQuantizedBvh & tp0 = *(::btQuantizedBvh *)p0;
	mem = btAlignedAlloc(sizeof(::btQuantizedBvh),16);
	o = new (mem)::btQuantizedBvh(tp0,p1);
	return (void*)o;
}
void btQuantizedBvh_free(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	delete o;
}
//method: calcSplittingAxis int ( ::btQuantizedBvh::* )( int,int ) 
int btQuantizedBvh_calcSplittingAxis(void *c,int p0,int p1) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	int retVal = (int)o->calcSplittingAxis(p0,p1);
	return retVal;
}
//method: buildInternal void ( ::btQuantizedBvh::* )(  ) 
void btQuantizedBvh_buildInternal(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	o->buildInternal();
}
//method: serialize bool ( ::btQuantizedBvh::* )( void *,unsigned int,bool ) const
int btQuantizedBvh_serialize(void *c,void* p0,unsigned int p1,int p2) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	void * tp0 = (void *)p0;
	int retVal = (int)o->serialize(tp0,p1,p2);
	return retVal;
}
//method: serialize bool ( ::btQuantizedBvh::* )( void *,unsigned int,bool ) const
int btQuantizedBvh_serialize0(void *c,void* p0,unsigned int p1,int p2) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	void * tp0 = (void *)p0;
	int retVal = (int)o->serialize(tp0,p1,p2);
	return retVal;
}
//method: serialize char const * ( ::btQuantizedBvh::* )( void *,::btSerializer * ) const
char const * btQuantizedBvh_serialize1(void *c,void* p0,void* p1) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: deSerializeDouble void ( ::btQuantizedBvh::* )( ::btQuantizedBvhDoubleData & ) 
void btQuantizedBvh_deSerializeDouble(void *c,void* p0) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	::btQuantizedBvhDoubleData & tp0 = *(::btQuantizedBvhDoubleData *)p0;
	o->deSerializeDouble(tp0);
}
//method: setQuantizationValues void ( ::btQuantizedBvh::* )( ::btVector3 const &,::btVector3 const &,::btScalar ) 
void btQuantizedBvh_setQuantizationValues(void *c,float* p0,float* p1,float p2) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->setQuantizationValues(tp0,tp1,p2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: deSerializeFloat void ( ::btQuantizedBvh::* )( ::btQuantizedBvhFloatData & ) 
void btQuantizedBvh_deSerializeFloat(void *c,void* p0) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	::btQuantizedBvhFloatData & tp0 = *(::btQuantizedBvhFloatData *)p0;
	o->deSerializeFloat(tp0);
}
//not supported method: setTraversalMode void ( ::btQuantizedBvh::* )( ::btQuantizedBvh::btTraversalMode ) 
// error:  - unsupported, void - ok

//method: setInternalNodeAabbMin void ( ::btQuantizedBvh::* )( int,::btVector3 const & ) 
void btQuantizedBvh_setInternalNodeAabbMin(void *c,int p0,float* p1) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->setInternalNodeAabbMin(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: isQuantized bool ( ::btQuantizedBvh::* )(  ) 
int btQuantizedBvh_isQuantized(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	int retVal = (int)o->isQuantized();
	return retVal;
}
//method: getAlignmentSerializationPadding unsigned int (*)(  )
unsigned int btQuantizedBvh_getAlignmentSerializationPadding() {
	unsigned int retVal = (unsigned int)::btQuantizedBvh::getAlignmentSerializationPadding();
	return retVal;
}
//method: calculateSerializeBufferSize unsigned int ( ::btQuantizedBvh::* )(  ) const
unsigned int btQuantizedBvh_calculateSerializeBufferSize(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	unsigned int retVal = (unsigned int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: sortAndCalcSplittingIndex int ( ::btQuantizedBvh::* )( int,int,int ) 
int btQuantizedBvh_sortAndCalcSplittingIndex(void *c,int p0,int p1,int p2) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	int retVal = (int)o->sortAndCalcSplittingIndex(p0,p1,p2);
	return retVal;
}
//method: reportAabbOverlappingNodex void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,::btVector3 const &,::btVector3 const & ) const
void btQuantizedBvh_reportAabbOverlappingNodex(void *c,void* p0,float* p1,float* p2) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	::btNodeOverlapCallback * tp0 = (::btNodeOverlapCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->reportAabbOverlappingNodex(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: swapLeafNodes void ( ::btQuantizedBvh::* )( int,int ) 
void btQuantizedBvh_swapLeafNodes(void *c,int p0,int p1) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	o->swapLeafNodes(p0,p1);
}
//method: getQuantizedNodeArray ::QuantizedNodeArray & ( ::btQuantizedBvh::* )(  ) 
void* btQuantizedBvh_getQuantizedNodeArray(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	void* retVal = (void*) &(o->getQuantizedNodeArray());
	return retVal;
}
//method: buildTree void ( ::btQuantizedBvh::* )( int,int ) 
void btQuantizedBvh_buildTree(void *c,int p0,int p1) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	o->buildTree(p0,p1);
}
//not supported method: walkStacklessQuantizedTreeCacheFriendly void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,short unsigned int *,short unsigned int * ) const
// error: ::btNodeOverlapCallback * - ok,  - unsupported,  - unsupported, void - ok

//method: reportRayOverlappingNodex void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,::btVector3 const &,::btVector3 const & ) const
void btQuantizedBvh_reportRayOverlappingNodex(void *c,void* p0,float* p1,float* p2) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	::btNodeOverlapCallback * tp0 = (::btNodeOverlapCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->reportRayOverlappingNodex(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: walkStacklessTree void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,::btVector3 const &,::btVector3 const & ) const
void btQuantizedBvh_walkStacklessTree(void *c,void* p0,float* p1,float* p2) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	::btNodeOverlapCallback * tp0 = (::btNodeOverlapCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->walkStacklessTree(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: walkStacklessQuantizedTreeAgainstRay void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,int,int ) const
void btQuantizedBvh_walkStacklessQuantizedTreeAgainstRay(void *c,void* p0,float* p1,float* p2,float* p3,float* p4,int p5,int p6) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	::btNodeOverlapCallback * tp0 = (::btNodeOverlapCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->walkStacklessQuantizedTreeAgainstRay(tp0,tp1,tp2,tp3,tp4,p5,p6);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: updateSubtreeHeaders void ( ::btQuantizedBvh::* )( int,int ) 
void btQuantizedBvh_updateSubtreeHeaders(void *c,int p0,int p1) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	o->updateSubtreeHeaders(p0,p1);
}
//method: deSerializeInPlace ::btQuantizedBvh * (*)( void *,unsigned int,bool )
void* btQuantizedBvh_deSerializeInPlace(void* p0,unsigned int p1,int p2) {
	void * tp0 = (void *)p0;
	void* retVal = (void*) ::btQuantizedBvh::deSerializeInPlace(tp0,p1,p2);
	return retVal;
}
//method: mergeInternalNodeAabb void ( ::btQuantizedBvh::* )( int,::btVector3 const &,::btVector3 const & ) 
void btQuantizedBvh_mergeInternalNodeAabb(void *c,int p0,float* p1,float* p2) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->mergeInternalNodeAabb(p0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//not supported method: quantizeWithClamp void ( ::btQuantizedBvh::* )( short unsigned int *,::btVector3 const &,int ) const
// error:  - unsupported, ::btVector3 const & - ok, int - ok, void - ok

//method: getAabbMin ::btVector3 ( ::btQuantizedBvh::* )( int ) const
void btQuantizedBvh_getAabbMin(void *c,int p0,float* ret) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAabbMin(p0);
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: walkStacklessTreeAgainstRay void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,int,int ) const
void btQuantizedBvh_walkStacklessTreeAgainstRay(void *c,void* p0,float* p1,float* p2,float* p3,float* p4,int p5,int p6) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	::btNodeOverlapCallback * tp0 = (::btNodeOverlapCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->walkStacklessTreeAgainstRay(tp0,tp1,tp2,tp3,tp4,p5,p6);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//not supported method: walkRecursiveQuantizedTreeAgainstQueryAabb void ( ::btQuantizedBvh::* )( ::btQuantizedBvhNode const *,::btNodeOverlapCallback *,short unsigned int *,short unsigned int * ) const
// error: ::btQuantizedBvhNode const * - ok, ::btNodeOverlapCallback * - ok,  - unsupported,  - unsupported, void - ok

//method: getLeafNodeArray ::QuantizedNodeArray & ( ::btQuantizedBvh::* )(  ) 
void* btQuantizedBvh_getLeafNodeArray(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	void* retVal = (void*) &(o->getLeafNodeArray());
	return retVal;
}
//method: calculateSerializeBufferSizeNew int ( ::btQuantizedBvh::* )(  ) const
int btQuantizedBvh_calculateSerializeBufferSizeNew(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	int retVal = (int)o->calculateSerializeBufferSizeNew();
	return retVal;
}
//method: setInternalNodeEscapeIndex void ( ::btQuantizedBvh::* )( int,int ) 
void btQuantizedBvh_setInternalNodeEscapeIndex(void *c,int p0,int p1) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	o->setInternalNodeEscapeIndex(p0,p1);
}
//method: getAabbMax ::btVector3 ( ::btQuantizedBvh::* )( int ) const
void btQuantizedBvh_getAabbMax(void *c,int p0,float* ret) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAabbMax(p0);
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//not supported method: quantize void ( ::btQuantizedBvh::* )( short unsigned int *,::btVector3 const &,int ) const
// error:  - unsupported, ::btVector3 const & - ok, int - ok, void - ok

//method: getSubtreeInfoArray ::BvhSubtreeInfoArray & ( ::btQuantizedBvh::* )(  ) 
void* btQuantizedBvh_getSubtreeInfoArray(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	void* retVal = (void*) &(o->getSubtreeInfoArray());
	return retVal;
}
//method: setInternalNodeAabbMax void ( ::btQuantizedBvh::* )( int,::btVector3 const & ) 
void btQuantizedBvh_setInternalNodeAabbMax(void *c,int p0,float* p1) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->setInternalNodeAabbMax(p0,tp1);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//not supported method: unQuantize ::btVector3 ( ::btQuantizedBvh::* )( short unsigned int const * ) const
// error:  - unsupported, ::btVector3 - ok

//method: reportBoxCastOverlappingNodex void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) const
void btQuantizedBvh_reportBoxCastOverlappingNodex(void *c,void* p0,float* p1,float* p2,float* p3,float* p4) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	::btNodeOverlapCallback * tp0 = (::btNodeOverlapCallback *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->reportBoxCastOverlappingNodex(tp0,tp1,tp2,tp3,tp4);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//not supported method: walkStacklessQuantizedTree void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,short unsigned int *,short unsigned int *,int,int ) const
// error: ::btNodeOverlapCallback * - ok,  - unsupported,  - unsupported, int - ok, int - ok, void - ok

//method: assignInternalNodeFromLeafNode void ( ::btQuantizedBvh::* )( int,int ) 
void btQuantizedBvh_assignInternalNodeFromLeafNode(void *c,int p0,int p1) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	o->assignInternalNodeFromLeafNode(p0,p1);
}
//attribute: ::BvhSubtreeInfoArray btQuantizedBvh->m_SubtreeHeaders
void btQuantizedBvh_m_SubtreeHeaders_set(void *c,void* a) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	::BvhSubtreeInfoArray & ta = *(::btAlignedObjectArray<btBvhSubtreeInfo> *)a;
	o->m_SubtreeHeaders = ta;
}
void* btQuantizedBvh_m_SubtreeHeaders_get(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	return (void*)&(o->m_SubtreeHeaders);
}

//attribute: int btQuantizedBvh->m_bulletVersion
void btQuantizedBvh_m_bulletVersion_set(void *c,int a) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	o->m_bulletVersion = a;
}
int btQuantizedBvh_m_bulletVersion_get(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	return (int)(o->m_bulletVersion);
}

//attribute: ::btVector3 btQuantizedBvh->m_bvhAabbMax
void btQuantizedBvh_m_bvhAabbMax_set(void *c,float* a) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_bvhAabbMax = ta;
}
void btQuantizedBvh_m_bvhAabbMax_get(void *c,float* a) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	a[0]=(o->m_bvhAabbMax).m_floats[0];a[1]=(o->m_bvhAabbMax).m_floats[1];a[2]=(o->m_bvhAabbMax).m_floats[2];
}

//attribute: ::btVector3 btQuantizedBvh->m_bvhAabbMin
void btQuantizedBvh_m_bvhAabbMin_set(void *c,float* a) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_bvhAabbMin = ta;
}
void btQuantizedBvh_m_bvhAabbMin_get(void *c,float* a) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	a[0]=(o->m_bvhAabbMin).m_floats[0];a[1]=(o->m_bvhAabbMin).m_floats[1];a[2]=(o->m_bvhAabbMin).m_floats[2];
}

//attribute: ::btVector3 btQuantizedBvh->m_bvhQuantization
void btQuantizedBvh_m_bvhQuantization_set(void *c,float* a) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_bvhQuantization = ta;
}
void btQuantizedBvh_m_bvhQuantization_get(void *c,float* a) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	a[0]=(o->m_bvhQuantization).m_floats[0];a[1]=(o->m_bvhQuantization).m_floats[1];a[2]=(o->m_bvhQuantization).m_floats[2];
}

//attribute: ::NodeArray btQuantizedBvh->m_contiguousNodes
void btQuantizedBvh_m_contiguousNodes_set(void *c,void* a) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	::NodeArray & ta = *(::btAlignedObjectArray<btOptimizedBvhNode> *)a;
	o->m_contiguousNodes = ta;
}
void* btQuantizedBvh_m_contiguousNodes_get(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	return (void*)&(o->m_contiguousNodes);
}

//attribute: int btQuantizedBvh->m_curNodeIndex
void btQuantizedBvh_m_curNodeIndex_set(void *c,int a) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	o->m_curNodeIndex = a;
}
int btQuantizedBvh_m_curNodeIndex_get(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	return (int)(o->m_curNodeIndex);
}

//attribute: ::NodeArray btQuantizedBvh->m_leafNodes
void btQuantizedBvh_m_leafNodes_set(void *c,void* a) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	::NodeArray & ta = *(::btAlignedObjectArray<btOptimizedBvhNode> *)a;
	o->m_leafNodes = ta;
}
void* btQuantizedBvh_m_leafNodes_get(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	return (void*)&(o->m_leafNodes);
}

//attribute: ::QuantizedNodeArray btQuantizedBvh->m_quantizedContiguousNodes
void btQuantizedBvh_m_quantizedContiguousNodes_set(void *c,void* a) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	::QuantizedNodeArray & ta = *(::btAlignedObjectArray<btQuantizedBvhNode> *)a;
	o->m_quantizedContiguousNodes = ta;
}
void* btQuantizedBvh_m_quantizedContiguousNodes_get(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	return (void*)&(o->m_quantizedContiguousNodes);
}

//attribute: ::QuantizedNodeArray btQuantizedBvh->m_quantizedLeafNodes
void btQuantizedBvh_m_quantizedLeafNodes_set(void *c,void* a) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	::QuantizedNodeArray & ta = *(::btAlignedObjectArray<btQuantizedBvhNode> *)a;
	o->m_quantizedLeafNodes = ta;
}
void* btQuantizedBvh_m_quantizedLeafNodes_get(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	return (void*)&(o->m_quantizedLeafNodes);
}

//attribute: int btQuantizedBvh->m_subtreeHeaderCount
void btQuantizedBvh_m_subtreeHeaderCount_set(void *c,int a) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	o->m_subtreeHeaderCount = a;
}
int btQuantizedBvh_m_subtreeHeaderCount_get(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	return (int)(o->m_subtreeHeaderCount);
}

//attribute: ::btQuantizedBvh::btTraversalMode btQuantizedBvh->m_traversalMode
// attribute not supported: //attribute: ::btQuantizedBvh::btTraversalMode btQuantizedBvh->m_traversalMode
//attribute: bool btQuantizedBvh->m_useQuantization
void btQuantizedBvh_m_useQuantization_set(void *c,int a) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	o->m_useQuantization = a;
}
int btQuantizedBvh_m_useQuantization_get(void *c) {
	::btQuantizedBvh *o = (::btQuantizedBvh*)c;
	return (int)(o->m_useQuantization);
}


// ::btQuantizedBvhDoubleData
//constructor: btQuantizedBvhDoubleData  ( ::btQuantizedBvhDoubleData::* )(  ) 
void* btQuantizedBvhDoubleData_new() {
	::btQuantizedBvhDoubleData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btQuantizedBvhDoubleData),16);
	o = new (mem)::btQuantizedBvhDoubleData();
	return (void*)o;
}
void btQuantizedBvhDoubleData_free(void *c) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	delete o;
}
//attribute: ::btVector3DoubleData btQuantizedBvhDoubleData->m_bvhAabbMax
void btQuantizedBvhDoubleData_m_bvhAabbMax_set(void *c,void* a) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_bvhAabbMax = ta;
}
void* btQuantizedBvhDoubleData_m_bvhAabbMax_get(void *c) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	return (void*)&(o->m_bvhAabbMax);
}

//attribute: ::btVector3DoubleData btQuantizedBvhDoubleData->m_bvhAabbMin
void btQuantizedBvhDoubleData_m_bvhAabbMin_set(void *c,void* a) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_bvhAabbMin = ta;
}
void* btQuantizedBvhDoubleData_m_bvhAabbMin_get(void *c) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	return (void*)&(o->m_bvhAabbMin);
}

//attribute: ::btVector3DoubleData btQuantizedBvhDoubleData->m_bvhQuantization
void btQuantizedBvhDoubleData_m_bvhQuantization_set(void *c,void* a) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_bvhQuantization = ta;
}
void* btQuantizedBvhDoubleData_m_bvhQuantization_get(void *c) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	return (void*)&(o->m_bvhQuantization);
}

//attribute: ::btOptimizedBvhNodeDoubleData * btQuantizedBvhDoubleData->m_contiguousNodesPtr
void btQuantizedBvhDoubleData_m_contiguousNodesPtr_set(void *c,void* a) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	::btOptimizedBvhNodeDoubleData * ta = (::btOptimizedBvhNodeDoubleData *)a;
	o->m_contiguousNodesPtr = ta;
}
void* btQuantizedBvhDoubleData_m_contiguousNodesPtr_get(void *c) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	return (void*)(o->m_contiguousNodesPtr);
}

//attribute: int btQuantizedBvhDoubleData->m_curNodeIndex
void btQuantizedBvhDoubleData_m_curNodeIndex_set(void *c,int a) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	o->m_curNodeIndex = a;
}
int btQuantizedBvhDoubleData_m_curNodeIndex_get(void *c) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	return (int)(o->m_curNodeIndex);
}

//attribute: int btQuantizedBvhDoubleData->m_numContiguousLeafNodes
void btQuantizedBvhDoubleData_m_numContiguousLeafNodes_set(void *c,int a) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	o->m_numContiguousLeafNodes = a;
}
int btQuantizedBvhDoubleData_m_numContiguousLeafNodes_get(void *c) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	return (int)(o->m_numContiguousLeafNodes);
}

//attribute: int btQuantizedBvhDoubleData->m_numQuantizedContiguousNodes
void btQuantizedBvhDoubleData_m_numQuantizedContiguousNodes_set(void *c,int a) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	o->m_numQuantizedContiguousNodes = a;
}
int btQuantizedBvhDoubleData_m_numQuantizedContiguousNodes_get(void *c) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	return (int)(o->m_numQuantizedContiguousNodes);
}

//attribute: int btQuantizedBvhDoubleData->m_numSubtreeHeaders
void btQuantizedBvhDoubleData_m_numSubtreeHeaders_set(void *c,int a) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	o->m_numSubtreeHeaders = a;
}
int btQuantizedBvhDoubleData_m_numSubtreeHeaders_get(void *c) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	return (int)(o->m_numSubtreeHeaders);
}

//attribute: ::btQuantizedBvhNodeData * btQuantizedBvhDoubleData->m_quantizedContiguousNodesPtr
void btQuantizedBvhDoubleData_m_quantizedContiguousNodesPtr_set(void *c,void* a) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	::btQuantizedBvhNodeData * ta = (::btQuantizedBvhNodeData *)a;
	o->m_quantizedContiguousNodesPtr = ta;
}
void* btQuantizedBvhDoubleData_m_quantizedContiguousNodesPtr_get(void *c) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	return (void*)(o->m_quantizedContiguousNodesPtr);
}

//attribute: ::btBvhSubtreeInfoData * btQuantizedBvhDoubleData->m_subTreeInfoPtr
void btQuantizedBvhDoubleData_m_subTreeInfoPtr_set(void *c,void* a) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	::btBvhSubtreeInfoData * ta = (::btBvhSubtreeInfoData *)a;
	o->m_subTreeInfoPtr = ta;
}
void* btQuantizedBvhDoubleData_m_subTreeInfoPtr_get(void *c) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	return (void*)(o->m_subTreeInfoPtr);
}

//attribute: int btQuantizedBvhDoubleData->m_traversalMode
void btQuantizedBvhDoubleData_m_traversalMode_set(void *c,int a) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	o->m_traversalMode = a;
}
int btQuantizedBvhDoubleData_m_traversalMode_get(void *c) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	return (int)(o->m_traversalMode);
}

//attribute: int btQuantizedBvhDoubleData->m_useQuantization
void btQuantizedBvhDoubleData_m_useQuantization_set(void *c,int a) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	o->m_useQuantization = a;
}
int btQuantizedBvhDoubleData_m_useQuantization_get(void *c) {
	::btQuantizedBvhDoubleData *o = (::btQuantizedBvhDoubleData*)c;
	return (int)(o->m_useQuantization);
}


// ::btQuantizedBvhFloatData
//constructor: btQuantizedBvhFloatData  ( ::btQuantizedBvhFloatData::* )(  ) 
void* btQuantizedBvhFloatData_new() {
	::btQuantizedBvhFloatData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btQuantizedBvhFloatData),16);
	o = new (mem)::btQuantizedBvhFloatData();
	return (void*)o;
}
void btQuantizedBvhFloatData_free(void *c) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	delete o;
}
//attribute: ::btVector3FloatData btQuantizedBvhFloatData->m_bvhAabbMax
void btQuantizedBvhFloatData_m_bvhAabbMax_set(void *c,void* a) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_bvhAabbMax = ta;
}
void* btQuantizedBvhFloatData_m_bvhAabbMax_get(void *c) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	return (void*)&(o->m_bvhAabbMax);
}

//attribute: ::btVector3FloatData btQuantizedBvhFloatData->m_bvhAabbMin
void btQuantizedBvhFloatData_m_bvhAabbMin_set(void *c,void* a) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_bvhAabbMin = ta;
}
void* btQuantizedBvhFloatData_m_bvhAabbMin_get(void *c) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	return (void*)&(o->m_bvhAabbMin);
}

//attribute: ::btVector3FloatData btQuantizedBvhFloatData->m_bvhQuantization
void btQuantizedBvhFloatData_m_bvhQuantization_set(void *c,void* a) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_bvhQuantization = ta;
}
void* btQuantizedBvhFloatData_m_bvhQuantization_get(void *c) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	return (void*)&(o->m_bvhQuantization);
}

//attribute: ::btOptimizedBvhNodeFloatData * btQuantizedBvhFloatData->m_contiguousNodesPtr
void btQuantizedBvhFloatData_m_contiguousNodesPtr_set(void *c,void* a) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	::btOptimizedBvhNodeFloatData * ta = (::btOptimizedBvhNodeFloatData *)a;
	o->m_contiguousNodesPtr = ta;
}
void* btQuantizedBvhFloatData_m_contiguousNodesPtr_get(void *c) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	return (void*)(o->m_contiguousNodesPtr);
}

//attribute: int btQuantizedBvhFloatData->m_curNodeIndex
void btQuantizedBvhFloatData_m_curNodeIndex_set(void *c,int a) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	o->m_curNodeIndex = a;
}
int btQuantizedBvhFloatData_m_curNodeIndex_get(void *c) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	return (int)(o->m_curNodeIndex);
}

//attribute: int btQuantizedBvhFloatData->m_numContiguousLeafNodes
void btQuantizedBvhFloatData_m_numContiguousLeafNodes_set(void *c,int a) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	o->m_numContiguousLeafNodes = a;
}
int btQuantizedBvhFloatData_m_numContiguousLeafNodes_get(void *c) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	return (int)(o->m_numContiguousLeafNodes);
}

//attribute: int btQuantizedBvhFloatData->m_numQuantizedContiguousNodes
void btQuantizedBvhFloatData_m_numQuantizedContiguousNodes_set(void *c,int a) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	o->m_numQuantizedContiguousNodes = a;
}
int btQuantizedBvhFloatData_m_numQuantizedContiguousNodes_get(void *c) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	return (int)(o->m_numQuantizedContiguousNodes);
}

//attribute: int btQuantizedBvhFloatData->m_numSubtreeHeaders
void btQuantizedBvhFloatData_m_numSubtreeHeaders_set(void *c,int a) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	o->m_numSubtreeHeaders = a;
}
int btQuantizedBvhFloatData_m_numSubtreeHeaders_get(void *c) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	return (int)(o->m_numSubtreeHeaders);
}

//attribute: ::btQuantizedBvhNodeData * btQuantizedBvhFloatData->m_quantizedContiguousNodesPtr
void btQuantizedBvhFloatData_m_quantizedContiguousNodesPtr_set(void *c,void* a) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	::btQuantizedBvhNodeData * ta = (::btQuantizedBvhNodeData *)a;
	o->m_quantizedContiguousNodesPtr = ta;
}
void* btQuantizedBvhFloatData_m_quantizedContiguousNodesPtr_get(void *c) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	return (void*)(o->m_quantizedContiguousNodesPtr);
}

//attribute: ::btBvhSubtreeInfoData * btQuantizedBvhFloatData->m_subTreeInfoPtr
void btQuantizedBvhFloatData_m_subTreeInfoPtr_set(void *c,void* a) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	::btBvhSubtreeInfoData * ta = (::btBvhSubtreeInfoData *)a;
	o->m_subTreeInfoPtr = ta;
}
void* btQuantizedBvhFloatData_m_subTreeInfoPtr_get(void *c) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	return (void*)(o->m_subTreeInfoPtr);
}

//attribute: int btQuantizedBvhFloatData->m_traversalMode
void btQuantizedBvhFloatData_m_traversalMode_set(void *c,int a) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	o->m_traversalMode = a;
}
int btQuantizedBvhFloatData_m_traversalMode_get(void *c) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	return (int)(o->m_traversalMode);
}

//attribute: int btQuantizedBvhFloatData->m_useQuantization
void btQuantizedBvhFloatData_m_useQuantization_set(void *c,int a) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	o->m_useQuantization = a;
}
int btQuantizedBvhFloatData_m_useQuantization_get(void *c) {
	::btQuantizedBvhFloatData *o = (::btQuantizedBvhFloatData*)c;
	return (int)(o->m_useQuantization);
}


// ::btQuantizedBvhNode
//constructor: btQuantizedBvhNode  ( ::btQuantizedBvhNode::* )(  ) 
void* btQuantizedBvhNode_new() {
	::btQuantizedBvhNode *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btQuantizedBvhNode),16);
	o = new (mem)::btQuantizedBvhNode();
	return (void*)o;
}
void btQuantizedBvhNode_free(void *c) {
	::btQuantizedBvhNode *o = (::btQuantizedBvhNode*)c;
	delete o;
}
//method: getEscapeIndex int ( ::btQuantizedBvhNode::* )(  ) const
int btQuantizedBvhNode_getEscapeIndex(void *c) {
	::btQuantizedBvhNode *o = (::btQuantizedBvhNode*)c;
	int retVal = (int)o->getEscapeIndex();
	return retVal;
}
//method: getTriangleIndex int ( ::btQuantizedBvhNode::* )(  ) const
int btQuantizedBvhNode_getTriangleIndex(void *c) {
	::btQuantizedBvhNode *o = (::btQuantizedBvhNode*)c;
	int retVal = (int)o->getTriangleIndex();
	return retVal;
}
//method: getPartId int ( ::btQuantizedBvhNode::* )(  ) const
int btQuantizedBvhNode_getPartId(void *c) {
	::btQuantizedBvhNode *o = (::btQuantizedBvhNode*)c;
	int retVal = (int)o->getPartId();
	return retVal;
}
//method: isLeafNode bool ( ::btQuantizedBvhNode::* )(  ) const
int btQuantizedBvhNode_isLeafNode(void *c) {
	::btQuantizedBvhNode *o = (::btQuantizedBvhNode*)c;
	int retVal = (int)o->isLeafNode();
	return retVal;
}
//attribute: int btQuantizedBvhNode->m_escapeIndexOrTriangleIndex
void btQuantizedBvhNode_m_escapeIndexOrTriangleIndex_set(void *c,int a) {
	::btQuantizedBvhNode *o = (::btQuantizedBvhNode*)c;
	o->m_escapeIndexOrTriangleIndex = a;
}
int btQuantizedBvhNode_m_escapeIndexOrTriangleIndex_get(void *c) {
	::btQuantizedBvhNode *o = (::btQuantizedBvhNode*)c;
	return (int)(o->m_escapeIndexOrTriangleIndex);
}

//attribute: short unsigned int[3] btQuantizedBvhNode->m_quantizedAabbMax
// attribute not supported: //attribute: short unsigned int[3] btQuantizedBvhNode->m_quantizedAabbMax
//attribute: short unsigned int[3] btQuantizedBvhNode->m_quantizedAabbMin
// attribute not supported: //attribute: short unsigned int[3] btQuantizedBvhNode->m_quantizedAabbMin

// ::btQuantizedBvhNodeData
//constructor: btQuantizedBvhNodeData  ( ::btQuantizedBvhNodeData::* )(  ) 
void* btQuantizedBvhNodeData_new() {
	::btQuantizedBvhNodeData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btQuantizedBvhNodeData),16);
	o = new (mem)::btQuantizedBvhNodeData();
	return (void*)o;
}
void btQuantizedBvhNodeData_free(void *c) {
	::btQuantizedBvhNodeData *o = (::btQuantizedBvhNodeData*)c;
	delete o;
}
//attribute: int btQuantizedBvhNodeData->m_escapeIndexOrTriangleIndex
void btQuantizedBvhNodeData_m_escapeIndexOrTriangleIndex_set(void *c,int a) {
	::btQuantizedBvhNodeData *o = (::btQuantizedBvhNodeData*)c;
	o->m_escapeIndexOrTriangleIndex = a;
}
int btQuantizedBvhNodeData_m_escapeIndexOrTriangleIndex_get(void *c) {
	::btQuantizedBvhNodeData *o = (::btQuantizedBvhNodeData*)c;
	return (int)(o->m_escapeIndexOrTriangleIndex);
}

//attribute: short unsigned int[3] btQuantizedBvhNodeData->m_quantizedAabbMax
// attribute not supported: //attribute: short unsigned int[3] btQuantizedBvhNodeData->m_quantizedAabbMax
//attribute: short unsigned int[3] btQuantizedBvhNodeData->m_quantizedAabbMin
// attribute not supported: //attribute: short unsigned int[3] btQuantizedBvhNodeData->m_quantizedAabbMin

// ::btSimpleBroadphase
//constructor: btSimpleBroadphase  ( ::btSimpleBroadphase::* )( int,::btOverlappingPairCache * ) 
void* btSimpleBroadphase_new(int p0,void* p1) {
	::btSimpleBroadphase *o = 0;
	 void *mem = 0;
	::btOverlappingPairCache * tp1 = (::btOverlappingPairCache *)p1;
	mem = btAlignedAlloc(sizeof(::btSimpleBroadphase),16);
	o = new (mem)::btSimpleBroadphase(p0,tp1);
	return (void*)o;
}
void btSimpleBroadphase_free(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	delete o;
}
//method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btSimpleBroadphase::* )(  ) 
void* btSimpleBroadphase_getOverlappingPairCache(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btSimpleBroadphase::* )(  ) 
void* btSimpleBroadphase_getOverlappingPairCache0(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: getOverlappingPairCache ::btOverlappingPairCache const * ( ::btSimpleBroadphase::* )(  ) const
void* btSimpleBroadphase_getOverlappingPairCache1(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: rayTest void ( ::btSimpleBroadphase::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseRayCallback &,::btVector3 const &,::btVector3 const & ) 
void btSimpleBroadphase_rayTest(void *c,float* p0,float* p1,void* p2,float* p3,float* p4) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btBroadphaseRayCallback & tp2 = *(::btBroadphaseRayCallback *)p2;
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	o->rayTest(tp0,tp1,tp2,tp3,tp4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
}
//method: setAabb void ( ::btSimpleBroadphase::* )( ::btBroadphaseProxy *,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btSimpleBroadphase_setAabb(void *c,void* p0,float* p1,float* p2,void* p3) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	::btDispatcher * tp3 = (::btDispatcher *)p3;
	o->setAabb(tp0,tp1,tp2,tp3);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: allocHandle int ( ::btSimpleBroadphase::* )(  ) 
int btSimpleBroadphase_allocHandle(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	int retVal = (int)o->allocHandle();
	return retVal;
}
//method: resetPool void ( ::btSimpleBroadphase::* )( ::btDispatcher * ) 
void btSimpleBroadphase_resetPool(void *c,void* p0) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->resetPool(tp0);
}
//method: testAabbOverlap bool ( ::btSimpleBroadphase::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
int btSimpleBroadphase_testAabbOverlap(void *c,void* p0,void* p1) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	int retVal = (int)o->testAabbOverlap(tp0,tp1);
	return retVal;
}
//method: calculateOverlappingPairs void ( ::btSimpleBroadphase::* )( ::btDispatcher * ) 
void btSimpleBroadphase_calculateOverlappingPairs(void *c,void* p0) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->calculateOverlappingPairs(tp0);
}
//method: freeHandle void ( ::btSimpleBroadphase::* )( ::btSimpleBroadphaseProxy * ) 
void btSimpleBroadphase_freeHandle(void *c,void* p0) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	::btSimpleBroadphaseProxy * tp0 = (::btSimpleBroadphaseProxy *)p0;
	o->freeHandle(tp0);
}
//method: printStats void ( ::btSimpleBroadphase::* )(  ) 
void btSimpleBroadphase_printStats(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	o->printStats();
}
//method: getAabb void ( ::btSimpleBroadphase::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
void btSimpleBroadphase_getAabb(void *c,void* p0,float* p1,float* p2) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->getAabb(tp0,tp1,tp2);
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: aabbTest void ( ::btSimpleBroadphase::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseAabbCallback & ) 
void btSimpleBroadphase_aabbTest(void *c,float* p0,float* p1,void* p2) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btBroadphaseAabbCallback & tp2 = *(::btBroadphaseAabbCallback *)p2;
	o->aabbTest(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: createProxy ::btBroadphaseProxy * ( ::btSimpleBroadphase::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int,::btDispatcher *,void * ) 
void* btSimpleBroadphase_createProxy(void *c,float* p0,float* p1,int p2,void* p3,short int p4,short int p5,void* p6,void* p7) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	void * tp3 = (void *)p3;
	::btDispatcher * tp6 = (::btDispatcher *)p6;
	void * tp7 = (void *)p7;
	void* retVal = (void*) o->createProxy(tp0,tp1,p2,tp3,p4,p5,tp6,tp7);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return retVal;
}
//method: getSimpleProxyFromProxy ::btSimpleBroadphaseProxy * ( ::btSimpleBroadphase::* )( ::btBroadphaseProxy * ) 
void* btSimpleBroadphase_getSimpleProxyFromProxy(void *c,void* p0) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	void* retVal = (void*) o->getSimpleProxyFromProxy(tp0);
	return retVal;
}
//method: getSimpleProxyFromProxy ::btSimpleBroadphaseProxy * ( ::btSimpleBroadphase::* )( ::btBroadphaseProxy * ) 
void* btSimpleBroadphase_getSimpleProxyFromProxy0(void *c,void* p0) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	void* retVal = (void*) o->getSimpleProxyFromProxy(tp0);
	return retVal;
}
//method: getSimpleProxyFromProxy ::btSimpleBroadphaseProxy const * ( ::btSimpleBroadphase::* )( ::btBroadphaseProxy * ) const
void* btSimpleBroadphase_getSimpleProxyFromProxy1(void *c,void* p0) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	void* retVal = (void*) o->getSimpleProxyFromProxy(tp0);
	return retVal;
}
//method: validate void ( ::btSimpleBroadphase::* )(  ) 
void btSimpleBroadphase_validate(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	o->validate();
}
//method: aabbOverlap bool (*)( ::btSimpleBroadphaseProxy *,::btSimpleBroadphaseProxy * )
int btSimpleBroadphase_aabbOverlap(void* p0,void* p1) {
	::btSimpleBroadphaseProxy * tp0 = (::btSimpleBroadphaseProxy *)p0;
	::btSimpleBroadphaseProxy * tp1 = (::btSimpleBroadphaseProxy *)p1;
	int retVal = (int)::btSimpleBroadphase::aabbOverlap(tp0,tp1);
	return retVal;
}
//method: getBroadphaseAabb void ( ::btSimpleBroadphase::* )( ::btVector3 &,::btVector3 & ) const
void btSimpleBroadphase_getBroadphaseAabb(void *c,float* p0,float* p1) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->getBroadphaseAabb(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: destroyProxy void ( ::btSimpleBroadphase::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btSimpleBroadphase_destroyProxy(void *c,void* p0,void* p1) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->destroyProxy(tp0,tp1);
}
//attribute: int btSimpleBroadphase->m_LastHandleIndex
void btSimpleBroadphase_m_LastHandleIndex_set(void *c,int a) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	o->m_LastHandleIndex = a;
}
int btSimpleBroadphase_m_LastHandleIndex_get(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	return (int)(o->m_LastHandleIndex);
}

//attribute: int btSimpleBroadphase->m_firstFreeHandle
void btSimpleBroadphase_m_firstFreeHandle_set(void *c,int a) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	o->m_firstFreeHandle = a;
}
int btSimpleBroadphase_m_firstFreeHandle_get(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	return (int)(o->m_firstFreeHandle);
}

//attribute: int btSimpleBroadphase->m_invalidPair
void btSimpleBroadphase_m_invalidPair_set(void *c,int a) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	o->m_invalidPair = a;
}
int btSimpleBroadphase_m_invalidPair_get(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	return (int)(o->m_invalidPair);
}

//attribute: int btSimpleBroadphase->m_maxHandles
void btSimpleBroadphase_m_maxHandles_set(void *c,int a) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	o->m_maxHandles = a;
}
int btSimpleBroadphase_m_maxHandles_get(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	return (int)(o->m_maxHandles);
}

//attribute: int btSimpleBroadphase->m_numHandles
void btSimpleBroadphase_m_numHandles_set(void *c,int a) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	o->m_numHandles = a;
}
int btSimpleBroadphase_m_numHandles_get(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	return (int)(o->m_numHandles);
}

//attribute: bool btSimpleBroadphase->m_ownsPairCache
void btSimpleBroadphase_m_ownsPairCache_set(void *c,int a) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	o->m_ownsPairCache = a;
}
int btSimpleBroadphase_m_ownsPairCache_get(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	return (int)(o->m_ownsPairCache);
}

//attribute: ::btSimpleBroadphaseProxy * btSimpleBroadphase->m_pHandles
void btSimpleBroadphase_m_pHandles_set(void *c,void* a) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	::btSimpleBroadphaseProxy * ta = (::btSimpleBroadphaseProxy *)a;
	o->m_pHandles = ta;
}
void* btSimpleBroadphase_m_pHandles_get(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	return (void*)(o->m_pHandles);
}

//attribute: void * btSimpleBroadphase->m_pHandlesRawPtr
void btSimpleBroadphase_m_pHandlesRawPtr_set(void *c,void* a) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	void * ta = (void *)a;
	o->m_pHandlesRawPtr = ta;
}
void* btSimpleBroadphase_m_pHandlesRawPtr_get(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	return (void*)(o->m_pHandlesRawPtr);
}

//attribute: ::btOverlappingPairCache * btSimpleBroadphase->m_pairCache
void btSimpleBroadphase_m_pairCache_set(void *c,void* a) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	::btOverlappingPairCache * ta = (::btOverlappingPairCache *)a;
	o->m_pairCache = ta;
}
void* btSimpleBroadphase_m_pairCache_get(void *c) {
	::btSimpleBroadphase *o = (::btSimpleBroadphase*)c;
	return (void*)(o->m_pairCache);
}


// ::btSimpleBroadphaseProxy
//constructor: btSimpleBroadphaseProxy  ( ::btSimpleBroadphaseProxy::* )(  ) 
void* btSimpleBroadphaseProxy_new0() {
	::btSimpleBroadphaseProxy *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSimpleBroadphaseProxy),16);
	o = new (mem)::btSimpleBroadphaseProxy();
	return (void*)o;
}
//constructor: btSimpleBroadphaseProxy  ( ::btSimpleBroadphaseProxy::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int,void * ) 
void* btSimpleBroadphaseProxy_new1(float* p0,float* p1,int p2,void* p3,short int p4,short int p5,void* p6) {
	::btSimpleBroadphaseProxy *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	void * tp3 = (void *)p3;
	void * tp6 = (void *)p6;
	mem = btAlignedAlloc(sizeof(::btSimpleBroadphaseProxy),16);
	o = new (mem)::btSimpleBroadphaseProxy(tp0,tp1,p2,tp3,p4,p5,tp6);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return (void*)o;
}
void btSimpleBroadphaseProxy_free(void *c) {
	::btSimpleBroadphaseProxy *o = (::btSimpleBroadphaseProxy*)c;
	delete o;
}
//method: GetNextFree int ( ::btSimpleBroadphaseProxy::* )(  ) const
int btSimpleBroadphaseProxy_GetNextFree(void *c) {
	::btSimpleBroadphaseProxy *o = (::btSimpleBroadphaseProxy*)c;
	int retVal = (int)o->GetNextFree();
	return retVal;
}
//method: SetNextFree void ( ::btSimpleBroadphaseProxy::* )( int ) 
void btSimpleBroadphaseProxy_SetNextFree(void *c,int p0) {
	::btSimpleBroadphaseProxy *o = (::btSimpleBroadphaseProxy*)c;
	o->SetNextFree(p0);
}
//attribute: int btSimpleBroadphaseProxy->m_nextFree
void btSimpleBroadphaseProxy_m_nextFree_set(void *c,int a) {
	::btSimpleBroadphaseProxy *o = (::btSimpleBroadphaseProxy*)c;
	o->m_nextFree = a;
}
int btSimpleBroadphaseProxy_m_nextFree_get(void *c) {
	::btSimpleBroadphaseProxy *o = (::btSimpleBroadphaseProxy*)c;
	return (int)(o->m_nextFree);
}


// ::btSortedOverlappingPairCache
//constructor: btSortedOverlappingPairCache  ( ::btSortedOverlappingPairCache::* )(  ) 
void* btSortedOverlappingPairCache_new() {
	::btSortedOverlappingPairCache *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSortedOverlappingPairCache),16);
	o = new (mem)::btSortedOverlappingPairCache();
	return (void*)o;
}
void btSortedOverlappingPairCache_free(void *c) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	delete o;
}
//method: sortOverlappingPairs void ( ::btSortedOverlappingPairCache::* )( ::btDispatcher * ) 
void btSortedOverlappingPairCache_sortOverlappingPairs(void *c,void* p0) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	o->sortOverlappingPairs(tp0);
}
//method: setInternalGhostPairCallback void ( ::btSortedOverlappingPairCache::* )( ::btOverlappingPairCallback * ) 
void btSortedOverlappingPairCache_setInternalGhostPairCallback(void *c,void* p0) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	::btOverlappingPairCallback * tp0 = (::btOverlappingPairCallback *)p0;
	o->setInternalGhostPairCallback(tp0);
}
//method: getOverlapFilterCallback ::btOverlapFilterCallback * ( ::btSortedOverlappingPairCache::* )(  ) 
void* btSortedOverlappingPairCache_getOverlapFilterCallback(void *c) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	void* retVal = (void*) o->getOverlapFilterCallback();
	return retVal;
}
//method: addOverlappingPair ::btBroadphasePair * ( ::btSortedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void* btSortedOverlappingPairCache_addOverlappingPair(void *c,void* p0,void* p1) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	void* retVal = (void*) o->addOverlappingPair(tp0,tp1);
	return retVal;
}
//method: removeOverlappingPairsContainingProxy void ( ::btSortedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btSortedOverlappingPairCache_removeOverlappingPairsContainingProxy(void *c,void* p0,void* p1) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->removeOverlappingPairsContainingProxy(tp0,tp1);
}
//method: needsBroadphaseCollision bool ( ::btSortedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) const
int btSortedOverlappingPairCache_needsBroadphaseCollision(void *c,void* p0,void* p1) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	int retVal = (int)o->needsBroadphaseCollision(tp0,tp1);
	return retVal;
}
//method: hasDeferredRemoval bool ( ::btSortedOverlappingPairCache::* )(  ) 
int btSortedOverlappingPairCache_hasDeferredRemoval(void *c) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	int retVal = (int)o->hasDeferredRemoval();
	return retVal;
}
//method: getOverlappingPairArray ::btBroadphasePairArray & ( ::btSortedOverlappingPairCache::* )(  ) 
void* btSortedOverlappingPairCache_getOverlappingPairArray(void *c) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	void* retVal = (void*) &(o->getOverlappingPairArray());
	return retVal;
}
//method: getOverlappingPairArray ::btBroadphasePairArray & ( ::btSortedOverlappingPairCache::* )(  ) 
void* btSortedOverlappingPairCache_getOverlappingPairArray0(void *c) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	void* retVal = (void*) &(o->getOverlappingPairArray());
	return retVal;
}
//method: getOverlappingPairArray ::btBroadphasePairArray const & ( ::btSortedOverlappingPairCache::* )(  ) const
void* btSortedOverlappingPairCache_getOverlappingPairArray1(void *c) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	void* retVal = (void*) &(o->getOverlappingPairArray());
	return retVal;
}
//method: findPair ::btBroadphasePair * ( ::btSortedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void* btSortedOverlappingPairCache_findPair(void *c,void* p0,void* p1) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	void* retVal = (void*) o->findPair(tp0,tp1);
	return retVal;
}
//method: cleanProxyFromPairs void ( ::btSortedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btSortedOverlappingPairCache_cleanProxyFromPairs(void *c,void* p0,void* p1) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->cleanProxyFromPairs(tp0,tp1);
}
//method: cleanOverlappingPair void ( ::btSortedOverlappingPairCache::* )( ::btBroadphasePair &,::btDispatcher * ) 
void btSortedOverlappingPairCache_cleanOverlappingPair(void *c,void* p0,void* p1) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	::btBroadphasePair & tp0 = *(::btBroadphasePair *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->cleanOverlappingPair(tp0,tp1);
}
//method: getNumOverlappingPairs int ( ::btSortedOverlappingPairCache::* )(  ) const
int btSortedOverlappingPairCache_getNumOverlappingPairs(void *c) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	int retVal = (int)o->getNumOverlappingPairs();
	return retVal;
}
//method: removeOverlappingPair void * ( ::btSortedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy *,::btDispatcher * ) 
void* btSortedOverlappingPairCache_removeOverlappingPair(void *c,void* p0,void* p1,void* p2) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	::btDispatcher * tp2 = (::btDispatcher *)p2;
	void* retVal = (void*) o->removeOverlappingPair(tp0,tp1,tp2);
	return retVal;
}
//method: processAllOverlappingPairs void ( ::btSortedOverlappingPairCache::* )( ::btOverlapCallback *,::btDispatcher * ) 
void btSortedOverlappingPairCache_processAllOverlappingPairs(void *c,void* p0,void* p1) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	::btOverlapCallback * tp0 = (::btOverlapCallback *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->processAllOverlappingPairs(tp0,tp1);
}
//method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btSortedOverlappingPairCache::* )(  ) 
void* btSortedOverlappingPairCache_getOverlappingPairArrayPtr(void *c) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	void* retVal = (void*) o->getOverlappingPairArrayPtr();
	return retVal;
}
//method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btSortedOverlappingPairCache::* )(  ) 
void* btSortedOverlappingPairCache_getOverlappingPairArrayPtr0(void *c) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	void* retVal = (void*) o->getOverlappingPairArrayPtr();
	return retVal;
}
//method: getOverlappingPairArrayPtr ::btBroadphasePair const * ( ::btSortedOverlappingPairCache::* )(  ) const
void* btSortedOverlappingPairCache_getOverlappingPairArrayPtr1(void *c) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	void* retVal = (void*) o->getOverlappingPairArrayPtr();
	return retVal;
}
//method: setOverlapFilterCallback void ( ::btSortedOverlappingPairCache::* )( ::btOverlapFilterCallback * ) 
void btSortedOverlappingPairCache_setOverlapFilterCallback(void *c,void* p0) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	::btOverlapFilterCallback * tp0 = (::btOverlapFilterCallback *)p0;
	o->setOverlapFilterCallback(tp0);
}
//attribute: ::btBroadphasePairArray btSortedOverlappingPairCache->m_overlappingPairArray
void btSortedOverlappingPairCache_m_overlappingPairArray_set(void *c,void* a) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	::btBroadphasePairArray & ta = *(::btAlignedObjectArray<btBroadphasePair> *)a;
	o->m_overlappingPairArray = ta;
}
void* btSortedOverlappingPairCache_m_overlappingPairArray_get(void *c) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	return (void*)&(o->m_overlappingPairArray);
}

//attribute: bool btSortedOverlappingPairCache->m_blockedForChanges
void btSortedOverlappingPairCache_m_blockedForChanges_set(void *c,int a) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	o->m_blockedForChanges = a;
}
int btSortedOverlappingPairCache_m_blockedForChanges_get(void *c) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	return (int)(o->m_blockedForChanges);
}

//attribute: bool btSortedOverlappingPairCache->m_hasDeferredRemoval
void btSortedOverlappingPairCache_m_hasDeferredRemoval_set(void *c,int a) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	o->m_hasDeferredRemoval = a;
}
int btSortedOverlappingPairCache_m_hasDeferredRemoval_get(void *c) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	return (int)(o->m_hasDeferredRemoval);
}

//attribute: ::btOverlapFilterCallback * btSortedOverlappingPairCache->m_overlapFilterCallback
void btSortedOverlappingPairCache_m_overlapFilterCallback_set(void *c,void* a) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	::btOverlapFilterCallback * ta = (::btOverlapFilterCallback *)a;
	o->m_overlapFilterCallback = ta;
}
void* btSortedOverlappingPairCache_m_overlapFilterCallback_get(void *c) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	return (void*)(o->m_overlapFilterCallback);
}

//attribute: ::btOverlappingPairCallback * btSortedOverlappingPairCache->m_ghostPairCallback
void btSortedOverlappingPairCache_m_ghostPairCallback_set(void *c,void* a) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	::btOverlappingPairCallback * ta = (::btOverlappingPairCallback *)a;
	o->m_ghostPairCallback = ta;
}
void* btSortedOverlappingPairCache_m_ghostPairCallback_get(void *c) {
	::btSortedOverlappingPairCache *o = (::btSortedOverlappingPairCache*)c;
	return (void*)(o->m_ghostPairCallback);
}


// ::btDbvt::sStkCLN
//constructor: sStkCLN  ( ::btDbvt::sStkCLN::* )( ::btDbvtNode const *,::btDbvtNode * ) 
void* btDbvt_sStkCLN_new(void* p0,void* p1) {
	::btDbvt::sStkCLN *o = 0;
	 void *mem = 0;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	::btDbvtNode * tp1 = (::btDbvtNode *)p1;
	mem = btAlignedAlloc(sizeof(::btDbvt::sStkCLN),16);
	o = new (mem)::btDbvt::sStkCLN(tp0,tp1);
	return (void*)o;
}
void btDbvt_sStkCLN_free(void *c) {
	::btDbvt::sStkCLN *o = (::btDbvt::sStkCLN*)c;
	delete o;
}
//attribute: ::btDbvtNode const * btDbvt_sStkCLN->node
void btDbvt_sStkCLN_node_set(void *c,void* a) {
	::btDbvt::sStkCLN *o = (::btDbvt::sStkCLN*)c;
	::btDbvtNode const * ta = (::btDbvtNode const *)a;
	o->node = ta;
}
void* btDbvt_sStkCLN_node_get(void *c) {
	::btDbvt::sStkCLN *o = (::btDbvt::sStkCLN*)c;
	return (void*)(o->node);
}

//attribute: ::btDbvtNode * btDbvt_sStkCLN->parent
void btDbvt_sStkCLN_parent_set(void *c,void* a) {
	::btDbvt::sStkCLN *o = (::btDbvt::sStkCLN*)c;
	::btDbvtNode * ta = (::btDbvtNode *)a;
	o->parent = ta;
}
void* btDbvt_sStkCLN_parent_get(void *c) {
	::btDbvt::sStkCLN *o = (::btDbvt::sStkCLN*)c;
	return (void*)(o->parent);
}


// ::btDbvt::sStkNN
//constructor: sStkNN  ( ::btDbvt::sStkNN::* )(  ) 
void* btDbvt_sStkNN_new0() {
	::btDbvt::sStkNN *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btDbvt::sStkNN),16);
	o = new (mem)::btDbvt::sStkNN();
	return (void*)o;
}
//constructor: sStkNN  ( ::btDbvt::sStkNN::* )( ::btDbvtNode const *,::btDbvtNode const * ) 
void* btDbvt_sStkNN_new1(void* p0,void* p1) {
	::btDbvt::sStkNN *o = 0;
	 void *mem = 0;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	::btDbvtNode const * tp1 = (::btDbvtNode const *)p1;
	mem = btAlignedAlloc(sizeof(::btDbvt::sStkNN),16);
	o = new (mem)::btDbvt::sStkNN(tp0,tp1);
	return (void*)o;
}
void btDbvt_sStkNN_free(void *c) {
	::btDbvt::sStkNN *o = (::btDbvt::sStkNN*)c;
	delete o;
}
//attribute: ::btDbvtNode const * btDbvt_sStkNN->a
void btDbvt_sStkNN_a_set(void *c,void* a) {
	::btDbvt::sStkNN *o = (::btDbvt::sStkNN*)c;
	::btDbvtNode const * ta = (::btDbvtNode const *)a;
	o->a = ta;
}
void* btDbvt_sStkNN_a_get(void *c) {
	::btDbvt::sStkNN *o = (::btDbvt::sStkNN*)c;
	return (void*)(o->a);
}

//attribute: ::btDbvtNode const * btDbvt_sStkNN->b
void btDbvt_sStkNN_b_set(void *c,void* a) {
	::btDbvt::sStkNN *o = (::btDbvt::sStkNN*)c;
	::btDbvtNode const * ta = (::btDbvtNode const *)a;
	o->b = ta;
}
void* btDbvt_sStkNN_b_get(void *c) {
	::btDbvt::sStkNN *o = (::btDbvt::sStkNN*)c;
	return (void*)(o->b);
}


// ::btDbvt::sStkNP
//constructor: sStkNP  ( ::btDbvt::sStkNP::* )( ::btDbvtNode const *,unsigned int ) 
void* btDbvt_sStkNP_new(void* p0,unsigned int p1) {
	::btDbvt::sStkNP *o = 0;
	 void *mem = 0;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	mem = btAlignedAlloc(sizeof(::btDbvt::sStkNP),16);
	o = new (mem)::btDbvt::sStkNP(tp0,p1);
	return (void*)o;
}
void btDbvt_sStkNP_free(void *c) {
	::btDbvt::sStkNP *o = (::btDbvt::sStkNP*)c;
	delete o;
}
//attribute: int btDbvt_sStkNP->mask
void btDbvt_sStkNP_mask_set(void *c,int a) {
	::btDbvt::sStkNP *o = (::btDbvt::sStkNP*)c;
	o->mask = a;
}
int btDbvt_sStkNP_mask_get(void *c) {
	::btDbvt::sStkNP *o = (::btDbvt::sStkNP*)c;
	return (int)(o->mask);
}

//attribute: ::btDbvtNode const * btDbvt_sStkNP->node
void btDbvt_sStkNP_node_set(void *c,void* a) {
	::btDbvt::sStkNP *o = (::btDbvt::sStkNP*)c;
	::btDbvtNode const * ta = (::btDbvtNode const *)a;
	o->node = ta;
}
void* btDbvt_sStkNP_node_get(void *c) {
	::btDbvt::sStkNP *o = (::btDbvt::sStkNP*)c;
	return (void*)(o->node);
}


// ::btDbvt::sStkNPS
//constructor: sStkNPS  ( ::btDbvt::sStkNPS::* )(  ) 
void* btDbvt_sStkNPS_new0() {
	::btDbvt::sStkNPS *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btDbvt::sStkNPS),16);
	o = new (mem)::btDbvt::sStkNPS();
	return (void*)o;
}
//constructor: sStkNPS  ( ::btDbvt::sStkNPS::* )( ::btDbvtNode const *,unsigned int,::btScalar ) 
void* btDbvt_sStkNPS_new1(void* p0,unsigned int p1,float p2) {
	::btDbvt::sStkNPS *o = 0;
	 void *mem = 0;
	::btDbvtNode const * tp0 = (::btDbvtNode const *)p0;
	mem = btAlignedAlloc(sizeof(::btDbvt::sStkNPS),16);
	o = new (mem)::btDbvt::sStkNPS(tp0,p1,p2);
	return (void*)o;
}
void btDbvt_sStkNPS_free(void *c) {
	::btDbvt::sStkNPS *o = (::btDbvt::sStkNPS*)c;
	delete o;
}
//attribute: int btDbvt_sStkNPS->mask
void btDbvt_sStkNPS_mask_set(void *c,int a) {
	::btDbvt::sStkNPS *o = (::btDbvt::sStkNPS*)c;
	o->mask = a;
}
int btDbvt_sStkNPS_mask_get(void *c) {
	::btDbvt::sStkNPS *o = (::btDbvt::sStkNPS*)c;
	return (int)(o->mask);
}

//attribute: ::btDbvtNode const * btDbvt_sStkNPS->node
void btDbvt_sStkNPS_node_set(void *c,void* a) {
	::btDbvt::sStkNPS *o = (::btDbvt::sStkNPS*)c;
	::btDbvtNode const * ta = (::btDbvtNode const *)a;
	o->node = ta;
}
void* btDbvt_sStkNPS_node_get(void *c) {
	::btDbvt::sStkNPS *o = (::btDbvt::sStkNPS*)c;
	return (void*)(o->node);
}

//attribute: ::btScalar btDbvt_sStkNPS->value
void btDbvt_sStkNPS_value_set(void *c,float a) {
	::btDbvt::sStkNPS *o = (::btDbvt::sStkNPS*)c;
	o->value = a;
}
float btDbvt_sStkNPS_value_get(void *c) {
	::btDbvt::sStkNPS *o = (::btDbvt::sStkNPS*)c;
	return (float)(o->value);
}


// ::btDiscreteCollisionDetectorInterface::ClosestPointInput
//constructor: ClosestPointInput  ( ::btDiscreteCollisionDetectorInterface::ClosestPointInput::* )(  ) 
void* btDiscreteCollisionDetectorInterface_ClosestPointInput_new() {
	::btDiscreteCollisionDetectorInterface::ClosestPointInput *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btDiscreteCollisionDetectorInterface::ClosestPointInput),16);
	o = new (mem)::btDiscreteCollisionDetectorInterface::ClosestPointInput();
	return (void*)o;
}
void btDiscreteCollisionDetectorInterface_ClosestPointInput_free(void *c) {
	::btDiscreteCollisionDetectorInterface::ClosestPointInput *o = (::btDiscreteCollisionDetectorInterface::ClosestPointInput*)c;
	delete o;
}
//attribute: ::btTransform btDiscreteCollisionDetectorInterface_ClosestPointInput->m_transformA
void btDiscreteCollisionDetectorInterface_ClosestPointInput_m_transformA_set(void *c,float* a) {
	::btDiscreteCollisionDetectorInterface::ClosestPointInput *o = (::btDiscreteCollisionDetectorInterface::ClosestPointInput*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_transformA = ta;
}
void btDiscreteCollisionDetectorInterface_ClosestPointInput_m_transformA_get(void *c,float* a) {
	::btDiscreteCollisionDetectorInterface::ClosestPointInput *o = (::btDiscreteCollisionDetectorInterface::ClosestPointInput*)c;
	a[0]=(o->m_transformA).getBasis().getRow(0).m_floats[0];a[1]=(o->m_transformA).getBasis().getRow(0).m_floats[1];a[2]=(o->m_transformA).getBasis().getRow(0).m_floats[2];a[3]=(o->m_transformA).getBasis().getRow(1).m_floats[0];a[4]=(o->m_transformA).getBasis().getRow(1).m_floats[1];a[5]=(o->m_transformA).getBasis().getRow(1).m_floats[2];a[6]=(o->m_transformA).getBasis().getRow(2).m_floats[0];a[7]=(o->m_transformA).getBasis().getRow(2).m_floats[1];a[8]=(o->m_transformA).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_transformA).getOrigin().m_floats[0];a[10]=(o->m_transformA).getOrigin().m_floats[1];a[11]=(o->m_transformA).getOrigin().m_floats[2];
}

//attribute: ::btTransform btDiscreteCollisionDetectorInterface_ClosestPointInput->m_transformB
void btDiscreteCollisionDetectorInterface_ClosestPointInput_m_transformB_set(void *c,float* a) {
	::btDiscreteCollisionDetectorInterface::ClosestPointInput *o = (::btDiscreteCollisionDetectorInterface::ClosestPointInput*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_transformB = ta;
}
void btDiscreteCollisionDetectorInterface_ClosestPointInput_m_transformB_get(void *c,float* a) {
	::btDiscreteCollisionDetectorInterface::ClosestPointInput *o = (::btDiscreteCollisionDetectorInterface::ClosestPointInput*)c;
	a[0]=(o->m_transformB).getBasis().getRow(0).m_floats[0];a[1]=(o->m_transformB).getBasis().getRow(0).m_floats[1];a[2]=(o->m_transformB).getBasis().getRow(0).m_floats[2];a[3]=(o->m_transformB).getBasis().getRow(1).m_floats[0];a[4]=(o->m_transformB).getBasis().getRow(1).m_floats[1];a[5]=(o->m_transformB).getBasis().getRow(1).m_floats[2];a[6]=(o->m_transformB).getBasis().getRow(2).m_floats[0];a[7]=(o->m_transformB).getBasis().getRow(2).m_floats[1];a[8]=(o->m_transformB).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_transformB).getOrigin().m_floats[0];a[10]=(o->m_transformB).getOrigin().m_floats[1];a[11]=(o->m_transformB).getOrigin().m_floats[2];
}

//attribute: ::btScalar btDiscreteCollisionDetectorInterface_ClosestPointInput->m_maximumDistanceSquared
void btDiscreteCollisionDetectorInterface_ClosestPointInput_m_maximumDistanceSquared_set(void *c,float a) {
	::btDiscreteCollisionDetectorInterface::ClosestPointInput *o = (::btDiscreteCollisionDetectorInterface::ClosestPointInput*)c;
	o->m_maximumDistanceSquared = a;
}
float btDiscreteCollisionDetectorInterface_ClosestPointInput_m_maximumDistanceSquared_get(void *c) {
	::btDiscreteCollisionDetectorInterface::ClosestPointInput *o = (::btDiscreteCollisionDetectorInterface::ClosestPointInput*)c;
	return (float)(o->m_maximumDistanceSquared);
}

//attribute: ::btStackAlloc * btDiscreteCollisionDetectorInterface_ClosestPointInput->m_stackAlloc
void btDiscreteCollisionDetectorInterface_ClosestPointInput_m_stackAlloc_set(void *c,void* a) {
	::btDiscreteCollisionDetectorInterface::ClosestPointInput *o = (::btDiscreteCollisionDetectorInterface::ClosestPointInput*)c;
	::btStackAlloc * ta = (::btStackAlloc *)a;
	o->m_stackAlloc = ta;
}
void* btDiscreteCollisionDetectorInterface_ClosestPointInput_m_stackAlloc_get(void *c) {
	::btDiscreteCollisionDetectorInterface::ClosestPointInput *o = (::btDiscreteCollisionDetectorInterface::ClosestPointInput*)c;
	return (void*)(o->m_stackAlloc);
}


// ::btDiscreteCollisionDetectorInterface::Result
//method: setShapeIdentifiersB void ( ::btDiscreteCollisionDetectorInterface::Result::* )( int,int ) 
void btDiscreteCollisionDetectorInterface_Result_setShapeIdentifiersB(void *c,int p0,int p1) {
	::btDiscreteCollisionDetectorInterface::Result *o = (::btDiscreteCollisionDetectorInterface::Result*)c;
	o->setShapeIdentifiersB(p0,p1);
}
//method: setShapeIdentifiersA void ( ::btDiscreteCollisionDetectorInterface::Result::* )( int,int ) 
void btDiscreteCollisionDetectorInterface_Result_setShapeIdentifiersA(void *c,int p0,int p1) {
	::btDiscreteCollisionDetectorInterface::Result *o = (::btDiscreteCollisionDetectorInterface::Result*)c;
	o->setShapeIdentifiersA(p0,p1);
}
//method: addContactPoint void ( ::btDiscreteCollisionDetectorInterface::Result::* )( ::btVector3 const &,::btVector3 const &,::btScalar ) 
void btDiscreteCollisionDetectorInterface_Result_addContactPoint(void *c,float* p0,float* p1,float p2) {
	::btDiscreteCollisionDetectorInterface::Result *o = (::btDiscreteCollisionDetectorInterface::Result*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->addContactPoint(tp0,tp1,p2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}

// ::btConstraintRow
//constructor: btConstraintRow  ( ::btConstraintRow::* )(  ) 
void* btConstraintRow_new() {
	::btConstraintRow *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btConstraintRow),16);
	o = new (mem)::btConstraintRow();
	return (void*)o;
}
void btConstraintRow_free(void *c) {
	::btConstraintRow *o = (::btConstraintRow*)c;
	delete o;
}
//attribute: ::btScalar[3] btConstraintRow->m_normal
// attribute not supported: //attribute: ::btScalar[3] btConstraintRow->m_normal
//attribute: ::btScalar btConstraintRow->m_rhs
void btConstraintRow_m_rhs_set(void *c,float a) {
	::btConstraintRow *o = (::btConstraintRow*)c;
	o->m_rhs = a;
}
float btConstraintRow_m_rhs_get(void *c) {
	::btConstraintRow *o = (::btConstraintRow*)c;
	return (float)(o->m_rhs);
}

//attribute: ::btScalar btConstraintRow->m_jacDiagInv
void btConstraintRow_m_jacDiagInv_set(void *c,float a) {
	::btConstraintRow *o = (::btConstraintRow*)c;
	o->m_jacDiagInv = a;
}
float btConstraintRow_m_jacDiagInv_get(void *c) {
	::btConstraintRow *o = (::btConstraintRow*)c;
	return (float)(o->m_jacDiagInv);
}

//attribute: ::btScalar btConstraintRow->m_lowerLimit
void btConstraintRow_m_lowerLimit_set(void *c,float a) {
	::btConstraintRow *o = (::btConstraintRow*)c;
	o->m_lowerLimit = a;
}
float btConstraintRow_m_lowerLimit_get(void *c) {
	::btConstraintRow *o = (::btConstraintRow*)c;
	return (float)(o->m_lowerLimit);
}

//attribute: ::btScalar btConstraintRow->m_upperLimit
void btConstraintRow_m_upperLimit_set(void *c,float a) {
	::btConstraintRow *o = (::btConstraintRow*)c;
	o->m_upperLimit = a;
}
float btConstraintRow_m_upperLimit_get(void *c) {
	::btConstraintRow *o = (::btConstraintRow*)c;
	return (float)(o->m_upperLimit);
}

//attribute: ::btScalar btConstraintRow->m_accumImpulse
void btConstraintRow_m_accumImpulse_set(void *c,float a) {
	::btConstraintRow *o = (::btConstraintRow*)c;
	o->m_accumImpulse = a;
}
float btConstraintRow_m_accumImpulse_get(void *c) {
	::btConstraintRow *o = (::btConstraintRow*)c;
	return (float)(o->m_accumImpulse);
}


// ::btDiscreteCollisionDetectorInterface
//method: getClosestPoints void ( ::btDiscreteCollisionDetectorInterface::* )( ::btDiscreteCollisionDetectorInterface::ClosestPointInput const &,::btDiscreteCollisionDetectorInterface::Result &,::btIDebugDraw *,bool ) 
void btDiscreteCollisionDetectorInterface_getClosestPoints(void *c,void* p0,void* p1,void* p2,int p3) {
	::btDiscreteCollisionDetectorInterface *o = (::btDiscreteCollisionDetectorInterface*)c;
	::btDiscreteCollisionDetectorInterface::ClosestPointInput const & tp0 = *(::btDiscreteCollisionDetectorInterface::ClosestPointInput const *)p0;
	::btDiscreteCollisionDetectorInterface::Result & tp1 = *(::btDiscreteCollisionDetectorInterface::Result *)p1;
	::btIDebugDraw * tp2 = (::btIDebugDraw *)p2;
	o->getClosestPoints(tp0,tp1,tp2,p3);
}

// ::btGjkEpaSolver2
//constructor: btGjkEpaSolver2  ( ::btGjkEpaSolver2::* )(  ) 
void* btGjkEpaSolver2_new() {
	::btGjkEpaSolver2 *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGjkEpaSolver2),16);
	o = new (mem)::btGjkEpaSolver2();
	return (void*)o;
}
void btGjkEpaSolver2_free(void *c) {
	::btGjkEpaSolver2 *o = (::btGjkEpaSolver2*)c;
	delete o;
}
//method: StackSizeRequirement int (*)(  )
int btGjkEpaSolver2_StackSizeRequirement() {
	int retVal = (int)::btGjkEpaSolver2::StackSizeRequirement();
	return retVal;
}
//method: Distance bool (*)( ::btConvexShape const *,::btTransform const &,::btConvexShape const *,::btTransform const &,::btVector3 const &,::btGjkEpaSolver2::sResults & )
int btGjkEpaSolver2_Distance(void* p0,float* p1,void* p2,float* p3,float* p4,void* p5) {
	::btConvexShape const * tp0 = (::btConvexShape const *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	::btConvexShape const * tp2 = (::btConvexShape const *)p2;
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	::btGjkEpaSolver2::sResults & tp5 = *(::btGjkEpaSolver2::sResults *)p5;
	int retVal = (int)::btGjkEpaSolver2::Distance(tp0,tp1,tp2,tp3,tp4,tp5);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	return retVal;
}
//method: Penetration bool (*)( ::btConvexShape const *,::btTransform const &,::btConvexShape const *,::btTransform const &,::btVector3 const &,::btGjkEpaSolver2::sResults &,bool )
int btGjkEpaSolver2_Penetration(void* p0,float* p1,void* p2,float* p3,float* p4,void* p5,int p6) {
	::btConvexShape const * tp0 = (::btConvexShape const *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	::btConvexShape const * tp2 = (::btConvexShape const *)p2;
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	::btGjkEpaSolver2::sResults & tp5 = *(::btGjkEpaSolver2::sResults *)p5;
	int retVal = (int)::btGjkEpaSolver2::Penetration(tp0,tp1,tp2,tp3,tp4,tp5,p6);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	return retVal;
}
//method: SignedDistance ::btScalar (*)( ::btVector3 const &,::btScalar,::btConvexShape const *,::btTransform const &,::btGjkEpaSolver2::sResults & )
float btGjkEpaSolver2_SignedDistance(float* p0,float p1,void* p2,float* p3,void* p4) {
	btVector3 tp0(p0[0],p0[1],p0[2]);
	::btConvexShape const * tp2 = (::btConvexShape const *)p2;
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	::btGjkEpaSolver2::sResults & tp4 = *(::btGjkEpaSolver2::sResults *)p4;
	float retVal = (float)::btGjkEpaSolver2::SignedDistance(tp0,p1,tp2,tp3,tp4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
	return retVal;
}
//method: SignedDistance ::btScalar (*)( ::btVector3 const &,::btScalar,::btConvexShape const *,::btTransform const &,::btGjkEpaSolver2::sResults & )
float btGjkEpaSolver2_SignedDistance0(float* p0,float p1,void* p2,float* p3,void* p4) {
	btVector3 tp0(p0[0],p0[1],p0[2]);
	::btConvexShape const * tp2 = (::btConvexShape const *)p2;
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	::btGjkEpaSolver2::sResults & tp4 = *(::btGjkEpaSolver2::sResults *)p4;
	float retVal = (float)::btGjkEpaSolver2::SignedDistance(tp0,p1,tp2,tp3,tp4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
	return retVal;
}
//method: SignedDistance bool (*)( ::btConvexShape const *,::btTransform const &,::btConvexShape const *,::btTransform const &,::btVector3 const &,::btGjkEpaSolver2::sResults & )
int btGjkEpaSolver2_SignedDistance1(void* p0,float* p1,void* p2,float* p3,float* p4,void* p5) {
	::btConvexShape const * tp0 = (::btConvexShape const *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	::btConvexShape const * tp2 = (::btConvexShape const *)p2;
	btMatrix3x3 mtp3(p3[0],p3[1],p3[2],p3[3],p3[4],p3[5],p3[6],p3[7],p3[8]);
	btVector3 vtp3(p3[9],p3[10],p3[11]);
	btTransform tp3(mtp3,vtp3);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	::btGjkEpaSolver2::sResults & tp5 = *(::btGjkEpaSolver2::sResults *)p5;
	int retVal = (int)::btGjkEpaSolver2::SignedDistance(tp0,tp1,tp2,tp3,tp4,tp5);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p3[0]=tp3.getBasis().getRow(0).m_floats[0];p3[1]=tp3.getBasis().getRow(0).m_floats[1];p3[2]=tp3.getBasis().getRow(0).m_floats[2];p3[3]=tp3.getBasis().getRow(1).m_floats[0];p3[4]=tp3.getBasis().getRow(1).m_floats[1];p3[5]=tp3.getBasis().getRow(1).m_floats[2];p3[6]=tp3.getBasis().getRow(2).m_floats[0];p3[7]=tp3.getBasis().getRow(2).m_floats[1];p3[8]=tp3.getBasis().getRow(2).m_floats[2];
	p3[9]=tp3.getOrigin().m_floats[0];p3[10]=tp3.getOrigin().m_floats[1];p3[11]=tp3.getOrigin().m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	return retVal;
}

// ::btGjkPairDetector
//not supported constructor: btGjkPairDetector  ( ::btGjkPairDetector::* )( ::btConvexShape const *,::btConvexShape const *,::btVoronoiSimplexSolver *,::btConvexPenetrationDepthSolver * ) 
// error: ::btConvexShape const * - ok, ::btConvexShape const * - ok, ::btVoronoiSimplexSolver * - ok,  - unsupported

//not supported constructor: btGjkPairDetector  ( ::btGjkPairDetector::* )( ::btConvexShape const *,::btConvexShape const *,int,int,::btScalar,::btScalar,::btVoronoiSimplexSolver *,::btConvexPenetrationDepthSolver * ) 
// error: ::btConvexShape const * - ok, ::btConvexShape const * - ok, int - ok, int - ok, ::btScalar - ok, ::btScalar - ok, ::btVoronoiSimplexSolver * - ok,  - unsupported

void btGjkPairDetector_free(void *c) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	delete o;
}
//method: setCachedSeperatingAxis void ( ::btGjkPairDetector::* )( ::btVector3 const & ) 
void btGjkPairDetector_setCachedSeperatingAxis(void *c,float* p0) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setCachedSeperatingAxis(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getCachedSeparatingAxis ::btVector3 const & ( ::btGjkPairDetector::* )(  ) const
void btGjkPairDetector_getCachedSeparatingAxis(void *c,float* ret) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getCachedSeparatingAxis();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//not supported method: setPenetrationDepthSolver void ( ::btGjkPairDetector::* )( ::btConvexPenetrationDepthSolver * ) 
// error:  - unsupported, void - ok

//method: getClosestPoints void ( ::btGjkPairDetector::* )( ::btDiscreteCollisionDetectorInterface::ClosestPointInput const &,::btDiscreteCollisionDetectorInterface::Result &,::btIDebugDraw *,bool ) 
void btGjkPairDetector_getClosestPoints(void *c,void* p0,void* p1,void* p2,int p3) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	::btDiscreteCollisionDetectorInterface::ClosestPointInput const & tp0 = *(::btDiscreteCollisionDetectorInterface::ClosestPointInput const *)p0;
	::btDiscreteCollisionDetectorInterface::Result & tp1 = *(::btDiscreteCollisionDetectorInterface::Result *)p1;
	::btIDebugDraw * tp2 = (::btIDebugDraw *)p2;
	o->getClosestPoints(tp0,tp1,tp2,p3);
}
//method: setMinkowskiA void ( ::btGjkPairDetector::* )( ::btConvexShape * ) 
void btGjkPairDetector_setMinkowskiA(void *c,void* p0) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	::btConvexShape * tp0 = (::btConvexShape *)p0;
	o->setMinkowskiA(tp0);
}
//method: setMinkowskiB void ( ::btGjkPairDetector::* )( ::btConvexShape * ) 
void btGjkPairDetector_setMinkowskiB(void *c,void* p0) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	::btConvexShape * tp0 = (::btConvexShape *)p0;
	o->setMinkowskiB(tp0);
}
//method: setIgnoreMargin void ( ::btGjkPairDetector::* )( bool ) 
void btGjkPairDetector_setIgnoreMargin(void *c,int p0) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	o->setIgnoreMargin(p0);
}
//method: getClosestPointsNonVirtual void ( ::btGjkPairDetector::* )( ::btDiscreteCollisionDetectorInterface::ClosestPointInput const &,::btDiscreteCollisionDetectorInterface::Result &,::btIDebugDraw * ) 
void btGjkPairDetector_getClosestPointsNonVirtual(void *c,void* p0,void* p1,void* p2) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	::btDiscreteCollisionDetectorInterface::ClosestPointInput const & tp0 = *(::btDiscreteCollisionDetectorInterface::ClosestPointInput const *)p0;
	::btDiscreteCollisionDetectorInterface::Result & tp1 = *(::btDiscreteCollisionDetectorInterface::Result *)p1;
	::btIDebugDraw * tp2 = (::btIDebugDraw *)p2;
	o->getClosestPointsNonVirtual(tp0,tp1,tp2);
}
//method: getCachedSeparatingDistance ::btScalar ( ::btGjkPairDetector::* )(  ) const
float btGjkPairDetector_getCachedSeparatingDistance(void *c) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	float retVal = (float)o->getCachedSeparatingDistance();
	return retVal;
}
//attribute: ::btVector3 btGjkPairDetector->m_cachedSeparatingAxis
void btGjkPairDetector_m_cachedSeparatingAxis_set(void *c,float* a) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_cachedSeparatingAxis = ta;
}
void btGjkPairDetector_m_cachedSeparatingAxis_get(void *c,float* a) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	a[0]=(o->m_cachedSeparatingAxis).m_floats[0];a[1]=(o->m_cachedSeparatingAxis).m_floats[1];a[2]=(o->m_cachedSeparatingAxis).m_floats[2];
}

//attribute: ::btConvexPenetrationDepthSolver * btGjkPairDetector->m_penetrationDepthSolver
// attribute not supported: //attribute: ::btConvexPenetrationDepthSolver * btGjkPairDetector->m_penetrationDepthSolver
//attribute: ::btVoronoiSimplexSolver * btGjkPairDetector->m_simplexSolver
void btGjkPairDetector_m_simplexSolver_set(void *c,void* a) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	::btVoronoiSimplexSolver * ta = (::btVoronoiSimplexSolver *)a;
	o->m_simplexSolver = ta;
}
void* btGjkPairDetector_m_simplexSolver_get(void *c) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	return (void*)(o->m_simplexSolver);
}

//attribute: ::btConvexShape const * btGjkPairDetector->m_minkowskiA
void btGjkPairDetector_m_minkowskiA_set(void *c,void* a) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	::btConvexShape const * ta = (::btConvexShape const *)a;
	o->m_minkowskiA = ta;
}
void* btGjkPairDetector_m_minkowskiA_get(void *c) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	return (void*)(o->m_minkowskiA);
}

//attribute: ::btConvexShape const * btGjkPairDetector->m_minkowskiB
void btGjkPairDetector_m_minkowskiB_set(void *c,void* a) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	::btConvexShape const * ta = (::btConvexShape const *)a;
	o->m_minkowskiB = ta;
}
void* btGjkPairDetector_m_minkowskiB_get(void *c) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	return (void*)(o->m_minkowskiB);
}

//attribute: int btGjkPairDetector->m_shapeTypeA
void btGjkPairDetector_m_shapeTypeA_set(void *c,int a) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	o->m_shapeTypeA = a;
}
int btGjkPairDetector_m_shapeTypeA_get(void *c) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	return (int)(o->m_shapeTypeA);
}

//attribute: int btGjkPairDetector->m_shapeTypeB
void btGjkPairDetector_m_shapeTypeB_set(void *c,int a) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	o->m_shapeTypeB = a;
}
int btGjkPairDetector_m_shapeTypeB_get(void *c) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	return (int)(o->m_shapeTypeB);
}

//attribute: ::btScalar btGjkPairDetector->m_marginA
void btGjkPairDetector_m_marginA_set(void *c,float a) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	o->m_marginA = a;
}
float btGjkPairDetector_m_marginA_get(void *c) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	return (float)(o->m_marginA);
}

//attribute: ::btScalar btGjkPairDetector->m_marginB
void btGjkPairDetector_m_marginB_set(void *c,float a) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	o->m_marginB = a;
}
float btGjkPairDetector_m_marginB_get(void *c) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	return (float)(o->m_marginB);
}

//attribute: bool btGjkPairDetector->m_ignoreMargin
void btGjkPairDetector_m_ignoreMargin_set(void *c,int a) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	o->m_ignoreMargin = a;
}
int btGjkPairDetector_m_ignoreMargin_get(void *c) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	return (int)(o->m_ignoreMargin);
}

//attribute: ::btScalar btGjkPairDetector->m_cachedSeparatingDistance
void btGjkPairDetector_m_cachedSeparatingDistance_set(void *c,float a) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	o->m_cachedSeparatingDistance = a;
}
float btGjkPairDetector_m_cachedSeparatingDistance_get(void *c) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	return (float)(o->m_cachedSeparatingDistance);
}

//attribute: int btGjkPairDetector->m_lastUsedMethod
void btGjkPairDetector_m_lastUsedMethod_set(void *c,int a) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	o->m_lastUsedMethod = a;
}
int btGjkPairDetector_m_lastUsedMethod_get(void *c) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	return (int)(o->m_lastUsedMethod);
}

//attribute: int btGjkPairDetector->m_curIter
void btGjkPairDetector_m_curIter_set(void *c,int a) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	o->m_curIter = a;
}
int btGjkPairDetector_m_curIter_get(void *c) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	return (int)(o->m_curIter);
}

//attribute: int btGjkPairDetector->m_degenerateSimplex
void btGjkPairDetector_m_degenerateSimplex_set(void *c,int a) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	o->m_degenerateSimplex = a;
}
int btGjkPairDetector_m_degenerateSimplex_get(void *c) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	return (int)(o->m_degenerateSimplex);
}

//attribute: int btGjkPairDetector->m_catchDegeneracies
void btGjkPairDetector_m_catchDegeneracies_set(void *c,int a) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	o->m_catchDegeneracies = a;
}
int btGjkPairDetector_m_catchDegeneracies_get(void *c) {
	::btGjkPairDetector *o = (::btGjkPairDetector*)c;
	return (int)(o->m_catchDegeneracies);
}


// ::btManifoldPoint
//constructor: btManifoldPoint  ( ::btManifoldPoint::* )(  ) 
void* btManifoldPoint_new0() {
	::btManifoldPoint *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btManifoldPoint),16);
	o = new (mem)::btManifoldPoint();
	return (void*)o;
}
//constructor: btManifoldPoint  ( ::btManifoldPoint::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
void* btManifoldPoint_new1(float* p0,float* p1,float* p2,float p3) {
	::btManifoldPoint *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	mem = btAlignedAlloc(sizeof(::btManifoldPoint),16);
	o = new (mem)::btManifoldPoint(tp0,tp1,tp2,p3);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	return (void*)o;
}
void btManifoldPoint_free(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	delete o;
}
//method: setDistance void ( ::btManifoldPoint::* )( ::btScalar ) 
void btManifoldPoint_setDistance(void *c,float p0) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->setDistance(p0);
}
//method: getLifeTime int ( ::btManifoldPoint::* )(  ) const
int btManifoldPoint_getLifeTime(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	int retVal = (int)o->getLifeTime();
	return retVal;
}
//method: getDistance ::btScalar ( ::btManifoldPoint::* )(  ) const
float btManifoldPoint_getDistance(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	float retVal = (float)o->getDistance();
	return retVal;
}
//method: getPositionWorldOnB ::btVector3 const & ( ::btManifoldPoint::* )(  ) const
void btManifoldPoint_getPositionWorldOnB(void *c,float* ret) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getPositionWorldOnB();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getAppliedImpulse ::btScalar ( ::btManifoldPoint::* )(  ) const
float btManifoldPoint_getAppliedImpulse(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	float retVal = (float)o->getAppliedImpulse();
	return retVal;
}
//method: getPositionWorldOnA ::btVector3 const & ( ::btManifoldPoint::* )(  ) const
void btManifoldPoint_getPositionWorldOnA(void *c,float* ret) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getPositionWorldOnA();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//attribute: ::btConstraintRow[3] btManifoldPoint->mConstraintRow
// attribute not supported: //attribute: ::btConstraintRow[3] btManifoldPoint->mConstraintRow
//attribute: ::btScalar btManifoldPoint->m_appliedImpulse
void btManifoldPoint_m_appliedImpulse_set(void *c,float a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_appliedImpulse = a;
}
float btManifoldPoint_m_appliedImpulse_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (float)(o->m_appliedImpulse);
}

//attribute: ::btScalar btManifoldPoint->m_appliedImpulseLateral1
void btManifoldPoint_m_appliedImpulseLateral1_set(void *c,float a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_appliedImpulseLateral1 = a;
}
float btManifoldPoint_m_appliedImpulseLateral1_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (float)(o->m_appliedImpulseLateral1);
}

//attribute: ::btScalar btManifoldPoint->m_appliedImpulseLateral2
void btManifoldPoint_m_appliedImpulseLateral2_set(void *c,float a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_appliedImpulseLateral2 = a;
}
float btManifoldPoint_m_appliedImpulseLateral2_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (float)(o->m_appliedImpulseLateral2);
}

//attribute: ::btScalar btManifoldPoint->m_combinedFriction
void btManifoldPoint_m_combinedFriction_set(void *c,float a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_combinedFriction = a;
}
float btManifoldPoint_m_combinedFriction_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (float)(o->m_combinedFriction);
}

//attribute: ::btScalar btManifoldPoint->m_combinedRestitution
void btManifoldPoint_m_combinedRestitution_set(void *c,float a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_combinedRestitution = a;
}
float btManifoldPoint_m_combinedRestitution_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (float)(o->m_combinedRestitution);
}

//attribute: ::btScalar btManifoldPoint->m_contactCFM1
void btManifoldPoint_m_contactCFM1_set(void *c,float a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_contactCFM1 = a;
}
float btManifoldPoint_m_contactCFM1_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (float)(o->m_contactCFM1);
}

//attribute: ::btScalar btManifoldPoint->m_contactCFM2
void btManifoldPoint_m_contactCFM2_set(void *c,float a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_contactCFM2 = a;
}
float btManifoldPoint_m_contactCFM2_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (float)(o->m_contactCFM2);
}

//attribute: ::btScalar btManifoldPoint->m_contactMotion1
void btManifoldPoint_m_contactMotion1_set(void *c,float a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_contactMotion1 = a;
}
float btManifoldPoint_m_contactMotion1_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (float)(o->m_contactMotion1);
}

//attribute: ::btScalar btManifoldPoint->m_contactMotion2
void btManifoldPoint_m_contactMotion2_set(void *c,float a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_contactMotion2 = a;
}
float btManifoldPoint_m_contactMotion2_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (float)(o->m_contactMotion2);
}

//attribute: ::btScalar btManifoldPoint->m_distance1
void btManifoldPoint_m_distance1_set(void *c,float a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_distance1 = a;
}
float btManifoldPoint_m_distance1_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (float)(o->m_distance1);
}

//attribute: int btManifoldPoint->m_index0
void btManifoldPoint_m_index0_set(void *c,int a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_index0 = a;
}
int btManifoldPoint_m_index0_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (int)(o->m_index0);
}

//attribute: int btManifoldPoint->m_index1
void btManifoldPoint_m_index1_set(void *c,int a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_index1 = a;
}
int btManifoldPoint_m_index1_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (int)(o->m_index1);
}

//attribute: ::btVector3 btManifoldPoint->m_lateralFrictionDir1
void btManifoldPoint_m_lateralFrictionDir1_set(void *c,float* a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_lateralFrictionDir1 = ta;
}
void btManifoldPoint_m_lateralFrictionDir1_get(void *c,float* a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	a[0]=(o->m_lateralFrictionDir1).m_floats[0];a[1]=(o->m_lateralFrictionDir1).m_floats[1];a[2]=(o->m_lateralFrictionDir1).m_floats[2];
}

//attribute: ::btVector3 btManifoldPoint->m_lateralFrictionDir2
void btManifoldPoint_m_lateralFrictionDir2_set(void *c,float* a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_lateralFrictionDir2 = ta;
}
void btManifoldPoint_m_lateralFrictionDir2_get(void *c,float* a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	a[0]=(o->m_lateralFrictionDir2).m_floats[0];a[1]=(o->m_lateralFrictionDir2).m_floats[1];a[2]=(o->m_lateralFrictionDir2).m_floats[2];
}

//attribute: bool btManifoldPoint->m_lateralFrictionInitialized
void btManifoldPoint_m_lateralFrictionInitialized_set(void *c,int a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_lateralFrictionInitialized = a;
}
int btManifoldPoint_m_lateralFrictionInitialized_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (int)(o->m_lateralFrictionInitialized);
}

//attribute: int btManifoldPoint->m_lifeTime
void btManifoldPoint_m_lifeTime_set(void *c,int a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_lifeTime = a;
}
int btManifoldPoint_m_lifeTime_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (int)(o->m_lifeTime);
}

//attribute: ::btVector3 btManifoldPoint->m_localPointA
void btManifoldPoint_m_localPointA_set(void *c,float* a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localPointA = ta;
}
void btManifoldPoint_m_localPointA_get(void *c,float* a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	a[0]=(o->m_localPointA).m_floats[0];a[1]=(o->m_localPointA).m_floats[1];a[2]=(o->m_localPointA).m_floats[2];
}

//attribute: ::btVector3 btManifoldPoint->m_localPointB
void btManifoldPoint_m_localPointB_set(void *c,float* a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_localPointB = ta;
}
void btManifoldPoint_m_localPointB_get(void *c,float* a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	a[0]=(o->m_localPointB).m_floats[0];a[1]=(o->m_localPointB).m_floats[1];a[2]=(o->m_localPointB).m_floats[2];
}

//attribute: ::btVector3 btManifoldPoint->m_normalWorldOnB
void btManifoldPoint_m_normalWorldOnB_set(void *c,float* a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_normalWorldOnB = ta;
}
void btManifoldPoint_m_normalWorldOnB_get(void *c,float* a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	a[0]=(o->m_normalWorldOnB).m_floats[0];a[1]=(o->m_normalWorldOnB).m_floats[1];a[2]=(o->m_normalWorldOnB).m_floats[2];
}

//attribute: int btManifoldPoint->m_partId0
void btManifoldPoint_m_partId0_set(void *c,int a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_partId0 = a;
}
int btManifoldPoint_m_partId0_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (int)(o->m_partId0);
}

//attribute: int btManifoldPoint->m_partId1
void btManifoldPoint_m_partId1_set(void *c,int a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	o->m_partId1 = a;
}
int btManifoldPoint_m_partId1_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (int)(o->m_partId1);
}

//attribute: ::btVector3 btManifoldPoint->m_positionWorldOnA
void btManifoldPoint_m_positionWorldOnA_set(void *c,float* a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_positionWorldOnA = ta;
}
void btManifoldPoint_m_positionWorldOnA_get(void *c,float* a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	a[0]=(o->m_positionWorldOnA).m_floats[0];a[1]=(o->m_positionWorldOnA).m_floats[1];a[2]=(o->m_positionWorldOnA).m_floats[2];
}

//attribute: ::btVector3 btManifoldPoint->m_positionWorldOnB
void btManifoldPoint_m_positionWorldOnB_set(void *c,float* a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_positionWorldOnB = ta;
}
void btManifoldPoint_m_positionWorldOnB_get(void *c,float* a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	a[0]=(o->m_positionWorldOnB).m_floats[0];a[1]=(o->m_positionWorldOnB).m_floats[1];a[2]=(o->m_positionWorldOnB).m_floats[2];
}

//attribute: void * btManifoldPoint->m_userPersistentData
void btManifoldPoint_m_userPersistentData_set(void *c,void* a) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	void * ta = (void *)a;
	o->m_userPersistentData = ta;
}
void* btManifoldPoint_m_userPersistentData_get(void *c) {
	::btManifoldPoint *o = (::btManifoldPoint*)c;
	return (void*)(o->m_userPersistentData);
}


// ::btPersistentManifold
//constructor: btPersistentManifold  ( ::btPersistentManifold::* )(  ) 
void* btPersistentManifold_new0() {
	::btPersistentManifold *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btPersistentManifold),16);
	o = new (mem)::btPersistentManifold();
	return (void*)o;
}
//constructor: btPersistentManifold  ( ::btPersistentManifold::* )( void *,void *,int,::btScalar,::btScalar ) 
void* btPersistentManifold_new1(void* p0,void* p1,int p2,float p3,float p4) {
	::btPersistentManifold *o = 0;
	 void *mem = 0;
	void * tp0 = (void *)p0;
	void * tp1 = (void *)p1;
	mem = btAlignedAlloc(sizeof(::btPersistentManifold),16);
	o = new (mem)::btPersistentManifold(tp0,tp1,p2,p3,p4);
	return (void*)o;
}
void btPersistentManifold_free(void *c) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	delete o;
}
//method: setBodies void ( ::btPersistentManifold::* )( void *,void * ) 
void btPersistentManifold_setBodies(void *c,void* p0,void* p1) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	void * tp0 = (void *)p0;
	void * tp1 = (void *)p1;
	o->setBodies(tp0,tp1);
}
//method: replaceContactPoint void ( ::btPersistentManifold::* )( ::btManifoldPoint const &,int ) 
void btPersistentManifold_replaceContactPoint(void *c,void* p0,int p1) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	::btManifoldPoint const & tp0 = *(::btManifoldPoint const *)p0;
	o->replaceContactPoint(tp0,p1);
}
//method: clearUserCache void ( ::btPersistentManifold::* )( ::btManifoldPoint & ) 
void btPersistentManifold_clearUserCache(void *c,void* p0) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	::btManifoldPoint & tp0 = *(::btManifoldPoint *)p0;
	o->clearUserCache(tp0);
}
//method: getBody1 void * ( ::btPersistentManifold::* )(  ) 
void* btPersistentManifold_getBody1(void *c) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	void* retVal = (void*) o->getBody1();
	return retVal;
}
//method: getBody1 void * ( ::btPersistentManifold::* )(  ) 
void* btPersistentManifold_getBody10(void *c) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	void* retVal = (void*) o->getBody1();
	return retVal;
}
//not supported method: getBody1 void const * ( ::btPersistentManifold::* )(  ) const
// error:  - unsupported

//method: getContactProcessingThreshold ::btScalar ( ::btPersistentManifold::* )(  ) const
float btPersistentManifold_getContactProcessingThreshold(void *c) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	float retVal = (float)o->getContactProcessingThreshold();
	return retVal;
}
//method: clearManifold void ( ::btPersistentManifold::* )(  ) 
void btPersistentManifold_clearManifold(void *c) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	o->clearManifold();
}
//method: getNumContacts int ( ::btPersistentManifold::* )(  ) const
int btPersistentManifold_getNumContacts(void *c) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	int retVal = (int)o->getNumContacts();
	return retVal;
}
//method: getBody0 void * ( ::btPersistentManifold::* )(  ) 
void* btPersistentManifold_getBody0(void *c) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	void* retVal = (void*) o->getBody0();
	return retVal;
}
//method: getBody0 void * ( ::btPersistentManifold::* )(  ) 
void* btPersistentManifold_getBody00(void *c) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	void* retVal = (void*) o->getBody0();
	return retVal;
}
//not supported method: getBody0 void const * ( ::btPersistentManifold::* )(  ) const
// error:  - unsupported

//method: addManifoldPoint int ( ::btPersistentManifold::* )( ::btManifoldPoint const & ) 
int btPersistentManifold_addManifoldPoint(void *c,void* p0) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	::btManifoldPoint const & tp0 = *(::btManifoldPoint const *)p0;
	int retVal = (int)o->addManifoldPoint(tp0);
	return retVal;
}
//method: getCacheEntry int ( ::btPersistentManifold::* )( ::btManifoldPoint const & ) const
int btPersistentManifold_getCacheEntry(void *c,void* p0) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	::btManifoldPoint const & tp0 = *(::btManifoldPoint const *)p0;
	int retVal = (int)o->getCacheEntry(tp0);
	return retVal;
}
//method: validContactDistance bool ( ::btPersistentManifold::* )( ::btManifoldPoint const & ) const
int btPersistentManifold_validContactDistance(void *c,void* p0) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	::btManifoldPoint const & tp0 = *(::btManifoldPoint const *)p0;
	int retVal = (int)o->validContactDistance(tp0);
	return retVal;
}
//method: removeContactPoint void ( ::btPersistentManifold::* )( int ) 
void btPersistentManifold_removeContactPoint(void *c,int p0) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	o->removeContactPoint(p0);
}
//method: getContactPoint ::btManifoldPoint const & ( ::btPersistentManifold::* )( int ) const
void* btPersistentManifold_getContactPoint(void *c,int p0) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	void* retVal = (void*) &(o->getContactPoint(p0));
	return retVal;
}
//method: getContactPoint ::btManifoldPoint const & ( ::btPersistentManifold::* )( int ) const
void* btPersistentManifold_getContactPoint0(void *c,int p0) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	void* retVal = (void*) &(o->getContactPoint(p0));
	return retVal;
}
//method: getContactPoint ::btManifoldPoint & ( ::btPersistentManifold::* )( int ) 
void* btPersistentManifold_getContactPoint1(void *c,int p0) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	void* retVal = (void*) &(o->getContactPoint(p0));
	return retVal;
}
//method: refreshContactPoints void ( ::btPersistentManifold::* )( ::btTransform const &,::btTransform const & ) 
void btPersistentManifold_refreshContactPoints(void *c,float* p0,float* p1) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	o->refreshContactPoints(tp0,tp1);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
}
//method: getContactBreakingThreshold ::btScalar ( ::btPersistentManifold::* )(  ) const
float btPersistentManifold_getContactBreakingThreshold(void *c) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	float retVal = (float)o->getContactBreakingThreshold();
	return retVal;
}
//attribute: int btPersistentManifold->m_companionIdA
void btPersistentManifold_m_companionIdA_set(void *c,int a) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	o->m_companionIdA = a;
}
int btPersistentManifold_m_companionIdA_get(void *c) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	return (int)(o->m_companionIdA);
}

//attribute: int btPersistentManifold->m_companionIdB
void btPersistentManifold_m_companionIdB_set(void *c,int a) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	o->m_companionIdB = a;
}
int btPersistentManifold_m_companionIdB_get(void *c) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	return (int)(o->m_companionIdB);
}

//attribute: int btPersistentManifold->m_index1a
void btPersistentManifold_m_index1a_set(void *c,int a) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	o->m_index1a = a;
}
int btPersistentManifold_m_index1a_get(void *c) {
	::btPersistentManifold *o = (::btPersistentManifold*)c;
	return (int)(o->m_index1a);
}


// ::btStorageResult
//method: addContactPoint void ( ::btStorageResult::* )( ::btVector3 const &,::btVector3 const &,::btScalar ) 
void btStorageResult_addContactPoint(void *c,float* p0,float* p1,float p2) {
	::btStorageResult *o = (::btStorageResult*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->addContactPoint(tp0,tp1,p2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//attribute: ::btVector3 btStorageResult->m_normalOnSurfaceB
void btStorageResult_m_normalOnSurfaceB_set(void *c,float* a) {
	::btStorageResult *o = (::btStorageResult*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_normalOnSurfaceB = ta;
}
void btStorageResult_m_normalOnSurfaceB_get(void *c,float* a) {
	::btStorageResult *o = (::btStorageResult*)c;
	a[0]=(o->m_normalOnSurfaceB).m_floats[0];a[1]=(o->m_normalOnSurfaceB).m_floats[1];a[2]=(o->m_normalOnSurfaceB).m_floats[2];
}

//attribute: ::btVector3 btStorageResult->m_closestPointInB
void btStorageResult_m_closestPointInB_set(void *c,float* a) {
	::btStorageResult *o = (::btStorageResult*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_closestPointInB = ta;
}
void btStorageResult_m_closestPointInB_get(void *c,float* a) {
	::btStorageResult *o = (::btStorageResult*)c;
	a[0]=(o->m_closestPointInB).m_floats[0];a[1]=(o->m_closestPointInB).m_floats[1];a[2]=(o->m_closestPointInB).m_floats[2];
}

//attribute: ::btScalar btStorageResult->m_distance
void btStorageResult_m_distance_set(void *c,float a) {
	::btStorageResult *o = (::btStorageResult*)c;
	o->m_distance = a;
}
float btStorageResult_m_distance_get(void *c) {
	::btStorageResult *o = (::btStorageResult*)c;
	return (float)(o->m_distance);
}


// ::btSubSimplexClosestResult
//constructor: btSubSimplexClosestResult  ( ::btSubSimplexClosestResult::* )(  ) 
void* btSubSimplexClosestResult_new() {
	::btSubSimplexClosestResult *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSubSimplexClosestResult),16);
	o = new (mem)::btSubSimplexClosestResult();
	return (void*)o;
}
void btSubSimplexClosestResult_free(void *c) {
	::btSubSimplexClosestResult *o = (::btSubSimplexClosestResult*)c;
	delete o;
}
//method: reset void ( ::btSubSimplexClosestResult::* )(  ) 
void btSubSimplexClosestResult_reset(void *c) {
	::btSubSimplexClosestResult *o = (::btSubSimplexClosestResult*)c;
	o->reset();
}
//method: isValid bool ( ::btSubSimplexClosestResult::* )(  ) 
int btSubSimplexClosestResult_isValid(void *c) {
	::btSubSimplexClosestResult *o = (::btSubSimplexClosestResult*)c;
	int retVal = (int)o->isValid();
	return retVal;
}
//method: setBarycentricCoordinates void ( ::btSubSimplexClosestResult::* )( ::btScalar,::btScalar,::btScalar,::btScalar ) 
void btSubSimplexClosestResult_setBarycentricCoordinates(void *c,float p0,float p1,float p2,float p3) {
	::btSubSimplexClosestResult *o = (::btSubSimplexClosestResult*)c;
	o->setBarycentricCoordinates(p0,p1,p2,p3);
}
//attribute: ::btVector3 btSubSimplexClosestResult->m_closestPointOnSimplex
void btSubSimplexClosestResult_m_closestPointOnSimplex_set(void *c,float* a) {
	::btSubSimplexClosestResult *o = (::btSubSimplexClosestResult*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_closestPointOnSimplex = ta;
}
void btSubSimplexClosestResult_m_closestPointOnSimplex_get(void *c,float* a) {
	::btSubSimplexClosestResult *o = (::btSubSimplexClosestResult*)c;
	a[0]=(o->m_closestPointOnSimplex).m_floats[0];a[1]=(o->m_closestPointOnSimplex).m_floats[1];a[2]=(o->m_closestPointOnSimplex).m_floats[2];
}

//attribute: ::btUsageBitfield btSubSimplexClosestResult->m_usedVertices
void btSubSimplexClosestResult_m_usedVertices_set(void *c,void* a) {
	::btSubSimplexClosestResult *o = (::btSubSimplexClosestResult*)c;
	::btUsageBitfield & ta = *(::btUsageBitfield *)a;
	o->m_usedVertices = ta;
}
void* btSubSimplexClosestResult_m_usedVertices_get(void *c) {
	::btSubSimplexClosestResult *o = (::btSubSimplexClosestResult*)c;
	return (void*)&(o->m_usedVertices);
}

//attribute: ::btScalar[4] btSubSimplexClosestResult->m_barycentricCoords
// attribute not supported: //attribute: ::btScalar[4] btSubSimplexClosestResult->m_barycentricCoords
//attribute: bool btSubSimplexClosestResult->m_degenerate
void btSubSimplexClosestResult_m_degenerate_set(void *c,int a) {
	::btSubSimplexClosestResult *o = (::btSubSimplexClosestResult*)c;
	o->m_degenerate = a;
}
int btSubSimplexClosestResult_m_degenerate_get(void *c) {
	::btSubSimplexClosestResult *o = (::btSubSimplexClosestResult*)c;
	return (int)(o->m_degenerate);
}


// ::btUsageBitfield
//constructor: btUsageBitfield  ( ::btUsageBitfield::* )(  ) 
void* btUsageBitfield_new() {
	::btUsageBitfield *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btUsageBitfield),16);
	o = new (mem)::btUsageBitfield();
	return (void*)o;
}
void btUsageBitfield_free(void *c) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	delete o;
}
//method: reset void ( ::btUsageBitfield::* )(  ) 
void btUsageBitfield_reset(void *c) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	o->reset();
}
//attribute: short unsigned int btUsageBitfield->unused1
void btUsageBitfield_unused1_set(void *c,short unsigned int a) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	o->unused1 = a;
}
short unsigned int btUsageBitfield_unused1_get(void *c) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	return (short unsigned int)(o->unused1);
}

//attribute: short unsigned int btUsageBitfield->unused2
void btUsageBitfield_unused2_set(void *c,short unsigned int a) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	o->unused2 = a;
}
short unsigned int btUsageBitfield_unused2_get(void *c) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	return (short unsigned int)(o->unused2);
}

//attribute: short unsigned int btUsageBitfield->unused3
void btUsageBitfield_unused3_set(void *c,short unsigned int a) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	o->unused3 = a;
}
short unsigned int btUsageBitfield_unused3_get(void *c) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	return (short unsigned int)(o->unused3);
}

//attribute: short unsigned int btUsageBitfield->unused4
void btUsageBitfield_unused4_set(void *c,short unsigned int a) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	o->unused4 = a;
}
short unsigned int btUsageBitfield_unused4_get(void *c) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	return (short unsigned int)(o->unused4);
}

//attribute: short unsigned int btUsageBitfield->usedVertexA
void btUsageBitfield_usedVertexA_set(void *c,short unsigned int a) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	o->usedVertexA = a;
}
short unsigned int btUsageBitfield_usedVertexA_get(void *c) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	return (short unsigned int)(o->usedVertexA);
}

//attribute: short unsigned int btUsageBitfield->usedVertexB
void btUsageBitfield_usedVertexB_set(void *c,short unsigned int a) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	o->usedVertexB = a;
}
short unsigned int btUsageBitfield_usedVertexB_get(void *c) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	return (short unsigned int)(o->usedVertexB);
}

//attribute: short unsigned int btUsageBitfield->usedVertexC
void btUsageBitfield_usedVertexC_set(void *c,short unsigned int a) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	o->usedVertexC = a;
}
short unsigned int btUsageBitfield_usedVertexC_get(void *c) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	return (short unsigned int)(o->usedVertexC);
}

//attribute: short unsigned int btUsageBitfield->usedVertexD
void btUsageBitfield_usedVertexD_set(void *c,short unsigned int a) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	o->usedVertexD = a;
}
short unsigned int btUsageBitfield_usedVertexD_get(void *c) {
	::btUsageBitfield *o = (::btUsageBitfield*)c;
	return (short unsigned int)(o->usedVertexD);
}


// ::btVoronoiSimplexSolver
//constructor: btVoronoiSimplexSolver  ( ::btVoronoiSimplexSolver::* )(  ) 
void* btVoronoiSimplexSolver_new() {
	::btVoronoiSimplexSolver *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btVoronoiSimplexSolver),16);
	o = new (mem)::btVoronoiSimplexSolver();
	return (void*)o;
}
void btVoronoiSimplexSolver_free(void *c) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	delete o;
}
//method: reset void ( ::btVoronoiSimplexSolver::* )(  ) 
void btVoronoiSimplexSolver_reset(void *c) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	o->reset();
}
//method: updateClosestVectorAndPoints bool ( ::btVoronoiSimplexSolver::* )(  ) 
int btVoronoiSimplexSolver_updateClosestVectorAndPoints(void *c) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	int retVal = (int)o->updateClosestVectorAndPoints();
	return retVal;
}
//method: setEqualVertexThreshold void ( ::btVoronoiSimplexSolver::* )( ::btScalar ) 
void btVoronoiSimplexSolver_setEqualVertexThreshold(void *c,float p0) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	o->setEqualVertexThreshold(p0);
}
//method: inSimplex bool ( ::btVoronoiSimplexSolver::* )( ::btVector3 const & ) 
int btVoronoiSimplexSolver_inSimplex(void *c,float* p0) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	int retVal = (int)o->inSimplex(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return retVal;
}
//method: closest bool ( ::btVoronoiSimplexSolver::* )( ::btVector3 & ) 
int btVoronoiSimplexSolver_closest(void *c,float* p0) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	int retVal = (int)o->closest(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	return retVal;
}
//method: closestPtPointTetrahedron bool ( ::btVoronoiSimplexSolver::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btSubSimplexClosestResult & ) 
int btVoronoiSimplexSolver_closestPtPointTetrahedron(void *c,float* p0,float* p1,float* p2,float* p3,float* p4,void* p5) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	::btSubSimplexClosestResult & tp5 = *(::btSubSimplexClosestResult *)p5;
	int retVal = (int)o->closestPtPointTetrahedron(tp0,tp1,tp2,tp3,tp4,tp5);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	return retVal;
}
//method: closestPtPointTriangle bool ( ::btVoronoiSimplexSolver::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btSubSimplexClosestResult & ) 
int btVoronoiSimplexSolver_closestPtPointTriangle(void *c,float* p0,float* p1,float* p2,float* p3,void* p4) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	::btSubSimplexClosestResult & tp4 = *(::btSubSimplexClosestResult *)p4;
	int retVal = (int)o->closestPtPointTriangle(tp0,tp1,tp2,tp3,tp4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	return retVal;
}
//method: pointOutsideOfPlane int ( ::btVoronoiSimplexSolver::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
int btVoronoiSimplexSolver_pointOutsideOfPlane(void *c,float* p0,float* p1,float* p2,float* p3,float* p4) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	btVector3 tp4(p4[0],p4[1],p4[2]);
	int retVal = (int)o->pointOutsideOfPlane(tp0,tp1,tp2,tp3,tp4);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	p4[0]=tp4.m_floats[0];p4[1]=tp4.m_floats[1];p4[2]=tp4.m_floats[2];
	return retVal;
}
//method: emptySimplex bool ( ::btVoronoiSimplexSolver::* )(  ) const
int btVoronoiSimplexSolver_emptySimplex(void *c) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	int retVal = (int)o->emptySimplex();
	return retVal;
}
//not supported method: getSimplex int ( ::btVoronoiSimplexSolver::* )( ::btVector3 *,::btVector3 *,::btVector3 * ) const
// error:  - unsupported,  - unsupported,  - unsupported, int - ok

//method: maxVertex ::btScalar ( ::btVoronoiSimplexSolver::* )(  ) 
float btVoronoiSimplexSolver_maxVertex(void *c) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	float retVal = (float)o->maxVertex();
	return retVal;
}
//method: addVertex void ( ::btVoronoiSimplexSolver::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btVoronoiSimplexSolver_addVertex(void *c,float* p0,float* p1,float* p2) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->addVertex(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: reduceVertices void ( ::btVoronoiSimplexSolver::* )( ::btUsageBitfield const & ) 
void btVoronoiSimplexSolver_reduceVertices(void *c,void* p0) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	::btUsageBitfield const & tp0 = *(::btUsageBitfield const *)p0;
	o->reduceVertices(tp0);
}
//method: backup_closest void ( ::btVoronoiSimplexSolver::* )( ::btVector3 & ) 
void btVoronoiSimplexSolver_backup_closest(void *c,float* p0) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->backup_closest(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: removeVertex void ( ::btVoronoiSimplexSolver::* )( int ) 
void btVoronoiSimplexSolver_removeVertex(void *c,int p0) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	o->removeVertex(p0);
}
//method: getEqualVertexThreshold ::btScalar ( ::btVoronoiSimplexSolver::* )(  ) const
float btVoronoiSimplexSolver_getEqualVertexThreshold(void *c) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	float retVal = (float)o->getEqualVertexThreshold();
	return retVal;
}
//method: compute_points void ( ::btVoronoiSimplexSolver::* )( ::btVector3 &,::btVector3 & ) 
void btVoronoiSimplexSolver_compute_points(void *c,float* p0,float* p1) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->compute_points(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: fullSimplex bool ( ::btVoronoiSimplexSolver::* )(  ) const
int btVoronoiSimplexSolver_fullSimplex(void *c) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	int retVal = (int)o->fullSimplex();
	return retVal;
}
//method: numVertices int ( ::btVoronoiSimplexSolver::* )(  ) const
int btVoronoiSimplexSolver_numVertices(void *c) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	int retVal = (int)o->numVertices();
	return retVal;
}
//attribute: ::btSubSimplexClosestResult btVoronoiSimplexSolver->m_cachedBC
void btVoronoiSimplexSolver_m_cachedBC_set(void *c,void* a) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	::btSubSimplexClosestResult & ta = *(::btSubSimplexClosestResult *)a;
	o->m_cachedBC = ta;
}
void* btVoronoiSimplexSolver_m_cachedBC_get(void *c) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	return (void*)&(o->m_cachedBC);
}

//attribute: ::btVector3 btVoronoiSimplexSolver->m_cachedP1
void btVoronoiSimplexSolver_m_cachedP1_set(void *c,float* a) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_cachedP1 = ta;
}
void btVoronoiSimplexSolver_m_cachedP1_get(void *c,float* a) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	a[0]=(o->m_cachedP1).m_floats[0];a[1]=(o->m_cachedP1).m_floats[1];a[2]=(o->m_cachedP1).m_floats[2];
}

//attribute: ::btVector3 btVoronoiSimplexSolver->m_cachedP2
void btVoronoiSimplexSolver_m_cachedP2_set(void *c,float* a) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_cachedP2 = ta;
}
void btVoronoiSimplexSolver_m_cachedP2_get(void *c,float* a) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	a[0]=(o->m_cachedP2).m_floats[0];a[1]=(o->m_cachedP2).m_floats[1];a[2]=(o->m_cachedP2).m_floats[2];
}

//attribute: ::btVector3 btVoronoiSimplexSolver->m_cachedV
void btVoronoiSimplexSolver_m_cachedV_set(void *c,float* a) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_cachedV = ta;
}
void btVoronoiSimplexSolver_m_cachedV_get(void *c,float* a) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	a[0]=(o->m_cachedV).m_floats[0];a[1]=(o->m_cachedV).m_floats[1];a[2]=(o->m_cachedV).m_floats[2];
}

//attribute: bool btVoronoiSimplexSolver->m_cachedValidClosest
void btVoronoiSimplexSolver_m_cachedValidClosest_set(void *c,int a) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	o->m_cachedValidClosest = a;
}
int btVoronoiSimplexSolver_m_cachedValidClosest_get(void *c) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	return (int)(o->m_cachedValidClosest);
}

//attribute: ::btScalar btVoronoiSimplexSolver->m_equalVertexThreshold
void btVoronoiSimplexSolver_m_equalVertexThreshold_set(void *c,float a) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	o->m_equalVertexThreshold = a;
}
float btVoronoiSimplexSolver_m_equalVertexThreshold_get(void *c) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	return (float)(o->m_equalVertexThreshold);
}

//attribute: ::btVector3 btVoronoiSimplexSolver->m_lastW
void btVoronoiSimplexSolver_m_lastW_set(void *c,float* a) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_lastW = ta;
}
void btVoronoiSimplexSolver_m_lastW_get(void *c,float* a) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	a[0]=(o->m_lastW).m_floats[0];a[1]=(o->m_lastW).m_floats[1];a[2]=(o->m_lastW).m_floats[2];
}

//attribute: bool btVoronoiSimplexSolver->m_needsUpdate
void btVoronoiSimplexSolver_m_needsUpdate_set(void *c,int a) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	o->m_needsUpdate = a;
}
int btVoronoiSimplexSolver_m_needsUpdate_get(void *c) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	return (int)(o->m_needsUpdate);
}

//attribute: int btVoronoiSimplexSolver->m_numVertices
void btVoronoiSimplexSolver_m_numVertices_set(void *c,int a) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	o->m_numVertices = a;
}
int btVoronoiSimplexSolver_m_numVertices_get(void *c) {
	::btVoronoiSimplexSolver *o = (::btVoronoiSimplexSolver*)c;
	return (int)(o->m_numVertices);
}

//attribute: ::btVector3[5] btVoronoiSimplexSolver->m_simplexPointsP
// attribute not supported: //attribute: ::btVector3[5] btVoronoiSimplexSolver->m_simplexPointsP
//attribute: ::btVector3[5] btVoronoiSimplexSolver->m_simplexPointsQ
// attribute not supported: //attribute: ::btVector3[5] btVoronoiSimplexSolver->m_simplexPointsQ
//attribute: ::btVector3[5] btVoronoiSimplexSolver->m_simplexVectorW
// attribute not supported: //attribute: ::btVector3[5] btVoronoiSimplexSolver->m_simplexVectorW

// ::btGjkEpaSolver2::sResults
//constructor: sResults  ( ::btGjkEpaSolver2::sResults::* )(  ) 
void* btGjkEpaSolver2_sResults_new() {
	::btGjkEpaSolver2::sResults *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGjkEpaSolver2::sResults),16);
	o = new (mem)::btGjkEpaSolver2::sResults();
	return (void*)o;
}
void btGjkEpaSolver2_sResults_free(void *c) {
	::btGjkEpaSolver2::sResults *o = (::btGjkEpaSolver2::sResults*)c;
	delete o;
}
//attribute: ::btScalar btGjkEpaSolver2_sResults->distance
void btGjkEpaSolver2_sResults_distance_set(void *c,float a) {
	::btGjkEpaSolver2::sResults *o = (::btGjkEpaSolver2::sResults*)c;
	o->distance = a;
}
float btGjkEpaSolver2_sResults_distance_get(void *c) {
	::btGjkEpaSolver2::sResults *o = (::btGjkEpaSolver2::sResults*)c;
	return (float)(o->distance);
}

//attribute: ::btVector3 btGjkEpaSolver2_sResults->normal
void btGjkEpaSolver2_sResults_normal_set(void *c,float* a) {
	::btGjkEpaSolver2::sResults *o = (::btGjkEpaSolver2::sResults*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->normal = ta;
}
void btGjkEpaSolver2_sResults_normal_get(void *c,float* a) {
	::btGjkEpaSolver2::sResults *o = (::btGjkEpaSolver2::sResults*)c;
	a[0]=(o->normal).m_floats[0];a[1]=(o->normal).m_floats[1];a[2]=(o->normal).m_floats[2];
}

//attribute: ::btGjkEpaSolver2::sResults::eStatus btGjkEpaSolver2_sResults->status
// attribute not supported: //attribute: ::btGjkEpaSolver2::sResults::eStatus btGjkEpaSolver2_sResults->status
//attribute: ::btVector3[2] btGjkEpaSolver2_sResults->witnesses
// attribute not supported: //attribute: ::btVector3[2] btGjkEpaSolver2_sResults->witnesses

// ::btCollisionWorld::AllHitsRayResultCallback
//constructor: AllHitsRayResultCallback  ( ::btCollisionWorld::AllHitsRayResultCallback::* )( ::btVector3 const &,::btVector3 const & ) 
void* btCollisionWorld_AllHitsRayResultCallback_new(float* p0,float* p1) {
	::btCollisionWorld::AllHitsRayResultCallback *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	mem = btAlignedAlloc(sizeof(::btCollisionWorld::AllHitsRayResultCallback),16);
	o = new (mem)::btCollisionWorld::AllHitsRayResultCallback(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return (void*)o;
}
void btCollisionWorld_AllHitsRayResultCallback_free(void *c) {
	::btCollisionWorld::AllHitsRayResultCallback *o = (::btCollisionWorld::AllHitsRayResultCallback*)c;
	delete o;
}
//method: addSingleResult ::btScalar ( ::btCollisionWorld::AllHitsRayResultCallback::* )( ::btCollisionWorld::LocalRayResult &,bool ) 
float btCollisionWorld_AllHitsRayResultCallback_addSingleResult(void *c,void* p0,int p1) {
	::btCollisionWorld::AllHitsRayResultCallback *o = (::btCollisionWorld::AllHitsRayResultCallback*)c;
	::btCollisionWorld::LocalRayResult & tp0 = *(::btCollisionWorld::LocalRayResult *)p0;
	float retVal = (float)o->addSingleResult(tp0,p1);
	return retVal;
}
//attribute: ::btAlignedObjectArray<btCollisionObject*> btCollisionWorld_AllHitsRayResultCallback->m_collisionObjects
void btCollisionWorld_AllHitsRayResultCallback_m_collisionObjects_set(void *c,void* a) {
	::btCollisionWorld::AllHitsRayResultCallback *o = (::btCollisionWorld::AllHitsRayResultCallback*)c;
	::btAlignedObjectArray<btCollisionObject*> & ta = *(::btAlignedObjectArray<btCollisionObject*> *)a;
	o->m_collisionObjects = ta;
}
void* btCollisionWorld_AllHitsRayResultCallback_m_collisionObjects_get(void *c) {
	::btCollisionWorld::AllHitsRayResultCallback *o = (::btCollisionWorld::AllHitsRayResultCallback*)c;
	return (void*)&(o->m_collisionObjects);
}

//attribute: ::btAlignedObjectArray<float> btCollisionWorld_AllHitsRayResultCallback->m_hitFractions
void btCollisionWorld_AllHitsRayResultCallback_m_hitFractions_set(void *c,void* a) {
	::btCollisionWorld::AllHitsRayResultCallback *o = (::btCollisionWorld::AllHitsRayResultCallback*)c;
	::btAlignedObjectArray<float> & ta = *(::btAlignedObjectArray<float> *)a;
	o->m_hitFractions = ta;
}
void* btCollisionWorld_AllHitsRayResultCallback_m_hitFractions_get(void *c) {
	::btCollisionWorld::AllHitsRayResultCallback *o = (::btCollisionWorld::AllHitsRayResultCallback*)c;
	return (void*)&(o->m_hitFractions);
}

//attribute: ::btAlignedObjectArray<btVector3> btCollisionWorld_AllHitsRayResultCallback->m_hitNormalWorld
void btCollisionWorld_AllHitsRayResultCallback_m_hitNormalWorld_set(void *c,void* a) {
	::btCollisionWorld::AllHitsRayResultCallback *o = (::btCollisionWorld::AllHitsRayResultCallback*)c;
	::btAlignedObjectArray<btVector3> & ta = *(::btAlignedObjectArray<btVector3> *)a;
	o->m_hitNormalWorld = ta;
}
void* btCollisionWorld_AllHitsRayResultCallback_m_hitNormalWorld_get(void *c) {
	::btCollisionWorld::AllHitsRayResultCallback *o = (::btCollisionWorld::AllHitsRayResultCallback*)c;
	return (void*)&(o->m_hitNormalWorld);
}

//attribute: ::btAlignedObjectArray<btVector3> btCollisionWorld_AllHitsRayResultCallback->m_hitPointWorld
void btCollisionWorld_AllHitsRayResultCallback_m_hitPointWorld_set(void *c,void* a) {
	::btCollisionWorld::AllHitsRayResultCallback *o = (::btCollisionWorld::AllHitsRayResultCallback*)c;
	::btAlignedObjectArray<btVector3> & ta = *(::btAlignedObjectArray<btVector3> *)a;
	o->m_hitPointWorld = ta;
}
void* btCollisionWorld_AllHitsRayResultCallback_m_hitPointWorld_get(void *c) {
	::btCollisionWorld::AllHitsRayResultCallback *o = (::btCollisionWorld::AllHitsRayResultCallback*)c;
	return (void*)&(o->m_hitPointWorld);
}

//attribute: ::btVector3 btCollisionWorld_AllHitsRayResultCallback->m_rayFromWorld
void btCollisionWorld_AllHitsRayResultCallback_m_rayFromWorld_set(void *c,float* a) {
	::btCollisionWorld::AllHitsRayResultCallback *o = (::btCollisionWorld::AllHitsRayResultCallback*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_rayFromWorld = ta;
}
void btCollisionWorld_AllHitsRayResultCallback_m_rayFromWorld_get(void *c,float* a) {
	::btCollisionWorld::AllHitsRayResultCallback *o = (::btCollisionWorld::AllHitsRayResultCallback*)c;
	a[0]=(o->m_rayFromWorld).m_floats[0];a[1]=(o->m_rayFromWorld).m_floats[1];a[2]=(o->m_rayFromWorld).m_floats[2];
}

//attribute: ::btVector3 btCollisionWorld_AllHitsRayResultCallback->m_rayToWorld
void btCollisionWorld_AllHitsRayResultCallback_m_rayToWorld_set(void *c,float* a) {
	::btCollisionWorld::AllHitsRayResultCallback *o = (::btCollisionWorld::AllHitsRayResultCallback*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_rayToWorld = ta;
}
void btCollisionWorld_AllHitsRayResultCallback_m_rayToWorld_get(void *c,float* a) {
	::btCollisionWorld::AllHitsRayResultCallback *o = (::btCollisionWorld::AllHitsRayResultCallback*)c;
	a[0]=(o->m_rayToWorld).m_floats[0];a[1]=(o->m_rayToWorld).m_floats[1];a[2]=(o->m_rayToWorld).m_floats[2];
}


// ::btCollisionWorld::ClosestConvexResultCallback
//constructor: ClosestConvexResultCallback  ( ::btCollisionWorld::ClosestConvexResultCallback::* )( ::btVector3 const &,::btVector3 const & ) 
void* btCollisionWorld_ClosestConvexResultCallback_new(float* p0,float* p1) {
	::btCollisionWorld::ClosestConvexResultCallback *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	mem = btAlignedAlloc(sizeof(::btCollisionWorld::ClosestConvexResultCallback),16);
	o = new (mem)::btCollisionWorld::ClosestConvexResultCallback(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return (void*)o;
}
void btCollisionWorld_ClosestConvexResultCallback_free(void *c) {
	::btCollisionWorld::ClosestConvexResultCallback *o = (::btCollisionWorld::ClosestConvexResultCallback*)c;
	delete o;
}
//method: addSingleResult ::btScalar ( ::btCollisionWorld::ClosestConvexResultCallback::* )( ::btCollisionWorld::LocalConvexResult &,bool ) 
float btCollisionWorld_ClosestConvexResultCallback_addSingleResult(void *c,void* p0,int p1) {
	::btCollisionWorld::ClosestConvexResultCallback *o = (::btCollisionWorld::ClosestConvexResultCallback*)c;
	::btCollisionWorld::LocalConvexResult & tp0 = *(::btCollisionWorld::LocalConvexResult *)p0;
	float retVal = (float)o->addSingleResult(tp0,p1);
	return retVal;
}
//attribute: ::btVector3 btCollisionWorld_ClosestConvexResultCallback->m_convexFromWorld
void btCollisionWorld_ClosestConvexResultCallback_m_convexFromWorld_set(void *c,float* a) {
	::btCollisionWorld::ClosestConvexResultCallback *o = (::btCollisionWorld::ClosestConvexResultCallback*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_convexFromWorld = ta;
}
void btCollisionWorld_ClosestConvexResultCallback_m_convexFromWorld_get(void *c,float* a) {
	::btCollisionWorld::ClosestConvexResultCallback *o = (::btCollisionWorld::ClosestConvexResultCallback*)c;
	a[0]=(o->m_convexFromWorld).m_floats[0];a[1]=(o->m_convexFromWorld).m_floats[1];a[2]=(o->m_convexFromWorld).m_floats[2];
}

//attribute: ::btVector3 btCollisionWorld_ClosestConvexResultCallback->m_convexToWorld
void btCollisionWorld_ClosestConvexResultCallback_m_convexToWorld_set(void *c,float* a) {
	::btCollisionWorld::ClosestConvexResultCallback *o = (::btCollisionWorld::ClosestConvexResultCallback*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_convexToWorld = ta;
}
void btCollisionWorld_ClosestConvexResultCallback_m_convexToWorld_get(void *c,float* a) {
	::btCollisionWorld::ClosestConvexResultCallback *o = (::btCollisionWorld::ClosestConvexResultCallback*)c;
	a[0]=(o->m_convexToWorld).m_floats[0];a[1]=(o->m_convexToWorld).m_floats[1];a[2]=(o->m_convexToWorld).m_floats[2];
}

//attribute: ::btCollisionObject * btCollisionWorld_ClosestConvexResultCallback->m_hitCollisionObject
void btCollisionWorld_ClosestConvexResultCallback_m_hitCollisionObject_set(void *c,void* a) {
	::btCollisionWorld::ClosestConvexResultCallback *o = (::btCollisionWorld::ClosestConvexResultCallback*)c;
	::btCollisionObject * ta = (::btCollisionObject *)a;
	o->m_hitCollisionObject = ta;
}
void* btCollisionWorld_ClosestConvexResultCallback_m_hitCollisionObject_get(void *c) {
	::btCollisionWorld::ClosestConvexResultCallback *o = (::btCollisionWorld::ClosestConvexResultCallback*)c;
	return (void*)(o->m_hitCollisionObject);
}

//attribute: ::btVector3 btCollisionWorld_ClosestConvexResultCallback->m_hitNormalWorld
void btCollisionWorld_ClosestConvexResultCallback_m_hitNormalWorld_set(void *c,float* a) {
	::btCollisionWorld::ClosestConvexResultCallback *o = (::btCollisionWorld::ClosestConvexResultCallback*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_hitNormalWorld = ta;
}
void btCollisionWorld_ClosestConvexResultCallback_m_hitNormalWorld_get(void *c,float* a) {
	::btCollisionWorld::ClosestConvexResultCallback *o = (::btCollisionWorld::ClosestConvexResultCallback*)c;
	a[0]=(o->m_hitNormalWorld).m_floats[0];a[1]=(o->m_hitNormalWorld).m_floats[1];a[2]=(o->m_hitNormalWorld).m_floats[2];
}

//attribute: ::btVector3 btCollisionWorld_ClosestConvexResultCallback->m_hitPointWorld
void btCollisionWorld_ClosestConvexResultCallback_m_hitPointWorld_set(void *c,float* a) {
	::btCollisionWorld::ClosestConvexResultCallback *o = (::btCollisionWorld::ClosestConvexResultCallback*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_hitPointWorld = ta;
}
void btCollisionWorld_ClosestConvexResultCallback_m_hitPointWorld_get(void *c,float* a) {
	::btCollisionWorld::ClosestConvexResultCallback *o = (::btCollisionWorld::ClosestConvexResultCallback*)c;
	a[0]=(o->m_hitPointWorld).m_floats[0];a[1]=(o->m_hitPointWorld).m_floats[1];a[2]=(o->m_hitPointWorld).m_floats[2];
}


// ::btCollisionWorld::ClosestRayResultCallback
//constructor: ClosestRayResultCallback  ( ::btCollisionWorld::ClosestRayResultCallback::* )( ::btVector3 const &,::btVector3 const & ) 
void* btCollisionWorld_ClosestRayResultCallback_new(float* p0,float* p1) {
	::btCollisionWorld::ClosestRayResultCallback *o = 0;
	 void *mem = 0;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	mem = btAlignedAlloc(sizeof(::btCollisionWorld::ClosestRayResultCallback),16);
	o = new (mem)::btCollisionWorld::ClosestRayResultCallback(tp0,tp1);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
	return (void*)o;
}
void btCollisionWorld_ClosestRayResultCallback_free(void *c) {
	::btCollisionWorld::ClosestRayResultCallback *o = (::btCollisionWorld::ClosestRayResultCallback*)c;
	delete o;
}
//method: addSingleResult ::btScalar ( ::btCollisionWorld::ClosestRayResultCallback::* )( ::btCollisionWorld::LocalRayResult &,bool ) 
float btCollisionWorld_ClosestRayResultCallback_addSingleResult(void *c,void* p0,int p1) {
	::btCollisionWorld::ClosestRayResultCallback *o = (::btCollisionWorld::ClosestRayResultCallback*)c;
	::btCollisionWorld::LocalRayResult & tp0 = *(::btCollisionWorld::LocalRayResult *)p0;
	float retVal = (float)o->addSingleResult(tp0,p1);
	return retVal;
}
//attribute: ::btVector3 btCollisionWorld_ClosestRayResultCallback->m_hitNormalWorld
void btCollisionWorld_ClosestRayResultCallback_m_hitNormalWorld_set(void *c,float* a) {
	::btCollisionWorld::ClosestRayResultCallback *o = (::btCollisionWorld::ClosestRayResultCallback*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_hitNormalWorld = ta;
}
void btCollisionWorld_ClosestRayResultCallback_m_hitNormalWorld_get(void *c,float* a) {
	::btCollisionWorld::ClosestRayResultCallback *o = (::btCollisionWorld::ClosestRayResultCallback*)c;
	a[0]=(o->m_hitNormalWorld).m_floats[0];a[1]=(o->m_hitNormalWorld).m_floats[1];a[2]=(o->m_hitNormalWorld).m_floats[2];
}

//attribute: ::btVector3 btCollisionWorld_ClosestRayResultCallback->m_hitPointWorld
void btCollisionWorld_ClosestRayResultCallback_m_hitPointWorld_set(void *c,float* a) {
	::btCollisionWorld::ClosestRayResultCallback *o = (::btCollisionWorld::ClosestRayResultCallback*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_hitPointWorld = ta;
}
void btCollisionWorld_ClosestRayResultCallback_m_hitPointWorld_get(void *c,float* a) {
	::btCollisionWorld::ClosestRayResultCallback *o = (::btCollisionWorld::ClosestRayResultCallback*)c;
	a[0]=(o->m_hitPointWorld).m_floats[0];a[1]=(o->m_hitPointWorld).m_floats[1];a[2]=(o->m_hitPointWorld).m_floats[2];
}

//attribute: ::btVector3 btCollisionWorld_ClosestRayResultCallback->m_rayFromWorld
void btCollisionWorld_ClosestRayResultCallback_m_rayFromWorld_set(void *c,float* a) {
	::btCollisionWorld::ClosestRayResultCallback *o = (::btCollisionWorld::ClosestRayResultCallback*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_rayFromWorld = ta;
}
void btCollisionWorld_ClosestRayResultCallback_m_rayFromWorld_get(void *c,float* a) {
	::btCollisionWorld::ClosestRayResultCallback *o = (::btCollisionWorld::ClosestRayResultCallback*)c;
	a[0]=(o->m_rayFromWorld).m_floats[0];a[1]=(o->m_rayFromWorld).m_floats[1];a[2]=(o->m_rayFromWorld).m_floats[2];
}

//attribute: ::btVector3 btCollisionWorld_ClosestRayResultCallback->m_rayToWorld
void btCollisionWorld_ClosestRayResultCallback_m_rayToWorld_set(void *c,float* a) {
	::btCollisionWorld::ClosestRayResultCallback *o = (::btCollisionWorld::ClosestRayResultCallback*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_rayToWorld = ta;
}
void btCollisionWorld_ClosestRayResultCallback_m_rayToWorld_get(void *c,float* a) {
	::btCollisionWorld::ClosestRayResultCallback *o = (::btCollisionWorld::ClosestRayResultCallback*)c;
	a[0]=(o->m_rayToWorld).m_floats[0];a[1]=(o->m_rayToWorld).m_floats[1];a[2]=(o->m_rayToWorld).m_floats[2];
}


// ::btCollisionWorld::ContactResultCallback
//method: addSingleResult ::btScalar ( ::btCollisionWorld::ContactResultCallback::* )( ::btManifoldPoint &,::btCollisionObject const *,int,int,::btCollisionObject const *,int,int ) 
float btCollisionWorld_ContactResultCallback_addSingleResult(void *c,void* p0,void* p1,int p2,int p3,void* p4,int p5,int p6) {
	::btCollisionWorld::ContactResultCallback *o = (::btCollisionWorld::ContactResultCallback*)c;
	::btManifoldPoint & tp0 = *(::btManifoldPoint *)p0;
	::btCollisionObject const * tp1 = (::btCollisionObject const *)p1;
	::btCollisionObject const * tp4 = (::btCollisionObject const *)p4;
	float retVal = (float)o->addSingleResult(tp0,tp1,p2,p3,tp4,p5,p6);
	return retVal;
}
//method: needsCollision bool ( ::btCollisionWorld::ContactResultCallback::* )( ::btBroadphaseProxy * ) const
int btCollisionWorld_ContactResultCallback_needsCollision(void *c,void* p0) {
	::btCollisionWorld::ContactResultCallback *o = (::btCollisionWorld::ContactResultCallback*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	int retVal = (int)o->needsCollision(tp0);
	return retVal;
}
//attribute: short int btCollisionWorld_ContactResultCallback->m_collisionFilterGroup
void btCollisionWorld_ContactResultCallback_m_collisionFilterGroup_set(void *c,short int a) {
	::btCollisionWorld::ContactResultCallback *o = (::btCollisionWorld::ContactResultCallback*)c;
	o->m_collisionFilterGroup = a;
}
short int btCollisionWorld_ContactResultCallback_m_collisionFilterGroup_get(void *c) {
	::btCollisionWorld::ContactResultCallback *o = (::btCollisionWorld::ContactResultCallback*)c;
	return (short int)(o->m_collisionFilterGroup);
}

//attribute: short int btCollisionWorld_ContactResultCallback->m_collisionFilterMask
void btCollisionWorld_ContactResultCallback_m_collisionFilterMask_set(void *c,short int a) {
	::btCollisionWorld::ContactResultCallback *o = (::btCollisionWorld::ContactResultCallback*)c;
	o->m_collisionFilterMask = a;
}
short int btCollisionWorld_ContactResultCallback_m_collisionFilterMask_get(void *c) {
	::btCollisionWorld::ContactResultCallback *o = (::btCollisionWorld::ContactResultCallback*)c;
	return (short int)(o->m_collisionFilterMask);
}


// ::btCollisionWorld::ConvexResultCallback
//method: addSingleResult ::btScalar ( ::btCollisionWorld::ConvexResultCallback::* )( ::btCollisionWorld::LocalConvexResult &,bool ) 
float btCollisionWorld_ConvexResultCallback_addSingleResult(void *c,void* p0,int p1) {
	::btCollisionWorld::ConvexResultCallback *o = (::btCollisionWorld::ConvexResultCallback*)c;
	::btCollisionWorld::LocalConvexResult & tp0 = *(::btCollisionWorld::LocalConvexResult *)p0;
	float retVal = (float)o->addSingleResult(tp0,p1);
	return retVal;
}
//method: needsCollision bool ( ::btCollisionWorld::ConvexResultCallback::* )( ::btBroadphaseProxy * ) const
int btCollisionWorld_ConvexResultCallback_needsCollision(void *c,void* p0) {
	::btCollisionWorld::ConvexResultCallback *o = (::btCollisionWorld::ConvexResultCallback*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	int retVal = (int)o->needsCollision(tp0);
	return retVal;
}
//method: hasHit bool ( ::btCollisionWorld::ConvexResultCallback::* )(  ) const
int btCollisionWorld_ConvexResultCallback_hasHit(void *c) {
	::btCollisionWorld::ConvexResultCallback *o = (::btCollisionWorld::ConvexResultCallback*)c;
	int retVal = (int)o->hasHit();
	return retVal;
}
//attribute: ::btScalar btCollisionWorld_ConvexResultCallback->m_closestHitFraction
void btCollisionWorld_ConvexResultCallback_m_closestHitFraction_set(void *c,float a) {
	::btCollisionWorld::ConvexResultCallback *o = (::btCollisionWorld::ConvexResultCallback*)c;
	o->m_closestHitFraction = a;
}
float btCollisionWorld_ConvexResultCallback_m_closestHitFraction_get(void *c) {
	::btCollisionWorld::ConvexResultCallback *o = (::btCollisionWorld::ConvexResultCallback*)c;
	return (float)(o->m_closestHitFraction);
}

//attribute: short int btCollisionWorld_ConvexResultCallback->m_collisionFilterGroup
void btCollisionWorld_ConvexResultCallback_m_collisionFilterGroup_set(void *c,short int a) {
	::btCollisionWorld::ConvexResultCallback *o = (::btCollisionWorld::ConvexResultCallback*)c;
	o->m_collisionFilterGroup = a;
}
short int btCollisionWorld_ConvexResultCallback_m_collisionFilterGroup_get(void *c) {
	::btCollisionWorld::ConvexResultCallback *o = (::btCollisionWorld::ConvexResultCallback*)c;
	return (short int)(o->m_collisionFilterGroup);
}

//attribute: short int btCollisionWorld_ConvexResultCallback->m_collisionFilterMask
void btCollisionWorld_ConvexResultCallback_m_collisionFilterMask_set(void *c,short int a) {
	::btCollisionWorld::ConvexResultCallback *o = (::btCollisionWorld::ConvexResultCallback*)c;
	o->m_collisionFilterMask = a;
}
short int btCollisionWorld_ConvexResultCallback_m_collisionFilterMask_get(void *c) {
	::btCollisionWorld::ConvexResultCallback *o = (::btCollisionWorld::ConvexResultCallback*)c;
	return (short int)(o->m_collisionFilterMask);
}


// ::btSphereSphereCollisionAlgorithm::CreateFunc
//constructor: CreateFunc  ( ::btSphereSphereCollisionAlgorithm::CreateFunc::* )(  ) 
void* btSphereSphereCollisionAlgorithm_CreateFunc_new() {
	::btSphereSphereCollisionAlgorithm::CreateFunc *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btSphereSphereCollisionAlgorithm::CreateFunc),16);
	o = new (mem)::btSphereSphereCollisionAlgorithm::CreateFunc();
	return (void*)o;
}
void btSphereSphereCollisionAlgorithm_CreateFunc_free(void *c) {
	::btSphereSphereCollisionAlgorithm::CreateFunc *o = (::btSphereSphereCollisionAlgorithm::CreateFunc*)c;
	delete o;
}
//method: CreateCollisionAlgorithm ::btCollisionAlgorithm * ( ::btSphereSphereCollisionAlgorithm::CreateFunc::* )( ::btCollisionAlgorithmConstructionInfo &,::btCollisionObject *,::btCollisionObject * ) 
void* btSphereSphereCollisionAlgorithm_CreateFunc_CreateCollisionAlgorithm(void *c,void* p0,void* p1,void* p2) {
	::btSphereSphereCollisionAlgorithm::CreateFunc *o = (::btSphereSphereCollisionAlgorithm::CreateFunc*)c;
	::btCollisionAlgorithmConstructionInfo & tp0 = *(::btCollisionAlgorithmConstructionInfo *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btCollisionObject * tp2 = (::btCollisionObject *)p2;
	void* retVal = (void*) o->CreateCollisionAlgorithm(tp0,tp1,tp2);
	return retVal;
}

// ::btConvexConvexAlgorithm::CreateFunc
//not supported constructor: CreateFunc  ( ::btConvexConvexAlgorithm::CreateFunc::* )( ::btVoronoiSimplexSolver *,::btConvexPenetrationDepthSolver * ) 
// error: ::btVoronoiSimplexSolver * - ok,  - unsupported

void btConvexConvexAlgorithm_CreateFunc_free(void *c) {
	::btConvexConvexAlgorithm::CreateFunc *o = (::btConvexConvexAlgorithm::CreateFunc*)c;
	delete o;
}
//method: CreateCollisionAlgorithm ::btCollisionAlgorithm * ( ::btConvexConvexAlgorithm::CreateFunc::* )( ::btCollisionAlgorithmConstructionInfo &,::btCollisionObject *,::btCollisionObject * ) 
void* btConvexConvexAlgorithm_CreateFunc_CreateCollisionAlgorithm(void *c,void* p0,void* p1,void* p2) {
	::btConvexConvexAlgorithm::CreateFunc *o = (::btConvexConvexAlgorithm::CreateFunc*)c;
	::btCollisionAlgorithmConstructionInfo & tp0 = *(::btCollisionAlgorithmConstructionInfo *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btCollisionObject * tp2 = (::btCollisionObject *)p2;
	void* retVal = (void*) o->CreateCollisionAlgorithm(tp0,tp1,tp2);
	return retVal;
}
//attribute: ::btConvexPenetrationDepthSolver * btConvexConvexAlgorithm_CreateFunc->m_pdSolver
// attribute not supported: //attribute: ::btConvexPenetrationDepthSolver * btConvexConvexAlgorithm_CreateFunc->m_pdSolver
//attribute: ::btVoronoiSimplexSolver * btConvexConvexAlgorithm_CreateFunc->m_simplexSolver
void btConvexConvexAlgorithm_CreateFunc_m_simplexSolver_set(void *c,void* a) {
	::btConvexConvexAlgorithm::CreateFunc *o = (::btConvexConvexAlgorithm::CreateFunc*)c;
	::btVoronoiSimplexSolver * ta = (::btVoronoiSimplexSolver *)a;
	o->m_simplexSolver = ta;
}
void* btConvexConvexAlgorithm_CreateFunc_m_simplexSolver_get(void *c) {
	::btConvexConvexAlgorithm::CreateFunc *o = (::btConvexConvexAlgorithm::CreateFunc*)c;
	return (void*)(o->m_simplexSolver);
}

//attribute: int btConvexConvexAlgorithm_CreateFunc->m_numPerturbationIterations
void btConvexConvexAlgorithm_CreateFunc_m_numPerturbationIterations_set(void *c,int a) {
	::btConvexConvexAlgorithm::CreateFunc *o = (::btConvexConvexAlgorithm::CreateFunc*)c;
	o->m_numPerturbationIterations = a;
}
int btConvexConvexAlgorithm_CreateFunc_m_numPerturbationIterations_get(void *c) {
	::btConvexConvexAlgorithm::CreateFunc *o = (::btConvexConvexAlgorithm::CreateFunc*)c;
	return (int)(o->m_numPerturbationIterations);
}

//attribute: int btConvexConvexAlgorithm_CreateFunc->m_minimumPointsPerturbationThreshold
void btConvexConvexAlgorithm_CreateFunc_m_minimumPointsPerturbationThreshold_set(void *c,int a) {
	::btConvexConvexAlgorithm::CreateFunc *o = (::btConvexConvexAlgorithm::CreateFunc*)c;
	o->m_minimumPointsPerturbationThreshold = a;
}
int btConvexConvexAlgorithm_CreateFunc_m_minimumPointsPerturbationThreshold_get(void *c) {
	::btConvexConvexAlgorithm::CreateFunc *o = (::btConvexConvexAlgorithm::CreateFunc*)c;
	return (int)(o->m_minimumPointsPerturbationThreshold);
}


// ::btCollisionWorld::LocalConvexResult
//constructor: LocalConvexResult  ( ::btCollisionWorld::LocalConvexResult::* )( ::btCollisionObject *,::btCollisionWorld::LocalShapeInfo *,::btVector3 const &,::btVector3 const &,::btScalar ) 
void* btCollisionWorld_LocalConvexResult_new(void* p0,void* p1,float* p2,float* p3,float p4) {
	::btCollisionWorld::LocalConvexResult *o = 0;
	 void *mem = 0;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionWorld::LocalShapeInfo * tp1 = (::btCollisionWorld::LocalShapeInfo *)p1;
	btVector3 tp2(p2[0],p2[1],p2[2]);
	btVector3 tp3(p3[0],p3[1],p3[2]);
	mem = btAlignedAlloc(sizeof(::btCollisionWorld::LocalConvexResult),16);
	o = new (mem)::btCollisionWorld::LocalConvexResult(tp0,tp1,tp2,tp3,p4);
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	p3[0]=tp3.m_floats[0];p3[1]=tp3.m_floats[1];p3[2]=tp3.m_floats[2];
	return (void*)o;
}
void btCollisionWorld_LocalConvexResult_free(void *c) {
	::btCollisionWorld::LocalConvexResult *o = (::btCollisionWorld::LocalConvexResult*)c;
	delete o;
}
//attribute: ::btCollisionObject * btCollisionWorld_LocalConvexResult->m_hitCollisionObject
void btCollisionWorld_LocalConvexResult_m_hitCollisionObject_set(void *c,void* a) {
	::btCollisionWorld::LocalConvexResult *o = (::btCollisionWorld::LocalConvexResult*)c;
	::btCollisionObject * ta = (::btCollisionObject *)a;
	o->m_hitCollisionObject = ta;
}
void* btCollisionWorld_LocalConvexResult_m_hitCollisionObject_get(void *c) {
	::btCollisionWorld::LocalConvexResult *o = (::btCollisionWorld::LocalConvexResult*)c;
	return (void*)(o->m_hitCollisionObject);
}

//attribute: ::btScalar btCollisionWorld_LocalConvexResult->m_hitFraction
void btCollisionWorld_LocalConvexResult_m_hitFraction_set(void *c,float a) {
	::btCollisionWorld::LocalConvexResult *o = (::btCollisionWorld::LocalConvexResult*)c;
	o->m_hitFraction = a;
}
float btCollisionWorld_LocalConvexResult_m_hitFraction_get(void *c) {
	::btCollisionWorld::LocalConvexResult *o = (::btCollisionWorld::LocalConvexResult*)c;
	return (float)(o->m_hitFraction);
}

//attribute: ::btVector3 btCollisionWorld_LocalConvexResult->m_hitNormalLocal
void btCollisionWorld_LocalConvexResult_m_hitNormalLocal_set(void *c,float* a) {
	::btCollisionWorld::LocalConvexResult *o = (::btCollisionWorld::LocalConvexResult*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_hitNormalLocal = ta;
}
void btCollisionWorld_LocalConvexResult_m_hitNormalLocal_get(void *c,float* a) {
	::btCollisionWorld::LocalConvexResult *o = (::btCollisionWorld::LocalConvexResult*)c;
	a[0]=(o->m_hitNormalLocal).m_floats[0];a[1]=(o->m_hitNormalLocal).m_floats[1];a[2]=(o->m_hitNormalLocal).m_floats[2];
}

//attribute: ::btVector3 btCollisionWorld_LocalConvexResult->m_hitPointLocal
void btCollisionWorld_LocalConvexResult_m_hitPointLocal_set(void *c,float* a) {
	::btCollisionWorld::LocalConvexResult *o = (::btCollisionWorld::LocalConvexResult*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_hitPointLocal = ta;
}
void btCollisionWorld_LocalConvexResult_m_hitPointLocal_get(void *c,float* a) {
	::btCollisionWorld::LocalConvexResult *o = (::btCollisionWorld::LocalConvexResult*)c;
	a[0]=(o->m_hitPointLocal).m_floats[0];a[1]=(o->m_hitPointLocal).m_floats[1];a[2]=(o->m_hitPointLocal).m_floats[2];
}

//attribute: ::btCollisionWorld::LocalShapeInfo * btCollisionWorld_LocalConvexResult->m_localShapeInfo
void btCollisionWorld_LocalConvexResult_m_localShapeInfo_set(void *c,void* a) {
	::btCollisionWorld::LocalConvexResult *o = (::btCollisionWorld::LocalConvexResult*)c;
	::btCollisionWorld::LocalShapeInfo * ta = (::btCollisionWorld::LocalShapeInfo *)a;
	o->m_localShapeInfo = ta;
}
void* btCollisionWorld_LocalConvexResult_m_localShapeInfo_get(void *c) {
	::btCollisionWorld::LocalConvexResult *o = (::btCollisionWorld::LocalConvexResult*)c;
	return (void*)(o->m_localShapeInfo);
}


// ::btCollisionWorld::LocalRayResult
//constructor: LocalRayResult  ( ::btCollisionWorld::LocalRayResult::* )( ::btCollisionObject *,::btCollisionWorld::LocalShapeInfo *,::btVector3 const &,::btScalar ) 
void* btCollisionWorld_LocalRayResult_new(void* p0,void* p1,float* p2,float p3) {
	::btCollisionWorld::LocalRayResult *o = 0;
	 void *mem = 0;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionWorld::LocalShapeInfo * tp1 = (::btCollisionWorld::LocalShapeInfo *)p1;
	btVector3 tp2(p2[0],p2[1],p2[2]);
	mem = btAlignedAlloc(sizeof(::btCollisionWorld::LocalRayResult),16);
	o = new (mem)::btCollisionWorld::LocalRayResult(tp0,tp1,tp2,p3);
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
	return (void*)o;
}
void btCollisionWorld_LocalRayResult_free(void *c) {
	::btCollisionWorld::LocalRayResult *o = (::btCollisionWorld::LocalRayResult*)c;
	delete o;
}
//attribute: ::btCollisionObject * btCollisionWorld_LocalRayResult->m_collisionObject
void btCollisionWorld_LocalRayResult_m_collisionObject_set(void *c,void* a) {
	::btCollisionWorld::LocalRayResult *o = (::btCollisionWorld::LocalRayResult*)c;
	::btCollisionObject * ta = (::btCollisionObject *)a;
	o->m_collisionObject = ta;
}
void* btCollisionWorld_LocalRayResult_m_collisionObject_get(void *c) {
	::btCollisionWorld::LocalRayResult *o = (::btCollisionWorld::LocalRayResult*)c;
	return (void*)(o->m_collisionObject);
}

//attribute: ::btScalar btCollisionWorld_LocalRayResult->m_hitFraction
void btCollisionWorld_LocalRayResult_m_hitFraction_set(void *c,float a) {
	::btCollisionWorld::LocalRayResult *o = (::btCollisionWorld::LocalRayResult*)c;
	o->m_hitFraction = a;
}
float btCollisionWorld_LocalRayResult_m_hitFraction_get(void *c) {
	::btCollisionWorld::LocalRayResult *o = (::btCollisionWorld::LocalRayResult*)c;
	return (float)(o->m_hitFraction);
}

//attribute: ::btVector3 btCollisionWorld_LocalRayResult->m_hitNormalLocal
void btCollisionWorld_LocalRayResult_m_hitNormalLocal_set(void *c,float* a) {
	::btCollisionWorld::LocalRayResult *o = (::btCollisionWorld::LocalRayResult*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_hitNormalLocal = ta;
}
void btCollisionWorld_LocalRayResult_m_hitNormalLocal_get(void *c,float* a) {
	::btCollisionWorld::LocalRayResult *o = (::btCollisionWorld::LocalRayResult*)c;
	a[0]=(o->m_hitNormalLocal).m_floats[0];a[1]=(o->m_hitNormalLocal).m_floats[1];a[2]=(o->m_hitNormalLocal).m_floats[2];
}

//attribute: ::btCollisionWorld::LocalShapeInfo * btCollisionWorld_LocalRayResult->m_localShapeInfo
void btCollisionWorld_LocalRayResult_m_localShapeInfo_set(void *c,void* a) {
	::btCollisionWorld::LocalRayResult *o = (::btCollisionWorld::LocalRayResult*)c;
	::btCollisionWorld::LocalShapeInfo * ta = (::btCollisionWorld::LocalShapeInfo *)a;
	o->m_localShapeInfo = ta;
}
void* btCollisionWorld_LocalRayResult_m_localShapeInfo_get(void *c) {
	::btCollisionWorld::LocalRayResult *o = (::btCollisionWorld::LocalRayResult*)c;
	return (void*)(o->m_localShapeInfo);
}


// ::btCollisionWorld::LocalShapeInfo
//constructor: LocalShapeInfo  ( ::btCollisionWorld::LocalShapeInfo::* )(  ) 
void* btCollisionWorld_LocalShapeInfo_new() {
	::btCollisionWorld::LocalShapeInfo *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCollisionWorld::LocalShapeInfo),16);
	o = new (mem)::btCollisionWorld::LocalShapeInfo();
	return (void*)o;
}
void btCollisionWorld_LocalShapeInfo_free(void *c) {
	::btCollisionWorld::LocalShapeInfo *o = (::btCollisionWorld::LocalShapeInfo*)c;
	delete o;
}
//attribute: int btCollisionWorld_LocalShapeInfo->m_shapePart
void btCollisionWorld_LocalShapeInfo_m_shapePart_set(void *c,int a) {
	::btCollisionWorld::LocalShapeInfo *o = (::btCollisionWorld::LocalShapeInfo*)c;
	o->m_shapePart = a;
}
int btCollisionWorld_LocalShapeInfo_m_shapePart_get(void *c) {
	::btCollisionWorld::LocalShapeInfo *o = (::btCollisionWorld::LocalShapeInfo*)c;
	return (int)(o->m_shapePart);
}

//attribute: int btCollisionWorld_LocalShapeInfo->m_triangleIndex
void btCollisionWorld_LocalShapeInfo_m_triangleIndex_set(void *c,int a) {
	::btCollisionWorld::LocalShapeInfo *o = (::btCollisionWorld::LocalShapeInfo*)c;
	o->m_triangleIndex = a;
}
int btCollisionWorld_LocalShapeInfo_m_triangleIndex_get(void *c) {
	::btCollisionWorld::LocalShapeInfo *o = (::btCollisionWorld::LocalShapeInfo*)c;
	return (int)(o->m_triangleIndex);
}


// ::btCollisionWorld::RayResultCallback
//method: addSingleResult ::btScalar ( ::btCollisionWorld::RayResultCallback::* )( ::btCollisionWorld::LocalRayResult &,bool ) 
float btCollisionWorld_RayResultCallback_addSingleResult(void *c,void* p0,int p1) {
	::btCollisionWorld::RayResultCallback *o = (::btCollisionWorld::RayResultCallback*)c;
	::btCollisionWorld::LocalRayResult & tp0 = *(::btCollisionWorld::LocalRayResult *)p0;
	float retVal = (float)o->addSingleResult(tp0,p1);
	return retVal;
}
//method: needsCollision bool ( ::btCollisionWorld::RayResultCallback::* )( ::btBroadphaseProxy * ) const
int btCollisionWorld_RayResultCallback_needsCollision(void *c,void* p0) {
	::btCollisionWorld::RayResultCallback *o = (::btCollisionWorld::RayResultCallback*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	int retVal = (int)o->needsCollision(tp0);
	return retVal;
}
//method: hasHit bool ( ::btCollisionWorld::RayResultCallback::* )(  ) const
int btCollisionWorld_RayResultCallback_hasHit(void *c) {
	::btCollisionWorld::RayResultCallback *o = (::btCollisionWorld::RayResultCallback*)c;
	int retVal = (int)o->hasHit();
	return retVal;
}
//attribute: ::btScalar btCollisionWorld_RayResultCallback->m_closestHitFraction
void btCollisionWorld_RayResultCallback_m_closestHitFraction_set(void *c,float a) {
	::btCollisionWorld::RayResultCallback *o = (::btCollisionWorld::RayResultCallback*)c;
	o->m_closestHitFraction = a;
}
float btCollisionWorld_RayResultCallback_m_closestHitFraction_get(void *c) {
	::btCollisionWorld::RayResultCallback *o = (::btCollisionWorld::RayResultCallback*)c;
	return (float)(o->m_closestHitFraction);
}

//attribute: short int btCollisionWorld_RayResultCallback->m_collisionFilterGroup
void btCollisionWorld_RayResultCallback_m_collisionFilterGroup_set(void *c,short int a) {
	::btCollisionWorld::RayResultCallback *o = (::btCollisionWorld::RayResultCallback*)c;
	o->m_collisionFilterGroup = a;
}
short int btCollisionWorld_RayResultCallback_m_collisionFilterGroup_get(void *c) {
	::btCollisionWorld::RayResultCallback *o = (::btCollisionWorld::RayResultCallback*)c;
	return (short int)(o->m_collisionFilterGroup);
}

//attribute: short int btCollisionWorld_RayResultCallback->m_collisionFilterMask
void btCollisionWorld_RayResultCallback_m_collisionFilterMask_set(void *c,short int a) {
	::btCollisionWorld::RayResultCallback *o = (::btCollisionWorld::RayResultCallback*)c;
	o->m_collisionFilterMask = a;
}
short int btCollisionWorld_RayResultCallback_m_collisionFilterMask_get(void *c) {
	::btCollisionWorld::RayResultCallback *o = (::btCollisionWorld::RayResultCallback*)c;
	return (short int)(o->m_collisionFilterMask);
}

//attribute: ::btCollisionObject * btCollisionWorld_RayResultCallback->m_collisionObject
void btCollisionWorld_RayResultCallback_m_collisionObject_set(void *c,void* a) {
	::btCollisionWorld::RayResultCallback *o = (::btCollisionWorld::RayResultCallback*)c;
	::btCollisionObject * ta = (::btCollisionObject *)a;
	o->m_collisionObject = ta;
}
void* btCollisionWorld_RayResultCallback_m_collisionObject_get(void *c) {
	::btCollisionWorld::RayResultCallback *o = (::btCollisionWorld::RayResultCallback*)c;
	return (void*)(o->m_collisionObject);
}

//attribute: unsigned int btCollisionWorld_RayResultCallback->m_flags
void btCollisionWorld_RayResultCallback_m_flags_set(void *c,unsigned int a) {
	::btCollisionWorld::RayResultCallback *o = (::btCollisionWorld::RayResultCallback*)c;
	o->m_flags = a;
}
unsigned int btCollisionWorld_RayResultCallback_m_flags_get(void *c) {
	::btCollisionWorld::RayResultCallback *o = (::btCollisionWorld::RayResultCallback*)c;
	return (unsigned int)(o->m_flags);
}


// ::btActivatingCollisionAlgorithm

// ::btCollisionAlgorithmCreateFunc
//constructor: btCollisionAlgorithmCreateFunc  ( ::btCollisionAlgorithmCreateFunc::* )(  ) 
void* btCollisionAlgorithmCreateFunc_new() {
	::btCollisionAlgorithmCreateFunc *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCollisionAlgorithmCreateFunc),16);
	o = new (mem)::btCollisionAlgorithmCreateFunc();
	return (void*)o;
}
void btCollisionAlgorithmCreateFunc_free(void *c) {
	::btCollisionAlgorithmCreateFunc *o = (::btCollisionAlgorithmCreateFunc*)c;
	delete o;
}
//method: CreateCollisionAlgorithm ::btCollisionAlgorithm * ( ::btCollisionAlgorithmCreateFunc::* )( ::btCollisionAlgorithmConstructionInfo &,::btCollisionObject *,::btCollisionObject * ) 
void* btCollisionAlgorithmCreateFunc_CreateCollisionAlgorithm(void *c,void* p0,void* p1,void* p2) {
	::btCollisionAlgorithmCreateFunc *o = (::btCollisionAlgorithmCreateFunc*)c;
	::btCollisionAlgorithmConstructionInfo & tp0 = *(::btCollisionAlgorithmConstructionInfo *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btCollisionObject * tp2 = (::btCollisionObject *)p2;
	void* retVal = (void*) o->CreateCollisionAlgorithm(tp0,tp1,tp2);
	return retVal;
}
//attribute: bool btCollisionAlgorithmCreateFunc->m_swapped
void btCollisionAlgorithmCreateFunc_m_swapped_set(void *c,int a) {
	::btCollisionAlgorithmCreateFunc *o = (::btCollisionAlgorithmCreateFunc*)c;
	o->m_swapped = a;
}
int btCollisionAlgorithmCreateFunc_m_swapped_get(void *c) {
	::btCollisionAlgorithmCreateFunc *o = (::btCollisionAlgorithmCreateFunc*)c;
	return (int)(o->m_swapped);
}


// ::btCollisionConfiguration
//not supported method: getPersistentManifoldPool ::btPoolAllocator * ( ::btCollisionConfiguration::* )(  ) 
// error:  - unsupported

//method: getStackAllocator ::btStackAlloc * ( ::btCollisionConfiguration::* )(  ) 
void* btCollisionConfiguration_getStackAllocator(void *c) {
	::btCollisionConfiguration *o = (::btCollisionConfiguration*)c;
	void* retVal = (void*) o->getStackAllocator();
	return retVal;
}
//not supported method: getCollisionAlgorithmPool ::btPoolAllocator * ( ::btCollisionConfiguration::* )(  ) 
// error:  - unsupported

//method: getCollisionAlgorithmCreateFunc ::btCollisionAlgorithmCreateFunc * ( ::btCollisionConfiguration::* )( int,int ) 
void* btCollisionConfiguration_getCollisionAlgorithmCreateFunc(void *c,int p0,int p1) {
	::btCollisionConfiguration *o = (::btCollisionConfiguration*)c;
	void* retVal = (void*) o->getCollisionAlgorithmCreateFunc(p0,p1);
	return retVal;
}

// ::btCollisionDispatcher
//constructor: btCollisionDispatcher  ( ::btCollisionDispatcher::* )( ::btCollisionConfiguration * ) 
void* btCollisionDispatcher_new(void* p0) {
	::btCollisionDispatcher *o = 0;
	 void *mem = 0;
	::btCollisionConfiguration * tp0 = (::btCollisionConfiguration *)p0;
	mem = btAlignedAlloc(sizeof(::btCollisionDispatcher),16);
	o = new (mem)::btCollisionDispatcher(tp0);
	return (void*)o;
}
void btCollisionDispatcher_free(void *c) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	delete o;
}
//method: allocateCollisionAlgorithm void * ( ::btCollisionDispatcher::* )( int ) 
void* btCollisionDispatcher_allocateCollisionAlgorithm(void *c,int p0) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	void* retVal = (void*) o->allocateCollisionAlgorithm(p0);
	return retVal;
}
//method: getDispatcherFlags int ( ::btCollisionDispatcher::* )(  ) const
int btCollisionDispatcher_getDispatcherFlags(void *c) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	int retVal = (int)o->getDispatcherFlags();
	return retVal;
}
//method: getCollisionConfiguration ::btCollisionConfiguration * ( ::btCollisionDispatcher::* )(  ) 
void* btCollisionDispatcher_getCollisionConfiguration(void *c) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	void* retVal = (void*) o->getCollisionConfiguration();
	return retVal;
}
//method: getCollisionConfiguration ::btCollisionConfiguration * ( ::btCollisionDispatcher::* )(  ) 
void* btCollisionDispatcher_getCollisionConfiguration0(void *c) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	void* retVal = (void*) o->getCollisionConfiguration();
	return retVal;
}
//method: getCollisionConfiguration ::btCollisionConfiguration const * ( ::btCollisionDispatcher::* )(  ) const
void* btCollisionDispatcher_getCollisionConfiguration1(void *c) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	void* retVal = (void*) o->getCollisionConfiguration();
	return retVal;
}
//method: setDispatcherFlags void ( ::btCollisionDispatcher::* )( int ) 
void btCollisionDispatcher_setDispatcherFlags(void *c,int p0) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	o->setDispatcherFlags(p0);
}
//method: releaseManifold void ( ::btCollisionDispatcher::* )( ::btPersistentManifold * ) 
void btCollisionDispatcher_releaseManifold(void *c,void* p0) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	::btPersistentManifold * tp0 = (::btPersistentManifold *)p0;
	o->releaseManifold(tp0);
}
//method: setCollisionConfiguration void ( ::btCollisionDispatcher::* )( ::btCollisionConfiguration * ) 
void btCollisionDispatcher_setCollisionConfiguration(void *c,void* p0) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	::btCollisionConfiguration * tp0 = (::btCollisionConfiguration *)p0;
	o->setCollisionConfiguration(tp0);
}
//method: getNumManifolds int ( ::btCollisionDispatcher::* )(  ) const
int btCollisionDispatcher_getNumManifolds(void *c) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	int retVal = (int)o->getNumManifolds();
	return retVal;
}
//method: clearManifold void ( ::btCollisionDispatcher::* )( ::btPersistentManifold * ) 
void btCollisionDispatcher_clearManifold(void *c,void* p0) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	::btPersistentManifold * tp0 = (::btPersistentManifold *)p0;
	o->clearManifold(tp0);
}
//method: freeCollisionAlgorithm void ( ::btCollisionDispatcher::* )( void * ) 
void btCollisionDispatcher_freeCollisionAlgorithm(void *c,void* p0) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	void * tp0 = (void *)p0;
	o->freeCollisionAlgorithm(tp0);
}
//not supported method: getInternalManifoldPointer ::btPersistentManifold * * ( ::btCollisionDispatcher::* )(  ) 
// error:  - unsupported

//method: registerCollisionCreateFunc void ( ::btCollisionDispatcher::* )( int,int,::btCollisionAlgorithmCreateFunc * ) 
void btCollisionDispatcher_registerCollisionCreateFunc(void *c,int p0,int p1,void* p2) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	::btCollisionAlgorithmCreateFunc * tp2 = (::btCollisionAlgorithmCreateFunc *)p2;
	o->registerCollisionCreateFunc(p0,p1,tp2);
}
//method: defaultNearCallback void (*)( ::btBroadphasePair &,::btCollisionDispatcher &,::btDispatcherInfo const & )
void btCollisionDispatcher_defaultNearCallback(void* p0,void* p1,void* p2) {
	::btBroadphasePair & tp0 = *(::btBroadphasePair *)p0;
	::btCollisionDispatcher & tp1 = *(::btCollisionDispatcher *)p1;
	::btDispatcherInfo const & tp2 = *(::btDispatcherInfo const *)p2;
	::btCollisionDispatcher::defaultNearCallback(tp0,tp1,tp2);
}
//not supported method: getNearCallback ::btNearCallback ( ::btCollisionDispatcher::* )(  ) const
// error:  - unsupported

//method: findAlgorithm ::btCollisionAlgorithm * ( ::btCollisionDispatcher::* )( ::btCollisionObject *,::btCollisionObject *,::btPersistentManifold * ) 
void* btCollisionDispatcher_findAlgorithm(void *c,void* p0,void* p1,void* p2) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btPersistentManifold * tp2 = (::btPersistentManifold *)p2;
	void* retVal = (void*) o->findAlgorithm(tp0,tp1,tp2);
	return retVal;
}
//method: needsResponse bool ( ::btCollisionDispatcher::* )( ::btCollisionObject *,::btCollisionObject * ) 
int btCollisionDispatcher_needsResponse(void *c,void* p0,void* p1) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	int retVal = (int)o->needsResponse(tp0,tp1);
	return retVal;
}
//method: getNewManifold ::btPersistentManifold * ( ::btCollisionDispatcher::* )( void *,void * ) 
void* btCollisionDispatcher_getNewManifold(void *c,void* p0,void* p1) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	void * tp0 = (void *)p0;
	void * tp1 = (void *)p1;
	void* retVal = (void*) o->getNewManifold(tp0,tp1);
	return retVal;
}
//method: dispatchAllCollisionPairs void ( ::btCollisionDispatcher::* )( ::btOverlappingPairCache *,::btDispatcherInfo const &,::btDispatcher * ) 
void btCollisionDispatcher_dispatchAllCollisionPairs(void *c,void* p0,void* p1,void* p2) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	::btOverlappingPairCache * tp0 = (::btOverlappingPairCache *)p0;
	::btDispatcherInfo const & tp1 = *(::btDispatcherInfo const *)p1;
	::btDispatcher * tp2 = (::btDispatcher *)p2;
	o->dispatchAllCollisionPairs(tp0,tp1,tp2);
}
//not supported method: getInternalManifoldPool ::btPoolAllocator * ( ::btCollisionDispatcher::* )(  ) 
// error:  - unsupported

//not supported method: getInternalManifoldPool ::btPoolAllocator * ( ::btCollisionDispatcher::* )(  ) 
// error:  - unsupported

//not supported method: getInternalManifoldPool ::btPoolAllocator const * ( ::btCollisionDispatcher::* )(  ) const
// error:  - unsupported

//method: needsCollision bool ( ::btCollisionDispatcher::* )( ::btCollisionObject *,::btCollisionObject * ) 
int btCollisionDispatcher_needsCollision(void *c,void* p0,void* p1) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	int retVal = (int)o->needsCollision(tp0,tp1);
	return retVal;
}
//method: getManifoldByIndexInternal ::btPersistentManifold * ( ::btCollisionDispatcher::* )( int ) 
void* btCollisionDispatcher_getManifoldByIndexInternal(void *c,int p0) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	void* retVal = (void*) o->getManifoldByIndexInternal(p0);
	return retVal;
}
//method: getManifoldByIndexInternal ::btPersistentManifold * ( ::btCollisionDispatcher::* )( int ) 
void* btCollisionDispatcher_getManifoldByIndexInternal0(void *c,int p0) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	void* retVal = (void*) o->getManifoldByIndexInternal(p0);
	return retVal;
}
//method: getManifoldByIndexInternal ::btPersistentManifold const * ( ::btCollisionDispatcher::* )( int ) const
void* btCollisionDispatcher_getManifoldByIndexInternal1(void *c,int p0) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	void* retVal = (void*) o->getManifoldByIndexInternal(p0);
	return retVal;
}
//not supported method: setNearCallback void ( ::btCollisionDispatcher::* )( ::btNearCallback ) 
// error:  - unsupported, void - ok

//attribute: ::btPoolAllocator * btCollisionDispatcher->m_collisionAlgorithmPoolAllocator
// attribute not supported: //attribute: ::btPoolAllocator * btCollisionDispatcher->m_collisionAlgorithmPoolAllocator
//attribute: ::btCollisionConfiguration * btCollisionDispatcher->m_collisionConfiguration
void btCollisionDispatcher_m_collisionConfiguration_set(void *c,void* a) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	::btCollisionConfiguration * ta = (::btCollisionConfiguration *)a;
	o->m_collisionConfiguration = ta;
}
void* btCollisionDispatcher_m_collisionConfiguration_get(void *c) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	return (void*)(o->m_collisionConfiguration);
}

//attribute: ::btManifoldResult btCollisionDispatcher->m_defaultManifoldResult
void btCollisionDispatcher_m_defaultManifoldResult_set(void *c,void* a) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	::btManifoldResult & ta = *(::btManifoldResult *)a;
	o->m_defaultManifoldResult = ta;
}
void* btCollisionDispatcher_m_defaultManifoldResult_get(void *c) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	return (void*)&(o->m_defaultManifoldResult);
}

//attribute: int btCollisionDispatcher->m_dispatcherFlags
void btCollisionDispatcher_m_dispatcherFlags_set(void *c,int a) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	o->m_dispatcherFlags = a;
}
int btCollisionDispatcher_m_dispatcherFlags_get(void *c) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	return (int)(o->m_dispatcherFlags);
}

//attribute: ::btCollisionAlgorithmCreateFunc *[36][36] btCollisionDispatcher->m_doubleDispatch
// attribute not supported: //attribute: ::btCollisionAlgorithmCreateFunc *[36][36] btCollisionDispatcher->m_doubleDispatch
//attribute: ::btAlignedObjectArray<btPersistentManifold*> btCollisionDispatcher->m_manifoldsPtr
void btCollisionDispatcher_m_manifoldsPtr_set(void *c,void* a) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	::btAlignedObjectArray<btPersistentManifold*> & ta = *(::btAlignedObjectArray<btPersistentManifold*> *)a;
	o->m_manifoldsPtr = ta;
}
void* btCollisionDispatcher_m_manifoldsPtr_get(void *c) {
	::btCollisionDispatcher *o = (::btCollisionDispatcher*)c;
	return (void*)&(o->m_manifoldsPtr);
}

//attribute: ::btNearCallback btCollisionDispatcher->m_nearCallback
// attribute not supported: //attribute: ::btNearCallback btCollisionDispatcher->m_nearCallback
//attribute: ::btPoolAllocator * btCollisionDispatcher->m_persistentManifoldPoolAllocator
// attribute not supported: //attribute: ::btPoolAllocator * btCollisionDispatcher->m_persistentManifoldPoolAllocator

// ::btCollisionObject
//constructor: btCollisionObject  ( ::btCollisionObject::* )(  ) 
void* btCollisionObject_new() {
	::btCollisionObject *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCollisionObject),16);
	o = new (mem)::btCollisionObject();
	return (void*)o;
}
void btCollisionObject_free(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	delete o;
}
//method: getCcdSquareMotionThreshold ::btScalar ( ::btCollisionObject::* )(  ) const
float btCollisionObject_getCcdSquareMotionThreshold(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	float retVal = (float)o->getCcdSquareMotionThreshold();
	return retVal;
}
//method: activate void ( ::btCollisionObject::* )( bool ) 
void btCollisionObject_activate(void *c,int p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->activate(p0);
}
//method: setInterpolationLinearVelocity void ( ::btCollisionObject::* )( ::btVector3 const & ) 
void btCollisionObject_setInterpolationLinearVelocity(void *c,float* p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setInterpolationLinearVelocity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: getFriction ::btScalar ( ::btCollisionObject::* )(  ) const
float btCollisionObject_getFriction(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	float retVal = (float)o->getFriction();
	return retVal;
}
//method: setCompanionId void ( ::btCollisionObject::* )( int ) 
void btCollisionObject_setCompanionId(void *c,int p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->setCompanionId(p0);
}
//method: setInterpolationAngularVelocity void ( ::btCollisionObject::* )( ::btVector3 const & ) 
void btCollisionObject_setInterpolationAngularVelocity(void *c,float* p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setInterpolationAngularVelocity(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: serialize char const * ( ::btCollisionObject::* )( void *,::btSerializer * ) const
char const * btCollisionObject_serialize(void *c,void* p0,void* p1) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void * tp0 = (void *)p0;
	::btSerializer * tp1 = (::btSerializer *)p1;
	char const * retVal = (char const *)o->serialize(tp0,tp1);
	return retVal;
}
//method: setWorldTransform void ( ::btCollisionObject::* )( ::btTransform const & ) 
void btCollisionObject_setWorldTransform(void *c,float* p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	o->setWorldTransform(tp0);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//method: getCompanionId int ( ::btCollisionObject::* )(  ) const
int btCollisionObject_getCompanionId(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	int retVal = (int)o->getCompanionId();
	return retVal;
}
//method: internalSetExtensionPointer void ( ::btCollisionObject::* )( void * ) 
void btCollisionObject_internalSetExtensionPointer(void *c,void* p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void * tp0 = (void *)p0;
	o->internalSetExtensionPointer(tp0);
}
//method: setContactProcessingThreshold void ( ::btCollisionObject::* )( ::btScalar ) 
void btCollisionObject_setContactProcessingThreshold(void *c,float p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->setContactProcessingThreshold(p0);
}
//method: setInterpolationWorldTransform void ( ::btCollisionObject::* )( ::btTransform const & ) 
void btCollisionObject_setInterpolationWorldTransform(void *c,float* p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	o->setInterpolationWorldTransform(tp0);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
}
//method: getInterpolationLinearVelocity ::btVector3 const & ( ::btCollisionObject::* )(  ) const
void btCollisionObject_getInterpolationLinearVelocity(void *c,float* ret) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getInterpolationLinearVelocity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: mergesSimulationIslands bool ( ::btCollisionObject::* )(  ) const
int btCollisionObject_mergesSimulationIslands(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	int retVal = (int)o->mergesSimulationIslands();
	return retVal;
}
//method: setCollisionShape void ( ::btCollisionObject::* )( ::btCollisionShape * ) 
void btCollisionObject_setCollisionShape(void *c,void* p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	::btCollisionShape * tp0 = (::btCollisionShape *)p0;
	o->setCollisionShape(tp0);
}
//method: setCcdMotionThreshold void ( ::btCollisionObject::* )( ::btScalar ) 
void btCollisionObject_setCcdMotionThreshold(void *c,float p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->setCcdMotionThreshold(p0);
}
//method: getIslandTag int ( ::btCollisionObject::* )(  ) const
int btCollisionObject_getIslandTag(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	int retVal = (int)o->getIslandTag();
	return retVal;
}
//method: calculateSerializeBufferSize int ( ::btCollisionObject::* )(  ) const
int btCollisionObject_calculateSerializeBufferSize(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	int retVal = (int)o->calculateSerializeBufferSize();
	return retVal;
}
//method: getCcdMotionThreshold ::btScalar ( ::btCollisionObject::* )(  ) const
float btCollisionObject_getCcdMotionThreshold(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	float retVal = (float)o->getCcdMotionThreshold();
	return retVal;
}
//method: setUserPointer void ( ::btCollisionObject::* )( void * ) 
void btCollisionObject_setUserPointer(void *c,void* p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void * tp0 = (void *)p0;
	o->setUserPointer(tp0);
}
//method: checkCollideWith bool ( ::btCollisionObject::* )( ::btCollisionObject * ) 
int btCollisionObject_checkCollideWith(void *c,void* p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	int retVal = (int)o->checkCollideWith(tp0);
	return retVal;
}
//method: getAnisotropicFriction ::btVector3 const & ( ::btCollisionObject::* )(  ) const
void btCollisionObject_getAnisotropicFriction(void *c,float* ret) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getAnisotropicFriction();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: getInterpolationAngularVelocity ::btVector3 const & ( ::btCollisionObject::* )(  ) const
void btCollisionObject_getInterpolationAngularVelocity(void *c,float* ret) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btVector3 tret(ret[0],ret[1],ret[2]);
	tret = o->getInterpolationAngularVelocity();
	ret[0]=tret.m_floats[0];ret[1]=tret.m_floats[1];ret[2]=tret.m_floats[2];
}
//method: forceActivationState void ( ::btCollisionObject::* )( int ) 
void btCollisionObject_forceActivationState(void *c,int p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->forceActivationState(p0);
}
//method: isStaticObject bool ( ::btCollisionObject::* )(  ) const
int btCollisionObject_isStaticObject(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	int retVal = (int)o->isStaticObject();
	return retVal;
}
//method: setFriction void ( ::btCollisionObject::* )( ::btScalar ) 
void btCollisionObject_setFriction(void *c,float p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->setFriction(p0);
}
//method: getInterpolationWorldTransform ::btTransform const & ( ::btCollisionObject::* )(  ) const
void btCollisionObject_getInterpolationWorldTransform(void *c,float* ret) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getInterpolationWorldTransform();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getInterpolationWorldTransform ::btTransform const & ( ::btCollisionObject::* )(  ) const
void btCollisionObject_getInterpolationWorldTransform0(void *c,float* ret) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getInterpolationWorldTransform();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getInterpolationWorldTransform ::btTransform & ( ::btCollisionObject::* )(  ) 
void btCollisionObject_getInterpolationWorldTransform1(void *c,float* ret) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getInterpolationWorldTransform();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: setIslandTag void ( ::btCollisionObject::* )( int ) 
void btCollisionObject_setIslandTag(void *c,int p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->setIslandTag(p0);
}
//method: setHitFraction void ( ::btCollisionObject::* )( ::btScalar ) 
void btCollisionObject_setHitFraction(void *c,float p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->setHitFraction(p0);
}
//method: serializeSingleObject void ( ::btCollisionObject::* )( ::btSerializer * ) const
void btCollisionObject_serializeSingleObject(void *c,void* p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	::btSerializer * tp0 = (::btSerializer *)p0;
	o->serializeSingleObject(tp0);
}
//method: getCollisionFlags int ( ::btCollisionObject::* )(  ) const
int btCollisionObject_getCollisionFlags(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	int retVal = (int)o->getCollisionFlags();
	return retVal;
}
//method: getDeactivationTime ::btScalar ( ::btCollisionObject::* )(  ) const
float btCollisionObject_getDeactivationTime(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	float retVal = (float)o->getDeactivationTime();
	return retVal;
}
//method: getCollisionShape ::btCollisionShape const * ( ::btCollisionObject::* )(  ) const
void* btCollisionObject_getCollisionShape(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void* retVal = (void*) o->getCollisionShape();
	return retVal;
}
//method: getCollisionShape ::btCollisionShape const * ( ::btCollisionObject::* )(  ) const
void* btCollisionObject_getCollisionShape0(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void* retVal = (void*) o->getCollisionShape();
	return retVal;
}
//method: getCollisionShape ::btCollisionShape * ( ::btCollisionObject::* )(  ) 
void* btCollisionObject_getCollisionShape1(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void* retVal = (void*) o->getCollisionShape();
	return retVal;
}
//method: setAnisotropicFriction void ( ::btCollisionObject::* )( ::btVector3 const & ) 
void btCollisionObject_setAnisotropicFriction(void *c,float* p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	o->setAnisotropicFriction(tp0);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
}
//method: checkCollideWithOverride bool ( ::btCollisionObject::* )( ::btCollisionObject * ) 
int btCollisionObject_checkCollideWithOverride(void *c,void* p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	int retVal = (int)o->checkCollideWithOverride(tp0);
	return retVal;
}
//method: getBroadphaseHandle ::btBroadphaseProxy * ( ::btCollisionObject::* )(  ) 
void* btCollisionObject_getBroadphaseHandle(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void* retVal = (void*) o->getBroadphaseHandle();
	return retVal;
}
//method: getBroadphaseHandle ::btBroadphaseProxy * ( ::btCollisionObject::* )(  ) 
void* btCollisionObject_getBroadphaseHandle0(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void* retVal = (void*) o->getBroadphaseHandle();
	return retVal;
}
//method: getBroadphaseHandle ::btBroadphaseProxy const * ( ::btCollisionObject::* )(  ) const
void* btCollisionObject_getBroadphaseHandle1(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void* retVal = (void*) o->getBroadphaseHandle();
	return retVal;
}
//method: getUserPointer void * ( ::btCollisionObject::* )(  ) const
void* btCollisionObject_getUserPointer(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void* retVal = (void*) o->getUserPointer();
	return retVal;
}
//method: setCcdSweptSphereRadius void ( ::btCollisionObject::* )( ::btScalar ) 
void btCollisionObject_setCcdSweptSphereRadius(void *c,float p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->setCcdSweptSphereRadius(p0);
}
//method: getWorldTransform ::btTransform & ( ::btCollisionObject::* )(  ) 
void btCollisionObject_getWorldTransform(void *c,float* ret) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getWorldTransform();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getWorldTransform ::btTransform & ( ::btCollisionObject::* )(  ) 
void btCollisionObject_getWorldTransform0(void *c,float* ret) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getWorldTransform();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: getWorldTransform ::btTransform const & ( ::btCollisionObject::* )(  ) const
void btCollisionObject_getWorldTransform1(void *c,float* ret) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btMatrix3x3 mtret(ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8]);
	btVector3 vtret(ret[9],ret[10],ret[11]);
	btTransform tret(mtret,vtret);
	tret = o->getWorldTransform();
	ret[0]=tret.getBasis().getRow(0).m_floats[0];ret[1]=tret.getBasis().getRow(0).m_floats[1];ret[2]=tret.getBasis().getRow(0).m_floats[2];ret[3]=tret.getBasis().getRow(1).m_floats[0];ret[4]=tret.getBasis().getRow(1).m_floats[1];ret[5]=tret.getBasis().getRow(1).m_floats[2];ret[6]=tret.getBasis().getRow(2).m_floats[0];ret[7]=tret.getBasis().getRow(2).m_floats[1];ret[8]=tret.getBasis().getRow(2).m_floats[2];
	ret[9]=tret.getOrigin().m_floats[0];ret[10]=tret.getOrigin().m_floats[1];ret[11]=tret.getOrigin().m_floats[2];
}
//method: setCollisionFlags void ( ::btCollisionObject::* )( int ) 
void btCollisionObject_setCollisionFlags(void *c,int p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->setCollisionFlags(p0);
}
//method: internalSetTemporaryCollisionShape void ( ::btCollisionObject::* )( ::btCollisionShape * ) 
void btCollisionObject_internalSetTemporaryCollisionShape(void *c,void* p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	::btCollisionShape * tp0 = (::btCollisionShape *)p0;
	o->internalSetTemporaryCollisionShape(tp0);
}
//method: getHitFraction ::btScalar ( ::btCollisionObject::* )(  ) const
float btCollisionObject_getHitFraction(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	float retVal = (float)o->getHitFraction();
	return retVal;
}
//method: isActive bool ( ::btCollisionObject::* )(  ) const
int btCollisionObject_isActive(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	int retVal = (int)o->isActive();
	return retVal;
}
//method: setActivationState void ( ::btCollisionObject::* )( int ) 
void btCollisionObject_setActivationState(void *c,int p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->setActivationState(p0);
}
//method: getInternalType int ( ::btCollisionObject::* )(  ) const
int btCollisionObject_getInternalType(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	int retVal = (int)o->getInternalType();
	return retVal;
}
//method: getActivationState int ( ::btCollisionObject::* )(  ) const
int btCollisionObject_getActivationState(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	int retVal = (int)o->getActivationState();
	return retVal;
}
//method: hasContactResponse bool ( ::btCollisionObject::* )(  ) const
int btCollisionObject_hasContactResponse(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	int retVal = (int)o->hasContactResponse();
	return retVal;
}
//method: getRootCollisionShape ::btCollisionShape const * ( ::btCollisionObject::* )(  ) const
void* btCollisionObject_getRootCollisionShape(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void* retVal = (void*) o->getRootCollisionShape();
	return retVal;
}
//method: getRootCollisionShape ::btCollisionShape const * ( ::btCollisionObject::* )(  ) const
void* btCollisionObject_getRootCollisionShape0(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void* retVal = (void*) o->getRootCollisionShape();
	return retVal;
}
//method: getRootCollisionShape ::btCollisionShape * ( ::btCollisionObject::* )(  ) 
void* btCollisionObject_getRootCollisionShape1(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void* retVal = (void*) o->getRootCollisionShape();
	return retVal;
}
//method: getRestitution ::btScalar ( ::btCollisionObject::* )(  ) const
float btCollisionObject_getRestitution(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	float retVal = (float)o->getRestitution();
	return retVal;
}
//method: getCcdSweptSphereRadius ::btScalar ( ::btCollisionObject::* )(  ) const
float btCollisionObject_getCcdSweptSphereRadius(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	float retVal = (float)o->getCcdSweptSphereRadius();
	return retVal;
}
//method: getContactProcessingThreshold ::btScalar ( ::btCollisionObject::* )(  ) const
float btCollisionObject_getContactProcessingThreshold(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	float retVal = (float)o->getContactProcessingThreshold();
	return retVal;
}
//method: setDeactivationTime void ( ::btCollisionObject::* )( ::btScalar ) 
void btCollisionObject_setDeactivationTime(void *c,float p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->setDeactivationTime(p0);
}
//method: internalGetExtensionPointer void * ( ::btCollisionObject::* )(  ) const
void* btCollisionObject_internalGetExtensionPointer(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void* retVal = (void*) o->internalGetExtensionPointer();
	return retVal;
}
//method: isStaticOrKinematicObject bool ( ::btCollisionObject::* )(  ) const
int btCollisionObject_isStaticOrKinematicObject(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	int retVal = (int)o->isStaticOrKinematicObject();
	return retVal;
}
//method: setRestitution void ( ::btCollisionObject::* )( ::btScalar ) 
void btCollisionObject_setRestitution(void *c,float p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->setRestitution(p0);
}
//method: hasAnisotropicFriction bool ( ::btCollisionObject::* )(  ) const
int btCollisionObject_hasAnisotropicFriction(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	int retVal = (int)o->hasAnisotropicFriction();
	return retVal;
}
//method: setBroadphaseHandle void ( ::btCollisionObject::* )( ::btBroadphaseProxy * ) 
void btCollisionObject_setBroadphaseHandle(void *c,void* p0) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	o->setBroadphaseHandle(tp0);
}
//method: isKinematicObject bool ( ::btCollisionObject::* )(  ) const
int btCollisionObject_isKinematicObject(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	int retVal = (int)o->isKinematicObject();
	return retVal;
}
//attribute: int btCollisionObject->m_activationState1
void btCollisionObject_m_activationState1_set(void *c,int a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->m_activationState1 = a;
}
int btCollisionObject_m_activationState1_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (int)(o->m_activationState1);
}

//attribute: ::btVector3 btCollisionObject->m_anisotropicFriction
void btCollisionObject_m_anisotropicFriction_set(void *c,float* a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_anisotropicFriction = ta;
}
void btCollisionObject_m_anisotropicFriction_get(void *c,float* a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	a[0]=(o->m_anisotropicFriction).m_floats[0];a[1]=(o->m_anisotropicFriction).m_floats[1];a[2]=(o->m_anisotropicFriction).m_floats[2];
}

//attribute: ::btBroadphaseProxy * btCollisionObject->m_broadphaseHandle
void btCollisionObject_m_broadphaseHandle_set(void *c,void* a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	::btBroadphaseProxy * ta = (::btBroadphaseProxy *)a;
	o->m_broadphaseHandle = ta;
}
void* btCollisionObject_m_broadphaseHandle_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (void*)(o->m_broadphaseHandle);
}

//attribute: ::btScalar btCollisionObject->m_ccdMotionThreshold
void btCollisionObject_m_ccdMotionThreshold_set(void *c,float a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->m_ccdMotionThreshold = a;
}
float btCollisionObject_m_ccdMotionThreshold_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (float)(o->m_ccdMotionThreshold);
}

//attribute: ::btScalar btCollisionObject->m_ccdSweptSphereRadius
void btCollisionObject_m_ccdSweptSphereRadius_set(void *c,float a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->m_ccdSweptSphereRadius = a;
}
float btCollisionObject_m_ccdSweptSphereRadius_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (float)(o->m_ccdSweptSphereRadius);
}

//attribute: int btCollisionObject->m_checkCollideWith
void btCollisionObject_m_checkCollideWith_set(void *c,int a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->m_checkCollideWith = a;
}
int btCollisionObject_m_checkCollideWith_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (int)(o->m_checkCollideWith);
}

//attribute: int btCollisionObject->m_collisionFlags
void btCollisionObject_m_collisionFlags_set(void *c,int a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->m_collisionFlags = a;
}
int btCollisionObject_m_collisionFlags_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (int)(o->m_collisionFlags);
}

//attribute: ::btCollisionShape * btCollisionObject->m_collisionShape
void btCollisionObject_m_collisionShape_set(void *c,void* a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	::btCollisionShape * ta = (::btCollisionShape *)a;
	o->m_collisionShape = ta;
}
void* btCollisionObject_m_collisionShape_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (void*)(o->m_collisionShape);
}

//attribute: int btCollisionObject->m_companionId
void btCollisionObject_m_companionId_set(void *c,int a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->m_companionId = a;
}
int btCollisionObject_m_companionId_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (int)(o->m_companionId);
}

//attribute: ::btScalar btCollisionObject->m_contactProcessingThreshold
void btCollisionObject_m_contactProcessingThreshold_set(void *c,float a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->m_contactProcessingThreshold = a;
}
float btCollisionObject_m_contactProcessingThreshold_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (float)(o->m_contactProcessingThreshold);
}

//attribute: ::btScalar btCollisionObject->m_deactivationTime
void btCollisionObject_m_deactivationTime_set(void *c,float a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->m_deactivationTime = a;
}
float btCollisionObject_m_deactivationTime_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (float)(o->m_deactivationTime);
}

//attribute: void * btCollisionObject->m_extensionPointer
void btCollisionObject_m_extensionPointer_set(void *c,void* a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void * ta = (void *)a;
	o->m_extensionPointer = ta;
}
void* btCollisionObject_m_extensionPointer_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (void*)(o->m_extensionPointer);
}

//attribute: ::btScalar btCollisionObject->m_friction
void btCollisionObject_m_friction_set(void *c,float a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->m_friction = a;
}
float btCollisionObject_m_friction_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (float)(o->m_friction);
}

//attribute: int btCollisionObject->m_hasAnisotropicFriction
void btCollisionObject_m_hasAnisotropicFriction_set(void *c,int a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->m_hasAnisotropicFriction = a;
}
int btCollisionObject_m_hasAnisotropicFriction_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (int)(o->m_hasAnisotropicFriction);
}

//attribute: ::btScalar btCollisionObject->m_hitFraction
void btCollisionObject_m_hitFraction_set(void *c,float a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->m_hitFraction = a;
}
float btCollisionObject_m_hitFraction_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (float)(o->m_hitFraction);
}

//attribute: int btCollisionObject->m_internalType
void btCollisionObject_m_internalType_set(void *c,int a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->m_internalType = a;
}
int btCollisionObject_m_internalType_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (int)(o->m_internalType);
}

//attribute: ::btVector3 btCollisionObject->m_interpolationAngularVelocity
void btCollisionObject_m_interpolationAngularVelocity_set(void *c,float* a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_interpolationAngularVelocity = ta;
}
void btCollisionObject_m_interpolationAngularVelocity_get(void *c,float* a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	a[0]=(o->m_interpolationAngularVelocity).m_floats[0];a[1]=(o->m_interpolationAngularVelocity).m_floats[1];a[2]=(o->m_interpolationAngularVelocity).m_floats[2];
}

//attribute: ::btVector3 btCollisionObject->m_interpolationLinearVelocity
void btCollisionObject_m_interpolationLinearVelocity_set(void *c,float* a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btVector3 ta(a[0],a[1],a[2]);
	o->m_interpolationLinearVelocity = ta;
}
void btCollisionObject_m_interpolationLinearVelocity_get(void *c,float* a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	a[0]=(o->m_interpolationLinearVelocity).m_floats[0];a[1]=(o->m_interpolationLinearVelocity).m_floats[1];a[2]=(o->m_interpolationLinearVelocity).m_floats[2];
}

//attribute: ::btTransform btCollisionObject->m_interpolationWorldTransform
void btCollisionObject_m_interpolationWorldTransform_set(void *c,float* a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_interpolationWorldTransform = ta;
}
void btCollisionObject_m_interpolationWorldTransform_get(void *c,float* a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	a[0]=(o->m_interpolationWorldTransform).getBasis().getRow(0).m_floats[0];a[1]=(o->m_interpolationWorldTransform).getBasis().getRow(0).m_floats[1];a[2]=(o->m_interpolationWorldTransform).getBasis().getRow(0).m_floats[2];a[3]=(o->m_interpolationWorldTransform).getBasis().getRow(1).m_floats[0];a[4]=(o->m_interpolationWorldTransform).getBasis().getRow(1).m_floats[1];a[5]=(o->m_interpolationWorldTransform).getBasis().getRow(1).m_floats[2];a[6]=(o->m_interpolationWorldTransform).getBasis().getRow(2).m_floats[0];a[7]=(o->m_interpolationWorldTransform).getBasis().getRow(2).m_floats[1];a[8]=(o->m_interpolationWorldTransform).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_interpolationWorldTransform).getOrigin().m_floats[0];a[10]=(o->m_interpolationWorldTransform).getOrigin().m_floats[1];a[11]=(o->m_interpolationWorldTransform).getOrigin().m_floats[2];
}

//attribute: int btCollisionObject->m_islandTag1
void btCollisionObject_m_islandTag1_set(void *c,int a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->m_islandTag1 = a;
}
int btCollisionObject_m_islandTag1_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (int)(o->m_islandTag1);
}

//attribute: ::btScalar btCollisionObject->m_restitution
void btCollisionObject_m_restitution_set(void *c,float a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	o->m_restitution = a;
}
float btCollisionObject_m_restitution_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (float)(o->m_restitution);
}

//attribute: ::btCollisionShape * btCollisionObject->m_rootCollisionShape
void btCollisionObject_m_rootCollisionShape_set(void *c,void* a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	::btCollisionShape * ta = (::btCollisionShape *)a;
	o->m_rootCollisionShape = ta;
}
void* btCollisionObject_m_rootCollisionShape_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (void*)(o->m_rootCollisionShape);
}

//attribute: void * btCollisionObject->m_userObjectPointer
void btCollisionObject_m_userObjectPointer_set(void *c,void* a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	void * ta = (void *)a;
	o->m_userObjectPointer = ta;
}
void* btCollisionObject_m_userObjectPointer_get(void *c) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	return (void*)(o->m_userObjectPointer);
}

//attribute: ::btTransform btCollisionObject->m_worldTransform
void btCollisionObject_m_worldTransform_set(void *c,float* a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_worldTransform = ta;
}
void btCollisionObject_m_worldTransform_get(void *c,float* a) {
	::btCollisionObject *o = (::btCollisionObject*)c;
	a[0]=(o->m_worldTransform).getBasis().getRow(0).m_floats[0];a[1]=(o->m_worldTransform).getBasis().getRow(0).m_floats[1];a[2]=(o->m_worldTransform).getBasis().getRow(0).m_floats[2];a[3]=(o->m_worldTransform).getBasis().getRow(1).m_floats[0];a[4]=(o->m_worldTransform).getBasis().getRow(1).m_floats[1];a[5]=(o->m_worldTransform).getBasis().getRow(1).m_floats[2];a[6]=(o->m_worldTransform).getBasis().getRow(2).m_floats[0];a[7]=(o->m_worldTransform).getBasis().getRow(2).m_floats[1];a[8]=(o->m_worldTransform).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_worldTransform).getOrigin().m_floats[0];a[10]=(o->m_worldTransform).getOrigin().m_floats[1];a[11]=(o->m_worldTransform).getOrigin().m_floats[2];
}


// ::btCollisionObjectDoubleData
//constructor: btCollisionObjectDoubleData  ( ::btCollisionObjectDoubleData::* )(  ) 
void* btCollisionObjectDoubleData_new() {
	::btCollisionObjectDoubleData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCollisionObjectDoubleData),16);
	o = new (mem)::btCollisionObjectDoubleData();
	return (void*)o;
}
void btCollisionObjectDoubleData_free(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	delete o;
}
//attribute: int btCollisionObjectDoubleData->m_activationState1
void btCollisionObjectDoubleData_m_activationState1_set(void *c,int a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	o->m_activationState1 = a;
}
int btCollisionObjectDoubleData_m_activationState1_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (int)(o->m_activationState1);
}

//attribute: ::btVector3DoubleData btCollisionObjectDoubleData->m_anisotropicFriction
void btCollisionObjectDoubleData_m_anisotropicFriction_set(void *c,void* a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_anisotropicFriction = ta;
}
void* btCollisionObjectDoubleData_m_anisotropicFriction_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (void*)&(o->m_anisotropicFriction);
}

//attribute: void * btCollisionObjectDoubleData->m_broadphaseHandle
void btCollisionObjectDoubleData_m_broadphaseHandle_set(void *c,void* a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	void * ta = (void *)a;
	o->m_broadphaseHandle = ta;
}
void* btCollisionObjectDoubleData_m_broadphaseHandle_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (void*)(o->m_broadphaseHandle);
}

//attribute: double btCollisionObjectDoubleData->m_ccdMotionThreshold
void btCollisionObjectDoubleData_m_ccdMotionThreshold_set(void *c,double a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	o->m_ccdMotionThreshold = a;
}
double btCollisionObjectDoubleData_m_ccdMotionThreshold_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (double)(o->m_ccdMotionThreshold);
}

//attribute: double btCollisionObjectDoubleData->m_ccdSweptSphereRadius
void btCollisionObjectDoubleData_m_ccdSweptSphereRadius_set(void *c,double a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	o->m_ccdSweptSphereRadius = a;
}
double btCollisionObjectDoubleData_m_ccdSweptSphereRadius_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (double)(o->m_ccdSweptSphereRadius);
}

//attribute: int btCollisionObjectDoubleData->m_checkCollideWith
void btCollisionObjectDoubleData_m_checkCollideWith_set(void *c,int a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	o->m_checkCollideWith = a;
}
int btCollisionObjectDoubleData_m_checkCollideWith_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (int)(o->m_checkCollideWith);
}

//attribute: int btCollisionObjectDoubleData->m_collisionFlags
void btCollisionObjectDoubleData_m_collisionFlags_set(void *c,int a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	o->m_collisionFlags = a;
}
int btCollisionObjectDoubleData_m_collisionFlags_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (int)(o->m_collisionFlags);
}

//attribute: void * btCollisionObjectDoubleData->m_collisionShape
void btCollisionObjectDoubleData_m_collisionShape_set(void *c,void* a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	void * ta = (void *)a;
	o->m_collisionShape = ta;
}
void* btCollisionObjectDoubleData_m_collisionShape_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (void*)(o->m_collisionShape);
}

//attribute: int btCollisionObjectDoubleData->m_companionId
void btCollisionObjectDoubleData_m_companionId_set(void *c,int a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	o->m_companionId = a;
}
int btCollisionObjectDoubleData_m_companionId_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (int)(o->m_companionId);
}

//attribute: double btCollisionObjectDoubleData->m_contactProcessingThreshold
void btCollisionObjectDoubleData_m_contactProcessingThreshold_set(void *c,double a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	o->m_contactProcessingThreshold = a;
}
double btCollisionObjectDoubleData_m_contactProcessingThreshold_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (double)(o->m_contactProcessingThreshold);
}

//attribute: double btCollisionObjectDoubleData->m_deactivationTime
void btCollisionObjectDoubleData_m_deactivationTime_set(void *c,double a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	o->m_deactivationTime = a;
}
double btCollisionObjectDoubleData_m_deactivationTime_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (double)(o->m_deactivationTime);
}

//attribute: double btCollisionObjectDoubleData->m_friction
void btCollisionObjectDoubleData_m_friction_set(void *c,double a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	o->m_friction = a;
}
double btCollisionObjectDoubleData_m_friction_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (double)(o->m_friction);
}

//attribute: int btCollisionObjectDoubleData->m_hasAnisotropicFriction
void btCollisionObjectDoubleData_m_hasAnisotropicFriction_set(void *c,int a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	o->m_hasAnisotropicFriction = a;
}
int btCollisionObjectDoubleData_m_hasAnisotropicFriction_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (int)(o->m_hasAnisotropicFriction);
}

//attribute: double btCollisionObjectDoubleData->m_hitFraction
void btCollisionObjectDoubleData_m_hitFraction_set(void *c,double a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	o->m_hitFraction = a;
}
double btCollisionObjectDoubleData_m_hitFraction_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (double)(o->m_hitFraction);
}

//attribute: int btCollisionObjectDoubleData->m_internalType
void btCollisionObjectDoubleData_m_internalType_set(void *c,int a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	o->m_internalType = a;
}
int btCollisionObjectDoubleData_m_internalType_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (int)(o->m_internalType);
}

//attribute: ::btVector3DoubleData btCollisionObjectDoubleData->m_interpolationAngularVelocity
void btCollisionObjectDoubleData_m_interpolationAngularVelocity_set(void *c,void* a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_interpolationAngularVelocity = ta;
}
void* btCollisionObjectDoubleData_m_interpolationAngularVelocity_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (void*)&(o->m_interpolationAngularVelocity);
}

//attribute: ::btVector3DoubleData btCollisionObjectDoubleData->m_interpolationLinearVelocity
void btCollisionObjectDoubleData_m_interpolationLinearVelocity_set(void *c,void* a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	::btVector3DoubleData & ta = *(::btVector3DoubleData *)a;
	o->m_interpolationLinearVelocity = ta;
}
void* btCollisionObjectDoubleData_m_interpolationLinearVelocity_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (void*)&(o->m_interpolationLinearVelocity);
}

//attribute: ::btTransformDoubleData btCollisionObjectDoubleData->m_interpolationWorldTransform
void btCollisionObjectDoubleData_m_interpolationWorldTransform_set(void *c,void* a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	::btTransformDoubleData & ta = *(::btTransformDoubleData *)a;
	o->m_interpolationWorldTransform = ta;
}
void* btCollisionObjectDoubleData_m_interpolationWorldTransform_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (void*)&(o->m_interpolationWorldTransform);
}

//attribute: int btCollisionObjectDoubleData->m_islandTag1
void btCollisionObjectDoubleData_m_islandTag1_set(void *c,int a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	o->m_islandTag1 = a;
}
int btCollisionObjectDoubleData_m_islandTag1_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (int)(o->m_islandTag1);
}

//attribute: char * btCollisionObjectDoubleData->m_name
void btCollisionObjectDoubleData_m_name_set(void *c,char * a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	o->m_name = a;
}
char * btCollisionObjectDoubleData_m_name_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (char *)(o->m_name);
}

//attribute: char[4] btCollisionObjectDoubleData->m_padding
// attribute not supported: //attribute: char[4] btCollisionObjectDoubleData->m_padding
//attribute: double btCollisionObjectDoubleData->m_restitution
void btCollisionObjectDoubleData_m_restitution_set(void *c,double a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	o->m_restitution = a;
}
double btCollisionObjectDoubleData_m_restitution_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (double)(o->m_restitution);
}

//attribute: ::btCollisionShapeData * btCollisionObjectDoubleData->m_rootCollisionShape
void btCollisionObjectDoubleData_m_rootCollisionShape_set(void *c,void* a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	::btCollisionShapeData * ta = (::btCollisionShapeData *)a;
	o->m_rootCollisionShape = ta;
}
void* btCollisionObjectDoubleData_m_rootCollisionShape_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (void*)(o->m_rootCollisionShape);
}

//attribute: ::btTransformDoubleData btCollisionObjectDoubleData->m_worldTransform
void btCollisionObjectDoubleData_m_worldTransform_set(void *c,void* a) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	::btTransformDoubleData & ta = *(::btTransformDoubleData *)a;
	o->m_worldTransform = ta;
}
void* btCollisionObjectDoubleData_m_worldTransform_get(void *c) {
	::btCollisionObjectDoubleData *o = (::btCollisionObjectDoubleData*)c;
	return (void*)&(o->m_worldTransform);
}


// ::btCollisionObjectFloatData
//constructor: btCollisionObjectFloatData  ( ::btCollisionObjectFloatData::* )(  ) 
void* btCollisionObjectFloatData_new() {
	::btCollisionObjectFloatData *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btCollisionObjectFloatData),16);
	o = new (mem)::btCollisionObjectFloatData();
	return (void*)o;
}
void btCollisionObjectFloatData_free(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	delete o;
}
//attribute: int btCollisionObjectFloatData->m_activationState1
void btCollisionObjectFloatData_m_activationState1_set(void *c,int a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	o->m_activationState1 = a;
}
int btCollisionObjectFloatData_m_activationState1_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (int)(o->m_activationState1);
}

//attribute: ::btVector3FloatData btCollisionObjectFloatData->m_anisotropicFriction
void btCollisionObjectFloatData_m_anisotropicFriction_set(void *c,void* a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_anisotropicFriction = ta;
}
void* btCollisionObjectFloatData_m_anisotropicFriction_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (void*)&(o->m_anisotropicFriction);
}

//attribute: void * btCollisionObjectFloatData->m_broadphaseHandle
void btCollisionObjectFloatData_m_broadphaseHandle_set(void *c,void* a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	void * ta = (void *)a;
	o->m_broadphaseHandle = ta;
}
void* btCollisionObjectFloatData_m_broadphaseHandle_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (void*)(o->m_broadphaseHandle);
}

//attribute: float btCollisionObjectFloatData->m_ccdMotionThreshold
void btCollisionObjectFloatData_m_ccdMotionThreshold_set(void *c,float a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	o->m_ccdMotionThreshold = a;
}
float btCollisionObjectFloatData_m_ccdMotionThreshold_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (float)(o->m_ccdMotionThreshold);
}

//attribute: float btCollisionObjectFloatData->m_ccdSweptSphereRadius
void btCollisionObjectFloatData_m_ccdSweptSphereRadius_set(void *c,float a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	o->m_ccdSweptSphereRadius = a;
}
float btCollisionObjectFloatData_m_ccdSweptSphereRadius_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (float)(o->m_ccdSweptSphereRadius);
}

//attribute: int btCollisionObjectFloatData->m_checkCollideWith
void btCollisionObjectFloatData_m_checkCollideWith_set(void *c,int a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	o->m_checkCollideWith = a;
}
int btCollisionObjectFloatData_m_checkCollideWith_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (int)(o->m_checkCollideWith);
}

//attribute: int btCollisionObjectFloatData->m_collisionFlags
void btCollisionObjectFloatData_m_collisionFlags_set(void *c,int a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	o->m_collisionFlags = a;
}
int btCollisionObjectFloatData_m_collisionFlags_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (int)(o->m_collisionFlags);
}

//attribute: void * btCollisionObjectFloatData->m_collisionShape
void btCollisionObjectFloatData_m_collisionShape_set(void *c,void* a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	void * ta = (void *)a;
	o->m_collisionShape = ta;
}
void* btCollisionObjectFloatData_m_collisionShape_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (void*)(o->m_collisionShape);
}

//attribute: int btCollisionObjectFloatData->m_companionId
void btCollisionObjectFloatData_m_companionId_set(void *c,int a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	o->m_companionId = a;
}
int btCollisionObjectFloatData_m_companionId_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (int)(o->m_companionId);
}

//attribute: float btCollisionObjectFloatData->m_contactProcessingThreshold
void btCollisionObjectFloatData_m_contactProcessingThreshold_set(void *c,float a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	o->m_contactProcessingThreshold = a;
}
float btCollisionObjectFloatData_m_contactProcessingThreshold_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (float)(o->m_contactProcessingThreshold);
}

//attribute: float btCollisionObjectFloatData->m_deactivationTime
void btCollisionObjectFloatData_m_deactivationTime_set(void *c,float a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	o->m_deactivationTime = a;
}
float btCollisionObjectFloatData_m_deactivationTime_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (float)(o->m_deactivationTime);
}

//attribute: float btCollisionObjectFloatData->m_friction
void btCollisionObjectFloatData_m_friction_set(void *c,float a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	o->m_friction = a;
}
float btCollisionObjectFloatData_m_friction_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (float)(o->m_friction);
}

//attribute: int btCollisionObjectFloatData->m_hasAnisotropicFriction
void btCollisionObjectFloatData_m_hasAnisotropicFriction_set(void *c,int a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	o->m_hasAnisotropicFriction = a;
}
int btCollisionObjectFloatData_m_hasAnisotropicFriction_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (int)(o->m_hasAnisotropicFriction);
}

//attribute: float btCollisionObjectFloatData->m_hitFraction
void btCollisionObjectFloatData_m_hitFraction_set(void *c,float a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	o->m_hitFraction = a;
}
float btCollisionObjectFloatData_m_hitFraction_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (float)(o->m_hitFraction);
}

//attribute: int btCollisionObjectFloatData->m_internalType
void btCollisionObjectFloatData_m_internalType_set(void *c,int a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	o->m_internalType = a;
}
int btCollisionObjectFloatData_m_internalType_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (int)(o->m_internalType);
}

//attribute: ::btVector3FloatData btCollisionObjectFloatData->m_interpolationAngularVelocity
void btCollisionObjectFloatData_m_interpolationAngularVelocity_set(void *c,void* a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_interpolationAngularVelocity = ta;
}
void* btCollisionObjectFloatData_m_interpolationAngularVelocity_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (void*)&(o->m_interpolationAngularVelocity);
}

//attribute: ::btVector3FloatData btCollisionObjectFloatData->m_interpolationLinearVelocity
void btCollisionObjectFloatData_m_interpolationLinearVelocity_set(void *c,void* a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	::btVector3FloatData & ta = *(::btVector3FloatData *)a;
	o->m_interpolationLinearVelocity = ta;
}
void* btCollisionObjectFloatData_m_interpolationLinearVelocity_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (void*)&(o->m_interpolationLinearVelocity);
}

//attribute: ::btTransformFloatData btCollisionObjectFloatData->m_interpolationWorldTransform
void btCollisionObjectFloatData_m_interpolationWorldTransform_set(void *c,void* a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	::btTransformFloatData & ta = *(::btTransformFloatData *)a;
	o->m_interpolationWorldTransform = ta;
}
void* btCollisionObjectFloatData_m_interpolationWorldTransform_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (void*)&(o->m_interpolationWorldTransform);
}

//attribute: int btCollisionObjectFloatData->m_islandTag1
void btCollisionObjectFloatData_m_islandTag1_set(void *c,int a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	o->m_islandTag1 = a;
}
int btCollisionObjectFloatData_m_islandTag1_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (int)(o->m_islandTag1);
}

//attribute: char * btCollisionObjectFloatData->m_name
void btCollisionObjectFloatData_m_name_set(void *c,char * a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	o->m_name = a;
}
char * btCollisionObjectFloatData_m_name_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (char *)(o->m_name);
}

//attribute: float btCollisionObjectFloatData->m_restitution
void btCollisionObjectFloatData_m_restitution_set(void *c,float a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	o->m_restitution = a;
}
float btCollisionObjectFloatData_m_restitution_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (float)(o->m_restitution);
}

//attribute: ::btCollisionShapeData * btCollisionObjectFloatData->m_rootCollisionShape
void btCollisionObjectFloatData_m_rootCollisionShape_set(void *c,void* a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	::btCollisionShapeData * ta = (::btCollisionShapeData *)a;
	o->m_rootCollisionShape = ta;
}
void* btCollisionObjectFloatData_m_rootCollisionShape_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (void*)(o->m_rootCollisionShape);
}

//attribute: ::btTransformFloatData btCollisionObjectFloatData->m_worldTransform
void btCollisionObjectFloatData_m_worldTransform_set(void *c,void* a) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	::btTransformFloatData & ta = *(::btTransformFloatData *)a;
	o->m_worldTransform = ta;
}
void* btCollisionObjectFloatData_m_worldTransform_get(void *c) {
	::btCollisionObjectFloatData *o = (::btCollisionObjectFloatData*)c;
	return (void*)&(o->m_worldTransform);
}


// ::btCollisionWorld
//constructor: btCollisionWorld  ( ::btCollisionWorld::* )( ::btDispatcher *,::btBroadphaseInterface *,::btCollisionConfiguration * ) 
void* btCollisionWorld_new(void* p0,void* p1,void* p2) {
	::btCollisionWorld *o = 0;
	 void *mem = 0;
	::btDispatcher * tp0 = (::btDispatcher *)p0;
	::btBroadphaseInterface * tp1 = (::btBroadphaseInterface *)p1;
	::btCollisionConfiguration * tp2 = (::btCollisionConfiguration *)p2;
	mem = btAlignedAlloc(sizeof(::btCollisionWorld),16);
	o = new (mem)::btCollisionWorld(tp0,tp1,tp2);
	return (void*)o;
}
void btCollisionWorld_free(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	delete o;
}
//method: setBroadphase void ( ::btCollisionWorld::* )( ::btBroadphaseInterface * ) 
void btCollisionWorld_setBroadphase(void *c,void* p0) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btBroadphaseInterface * tp0 = (::btBroadphaseInterface *)p0;
	o->setBroadphase(tp0);
}
//method: serialize void ( ::btCollisionWorld::* )( ::btSerializer * ) 
void btCollisionWorld_serialize(void *c,void* p0) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btSerializer * tp0 = (::btSerializer *)p0;
	o->serialize(tp0);
}
//method: getDispatcher ::btDispatcher * ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getDispatcher(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	void* retVal = (void*) o->getDispatcher();
	return retVal;
}
//method: getDispatcher ::btDispatcher * ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getDispatcher0(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	void* retVal = (void*) o->getDispatcher();
	return retVal;
}
//method: getDispatcher ::btDispatcher const * ( ::btCollisionWorld::* )(  ) const
void* btCollisionWorld_getDispatcher1(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	void* retVal = (void*) o->getDispatcher();
	return retVal;
}
//method: getDispatchInfo ::btDispatcherInfo & ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getDispatchInfo(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	void* retVal = (void*) &(o->getDispatchInfo());
	return retVal;
}
//method: getDispatchInfo ::btDispatcherInfo & ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getDispatchInfo0(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	void* retVal = (void*) &(o->getDispatchInfo());
	return retVal;
}
//method: getDispatchInfo ::btDispatcherInfo const & ( ::btCollisionWorld::* )(  ) const
void* btCollisionWorld_getDispatchInfo1(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	void* retVal = (void*) &(o->getDispatchInfo());
	return retVal;
}
//method: getDebugDrawer ::btIDebugDraw * ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getDebugDrawer(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	void* retVal = (void*) o->getDebugDrawer();
	return retVal;
}
//method: performDiscreteCollisionDetection void ( ::btCollisionWorld::* )(  ) 
void btCollisionWorld_performDiscreteCollisionDetection(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	o->performDiscreteCollisionDetection();
}
//method: getCollisionObjectArray ::btCollisionObjectArray & ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getCollisionObjectArray(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	void* retVal = (void*) &(o->getCollisionObjectArray());
	return retVal;
}
//method: getCollisionObjectArray ::btCollisionObjectArray & ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getCollisionObjectArray0(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	void* retVal = (void*) &(o->getCollisionObjectArray());
	return retVal;
}
//method: getCollisionObjectArray ::btCollisionObjectArray const & ( ::btCollisionWorld::* )(  ) const
void* btCollisionWorld_getCollisionObjectArray1(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	void* retVal = (void*) &(o->getCollisionObjectArray());
	return retVal;
}
//method: debugDrawObject void ( ::btCollisionWorld::* )( ::btTransform const &,::btCollisionShape const *,::btVector3 const & ) 
void btCollisionWorld_debugDrawObject(void *c,float* p0,void* p1,float* p2) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	::btCollisionShape const * tp1 = (::btCollisionShape const *)p1;
	btVector3 tp2(p2[0],p2[1],p2[2]);
	o->debugDrawObject(tp0,tp1,tp2);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p2[0]=tp2.m_floats[0];p2[1]=tp2.m_floats[1];p2[2]=tp2.m_floats[2];
}
//method: rayTest void ( ::btCollisionWorld::* )( ::btVector3 const &,::btVector3 const &,::btCollisionWorld::RayResultCallback & ) const
void btCollisionWorld_rayTest(void *c,float* p0,float* p1,void* p2) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btCollisionWorld::RayResultCallback & tp2 = *(::btCollisionWorld::RayResultCallback *)p2;
	o->rayTest(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: addCollisionObject void ( ::btCollisionWorld::* )( ::btCollisionObject *,short int,short int ) 
void btCollisionWorld_addCollisionObject(void *c,void* p0,short int p1,short int p2) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	o->addCollisionObject(tp0,p1,p2);
}
//method: setForceUpdateAllAabbs void ( ::btCollisionWorld::* )( bool ) 
void btCollisionWorld_setForceUpdateAllAabbs(void *c,int p0) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	o->setForceUpdateAllAabbs(p0);
}
//method: contactTest void ( ::btCollisionWorld::* )( ::btCollisionObject *,::btCollisionWorld::ContactResultCallback & ) 
void btCollisionWorld_contactTest(void *c,void* p0,void* p1) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionWorld::ContactResultCallback & tp1 = *(::btCollisionWorld::ContactResultCallback *)p1;
	o->contactTest(tp0,tp1);
}
//method: getForceUpdateAllAabbs bool ( ::btCollisionWorld::* )(  ) const
int btCollisionWorld_getForceUpdateAllAabbs(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	int retVal = (int)o->getForceUpdateAllAabbs();
	return retVal;
}
//method: updateAabbs void ( ::btCollisionWorld::* )(  ) 
void btCollisionWorld_updateAabbs(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	o->updateAabbs();
}
//method: setDebugDrawer void ( ::btCollisionWorld::* )( ::btIDebugDraw * ) 
void btCollisionWorld_setDebugDrawer(void *c,void* p0) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btIDebugDraw * tp0 = (::btIDebugDraw *)p0;
	o->setDebugDrawer(tp0);
}
//method: debugDrawWorld void ( ::btCollisionWorld::* )(  ) 
void btCollisionWorld_debugDrawWorld(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	o->debugDrawWorld();
}
//method: convexSweepTest void ( ::btCollisionWorld::* )( ::btConvexShape const *,::btTransform const &,::btTransform const &,::btCollisionWorld::ConvexResultCallback &,::btScalar ) const
void btCollisionWorld_convexSweepTest(void *c,void* p0,float* p1,float* p2,void* p3,float p4) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btConvexShape const * tp0 = (::btConvexShape const *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	::btCollisionWorld::ConvexResultCallback & tp3 = *(::btCollisionWorld::ConvexResultCallback *)p3;
	o->convexSweepTest(tp0,tp1,tp2,tp3,p4);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
}
//method: getNumCollisionObjects int ( ::btCollisionWorld::* )(  ) const
int btCollisionWorld_getNumCollisionObjects(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	int retVal = (int)o->getNumCollisionObjects();
	return retVal;
}
//method: contactPairTest void ( ::btCollisionWorld::* )( ::btCollisionObject *,::btCollisionObject *,::btCollisionWorld::ContactResultCallback & ) 
void btCollisionWorld_contactPairTest(void *c,void* p0,void* p1,void* p2) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btCollisionWorld::ContactResultCallback & tp2 = *(::btCollisionWorld::ContactResultCallback *)p2;
	o->contactPairTest(tp0,tp1,tp2);
}
//method: getBroadphase ::btBroadphaseInterface const * ( ::btCollisionWorld::* )(  ) const
void* btCollisionWorld_getBroadphase(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	void* retVal = (void*) o->getBroadphase();
	return retVal;
}
//method: getBroadphase ::btBroadphaseInterface const * ( ::btCollisionWorld::* )(  ) const
void* btCollisionWorld_getBroadphase0(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	void* retVal = (void*) o->getBroadphase();
	return retVal;
}
//method: getBroadphase ::btBroadphaseInterface * ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getBroadphase1(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	void* retVal = (void*) o->getBroadphase();
	return retVal;
}
//method: rayTestSingle void (*)( ::btTransform const &,::btTransform const &,::btCollisionObject *,::btCollisionShape const *,::btTransform const &,::btCollisionWorld::RayResultCallback & )
void btCollisionWorld_rayTestSingle(float* p0,float* p1,void* p2,void* p3,float* p4,void* p5) {
	btMatrix3x3 mtp0(p0[0],p0[1],p0[2],p0[3],p0[4],p0[5],p0[6],p0[7],p0[8]);
	btVector3 vtp0(p0[9],p0[10],p0[11]);
	btTransform tp0(mtp0,vtp0);
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	::btCollisionObject * tp2 = (::btCollisionObject *)p2;
	::btCollisionShape const * tp3 = (::btCollisionShape const *)p3;
	btMatrix3x3 mtp4(p4[0],p4[1],p4[2],p4[3],p4[4],p4[5],p4[6],p4[7],p4[8]);
	btVector3 vtp4(p4[9],p4[10],p4[11]);
	btTransform tp4(mtp4,vtp4);
	::btCollisionWorld::RayResultCallback & tp5 = *(::btCollisionWorld::RayResultCallback *)p5;
	::btCollisionWorld::rayTestSingle(tp0,tp1,tp2,tp3,tp4,tp5);
	p0[0]=tp0.getBasis().getRow(0).m_floats[0];p0[1]=tp0.getBasis().getRow(0).m_floats[1];p0[2]=tp0.getBasis().getRow(0).m_floats[2];p0[3]=tp0.getBasis().getRow(1).m_floats[0];p0[4]=tp0.getBasis().getRow(1).m_floats[1];p0[5]=tp0.getBasis().getRow(1).m_floats[2];p0[6]=tp0.getBasis().getRow(2).m_floats[0];p0[7]=tp0.getBasis().getRow(2).m_floats[1];p0[8]=tp0.getBasis().getRow(2).m_floats[2];
	p0[9]=tp0.getOrigin().m_floats[0];p0[10]=tp0.getOrigin().m_floats[1];p0[11]=tp0.getOrigin().m_floats[2];
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p4[0]=tp4.getBasis().getRow(0).m_floats[0];p4[1]=tp4.getBasis().getRow(0).m_floats[1];p4[2]=tp4.getBasis().getRow(0).m_floats[2];p4[3]=tp4.getBasis().getRow(1).m_floats[0];p4[4]=tp4.getBasis().getRow(1).m_floats[1];p4[5]=tp4.getBasis().getRow(1).m_floats[2];p4[6]=tp4.getBasis().getRow(2).m_floats[0];p4[7]=tp4.getBasis().getRow(2).m_floats[1];p4[8]=tp4.getBasis().getRow(2).m_floats[2];
	p4[9]=tp4.getOrigin().m_floats[0];p4[10]=tp4.getOrigin().m_floats[1];p4[11]=tp4.getOrigin().m_floats[2];
}
//method: objectQuerySingle void (*)( ::btConvexShape const *,::btTransform const &,::btTransform const &,::btCollisionObject *,::btCollisionShape const *,::btTransform const &,::btCollisionWorld::ConvexResultCallback &,::btScalar )
void btCollisionWorld_objectQuerySingle(void* p0,float* p1,float* p2,void* p3,void* p4,float* p5,void* p6,float p7) {
	::btConvexShape const * tp0 = (::btConvexShape const *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	::btCollisionObject * tp3 = (::btCollisionObject *)p3;
	::btCollisionShape const * tp4 = (::btCollisionShape const *)p4;
	btMatrix3x3 mtp5(p5[0],p5[1],p5[2],p5[3],p5[4],p5[5],p5[6],p5[7],p5[8]);
	btVector3 vtp5(p5[9],p5[10],p5[11]);
	btTransform tp5(mtp5,vtp5);
	::btCollisionWorld::ConvexResultCallback & tp6 = *(::btCollisionWorld::ConvexResultCallback *)p6;
	::btCollisionWorld::objectQuerySingle(tp0,tp1,tp2,tp3,tp4,tp5,tp6,p7);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
	p5[0]=tp5.getBasis().getRow(0).m_floats[0];p5[1]=tp5.getBasis().getRow(0).m_floats[1];p5[2]=tp5.getBasis().getRow(0).m_floats[2];p5[3]=tp5.getBasis().getRow(1).m_floats[0];p5[4]=tp5.getBasis().getRow(1).m_floats[1];p5[5]=tp5.getBasis().getRow(1).m_floats[2];p5[6]=tp5.getBasis().getRow(2).m_floats[0];p5[7]=tp5.getBasis().getRow(2).m_floats[1];p5[8]=tp5.getBasis().getRow(2).m_floats[2];
	p5[9]=tp5.getOrigin().m_floats[0];p5[10]=tp5.getOrigin().m_floats[1];p5[11]=tp5.getOrigin().m_floats[2];
}
//method: updateSingleAabb void ( ::btCollisionWorld::* )( ::btCollisionObject * ) 
void btCollisionWorld_updateSingleAabb(void *c,void* p0) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	o->updateSingleAabb(tp0);
}
//method: serializeCollisionObjects void ( ::btCollisionWorld::* )( ::btSerializer * ) 
void btCollisionWorld_serializeCollisionObjects(void *c,void* p0) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btSerializer * tp0 = (::btSerializer *)p0;
	o->serializeCollisionObjects(tp0);
}
//method: getPairCache ::btOverlappingPairCache * ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getPairCache(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	void* retVal = (void*) o->getPairCache();
	return retVal;
}
//method: removeCollisionObject void ( ::btCollisionWorld::* )( ::btCollisionObject * ) 
void btCollisionWorld_removeCollisionObject(void *c,void* p0) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	o->removeCollisionObject(tp0);
}
//attribute: ::btBroadphaseInterface * btCollisionWorld->m_broadphasePairCache
void btCollisionWorld_m_broadphasePairCache_set(void *c,void* a) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btBroadphaseInterface * ta = (::btBroadphaseInterface *)a;
	o->m_broadphasePairCache = ta;
}
void* btCollisionWorld_m_broadphasePairCache_get(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	return (void*)(o->m_broadphasePairCache);
}

//attribute: ::btAlignedObjectArray<btCollisionObject*> btCollisionWorld->m_collisionObjects
void btCollisionWorld_m_collisionObjects_set(void *c,void* a) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btAlignedObjectArray<btCollisionObject*> & ta = *(::btAlignedObjectArray<btCollisionObject*> *)a;
	o->m_collisionObjects = ta;
}
void* btCollisionWorld_m_collisionObjects_get(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	return (void*)&(o->m_collisionObjects);
}

//attribute: ::btIDebugDraw * btCollisionWorld->m_debugDrawer
void btCollisionWorld_m_debugDrawer_set(void *c,void* a) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btIDebugDraw * ta = (::btIDebugDraw *)a;
	o->m_debugDrawer = ta;
}
void* btCollisionWorld_m_debugDrawer_get(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	return (void*)(o->m_debugDrawer);
}

//attribute: ::btDispatcherInfo btCollisionWorld->m_dispatchInfo
void btCollisionWorld_m_dispatchInfo_set(void *c,void* a) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btDispatcherInfo & ta = *(::btDispatcherInfo *)a;
	o->m_dispatchInfo = ta;
}
void* btCollisionWorld_m_dispatchInfo_get(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	return (void*)&(o->m_dispatchInfo);
}

//attribute: ::btDispatcher * btCollisionWorld->m_dispatcher1
void btCollisionWorld_m_dispatcher1_set(void *c,void* a) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btDispatcher * ta = (::btDispatcher *)a;
	o->m_dispatcher1 = ta;
}
void* btCollisionWorld_m_dispatcher1_get(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	return (void*)(o->m_dispatcher1);
}

//attribute: bool btCollisionWorld->m_forceUpdateAllAabbs
void btCollisionWorld_m_forceUpdateAllAabbs_set(void *c,int a) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	o->m_forceUpdateAllAabbs = a;
}
int btCollisionWorld_m_forceUpdateAllAabbs_get(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	return (int)(o->m_forceUpdateAllAabbs);
}

//attribute: ::btStackAlloc * btCollisionWorld->m_stackAlloc
void btCollisionWorld_m_stackAlloc_set(void *c,void* a) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	::btStackAlloc * ta = (::btStackAlloc *)a;
	o->m_stackAlloc = ta;
}
void* btCollisionWorld_m_stackAlloc_get(void *c) {
	::btCollisionWorld *o = (::btCollisionWorld*)c;
	return (void*)(o->m_stackAlloc);
}


// ::btConvexConvexAlgorithm
//not supported constructor: btConvexConvexAlgorithm  ( ::btConvexConvexAlgorithm::* )( ::btPersistentManifold *,::btCollisionAlgorithmConstructionInfo const &,::btCollisionObject *,::btCollisionObject *,::btVoronoiSimplexSolver *,::btConvexPenetrationDepthSolver *,int,int ) 
// error: ::btPersistentManifold * - ok, ::btCollisionAlgorithmConstructionInfo const & - ok, ::btCollisionObject * - ok, ::btCollisionObject * - ok, ::btVoronoiSimplexSolver * - ok,  - unsupported, int - ok, int - ok

void btConvexConvexAlgorithm_free(void *c) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	delete o;
}
//method: getAllContactManifolds void ( ::btConvexConvexAlgorithm::* )( ::btManifoldArray & ) 
void btConvexConvexAlgorithm_getAllContactManifolds(void *c,void* p0) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	::btManifoldArray & tp0 = *(::btAlignedObjectArray<btPersistentManifold*> *)p0;
	o->getAllContactManifolds(tp0);
}
//method: calculateTimeOfImpact ::btScalar ( ::btConvexConvexAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
float btConvexConvexAlgorithm_calculateTimeOfImpact(void *c,void* p0,void* p1,void* p2,void* p3) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btDispatcherInfo const & tp2 = *(::btDispatcherInfo const *)p2;
	::btManifoldResult * tp3 = (::btManifoldResult *)p3;
	float retVal = (float)o->calculateTimeOfImpact(tp0,tp1,tp2,tp3);
	return retVal;
}
//method: setLowLevelOfDetail void ( ::btConvexConvexAlgorithm::* )( bool ) 
void btConvexConvexAlgorithm_setLowLevelOfDetail(void *c,int p0) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	o->setLowLevelOfDetail(p0);
}
//method: processCollision void ( ::btConvexConvexAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
void btConvexConvexAlgorithm_processCollision(void *c,void* p0,void* p1,void* p2,void* p3) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btDispatcherInfo const & tp2 = *(::btDispatcherInfo const *)p2;
	::btManifoldResult * tp3 = (::btManifoldResult *)p3;
	o->processCollision(tp0,tp1,tp2,tp3);
}
//method: getManifold ::btPersistentManifold const * ( ::btConvexConvexAlgorithm::* )(  ) 
void* btConvexConvexAlgorithm_getManifold(void *c) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	void* retVal = (void*) o->getManifold();
	return retVal;
}
//attribute: ::btVoronoiSimplexSolver * btConvexConvexAlgorithm->m_simplexSolver
void btConvexConvexAlgorithm_m_simplexSolver_set(void *c,void* a) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	::btVoronoiSimplexSolver * ta = (::btVoronoiSimplexSolver *)a;
	o->m_simplexSolver = ta;
}
void* btConvexConvexAlgorithm_m_simplexSolver_get(void *c) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	return (void*)(o->m_simplexSolver);
}

//attribute: ::btConvexPenetrationDepthSolver * btConvexConvexAlgorithm->m_pdSolver
// attribute not supported: //attribute: ::btConvexPenetrationDepthSolver * btConvexConvexAlgorithm->m_pdSolver
//attribute: bool btConvexConvexAlgorithm->m_ownManifold
void btConvexConvexAlgorithm_m_ownManifold_set(void *c,int a) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	o->m_ownManifold = a;
}
int btConvexConvexAlgorithm_m_ownManifold_get(void *c) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	return (int)(o->m_ownManifold);
}

//attribute: ::btPersistentManifold * btConvexConvexAlgorithm->m_manifoldPtr
void btConvexConvexAlgorithm_m_manifoldPtr_set(void *c,void* a) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	::btPersistentManifold * ta = (::btPersistentManifold *)a;
	o->m_manifoldPtr = ta;
}
void* btConvexConvexAlgorithm_m_manifoldPtr_get(void *c) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	return (void*)(o->m_manifoldPtr);
}

//attribute: bool btConvexConvexAlgorithm->m_lowLevelOfDetail
void btConvexConvexAlgorithm_m_lowLevelOfDetail_set(void *c,int a) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	o->m_lowLevelOfDetail = a;
}
int btConvexConvexAlgorithm_m_lowLevelOfDetail_get(void *c) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	return (int)(o->m_lowLevelOfDetail);
}

//attribute: int btConvexConvexAlgorithm->m_numPerturbationIterations
void btConvexConvexAlgorithm_m_numPerturbationIterations_set(void *c,int a) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	o->m_numPerturbationIterations = a;
}
int btConvexConvexAlgorithm_m_numPerturbationIterations_get(void *c) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	return (int)(o->m_numPerturbationIterations);
}

//attribute: int btConvexConvexAlgorithm->m_minimumPointsPerturbationThreshold
void btConvexConvexAlgorithm_m_minimumPointsPerturbationThreshold_set(void *c,int a) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	o->m_minimumPointsPerturbationThreshold = a;
}
int btConvexConvexAlgorithm_m_minimumPointsPerturbationThreshold_get(void *c) {
	::btConvexConvexAlgorithm *o = (::btConvexConvexAlgorithm*)c;
	return (int)(o->m_minimumPointsPerturbationThreshold);
}


// ::btDefaultCollisionConfiguration
//constructor: btDefaultCollisionConfiguration  ( ::btDefaultCollisionConfiguration::* )( ::btDefaultCollisionConstructionInfo const & ) 
void* btDefaultCollisionConfiguration_new(void* p0) {
	::btDefaultCollisionConfiguration *o = 0;
	 void *mem = 0;
	::btDefaultCollisionConstructionInfo const & tp0 = *(::btDefaultCollisionConstructionInfo const *)p0;
	mem = btAlignedAlloc(sizeof(::btDefaultCollisionConfiguration),16);
	o = new (mem)::btDefaultCollisionConfiguration(tp0);
	return (void*)o;
}
void btDefaultCollisionConfiguration_free(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	delete o;
}
//method: getStackAllocator ::btStackAlloc * ( ::btDefaultCollisionConfiguration::* )(  ) 
void* btDefaultCollisionConfiguration_getStackAllocator(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	void* retVal = (void*) o->getStackAllocator();
	return retVal;
}
//not supported method: getPersistentManifoldPool ::btPoolAllocator * ( ::btDefaultCollisionConfiguration::* )(  ) 
// error:  - unsupported

//method: setPlaneConvexMultipointIterations void ( ::btDefaultCollisionConfiguration::* )( int,int ) 
void btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations(void *c,int p0,int p1) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	o->setPlaneConvexMultipointIterations(p0,p1);
}
//method: getSimplexSolver ::btVoronoiSimplexSolver * ( ::btDefaultCollisionConfiguration::* )(  ) 
void* btDefaultCollisionConfiguration_getSimplexSolver(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	void* retVal = (void*) o->getSimplexSolver();
	return retVal;
}
//method: setConvexConvexMultipointIterations void ( ::btDefaultCollisionConfiguration::* )( int,int ) 
void btDefaultCollisionConfiguration_setConvexConvexMultipointIterations(void *c,int p0,int p1) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	o->setConvexConvexMultipointIterations(p0,p1);
}
//not supported method: getCollisionAlgorithmPool ::btPoolAllocator * ( ::btDefaultCollisionConfiguration::* )(  ) 
// error:  - unsupported

//method: getCollisionAlgorithmCreateFunc ::btCollisionAlgorithmCreateFunc * ( ::btDefaultCollisionConfiguration::* )( int,int ) 
void* btDefaultCollisionConfiguration_getCollisionAlgorithmCreateFunc(void *c,int p0,int p1) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	void* retVal = (void*) o->getCollisionAlgorithmCreateFunc(p0,p1);
	return retVal;
}
//attribute: int btDefaultCollisionConfiguration->m_persistentManifoldPoolSize
void btDefaultCollisionConfiguration_m_persistentManifoldPoolSize_set(void *c,int a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	o->m_persistentManifoldPoolSize = a;
}
int btDefaultCollisionConfiguration_m_persistentManifoldPoolSize_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (int)(o->m_persistentManifoldPoolSize);
}

//attribute: ::btStackAlloc * btDefaultCollisionConfiguration->m_stackAlloc
void btDefaultCollisionConfiguration_m_stackAlloc_set(void *c,void* a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	::btStackAlloc * ta = (::btStackAlloc *)a;
	o->m_stackAlloc = ta;
}
void* btDefaultCollisionConfiguration_m_stackAlloc_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (void*)(o->m_stackAlloc);
}

//attribute: bool btDefaultCollisionConfiguration->m_ownsStackAllocator
void btDefaultCollisionConfiguration_m_ownsStackAllocator_set(void *c,int a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	o->m_ownsStackAllocator = a;
}
int btDefaultCollisionConfiguration_m_ownsStackAllocator_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (int)(o->m_ownsStackAllocator);
}

//attribute: ::btPoolAllocator * btDefaultCollisionConfiguration->m_persistentManifoldPool
// attribute not supported: //attribute: ::btPoolAllocator * btDefaultCollisionConfiguration->m_persistentManifoldPool
//attribute: bool btDefaultCollisionConfiguration->m_ownsPersistentManifoldPool
void btDefaultCollisionConfiguration_m_ownsPersistentManifoldPool_set(void *c,int a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	o->m_ownsPersistentManifoldPool = a;
}
int btDefaultCollisionConfiguration_m_ownsPersistentManifoldPool_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (int)(o->m_ownsPersistentManifoldPool);
}

//attribute: ::btPoolAllocator * btDefaultCollisionConfiguration->m_collisionAlgorithmPool
// attribute not supported: //attribute: ::btPoolAllocator * btDefaultCollisionConfiguration->m_collisionAlgorithmPool
//attribute: bool btDefaultCollisionConfiguration->m_ownsCollisionAlgorithmPool
void btDefaultCollisionConfiguration_m_ownsCollisionAlgorithmPool_set(void *c,int a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	o->m_ownsCollisionAlgorithmPool = a;
}
int btDefaultCollisionConfiguration_m_ownsCollisionAlgorithmPool_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (int)(o->m_ownsCollisionAlgorithmPool);
}

//attribute: ::btVoronoiSimplexSolver * btDefaultCollisionConfiguration->m_simplexSolver
void btDefaultCollisionConfiguration_m_simplexSolver_set(void *c,void* a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	::btVoronoiSimplexSolver * ta = (::btVoronoiSimplexSolver *)a;
	o->m_simplexSolver = ta;
}
void* btDefaultCollisionConfiguration_m_simplexSolver_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (void*)(o->m_simplexSolver);
}

//attribute: ::btConvexPenetrationDepthSolver * btDefaultCollisionConfiguration->m_pdSolver
// attribute not supported: //attribute: ::btConvexPenetrationDepthSolver * btDefaultCollisionConfiguration->m_pdSolver
//attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_convexConvexCreateFunc
void btDefaultCollisionConfiguration_m_convexConvexCreateFunc_set(void *c,void* a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_convexConvexCreateFunc = ta;
}
void* btDefaultCollisionConfiguration_m_convexConvexCreateFunc_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (void*)(o->m_convexConvexCreateFunc);
}

//attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_convexConcaveCreateFunc
void btDefaultCollisionConfiguration_m_convexConcaveCreateFunc_set(void *c,void* a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_convexConcaveCreateFunc = ta;
}
void* btDefaultCollisionConfiguration_m_convexConcaveCreateFunc_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (void*)(o->m_convexConcaveCreateFunc);
}

//attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_swappedConvexConcaveCreateFunc
void btDefaultCollisionConfiguration_m_swappedConvexConcaveCreateFunc_set(void *c,void* a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_swappedConvexConcaveCreateFunc = ta;
}
void* btDefaultCollisionConfiguration_m_swappedConvexConcaveCreateFunc_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (void*)(o->m_swappedConvexConcaveCreateFunc);
}

//attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_compoundCreateFunc
void btDefaultCollisionConfiguration_m_compoundCreateFunc_set(void *c,void* a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_compoundCreateFunc = ta;
}
void* btDefaultCollisionConfiguration_m_compoundCreateFunc_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (void*)(o->m_compoundCreateFunc);
}

//attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_swappedCompoundCreateFunc
void btDefaultCollisionConfiguration_m_swappedCompoundCreateFunc_set(void *c,void* a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_swappedCompoundCreateFunc = ta;
}
void* btDefaultCollisionConfiguration_m_swappedCompoundCreateFunc_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (void*)(o->m_swappedCompoundCreateFunc);
}

//attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_emptyCreateFunc
void btDefaultCollisionConfiguration_m_emptyCreateFunc_set(void *c,void* a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_emptyCreateFunc = ta;
}
void* btDefaultCollisionConfiguration_m_emptyCreateFunc_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (void*)(o->m_emptyCreateFunc);
}

//attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_sphereSphereCF
void btDefaultCollisionConfiguration_m_sphereSphereCF_set(void *c,void* a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_sphereSphereCF = ta;
}
void* btDefaultCollisionConfiguration_m_sphereSphereCF_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (void*)(o->m_sphereSphereCF);
}

//attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_boxBoxCF
void btDefaultCollisionConfiguration_m_boxBoxCF_set(void *c,void* a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_boxBoxCF = ta;
}
void* btDefaultCollisionConfiguration_m_boxBoxCF_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (void*)(o->m_boxBoxCF);
}

//attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_sphereTriangleCF
void btDefaultCollisionConfiguration_m_sphereTriangleCF_set(void *c,void* a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_sphereTriangleCF = ta;
}
void* btDefaultCollisionConfiguration_m_sphereTriangleCF_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (void*)(o->m_sphereTriangleCF);
}

//attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_triangleSphereCF
void btDefaultCollisionConfiguration_m_triangleSphereCF_set(void *c,void* a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_triangleSphereCF = ta;
}
void* btDefaultCollisionConfiguration_m_triangleSphereCF_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (void*)(o->m_triangleSphereCF);
}

//attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_planeConvexCF
void btDefaultCollisionConfiguration_m_planeConvexCF_set(void *c,void* a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_planeConvexCF = ta;
}
void* btDefaultCollisionConfiguration_m_planeConvexCF_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (void*)(o->m_planeConvexCF);
}

//attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_convexPlaneCF
void btDefaultCollisionConfiguration_m_convexPlaneCF_set(void *c,void* a) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	::btCollisionAlgorithmCreateFunc * ta = (::btCollisionAlgorithmCreateFunc *)a;
	o->m_convexPlaneCF = ta;
}
void* btDefaultCollisionConfiguration_m_convexPlaneCF_get(void *c) {
	::btDefaultCollisionConfiguration *o = (::btDefaultCollisionConfiguration*)c;
	return (void*)(o->m_convexPlaneCF);
}


// ::btDefaultCollisionConstructionInfo
//constructor: btDefaultCollisionConstructionInfo  ( ::btDefaultCollisionConstructionInfo::* )(  ) 
void* btDefaultCollisionConstructionInfo_new() {
	::btDefaultCollisionConstructionInfo *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btDefaultCollisionConstructionInfo),16);
	o = new (mem)::btDefaultCollisionConstructionInfo();
	return (void*)o;
}
void btDefaultCollisionConstructionInfo_free(void *c) {
	::btDefaultCollisionConstructionInfo *o = (::btDefaultCollisionConstructionInfo*)c;
	delete o;
}
//attribute: ::btPoolAllocator * btDefaultCollisionConstructionInfo->m_collisionAlgorithmPool
// attribute not supported: //attribute: ::btPoolAllocator * btDefaultCollisionConstructionInfo->m_collisionAlgorithmPool
//attribute: int btDefaultCollisionConstructionInfo->m_customCollisionAlgorithmMaxElementSize
void btDefaultCollisionConstructionInfo_m_customCollisionAlgorithmMaxElementSize_set(void *c,int a) {
	::btDefaultCollisionConstructionInfo *o = (::btDefaultCollisionConstructionInfo*)c;
	o->m_customCollisionAlgorithmMaxElementSize = a;
}
int btDefaultCollisionConstructionInfo_m_customCollisionAlgorithmMaxElementSize_get(void *c) {
	::btDefaultCollisionConstructionInfo *o = (::btDefaultCollisionConstructionInfo*)c;
	return (int)(o->m_customCollisionAlgorithmMaxElementSize);
}

//attribute: int btDefaultCollisionConstructionInfo->m_defaultMaxCollisionAlgorithmPoolSize
void btDefaultCollisionConstructionInfo_m_defaultMaxCollisionAlgorithmPoolSize_set(void *c,int a) {
	::btDefaultCollisionConstructionInfo *o = (::btDefaultCollisionConstructionInfo*)c;
	o->m_defaultMaxCollisionAlgorithmPoolSize = a;
}
int btDefaultCollisionConstructionInfo_m_defaultMaxCollisionAlgorithmPoolSize_get(void *c) {
	::btDefaultCollisionConstructionInfo *o = (::btDefaultCollisionConstructionInfo*)c;
	return (int)(o->m_defaultMaxCollisionAlgorithmPoolSize);
}

//attribute: int btDefaultCollisionConstructionInfo->m_defaultMaxPersistentManifoldPoolSize
void btDefaultCollisionConstructionInfo_m_defaultMaxPersistentManifoldPoolSize_set(void *c,int a) {
	::btDefaultCollisionConstructionInfo *o = (::btDefaultCollisionConstructionInfo*)c;
	o->m_defaultMaxPersistentManifoldPoolSize = a;
}
int btDefaultCollisionConstructionInfo_m_defaultMaxPersistentManifoldPoolSize_get(void *c) {
	::btDefaultCollisionConstructionInfo *o = (::btDefaultCollisionConstructionInfo*)c;
	return (int)(o->m_defaultMaxPersistentManifoldPoolSize);
}

//attribute: int btDefaultCollisionConstructionInfo->m_defaultStackAllocatorSize
void btDefaultCollisionConstructionInfo_m_defaultStackAllocatorSize_set(void *c,int a) {
	::btDefaultCollisionConstructionInfo *o = (::btDefaultCollisionConstructionInfo*)c;
	o->m_defaultStackAllocatorSize = a;
}
int btDefaultCollisionConstructionInfo_m_defaultStackAllocatorSize_get(void *c) {
	::btDefaultCollisionConstructionInfo *o = (::btDefaultCollisionConstructionInfo*)c;
	return (int)(o->m_defaultStackAllocatorSize);
}

//attribute: ::btPoolAllocator * btDefaultCollisionConstructionInfo->m_persistentManifoldPool
// attribute not supported: //attribute: ::btPoolAllocator * btDefaultCollisionConstructionInfo->m_persistentManifoldPool
//attribute: ::btStackAlloc * btDefaultCollisionConstructionInfo->m_stackAlloc
void btDefaultCollisionConstructionInfo_m_stackAlloc_set(void *c,void* a) {
	::btDefaultCollisionConstructionInfo *o = (::btDefaultCollisionConstructionInfo*)c;
	::btStackAlloc * ta = (::btStackAlloc *)a;
	o->m_stackAlloc = ta;
}
void* btDefaultCollisionConstructionInfo_m_stackAlloc_get(void *c) {
	::btDefaultCollisionConstructionInfo *o = (::btDefaultCollisionConstructionInfo*)c;
	return (void*)(o->m_stackAlloc);
}

//attribute: int btDefaultCollisionConstructionInfo->m_useEpaPenetrationAlgorithm
void btDefaultCollisionConstructionInfo_m_useEpaPenetrationAlgorithm_set(void *c,int a) {
	::btDefaultCollisionConstructionInfo *o = (::btDefaultCollisionConstructionInfo*)c;
	o->m_useEpaPenetrationAlgorithm = a;
}
int btDefaultCollisionConstructionInfo_m_useEpaPenetrationAlgorithm_get(void *c) {
	::btDefaultCollisionConstructionInfo *o = (::btDefaultCollisionConstructionInfo*)c;
	return (int)(o->m_useEpaPenetrationAlgorithm);
}


// ::btGhostObject
//constructor: btGhostObject  ( ::btGhostObject::* )(  ) 
void* btGhostObject_new() {
	::btGhostObject *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGhostObject),16);
	o = new (mem)::btGhostObject();
	return (void*)o;
}
void btGhostObject_free(void *c) {
	::btGhostObject *o = (::btGhostObject*)c;
	delete o;
}
//method: convexSweepTest void ( ::btGhostObject::* )( ::btConvexShape const *,::btTransform const &,::btTransform const &,::btCollisionWorld::ConvexResultCallback &,::btScalar ) const
void btGhostObject_convexSweepTest(void *c,void* p0,float* p1,float* p2,void* p3,float p4) {
	::btGhostObject *o = (::btGhostObject*)c;
	::btConvexShape const * tp0 = (::btConvexShape const *)p0;
	btMatrix3x3 mtp1(p1[0],p1[1],p1[2],p1[3],p1[4],p1[5],p1[6],p1[7],p1[8]);
	btVector3 vtp1(p1[9],p1[10],p1[11]);
	btTransform tp1(mtp1,vtp1);
	btMatrix3x3 mtp2(p2[0],p2[1],p2[2],p2[3],p2[4],p2[5],p2[6],p2[7],p2[8]);
	btVector3 vtp2(p2[9],p2[10],p2[11]);
	btTransform tp2(mtp2,vtp2);
	::btCollisionWorld::ConvexResultCallback & tp3 = *(::btCollisionWorld::ConvexResultCallback *)p3;
	o->convexSweepTest(tp0,tp1,tp2,tp3,p4);
	p1[0]=tp1.getBasis().getRow(0).m_floats[0];p1[1]=tp1.getBasis().getRow(0).m_floats[1];p1[2]=tp1.getBasis().getRow(0).m_floats[2];p1[3]=tp1.getBasis().getRow(1).m_floats[0];p1[4]=tp1.getBasis().getRow(1).m_floats[1];p1[5]=tp1.getBasis().getRow(1).m_floats[2];p1[6]=tp1.getBasis().getRow(2).m_floats[0];p1[7]=tp1.getBasis().getRow(2).m_floats[1];p1[8]=tp1.getBasis().getRow(2).m_floats[2];
	p1[9]=tp1.getOrigin().m_floats[0];p1[10]=tp1.getOrigin().m_floats[1];p1[11]=tp1.getOrigin().m_floats[2];
	p2[0]=tp2.getBasis().getRow(0).m_floats[0];p2[1]=tp2.getBasis().getRow(0).m_floats[1];p2[2]=tp2.getBasis().getRow(0).m_floats[2];p2[3]=tp2.getBasis().getRow(1).m_floats[0];p2[4]=tp2.getBasis().getRow(1).m_floats[1];p2[5]=tp2.getBasis().getRow(1).m_floats[2];p2[6]=tp2.getBasis().getRow(2).m_floats[0];p2[7]=tp2.getBasis().getRow(2).m_floats[1];p2[8]=tp2.getBasis().getRow(2).m_floats[2];
	p2[9]=tp2.getOrigin().m_floats[0];p2[10]=tp2.getOrigin().m_floats[1];p2[11]=tp2.getOrigin().m_floats[2];
}
//method: removeOverlappingObjectInternal void ( ::btGhostObject::* )( ::btBroadphaseProxy *,::btDispatcher *,::btBroadphaseProxy * ) 
void btGhostObject_removeOverlappingObjectInternal(void *c,void* p0,void* p1,void* p2) {
	::btGhostObject *o = (::btGhostObject*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	::btBroadphaseProxy * tp2 = (::btBroadphaseProxy *)p2;
	o->removeOverlappingObjectInternal(tp0,tp1,tp2);
}
//method: getNumOverlappingObjects int ( ::btGhostObject::* )(  ) const
int btGhostObject_getNumOverlappingObjects(void *c) {
	::btGhostObject *o = (::btGhostObject*)c;
	int retVal = (int)o->getNumOverlappingObjects();
	return retVal;
}
//method: addOverlappingObjectInternal void ( ::btGhostObject::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void btGhostObject_addOverlappingObjectInternal(void *c,void* p0,void* p1) {
	::btGhostObject *o = (::btGhostObject*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	o->addOverlappingObjectInternal(tp0,tp1);
}
//method: rayTest void ( ::btGhostObject::* )( ::btVector3 const &,::btVector3 const &,::btCollisionWorld::RayResultCallback & ) const
void btGhostObject_rayTest(void *c,float* p0,float* p1,void* p2) {
	::btGhostObject *o = (::btGhostObject*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	::btCollisionWorld::RayResultCallback & tp2 = *(::btCollisionWorld::RayResultCallback *)p2;
	o->rayTest(tp0,tp1,tp2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getOverlappingPairs ::btAlignedObjectArray<btCollisionObject*> & ( ::btGhostObject::* )(  ) 
void* btGhostObject_getOverlappingPairs(void *c) {
	::btGhostObject *o = (::btGhostObject*)c;
	void* retVal = (void*) &(o->getOverlappingPairs());
	return retVal;
}
//method: getOverlappingPairs ::btAlignedObjectArray<btCollisionObject*> & ( ::btGhostObject::* )(  ) 
void* btGhostObject_getOverlappingPairs0(void *c) {
	::btGhostObject *o = (::btGhostObject*)c;
	void* retVal = (void*) &(o->getOverlappingPairs());
	return retVal;
}
//not supported method: getOverlappingPairs ::btAlignedObjectArray<btCollisionObject*> const ( ::btGhostObject::* )(  ) const
// error:  - unsupported

//method: upcast ::btGhostObject const * (*)( ::btCollisionObject const * )
void* btGhostObject_upcast(void* p0) {
	::btCollisionObject const * tp0 = (::btCollisionObject const *)p0;
	void* retVal = (void*) ::btGhostObject::upcast(tp0);
	return retVal;
}
//method: upcast ::btGhostObject const * (*)( ::btCollisionObject const * )
void* btGhostObject_upcast0(void* p0) {
	::btCollisionObject const * tp0 = (::btCollisionObject const *)p0;
	void* retVal = (void*) ::btGhostObject::upcast(tp0);
	return retVal;
}
//method: upcast ::btGhostObject * (*)( ::btCollisionObject * )
void* btGhostObject_upcast1(void* p0) {
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	void* retVal = (void*) ::btGhostObject::upcast(tp0);
	return retVal;
}
//method: getOverlappingObject ::btCollisionObject * ( ::btGhostObject::* )( int ) 
void* btGhostObject_getOverlappingObject(void *c,int p0) {
	::btGhostObject *o = (::btGhostObject*)c;
	void* retVal = (void*) o->getOverlappingObject(p0);
	return retVal;
}
//method: getOverlappingObject ::btCollisionObject * ( ::btGhostObject::* )( int ) 
void* btGhostObject_getOverlappingObject0(void *c,int p0) {
	::btGhostObject *o = (::btGhostObject*)c;
	void* retVal = (void*) o->getOverlappingObject(p0);
	return retVal;
}
//method: getOverlappingObject ::btCollisionObject const * ( ::btGhostObject::* )( int ) const
void* btGhostObject_getOverlappingObject1(void *c,int p0) {
	::btGhostObject *o = (::btGhostObject*)c;
	void* retVal = (void*) o->getOverlappingObject(p0);
	return retVal;
}
//attribute: ::btAlignedObjectArray<btCollisionObject*> btGhostObject->m_overlappingObjects
void btGhostObject_m_overlappingObjects_set(void *c,void* a) {
	::btGhostObject *o = (::btGhostObject*)c;
	::btAlignedObjectArray<btCollisionObject*> & ta = *(::btAlignedObjectArray<btCollisionObject*> *)a;
	o->m_overlappingObjects = ta;
}
void* btGhostObject_m_overlappingObjects_get(void *c) {
	::btGhostObject *o = (::btGhostObject*)c;
	return (void*)&(o->m_overlappingObjects);
}


// ::btGhostPairCallback
//constructor: btGhostPairCallback  ( ::btGhostPairCallback::* )(  ) 
void* btGhostPairCallback_new() {
	::btGhostPairCallback *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btGhostPairCallback),16);
	o = new (mem)::btGhostPairCallback();
	return (void*)o;
}
void btGhostPairCallback_free(void *c) {
	::btGhostPairCallback *o = (::btGhostPairCallback*)c;
	delete o;
}
//method: addOverlappingPair ::btBroadphasePair * ( ::btGhostPairCallback::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void* btGhostPairCallback_addOverlappingPair(void *c,void* p0,void* p1) {
	::btGhostPairCallback *o = (::btGhostPairCallback*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	void* retVal = (void*) o->addOverlappingPair(tp0,tp1);
	return retVal;
}
//method: removeOverlappingPair void * ( ::btGhostPairCallback::* )( ::btBroadphaseProxy *,::btBroadphaseProxy *,::btDispatcher * ) 
void* btGhostPairCallback_removeOverlappingPair(void *c,void* p0,void* p1,void* p2) {
	::btGhostPairCallback *o = (::btGhostPairCallback*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	::btDispatcher * tp2 = (::btDispatcher *)p2;
	void* retVal = (void*) o->removeOverlappingPair(tp0,tp1,tp2);
	return retVal;
}
//method: removeOverlappingPairsContainingProxy void ( ::btGhostPairCallback::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btGhostPairCallback_removeOverlappingPairsContainingProxy(void *c,void* p0,void* p1) {
	::btGhostPairCallback *o = (::btGhostPairCallback*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	o->removeOverlappingPairsContainingProxy(tp0,tp1);
}

// ::btManifoldResult
//constructor: btManifoldResult  ( ::btManifoldResult::* )(  ) 
void* btManifoldResult_new0() {
	::btManifoldResult *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btManifoldResult),16);
	o = new (mem)::btManifoldResult();
	return (void*)o;
}
//constructor: btManifoldResult  ( ::btManifoldResult::* )( ::btCollisionObject *,::btCollisionObject * ) 
void* btManifoldResult_new1(void* p0,void* p1) {
	::btManifoldResult *o = 0;
	 void *mem = 0;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	mem = btAlignedAlloc(sizeof(::btManifoldResult),16);
	o = new (mem)::btManifoldResult(tp0,tp1);
	return (void*)o;
}
void btManifoldResult_free(void *c) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	delete o;
}
//method: getPersistentManifold ::btPersistentManifold const * ( ::btManifoldResult::* )(  ) const
void* btManifoldResult_getPersistentManifold(void *c) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	void* retVal = (void*) o->getPersistentManifold();
	return retVal;
}
//method: getPersistentManifold ::btPersistentManifold const * ( ::btManifoldResult::* )(  ) const
void* btManifoldResult_getPersistentManifold0(void *c) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	void* retVal = (void*) o->getPersistentManifold();
	return retVal;
}
//method: getPersistentManifold ::btPersistentManifold * ( ::btManifoldResult::* )(  ) 
void* btManifoldResult_getPersistentManifold1(void *c) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	void* retVal = (void*) o->getPersistentManifold();
	return retVal;
}
//method: getBody0Internal ::btCollisionObject const * ( ::btManifoldResult::* )(  ) const
void* btManifoldResult_getBody0Internal(void *c) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	void* retVal = (void*) o->getBody0Internal();
	return retVal;
}
//method: addContactPoint void ( ::btManifoldResult::* )( ::btVector3 const &,::btVector3 const &,::btScalar ) 
void btManifoldResult_addContactPoint(void *c,float* p0,float* p1,float p2) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	btVector3 tp0(p0[0],p0[1],p0[2]);
	btVector3 tp1(p1[0],p1[1],p1[2]);
	o->addContactPoint(tp0,tp1,p2);
	p0[0]=tp0.m_floats[0];p0[1]=tp0.m_floats[1];p0[2]=tp0.m_floats[2];
	p1[0]=tp1.m_floats[0];p1[1]=tp1.m_floats[1];p1[2]=tp1.m_floats[2];
}
//method: getBody1Internal ::btCollisionObject const * ( ::btManifoldResult::* )(  ) const
void* btManifoldResult_getBody1Internal(void *c) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	void* retVal = (void*) o->getBody1Internal();
	return retVal;
}
//method: setShapeIdentifiersB void ( ::btManifoldResult::* )( int,int ) 
void btManifoldResult_setShapeIdentifiersB(void *c,int p0,int p1) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	o->setShapeIdentifiersB(p0,p1);
}
//method: setShapeIdentifiersA void ( ::btManifoldResult::* )( int,int ) 
void btManifoldResult_setShapeIdentifiersA(void *c,int p0,int p1) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	o->setShapeIdentifiersA(p0,p1);
}
//method: refreshContactPoints void ( ::btManifoldResult::* )(  ) 
void btManifoldResult_refreshContactPoints(void *c) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	o->refreshContactPoints();
}
//method: setPersistentManifold void ( ::btManifoldResult::* )( ::btPersistentManifold * ) 
void btManifoldResult_setPersistentManifold(void *c,void* p0) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	::btPersistentManifold * tp0 = (::btPersistentManifold *)p0;
	o->setPersistentManifold(tp0);
}
//attribute: ::btCollisionObject * btManifoldResult->m_body0
void btManifoldResult_m_body0_set(void *c,void* a) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	::btCollisionObject * ta = (::btCollisionObject *)a;
	o->m_body0 = ta;
}
void* btManifoldResult_m_body0_get(void *c) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	return (void*)(o->m_body0);
}

//attribute: ::btCollisionObject * btManifoldResult->m_body1
void btManifoldResult_m_body1_set(void *c,void* a) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	::btCollisionObject * ta = (::btCollisionObject *)a;
	o->m_body1 = ta;
}
void* btManifoldResult_m_body1_get(void *c) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	return (void*)(o->m_body1);
}

//attribute: int btManifoldResult->m_index0
void btManifoldResult_m_index0_set(void *c,int a) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	o->m_index0 = a;
}
int btManifoldResult_m_index0_get(void *c) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	return (int)(o->m_index0);
}

//attribute: int btManifoldResult->m_index1
void btManifoldResult_m_index1_set(void *c,int a) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	o->m_index1 = a;
}
int btManifoldResult_m_index1_get(void *c) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	return (int)(o->m_index1);
}

//attribute: ::btPersistentManifold * btManifoldResult->m_manifoldPtr
void btManifoldResult_m_manifoldPtr_set(void *c,void* a) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	::btPersistentManifold * ta = (::btPersistentManifold *)a;
	o->m_manifoldPtr = ta;
}
void* btManifoldResult_m_manifoldPtr_get(void *c) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	return (void*)(o->m_manifoldPtr);
}

//attribute: int btManifoldResult->m_partId0
void btManifoldResult_m_partId0_set(void *c,int a) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	o->m_partId0 = a;
}
int btManifoldResult_m_partId0_get(void *c) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	return (int)(o->m_partId0);
}

//attribute: int btManifoldResult->m_partId1
void btManifoldResult_m_partId1_set(void *c,int a) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	o->m_partId1 = a;
}
int btManifoldResult_m_partId1_get(void *c) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	return (int)(o->m_partId1);
}

//attribute: ::btTransform btManifoldResult->m_rootTransA
void btManifoldResult_m_rootTransA_set(void *c,float* a) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_rootTransA = ta;
}
void btManifoldResult_m_rootTransA_get(void *c,float* a) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	a[0]=(o->m_rootTransA).getBasis().getRow(0).m_floats[0];a[1]=(o->m_rootTransA).getBasis().getRow(0).m_floats[1];a[2]=(o->m_rootTransA).getBasis().getRow(0).m_floats[2];a[3]=(o->m_rootTransA).getBasis().getRow(1).m_floats[0];a[4]=(o->m_rootTransA).getBasis().getRow(1).m_floats[1];a[5]=(o->m_rootTransA).getBasis().getRow(1).m_floats[2];a[6]=(o->m_rootTransA).getBasis().getRow(2).m_floats[0];a[7]=(o->m_rootTransA).getBasis().getRow(2).m_floats[1];a[8]=(o->m_rootTransA).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_rootTransA).getOrigin().m_floats[0];a[10]=(o->m_rootTransA).getOrigin().m_floats[1];a[11]=(o->m_rootTransA).getOrigin().m_floats[2];
}

//attribute: ::btTransform btManifoldResult->m_rootTransB
void btManifoldResult_m_rootTransB_set(void *c,float* a) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	btMatrix3x3 mta(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
	btVector3 vta(a[9],a[10],a[11]);
	btTransform ta(mta,vta);
	o->m_rootTransB = ta;
}
void btManifoldResult_m_rootTransB_get(void *c,float* a) {
	::btManifoldResult *o = (::btManifoldResult*)c;
	a[0]=(o->m_rootTransB).getBasis().getRow(0).m_floats[0];a[1]=(o->m_rootTransB).getBasis().getRow(0).m_floats[1];a[2]=(o->m_rootTransB).getBasis().getRow(0).m_floats[2];a[3]=(o->m_rootTransB).getBasis().getRow(1).m_floats[0];a[4]=(o->m_rootTransB).getBasis().getRow(1).m_floats[1];a[5]=(o->m_rootTransB).getBasis().getRow(1).m_floats[2];a[6]=(o->m_rootTransB).getBasis().getRow(2).m_floats[0];a[7]=(o->m_rootTransB).getBasis().getRow(2).m_floats[1];a[8]=(o->m_rootTransB).getBasis().getRow(2).m_floats[2];
	a[9]=(o->m_rootTransB).getOrigin().m_floats[0];a[10]=(o->m_rootTransB).getOrigin().m_floats[1];a[11]=(o->m_rootTransB).getOrigin().m_floats[2];
}


// ::btPairCachingGhostObject
//constructor: btPairCachingGhostObject  ( ::btPairCachingGhostObject::* )(  ) 
void* btPairCachingGhostObject_new() {
	::btPairCachingGhostObject *o = 0;
	 void *mem = 0;
	mem = btAlignedAlloc(sizeof(::btPairCachingGhostObject),16);
	o = new (mem)::btPairCachingGhostObject();
	return (void*)o;
}
void btPairCachingGhostObject_free(void *c) {
	::btPairCachingGhostObject *o = (::btPairCachingGhostObject*)c;
	delete o;
}
//method: removeOverlappingObjectInternal void ( ::btPairCachingGhostObject::* )( ::btBroadphaseProxy *,::btDispatcher *,::btBroadphaseProxy * ) 
void btPairCachingGhostObject_removeOverlappingObjectInternal(void *c,void* p0,void* p1,void* p2) {
	::btPairCachingGhostObject *o = (::btPairCachingGhostObject*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btDispatcher * tp1 = (::btDispatcher *)p1;
	::btBroadphaseProxy * tp2 = (::btBroadphaseProxy *)p2;
	o->removeOverlappingObjectInternal(tp0,tp1,tp2);
}
//method: getOverlappingPairCache ::btHashedOverlappingPairCache * ( ::btPairCachingGhostObject::* )(  ) 
void* btPairCachingGhostObject_getOverlappingPairCache(void *c) {
	::btPairCachingGhostObject *o = (::btPairCachingGhostObject*)c;
	void* retVal = (void*) o->getOverlappingPairCache();
	return retVal;
}
//method: addOverlappingObjectInternal void ( ::btPairCachingGhostObject::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void btPairCachingGhostObject_addOverlappingObjectInternal(void *c,void* p0,void* p1) {
	::btPairCachingGhostObject *o = (::btPairCachingGhostObject*)c;
	::btBroadphaseProxy * tp0 = (::btBroadphaseProxy *)p0;
	::btBroadphaseProxy * tp1 = (::btBroadphaseProxy *)p1;
	o->addOverlappingObjectInternal(tp0,tp1);
}
//attribute: ::btHashedOverlappingPairCache * btPairCachingGhostObject->m_hashPairCache
void btPairCachingGhostObject_m_hashPairCache_set(void *c,void* a) {
	::btPairCachingGhostObject *o = (::btPairCachingGhostObject*)c;
	::btHashedOverlappingPairCache * ta = (::btHashedOverlappingPairCache *)a;
	o->m_hashPairCache = ta;
}
void* btPairCachingGhostObject_m_hashPairCache_get(void *c) {
	::btPairCachingGhostObject *o = (::btPairCachingGhostObject*)c;
	return (void*)(o->m_hashPairCache);
}


// ::btSphereSphereCollisionAlgorithm
//constructor: btSphereSphereCollisionAlgorithm  ( ::btSphereSphereCollisionAlgorithm::* )( ::btPersistentManifold *,::btCollisionAlgorithmConstructionInfo const &,::btCollisionObject *,::btCollisionObject * ) 
void* btSphereSphereCollisionAlgorithm_new0(void* p0,void* p1,void* p2,void* p3) {
	::btSphereSphereCollisionAlgorithm *o = 0;
	 void *mem = 0;
	::btPersistentManifold * tp0 = (::btPersistentManifold *)p0;
	::btCollisionAlgorithmConstructionInfo const & tp1 = *(::btCollisionAlgorithmConstructionInfo const *)p1;
	::btCollisionObject * tp2 = (::btCollisionObject *)p2;
	::btCollisionObject * tp3 = (::btCollisionObject *)p3;
	mem = btAlignedAlloc(sizeof(::btSphereSphereCollisionAlgorithm),16);
	o = new (mem)::btSphereSphereCollisionAlgorithm(tp0,tp1,tp2,tp3);
	return (void*)o;
}
//constructor: btSphereSphereCollisionAlgorithm  ( ::btSphereSphereCollisionAlgorithm::* )( ::btCollisionAlgorithmConstructionInfo const & ) 
void* btSphereSphereCollisionAlgorithm_new1(void* p0) {
	::btSphereSphereCollisionAlgorithm *o = 0;
	 void *mem = 0;
	::btCollisionAlgorithmConstructionInfo const & tp0 = *(::btCollisionAlgorithmConstructionInfo const *)p0;
	mem = btAlignedAlloc(sizeof(::btSphereSphereCollisionAlgorithm),16);
	o = new (mem)::btSphereSphereCollisionAlgorithm(tp0);
	return (void*)o;
}
void btSphereSphereCollisionAlgorithm_free(void *c) {
	::btSphereSphereCollisionAlgorithm *o = (::btSphereSphereCollisionAlgorithm*)c;
	delete o;
}
//method: getAllContactManifolds void ( ::btSphereSphereCollisionAlgorithm::* )( ::btManifoldArray & ) 
void btSphereSphereCollisionAlgorithm_getAllContactManifolds(void *c,void* p0) {
	::btSphereSphereCollisionAlgorithm *o = (::btSphereSphereCollisionAlgorithm*)c;
	::btManifoldArray & tp0 = *(::btAlignedObjectArray<btPersistentManifold*> *)p0;
	o->getAllContactManifolds(tp0);
}
//method: calculateTimeOfImpact ::btScalar ( ::btSphereSphereCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
float btSphereSphereCollisionAlgorithm_calculateTimeOfImpact(void *c,void* p0,void* p1,void* p2,void* p3) {
	::btSphereSphereCollisionAlgorithm *o = (::btSphereSphereCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btDispatcherInfo const & tp2 = *(::btDispatcherInfo const *)p2;
	::btManifoldResult * tp3 = (::btManifoldResult *)p3;
	float retVal = (float)o->calculateTimeOfImpact(tp0,tp1,tp2,tp3);
	return retVal;
}
//method: processCollision void ( ::btSphereSphereCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
void btSphereSphereCollisionAlgorithm_processCollision(void *c,void* p0,void* p1,void* p2,void* p3) {
	::btSphereSphereCollisionAlgorithm *o = (::btSphereSphereCollisionAlgorithm*)c;
	::btCollisionObject * tp0 = (::btCollisionObject *)p0;
	::btCollisionObject * tp1 = (::btCollisionObject *)p1;
	::btDispatcherInfo const & tp2 = *(::btDispatcherInfo const *)p2;
	::btManifoldResult * tp3 = (::btManifoldResult *)p3;
	o->processCollision(tp0,tp1,tp2,tp3);
}
//attribute: bool btSphereSphereCollisionAlgorithm->m_ownManifold
void btSphereSphereCollisionAlgorithm_m_ownManifold_set(void *c,int a) {
	::btSphereSphereCollisionAlgorithm *o = (::btSphereSphereCollisionAlgorithm*)c;
	o->m_ownManifold = a;
}
int btSphereSphereCollisionAlgorithm_m_ownManifold_get(void *c) {
	::btSphereSphereCollisionAlgorithm *o = (::btSphereSphereCollisionAlgorithm*)c;
	return (int)(o->m_ownManifold);
}

//attribute: ::btPersistentManifold * btSphereSphereCollisionAlgorithm->m_manifoldPtr
void btSphereSphereCollisionAlgorithm_m_manifoldPtr_set(void *c,void* a) {
	::btSphereSphereCollisionAlgorithm *o = (::btSphereSphereCollisionAlgorithm*)c;
	::btPersistentManifold * ta = (::btPersistentManifold *)a;
	o->m_manifoldPtr = ta;
}
void* btSphereSphereCollisionAlgorithm_m_manifoldPtr_get(void *c) {
	::btSphereSphereCollisionAlgorithm *o = (::btSphereSphereCollisionAlgorithm*)c;
	return (void*)(o->m_manifoldPtr);
}


