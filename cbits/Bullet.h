#ifdef __cplusplus
extern "C" { 
#endif
typedef void* O_btSoftBody_AJoint;
typedef void* O_btCollisionWorld_AllHitsRayResultCallback;
typedef void* O_btSoftBody_Anchor;
typedef void* O_bT_BOX_BOX_TRANSFORM_CACHE;
typedef void* O_bT_QUANTIZED_BVH_NODE;
typedef void* O_btSoftBody_Body;
typedef void* O_btSoftBody_CJoint;
typedef void* O_cProfileIterator;
typedef void* O_cProfileManager;
typedef void* O_cProfileNode;
typedef void* O_cProfileSample;
typedef void* O_btCollisionWorld_ClosestConvexResultCallback;
typedef void* O_btDiscreteCollisionDetectorInterface_ClosestPointInput;
typedef void* O_btCollisionWorld_ClosestRayResultCallback;
typedef void* O_btSoftBody_Cluster;
typedef void* O_btGImpactCompoundShape_CompoundPrimitiveManager;
typedef void* O_btSoftBody_Config;
typedef void* O_btCollisionWorld_ContactResultCallback;
typedef void* O_btCollisionWorld_ConvexResultCallback;
typedef void* O_btGImpactCollisionAlgorithm_CreateFunc;
typedef void* O_btSphereSphereCollisionAlgorithm_CreateFunc;
typedef void* O_btConvexConvexAlgorithm_CreateFunc;
typedef void* O_btSoftBody_Element;
typedef void* O_btSoftBody_Face;
typedef void* O_btSoftBody_Feature;
typedef void* O_gIM_BVH_DATA;
typedef void* O_gIM_BVH_DATA_ARRAY;
typedef void* O_gIM_BVH_TREE_NODE;
typedef void* O_gIM_BVH_TREE_NODE_ARRAY;
typedef void* O_gIM_PAIR;
typedef void* O_gIM_QUANTIZED_BVH_NODE_ARRAY;
typedef void* O_gIM_TRIANGLE_CONTACT;
typedef void* O_btDbvt_IClone;
typedef void* O_btDbvt_ICollide;
typedef void* O_btSoftBody_AJoint_IControl;
typedef void* O_btDbvt_IWriter;
typedef void* O_btSoftBody_ImplicitFn;
typedef void* O_btSoftBody_Impulse;
typedef void* O_btSoftBody_Joint;
typedef void* O_btSoftBody_LJoint;
typedef void* O_btSoftBody_Link;
typedef void* O_btCollisionWorld_LocalConvexResult;
typedef void* O_btCollisionWorld_LocalRayResult;
typedef void* O_btCollisionWorld_LocalShapeInfo;
typedef void* O_btSoftBody_Material;
typedef void* O_btSoftBody_Node;
typedef void* O_btSoftBody_Note;
typedef void* O_btSoftBody_Pose;
typedef void* O_btSoftBody_RContact;
typedef void* O_btSoftBody_RayFromToCaster;
typedef void* O_btCollisionWorld_RayResultCallback;
typedef void* O_btWheelInfo_RaycastInfo;
typedef void* O_btDiscreteCollisionDetectorInterface_Result;
typedef void* O_btSoftBody_SContact;
typedef void* O_btSoftBody_SolverState;
typedef void* O_btSoftBody_Joint_Specs;
typedef void* O_btSoftBody_LJoint_Specs;
typedef void* O_btSoftBody_AJoint_Specs;
typedef void* O_btSoftBody_Tetra;
typedef void* O_btGImpactMeshShapePart_TrimeshPrimitiveManager;
typedef void* O_bt32BitAxisSweep3;
typedef void* O_btAABB;
typedef void* O_btActionInterface;
typedef void* O_btActivatingCollisionAlgorithm;
typedef void* O_btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u_;
typedef void* O_btAlignedAllocator_GIM_BVH_DATA_16u_;
typedef void* O_btAlignedAllocator_GIM_BVH_TREE_NODE_16u_;
typedef void* O_btAlignedAllocator_GIM_PAIR_16u_;
typedef void* O_btAlignedAllocator_bool_16u_;
typedef void* O_btAlignedAllocator_btActionInterface_ptr_16u_;
typedef void* O_btAlignedAllocator_btBroadphaseInterface_ptr_16u_;
typedef void* O_btAlignedAllocator_btBroadphasePair_16u_;
typedef void* O_btAlignedAllocator_btBvhSubtreeInfo_16u_;
typedef void* O_btAlignedAllocator_btChunk_ptr_16u_;
typedef void* O_btAlignedAllocator_btCollisionObject_ptr_16u_;
typedef void* O_btAlignedAllocator_btCollisionShape_ptr_16u_;
typedef void* O_btAlignedAllocator_btCompoundShapeChild_16u_;
typedef void* O_btAlignedAllocator_btDbvt_sStkNN_16u_;
typedef void* O_btAlignedAllocator_btDbvt_sStkNP_16u_;
typedef void* O_btAlignedAllocator_btDbvt_sStkNPS_16u_;
typedef void* O_btAlignedAllocator_btDbvtNodeconst_ptr_16u_;
typedef void* O_btAlignedAllocator_btGImpactMeshShapePart_ptr_16u_;
typedef void* O_btAlignedAllocator_btHashInt_16u_;
typedef void* O_btAlignedAllocator_btHashPtr_16u_;
typedef void* O_btAlignedAllocator_btHashString_16u_;
typedef void* O_btAlignedAllocator_btIndexedMesh_16u_;
typedef void* O_btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_ptr_16u_;
typedef void* O_btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_ptr_16u_;
typedef void* O_btAlignedAllocator_btOptimizedBvhNode_16u_;
typedef void* O_btAlignedAllocator_btPersistentManifold_ptr_16u_;
typedef void* O_btAlignedAllocator_btPointerUid_16u_;
typedef void* O_btAlignedAllocator_btQuantizedBvhNode_16u_;
typedef void* O_btAlignedAllocator_btRigidBody_ptr_16u_;
typedef void* O_btAlignedAllocator_btSoftBody_ptr_16u_;
typedef void* O_btAlignedAllocator_btSoftBody_Anchor_16u_;
typedef void* O_btAlignedAllocator_btSoftBody_Cluster_ptr_16u_;
typedef void* O_btAlignedAllocator_btSoftBody_Face_16u_;
typedef void* O_btAlignedAllocator_btSoftBody_Joint_ptr_16u_;
typedef void* O_btAlignedAllocator_btSoftBody_Link_16u_;
typedef void* O_btAlignedAllocator_btSoftBody_Material_ptr_16u_;
typedef void* O_btAlignedAllocator_btSoftBody_Node_ptr_16u_;
typedef void* O_btAlignedAllocator_btSoftBody_Node_16u_;
typedef void* O_btAlignedAllocator_btSoftBody_Note_16u_;
typedef void* O_btAlignedAllocator_btSoftBody_RContact_16u_;
typedef void* O_btAlignedAllocator_btSoftBody_SContact_16u_;
typedef void* O_btAlignedAllocator_btSoftBody_Tetra_16u_;
typedef void* O_btAlignedAllocator_btSoftBody_ePSolver___16u_;
typedef void* O_btAlignedAllocator_btSoftBody_eVSolver___16u_;
typedef void* O_btAlignedAllocator_btSolverConstraint_16u_;
typedef void* O_btAlignedAllocator_btSparseSdf_3__Cell_ptr_16u_;
typedef void* O_btAlignedAllocator_btTransform_16u_;
typedef void* O_btAlignedAllocator_btTriangleInfo_16u_;
typedef void* O_btAlignedAllocator_btTypedConstraint_ptr_16u_;
typedef void* O_btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u_;
typedef void* O_btAlignedAllocator_btVector3_16u_;
typedef void* O_btAlignedAllocator_btWheelInfo_16u_;
typedef void* O_btAlignedAllocator_charconst_ptr_16u_;
typedef void* O_btAlignedAllocator_char_ptr_16u_;
typedef void* O_btAlignedAllocator_float_16u_;
typedef void* O_btAlignedAllocator_int_16u_;
typedef void* O_btAlignedAllocator_short_ptr_16u_;
typedef void* O_btAlignedAllocator_short_16u_;
typedef void* O_btAlignedAllocator_unsignedint_16u_;
typedef void* O_btAlignedAllocator_unsignedshort_16u_;
typedef void* O_btAlignedAllocator_void_ptr_16u_;
typedef void* O_btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_;
typedef void* O_btAlignedObjectArray_GIM_BVH_DATA_;
typedef void* O_btAlignedObjectArray_GIM_BVH_TREE_NODE_;
typedef void* O_btAlignedObjectArray_GIM_PAIR_;
typedef void* O_btAlignedObjectArray_bool_;
typedef void* O_btAlignedObjectArray_btActionInterface_ptr_;
typedef void* O_btAlignedObjectArray_btBroadphaseInterface_ptr_;
typedef void* O_btAlignedObjectArray_btBroadphasePair_;
typedef void* O_btAlignedObjectArray_btBvhSubtreeInfo_;
typedef void* O_btAlignedObjectArray_btChunk_ptr_;
typedef void* O_btAlignedObjectArray_btCollisionObject_ptr_;
typedef void* O_btAlignedObjectArray_btCollisionShape_ptr_;
typedef void* O_btAlignedObjectArray_btCompoundShapeChild_;
typedef void* O_btAlignedObjectArray_btDbvt_sStkNN_;
typedef void* O_btAlignedObjectArray_btDbvt_sStkNP_;
typedef void* O_btAlignedObjectArray_btDbvt_sStkNPS_;
typedef void* O_btAlignedObjectArray_btDbvtNodeconst_ptr_;
typedef void* O_btAlignedObjectArray_btGImpactMeshShapePart_ptr_;
typedef void* O_btAlignedObjectArray_btHashInt_;
typedef void* O_btAlignedObjectArray_btHashPtr_;
typedef void* O_btAlignedObjectArray_btHashString_;
typedef void* O_btAlignedObjectArray_btIndexedMesh_;
typedef void* O_btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_;
typedef void* O_btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_;
typedef void* O_btAlignedObjectArray_btOptimizedBvhNode_;
typedef void* O_btAlignedObjectArray_btPersistentManifold_ptr_;
typedef void* O_btAlignedObjectArray_btPointerUid_;
typedef void* O_btAlignedObjectArray_btQuantizedBvhNode_;
typedef void* O_btAlignedObjectArray_btRigidBody_ptr_;
typedef void* O_btAlignedObjectArray_btSoftBody_ptr_;
typedef void* O_btAlignedObjectArray_btSoftBody_Anchor_;
typedef void* O_btAlignedObjectArray_btSoftBody_Cluster_ptr_;
typedef void* O_btAlignedObjectArray_btSoftBody_Face_;
typedef void* O_btAlignedObjectArray_btSoftBody_Joint_ptr_;
typedef void* O_btAlignedObjectArray_btSoftBody_Link_;
typedef void* O_btAlignedObjectArray_btSoftBody_Material_ptr_;
typedef void* O_btAlignedObjectArray_btSoftBody_Node_ptr_;
typedef void* O_btAlignedObjectArray_btSoftBody_Node_;
typedef void* O_btAlignedObjectArray_btSoftBody_Note_;
typedef void* O_btAlignedObjectArray_btSoftBody_RContact_;
typedef void* O_btAlignedObjectArray_btSoftBody_SContact_;
typedef void* O_btAlignedObjectArray_btSoftBody_Tetra_;
typedef void* O_btAlignedObjectArray_btSoftBody_ePSolver___;
typedef void* O_btAlignedObjectArray_btSoftBody_eVSolver___;
typedef void* O_btAlignedObjectArray_btSolverConstraint_;
typedef void* O_btAlignedObjectArray_btSparseSdf_3__Cell_ptr_;
typedef void* O_btAlignedObjectArray_btTransform_;
typedef void* O_btAlignedObjectArray_btTriangleInfo_;
typedef void* O_btAlignedObjectArray_btTypedConstraint_ptr_;
typedef void* O_btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_;
typedef void* O_btAlignedObjectArray_btVector3_;
typedef void* O_btAlignedObjectArray_btWheelInfo_;
typedef void* O_btAlignedObjectArray_charconst_ptr_;
typedef void* O_btAlignedObjectArray_char_ptr_;
typedef void* O_btAlignedObjectArray_float_;
typedef void* O_btAlignedObjectArray_int_;
typedef void* O_btAlignedObjectArray_short_ptr_;
typedef void* O_btAlignedObjectArray_short_;
typedef void* O_btAlignedObjectArray_unsignedint_;
typedef void* O_btAlignedObjectArray_unsignedshort_;
typedef void* O_btAlignedObjectArray_void_ptr_;
typedef void* O_btAngularLimit;
typedef void* O_btAxisSweep3;
typedef void* O_btAxisSweep3Internal_unsignedint_;
typedef void* O_btAxisSweep3Internal_unsignedshort_;
typedef void* O_btBU_Simplex1to4;
typedef void* O_btBlock;
typedef void* O_btBoxShape;
typedef void* O_btMultiSapBroadphase_btBridgeProxy;
typedef void* O_btBroadphaseAabbCallback;
typedef void* O_btBroadphaseInterface;
typedef void* O_btBroadphasePair;
typedef void* O_btBroadphasePairSortPredicate;
typedef void* O_btBroadphaseProxy;
typedef void* O_btBroadphaseRayCallback;
typedef void* O_btBvhSubtreeInfo;
typedef void* O_btBvhSubtreeInfoData;
typedef void* O_btBvhTree;
typedef void* O_btBvhTriangleMeshShape;
typedef void* O_btCapsuleShape;
typedef void* O_btCapsuleShapeData;
typedef void* O_btCapsuleShapeX;
typedef void* O_btCapsuleShapeZ;
typedef void* O_btCharIndexTripletData;
typedef void* O_btChunk;
typedef void* O_btClock;
typedef void* O_btCollisionAlgorithm;
typedef void* O_btCollisionAlgorithmConstructionInfo;
typedef void* O_btCollisionAlgorithmCreateFunc;
typedef void* O_btCollisionConfiguration;
typedef void* O_btCollisionDispatcher;
typedef void* O_btCollisionObject;
typedef void* O_btCollisionObjectDoubleData;
typedef void* O_btCollisionObjectFloatData;
typedef void* O_btCollisionShape;
typedef void* O_btCollisionShapeData;
typedef void* O_btCollisionWorld;
typedef void* O_btCompoundShape;
typedef void* O_btCompoundShapeChild;
typedef void* O_btCompoundShapeChildData;
typedef void* O_btCompoundShapeData;
typedef void* O_btConcaveShape;
typedef void* O_btConeShape;
typedef void* O_btConeShapeX;
typedef void* O_btConeShapeZ;
typedef void* O_btConeTwistConstraint;
typedef void* O_btConeTwistConstraintData;
typedef void* O_btTypedConstraint_btConstraintInfo1;
typedef void* O_btTypedConstraint_btConstraintInfo2;
typedef void* O_btConstraintRow;
typedef void* O_btConstraintSetting;
typedef void* O_btConstraintSolver;
typedef void* O_btContactConstraint;
typedef void* O_btContactSolverInfo;
typedef void* O_btContactSolverInfoData;
typedef void* O_btConvexConvexAlgorithm;
typedef void* O_btConvexHullShape;
typedef void* O_btConvexHullShapeData;
typedef void* O_btConvexInternalAabbCachingShape;
typedef void* O_btConvexInternalShape;
typedef void* O_btConvexInternalShapeData;
typedef void* O_btConvexSeparatingDistanceUtil;
typedef void* O_btConvexShape;
typedef void* O_btConvexTriangleMeshShape;
typedef void* O_btCylinderShape;
typedef void* O_btCylinderShapeData;
typedef void* O_btCylinderShapeX;
typedef void* O_btCylinderShapeZ;
typedef void* O_btDbvt;
typedef void* O_btDbvtAabbMm;
typedef void* O_btDbvtBroadphase;
typedef void* O_btDbvtNode;
typedef void* O_btDbvtProxy;
typedef void* O_btDefaultCollisionConfiguration;
typedef void* O_btDefaultCollisionConstructionInfo;
typedef void* O_btDefaultMotionState;
typedef void* O_btDefaultSerializer;
typedef void* O_btDefaultVehicleRaycaster;
typedef void* O_btDiscreteCollisionDetectorInterface;
typedef void* O_btDiscreteDynamicsWorld;
typedef void* O_btDispatcher;
typedef void* O_btDispatcherInfo;
typedef void* O_btDynamicsWorld;
typedef void* O_btEmptyShape;
typedef void* O_btGImpactBvh;
typedef void* O_btGImpactCollisionAlgorithm;
typedef void* O_btGImpactCompoundShape;
typedef void* O_btGImpactMeshShape;
typedef void* O_btGImpactMeshShapeData;
typedef void* O_btGImpactMeshShapePart;
typedef void* O_btGImpactQuantizedBvh;
typedef void* O_btGImpactShapeInterface;
typedef void* O_btGLDebugDrawer;
typedef void* O_btGeneric6DofConstraint;
typedef void* O_btGeneric6DofConstraintData;
typedef void* O_btGeneric6DofSpringConstraint;
typedef void* O_btGeneric6DofSpringConstraintData;
typedef void* O_btGeometryUtil;
typedef void* O_btGhostObject;
typedef void* O_btGhostPairCallback;
typedef void* O_btGjkEpaSolver2;
typedef void* O_btGjkPairDetector;
typedef void* O_btHashInt;
typedef void* O_btHashMap_btHashInt_btTriangleInfo_;
typedef void* O_btHashMap_btHashInt_int_;
typedef void* O_btHashMap_btHashPtr_btPointerUid_;
typedef void* O_btHashMap_btHashPtr_charconst_ptr_;
typedef void* O_btHashMap_btHashPtr_void_ptr_;
typedef void* O_btHashMap_btHashString_int_;
typedef void* O_btHashPtr;
typedef void* O_btHashString;
typedef void* O_btHashedOverlappingPairCache;
typedef void* O_btHinge2Constraint;
typedef void* O_btHingeConstraint;
typedef void* O_btHingeConstraintDoubleData;
typedef void* O_btHingeConstraintFloatData;
typedef void* O_btIDebugDraw;
typedef void* O_btIndexedMesh;
typedef void* O_btIntIndexData;
typedef void* O_btInternalTriangleIndexCallback;
typedef void* O_btJacobianEntry;
typedef void* O_btManifoldPoint;
typedef void* O_btManifoldResult;
typedef void* O_btMatrix3x3DoubleData;
typedef void* O_btMatrix3x3FloatData;
typedef void* O_btMeshPartData;
typedef void* O_btMotionState;
typedef void* O_btMultiSapBroadphase;
typedef void* O_btMultiSapBroadphase_btMultiSapProxy;
typedef void* O_btMultiSphereShape;
typedef void* O_btMultiSphereShapeData;
typedef void* O_btNodeOverlapCallback;
typedef void* O_btNullPairCache;
typedef void* O_btOptimizedBvh;
typedef void* O_btOptimizedBvhNode;
typedef void* O_btOptimizedBvhNodeDoubleData;
typedef void* O_btOptimizedBvhNodeFloatData;
typedef void* O_btOverlapCallback;
typedef void* O_btOverlapFilterCallback;
typedef void* O_btOverlappingPairCache;
typedef void* O_btOverlappingPairCallback;
typedef void* O_btPairCachingGhostObject;
typedef void* O_btPairSet;
typedef void* O_btPersistentManifold;
typedef void* O_btPoint2PointConstraint;
typedef void* O_btPoint2PointConstraintDoubleData;
typedef void* O_btPoint2PointConstraintFloatData;
typedef void* O_btPointerUid;
typedef void* O_btPolyhedralConvexAabbCachingShape;
typedef void* O_btPolyhedralConvexShape;
typedef void* O_btPositionAndRadius;
typedef void* O_btPrimitiveManagerBase;
typedef void* O_btPrimitiveTriangle;
typedef void* O_btQuadWord;
typedef void* O_btQuantizedBvh;
typedef void* O_btQuantizedBvhDoubleData;
typedef void* O_btQuantizedBvhFloatData;
typedef void* O_btQuantizedBvhNode;
typedef void* O_btQuantizedBvhNodeData;
typedef void* O_btQuantizedBvhTree;
typedef void* O_btRaycastVehicle;
typedef void* O_btRigidBody;
typedef void* O_btRigidBody_btRigidBodyConstructionInfo;
typedef void* O_btRigidBodyDoubleData;
typedef void* O_btRigidBodyFloatData;
typedef void* O_btRotationalLimitMotor;
typedef void* O_btScaledBvhTriangleMeshShape;
typedef void* O_btScaledTriangleMeshShapeData;
typedef void* O_btSequentialImpulseConstraintSolver;
typedef void* O_btSerializer;
typedef void* O_btShortIntIndexData;
typedef void* O_btShortIntIndexTripletData;
typedef void* O_btSimpleBroadphase;
typedef void* O_btSimpleBroadphaseProxy;
typedef void* O_btSimpleDynamicsWorld;
typedef void* O_btSliderConstraint;
typedef void* O_btSliderConstraintData;
typedef void* O_btSoftBody;
typedef void* O_btSoftBodyHelpers;
typedef void* O_btSoftBodyRigidBodyCollisionConfiguration;
typedef void* O_btSoftBodyWorldInfo;
typedef void* O_btSoftRigidDynamicsWorld;
typedef void* O_btSolverBodyObsolete;
typedef void* O_btSolverConstraint;
typedef void* O_btSortedOverlappingPairCache;
typedef void* O_btSparseSdf_3_;
typedef void* O_btSphereShape;
typedef void* O_btSphereSphereCollisionAlgorithm;
typedef void* O_btStackAlloc;
typedef void* O_btStaticPlaneShape;
typedef void* O_btStaticPlaneShapeData;
typedef void* O_btStorageResult;
typedef void* O_btStridingMeshInterface;
typedef void* O_btStridingMeshInterfaceData;
typedef void* O_btSubSimplexClosestResult;
typedef void* O_btTetrahedronShapeEx;
typedef void* O_btTransformDoubleData;
typedef void* O_btTransformFloatData;
typedef void* O_btTransformUtil;
typedef void* O_btTranslationalLimitMotor;
typedef void* O_btTriangleCallback;
typedef void* O_btTriangleIndexVertexArray;
typedef void* O_btTriangleInfo;
typedef void* O_btTriangleInfoData;
typedef void* O_btTriangleInfoMap;
typedef void* O_btTriangleInfoMapData;
typedef void* O_btTriangleMesh;
typedef void* O_btTriangleMeshShape;
typedef void* O_btTriangleMeshShapeData;
typedef void* O_btTriangleShape;
typedef void* O_btTriangleShapeEx;
typedef void* O_btTypedConstraint;
typedef void* O_btTypedConstraintData;
typedef void* O_btTypedObject;
typedef void* O_btUniformScalingShape;
typedef void* O_btUniversalConstraint;
typedef void* O_btUsageBitfield;
typedef void* O_btVector3DoubleData;
typedef void* O_btVector3FloatData;
typedef void* O_btVehicleRaycaster;
typedef void* O_btVehicleRaycaster_btVehicleRaycasterResult;
typedef void* O_btRaycastVehicle_btVehicleTuning;
typedef void* O_btVoronoiSimplexSolver;
typedef void* O_btWheelInfo;
typedef void* O_btWheelInfoConstructionInfo;
typedef void* O_btSoftBody_eAeroModel;
typedef void* O_btSoftBody_eFeature;
typedef void* O_btSoftBody_ePSolver;
typedef void* O_btSoftBody_eSolverPresets;
typedef void* O_btSoftBody_Joint_eType;
typedef void* O_btSoftBody_eVSolver;
typedef void* O_btSoftBody_fCollision;
typedef void* O_fDrawFlags;
typedef void* O_btSoftBody_fMaterial;
typedef void* O_btSoftBody_sCti;
typedef void* O_btSoftBody_sMedium;
typedef void* O_btSoftBody_sRayCast;
typedef void* O_btGjkEpaSolver2_sResults;
typedef void* O_btDbvt_sStkCLN;
typedef void* O_btDbvt_sStkNN;
typedef void* O_btDbvt_sStkNP;
typedef void* O_btDbvt_sStkNPS;
void* btGLDebugDrawer_new(); //constructor: btGLDebugDrawer  ( ::btGLDebugDrawer::* )(  ) 
void btGLDebugDrawer_free(void *c); 
void btGLDebugDrawer_draw3dText(void *c,float* p0,char const * p1); //method: draw3dText void ( ::btGLDebugDrawer::* )( ::btVector3 const &,char const * ) 
void btGLDebugDrawer_drawTriangle(void *c,float* p0,float* p1,float* p2,float* p3,float p4); //method: drawTriangle void ( ::btGLDebugDrawer::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
void btGLDebugDrawer_drawBox(void *c,float* p0,float* p1,float* p2,float p3); //method: drawBox void ( ::btGLDebugDrawer::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
void btGLDebugDrawer_drawContactPoint(void *c,float* p0,float* p1,float p2,int p3,float* p4); //method: drawContactPoint void ( ::btGLDebugDrawer::* )( ::btVector3 const &,::btVector3 const &,::btScalar,int,::btVector3 const & ) 
void btGLDebugDrawer_drawLine(void *c,float* p0,float* p1,float* p2,float* p3); //method: drawLine void ( ::btGLDebugDrawer::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btGLDebugDrawer_drawLine0(void *c,float* p0,float* p1,float* p2,float* p3); //method: drawLine void ( ::btGLDebugDrawer::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btGLDebugDrawer_drawLine1(void *c,float* p0,float* p1,float* p2); //method: drawLine void ( ::btGLDebugDrawer::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btGLDebugDrawer_reportErrorWarning(void *c,char const * p0); //method: reportErrorWarning void ( ::btGLDebugDrawer::* )( char const * ) 
int btGLDebugDrawer_getDebugMode(void *c); //method: getDebugMode int ( ::btGLDebugDrawer::* )(  ) const
void btGLDebugDrawer_setDebugMode(void *c,int p0); //method: setDebugMode void ( ::btGLDebugDrawer::* )( int ) 
void btGLDebugDrawer_drawSphere(void *c,float* p0,float p1,float* p2); //method: drawSphere void ( ::btGLDebugDrawer::* )( ::btVector3 const &,::btScalar,::btVector3 const & ) 
void* btSoftBody_AJoint_new(); //constructor: AJoint  ( ::btSoftBody::AJoint::* )(  ) 
void btSoftBody_AJoint_free(void *c); 
void btSoftBody_AJoint_Terminate(void *c,float p0); //method: Terminate void ( ::btSoftBody::AJoint::* )( ::btScalar ) 
//not supported method: Type ::btSoftBody::Joint::eType::_ ( ::btSoftBody::AJoint::* )(  ) const
// error:  - unsupported

void btSoftBody_AJoint_Solve(void *c,float p0,float p1); //method: Solve void ( ::btSoftBody::AJoint::* )( ::btScalar,::btScalar ) 
void btSoftBody_AJoint_Prepare(void *c,float p0,int p1); //method: Prepare void ( ::btSoftBody::AJoint::* )( ::btScalar,int ) 
// attribute not supported: //attribute: ::btVector3[2] btSoftBody_AJoint->m_axis
void btSoftBody_AJoint_m_icontrol_set(void *c,void* a); //attribute: ::btSoftBody::AJoint::IControl * btSoftBody_AJoint->m_icontrol
void* btSoftBody_AJoint_m_icontrol_get(void *c); //attribute: ::btSoftBody::AJoint::IControl * btSoftBody_AJoint->m_icontrol
void* btSoftBody_Anchor_new(); //constructor: Anchor  ( ::btSoftBody::Anchor::* )(  ) 
void btSoftBody_Anchor_free(void *c); 
void btSoftBody_Anchor_m_node_set(void *c,void* a); //attribute: ::btSoftBody::Node * btSoftBody_Anchor->m_node
void* btSoftBody_Anchor_m_node_get(void *c); //attribute: ::btSoftBody::Node * btSoftBody_Anchor->m_node
void btSoftBody_Anchor_m_local_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Anchor->m_local
void btSoftBody_Anchor_m_local_get(void *c,float* a);
void btSoftBody_Anchor_m_body_set(void *c,void* a); //attribute: ::btRigidBody * btSoftBody_Anchor->m_body
void* btSoftBody_Anchor_m_body_get(void *c); //attribute: ::btRigidBody * btSoftBody_Anchor->m_body
void btSoftBody_Anchor_m_influence_set(void *c,float a); //attribute: ::btScalar btSoftBody_Anchor->m_influence
float btSoftBody_Anchor_m_influence_get(void *c); //attribute: ::btScalar btSoftBody_Anchor->m_influence
void btSoftBody_Anchor_m_c0_set(void *c,float* a); //attribute: ::btMatrix3x3 btSoftBody_Anchor->m_c0
void btSoftBody_Anchor_m_c0_get(void *c,float* a);
void btSoftBody_Anchor_m_c1_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Anchor->m_c1
void btSoftBody_Anchor_m_c1_get(void *c,float* a);
void btSoftBody_Anchor_m_c2_set(void *c,float a); //attribute: ::btScalar btSoftBody_Anchor->m_c2
float btSoftBody_Anchor_m_c2_get(void *c); //attribute: ::btScalar btSoftBody_Anchor->m_c2
void* btSoftBody_Body_new0(); //constructor: Body  ( ::btSoftBody::Body::* )(  ) 
void* btSoftBody_Body_new1(void* p0); //constructor: Body  ( ::btSoftBody::Body::* )( ::btSoftBody::Cluster * ) 
void* btSoftBody_Body_new2(void* p0); //constructor: Body  ( ::btSoftBody::Body::* )( ::btCollisionObject * ) 
void btSoftBody_Body_free(void *c); 
void btSoftBody_Body_invWorldInertia(void *c,float* ret); //method: invWorldInertia ::btMatrix3x3 const & ( ::btSoftBody::Body::* )(  ) const
void btSoftBody_Body_activate(void *c); //method: activate void ( ::btSoftBody::Body::* )(  ) const
void btSoftBody_Body_linearVelocity(void *c,float* ret); //method: linearVelocity ::btVector3 ( ::btSoftBody::Body::* )(  ) const
void btSoftBody_Body_applyVImpulse(void *c,float* p0,float* p1); //method: applyVImpulse void ( ::btSoftBody::Body::* )( ::btVector3 const &,::btVector3 const & ) const
void btSoftBody_Body_applyDImpulse(void *c,float* p0,float* p1); //method: applyDImpulse void ( ::btSoftBody::Body::* )( ::btVector3 const &,::btVector3 const & ) const
void btSoftBody_Body_applyDCImpulse(void *c,float* p0); //method: applyDCImpulse void ( ::btSoftBody::Body::* )( ::btVector3 const & ) const
void btSoftBody_Body_applyAImpulse(void *c,void* p0); //method: applyAImpulse void ( ::btSoftBody::Body::* )( ::btSoftBody::Impulse const & ) const
void btSoftBody_Body_angularVelocity(void *c,float* p0,float* ret); //method: angularVelocity ::btVector3 ( ::btSoftBody::Body::* )( ::btVector3 const & ) const
void btSoftBody_Body_angularVelocity0(void *c,float* p0,float* ret); //method: angularVelocity ::btVector3 ( ::btSoftBody::Body::* )( ::btVector3 const & ) const
void btSoftBody_Body_angularVelocity1(void *c,float* ret); //method: angularVelocity ::btVector3 ( ::btSoftBody::Body::* )(  ) const
void btSoftBody_Body_applyVAImpulse(void *c,float* p0); //method: applyVAImpulse void ( ::btSoftBody::Body::* )( ::btVector3 const & ) const
void btSoftBody_Body_applyImpulse(void *c,void* p0,float* p1); //method: applyImpulse void ( ::btSoftBody::Body::* )( ::btSoftBody::Impulse const &,::btVector3 const & ) const
void btSoftBody_Body_applyDAImpulse(void *c,float* p0); //method: applyDAImpulse void ( ::btSoftBody::Body::* )( ::btVector3 const & ) const
void btSoftBody_Body_velocity(void *c,float* p0,float* ret); //method: velocity ::btVector3 ( ::btSoftBody::Body::* )( ::btVector3 const & ) const
float btSoftBody_Body_invMass(void *c); //method: invMass ::btScalar ( ::btSoftBody::Body::* )(  ) const
void btSoftBody_Body_xform(void *c,float* ret); //method: xform ::btTransform const & ( ::btSoftBody::Body::* )(  ) const
void btSoftBody_Body_m_soft_set(void *c,void* a); //attribute: ::btSoftBody::Cluster * btSoftBody_Body->m_soft
void* btSoftBody_Body_m_soft_get(void *c); //attribute: ::btSoftBody::Cluster * btSoftBody_Body->m_soft
void btSoftBody_Body_m_rigid_set(void *c,void* a); //attribute: ::btRigidBody * btSoftBody_Body->m_rigid
void* btSoftBody_Body_m_rigid_get(void *c); //attribute: ::btRigidBody * btSoftBody_Body->m_rigid
void btSoftBody_Body_m_collisionObject_set(void *c,void* a); //attribute: ::btCollisionObject * btSoftBody_Body->m_collisionObject
void* btSoftBody_Body_m_collisionObject_get(void *c); //attribute: ::btCollisionObject * btSoftBody_Body->m_collisionObject
void* btSoftBody_CJoint_new(); //constructor: CJoint  ( ::btSoftBody::CJoint::* )(  ) 
void btSoftBody_CJoint_free(void *c); 
void btSoftBody_CJoint_Terminate(void *c,float p0); //method: Terminate void ( ::btSoftBody::CJoint::* )( ::btScalar ) 
//not supported method: Type ::btSoftBody::Joint::eType::_ ( ::btSoftBody::CJoint::* )(  ) const
// error:  - unsupported

void btSoftBody_CJoint_Solve(void *c,float p0,float p1); //method: Solve void ( ::btSoftBody::CJoint::* )( ::btScalar,::btScalar ) 
void btSoftBody_CJoint_Prepare(void *c,float p0,int p1); //method: Prepare void ( ::btSoftBody::CJoint::* )( ::btScalar,int ) 
void btSoftBody_CJoint_m_life_set(void *c,int a); //attribute: int btSoftBody_CJoint->m_life
int btSoftBody_CJoint_m_life_get(void *c); //attribute: int btSoftBody_CJoint->m_life
void btSoftBody_CJoint_m_maxlife_set(void *c,int a); //attribute: int btSoftBody_CJoint->m_maxlife
int btSoftBody_CJoint_m_maxlife_get(void *c); //attribute: int btSoftBody_CJoint->m_maxlife
// attribute not supported: //attribute: ::btVector3[2] btSoftBody_CJoint->m_rpos
void btSoftBody_CJoint_m_normal_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_CJoint->m_normal
void btSoftBody_CJoint_m_normal_get(void *c,float* a);
void btSoftBody_CJoint_m_friction_set(void *c,float a); //attribute: ::btScalar btSoftBody_CJoint->m_friction
float btSoftBody_CJoint_m_friction_get(void *c); //attribute: ::btScalar btSoftBody_CJoint->m_friction
void* btSoftBody_Cluster_new(); //constructor: Cluster  ( ::btSoftBody::Cluster::* )(  ) 
void btSoftBody_Cluster_free(void *c); 
void btSoftBody_Cluster_m_adamping_set(void *c,float a); //attribute: ::btScalar btSoftBody_Cluster->m_adamping
float btSoftBody_Cluster_m_adamping_get(void *c); //attribute: ::btScalar btSoftBody_Cluster->m_adamping
void btSoftBody_Cluster_m_av_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Cluster->m_av
void btSoftBody_Cluster_m_av_get(void *c,float* a);
void btSoftBody_Cluster_m_clusterIndex_set(void *c,int a); //attribute: int btSoftBody_Cluster->m_clusterIndex
int btSoftBody_Cluster_m_clusterIndex_get(void *c); //attribute: int btSoftBody_Cluster->m_clusterIndex
void btSoftBody_Cluster_m_collide_set(void *c,int a); //attribute: bool btSoftBody_Cluster->m_collide
int btSoftBody_Cluster_m_collide_get(void *c); //attribute: bool btSoftBody_Cluster->m_collide
void btSoftBody_Cluster_m_com_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Cluster->m_com
void btSoftBody_Cluster_m_com_get(void *c,float* a);
void btSoftBody_Cluster_m_containsAnchor_set(void *c,int a); //attribute: bool btSoftBody_Cluster->m_containsAnchor
int btSoftBody_Cluster_m_containsAnchor_get(void *c); //attribute: bool btSoftBody_Cluster->m_containsAnchor
// attribute not supported: //attribute: ::btVector3[2] btSoftBody_Cluster->m_dimpulses
void btSoftBody_Cluster_m_framerefs_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btVector3> btSoftBody_Cluster->m_framerefs
void* btSoftBody_Cluster_m_framerefs_get(void *c); //attribute: ::btAlignedObjectArray<btVector3> btSoftBody_Cluster->m_framerefs
void btSoftBody_Cluster_m_framexform_set(void *c,float* a); //attribute: ::btTransform btSoftBody_Cluster->m_framexform
void btSoftBody_Cluster_m_framexform_get(void *c,float* a);
void btSoftBody_Cluster_m_idmass_set(void *c,float a); //attribute: ::btScalar btSoftBody_Cluster->m_idmass
float btSoftBody_Cluster_m_idmass_get(void *c); //attribute: ::btScalar btSoftBody_Cluster->m_idmass
void btSoftBody_Cluster_m_imass_set(void *c,float a); //attribute: ::btScalar btSoftBody_Cluster->m_imass
float btSoftBody_Cluster_m_imass_get(void *c); //attribute: ::btScalar btSoftBody_Cluster->m_imass
void btSoftBody_Cluster_m_invwi_set(void *c,float* a); //attribute: ::btMatrix3x3 btSoftBody_Cluster->m_invwi
void btSoftBody_Cluster_m_invwi_get(void *c,float* a);
void btSoftBody_Cluster_m_ldamping_set(void *c,float a); //attribute: ::btScalar btSoftBody_Cluster->m_ldamping
float btSoftBody_Cluster_m_ldamping_get(void *c); //attribute: ::btScalar btSoftBody_Cluster->m_ldamping
void btSoftBody_Cluster_m_leaf_set(void *c,void* a); //attribute: ::btDbvtNode * btSoftBody_Cluster->m_leaf
void* btSoftBody_Cluster_m_leaf_get(void *c); //attribute: ::btDbvtNode * btSoftBody_Cluster->m_leaf
void btSoftBody_Cluster_m_locii_set(void *c,float* a); //attribute: ::btMatrix3x3 btSoftBody_Cluster->m_locii
void btSoftBody_Cluster_m_locii_get(void *c,float* a);
void btSoftBody_Cluster_m_lv_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Cluster->m_lv
void btSoftBody_Cluster_m_lv_get(void *c,float* a);
void btSoftBody_Cluster_m_masses_set(void *c,void* a); //attribute: ::btAlignedObjectArray<float> btSoftBody_Cluster->m_masses
void* btSoftBody_Cluster_m_masses_get(void *c); //attribute: ::btAlignedObjectArray<float> btSoftBody_Cluster->m_masses
void btSoftBody_Cluster_m_matching_set(void *c,float a); //attribute: ::btScalar btSoftBody_Cluster->m_matching
float btSoftBody_Cluster_m_matching_get(void *c); //attribute: ::btScalar btSoftBody_Cluster->m_matching
void btSoftBody_Cluster_m_maxSelfCollisionImpulse_set(void *c,float a); //attribute: ::btScalar btSoftBody_Cluster->m_maxSelfCollisionImpulse
float btSoftBody_Cluster_m_maxSelfCollisionImpulse_get(void *c); //attribute: ::btScalar btSoftBody_Cluster->m_maxSelfCollisionImpulse
void btSoftBody_Cluster_m_ndamping_set(void *c,float a); //attribute: ::btScalar btSoftBody_Cluster->m_ndamping
float btSoftBody_Cluster_m_ndamping_get(void *c); //attribute: ::btScalar btSoftBody_Cluster->m_ndamping
void btSoftBody_Cluster_m_ndimpulses_set(void *c,int a); //attribute: int btSoftBody_Cluster->m_ndimpulses
int btSoftBody_Cluster_m_ndimpulses_get(void *c); //attribute: int btSoftBody_Cluster->m_ndimpulses
void btSoftBody_Cluster_m_nodes_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSoftBody::Node*> btSoftBody_Cluster->m_nodes
void* btSoftBody_Cluster_m_nodes_get(void *c); //attribute: ::btAlignedObjectArray<btSoftBody::Node*> btSoftBody_Cluster->m_nodes
void btSoftBody_Cluster_m_nvimpulses_set(void *c,int a); //attribute: int btSoftBody_Cluster->m_nvimpulses
int btSoftBody_Cluster_m_nvimpulses_get(void *c); //attribute: int btSoftBody_Cluster->m_nvimpulses
void btSoftBody_Cluster_m_selfCollisionImpulseFactor_set(void *c,float a); //attribute: ::btScalar btSoftBody_Cluster->m_selfCollisionImpulseFactor
float btSoftBody_Cluster_m_selfCollisionImpulseFactor_get(void *c); //attribute: ::btScalar btSoftBody_Cluster->m_selfCollisionImpulseFactor
// attribute not supported: //attribute: ::btVector3[2] btSoftBody_Cluster->m_vimpulses
void* btSoftBody_Config_new(); //constructor: Config  ( ::btSoftBody::Config::* )(  ) 
void btSoftBody_Config_free(void *c); 
// attribute not supported: //attribute: ::btSoftBody::eAeroModel::_ btSoftBody_Config->aeromodel
void btSoftBody_Config_kVCF_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kVCF
float btSoftBody_Config_kVCF_get(void *c); //attribute: ::btScalar btSoftBody_Config->kVCF
void btSoftBody_Config_kDP_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kDP
float btSoftBody_Config_kDP_get(void *c); //attribute: ::btScalar btSoftBody_Config->kDP
void btSoftBody_Config_kDG_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kDG
float btSoftBody_Config_kDG_get(void *c); //attribute: ::btScalar btSoftBody_Config->kDG
void btSoftBody_Config_kLF_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kLF
float btSoftBody_Config_kLF_get(void *c); //attribute: ::btScalar btSoftBody_Config->kLF
void btSoftBody_Config_kPR_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kPR
float btSoftBody_Config_kPR_get(void *c); //attribute: ::btScalar btSoftBody_Config->kPR
void btSoftBody_Config_kVC_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kVC
float btSoftBody_Config_kVC_get(void *c); //attribute: ::btScalar btSoftBody_Config->kVC
void btSoftBody_Config_kDF_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kDF
float btSoftBody_Config_kDF_get(void *c); //attribute: ::btScalar btSoftBody_Config->kDF
void btSoftBody_Config_kMT_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kMT
float btSoftBody_Config_kMT_get(void *c); //attribute: ::btScalar btSoftBody_Config->kMT
void btSoftBody_Config_kCHR_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kCHR
float btSoftBody_Config_kCHR_get(void *c); //attribute: ::btScalar btSoftBody_Config->kCHR
void btSoftBody_Config_kKHR_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kKHR
float btSoftBody_Config_kKHR_get(void *c); //attribute: ::btScalar btSoftBody_Config->kKHR
void btSoftBody_Config_kSHR_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kSHR
float btSoftBody_Config_kSHR_get(void *c); //attribute: ::btScalar btSoftBody_Config->kSHR
void btSoftBody_Config_kAHR_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kAHR
float btSoftBody_Config_kAHR_get(void *c); //attribute: ::btScalar btSoftBody_Config->kAHR
void btSoftBody_Config_kSRHR_CL_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kSRHR_CL
float btSoftBody_Config_kSRHR_CL_get(void *c); //attribute: ::btScalar btSoftBody_Config->kSRHR_CL
void btSoftBody_Config_kSKHR_CL_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kSKHR_CL
float btSoftBody_Config_kSKHR_CL_get(void *c); //attribute: ::btScalar btSoftBody_Config->kSKHR_CL
void btSoftBody_Config_kSSHR_CL_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kSSHR_CL
float btSoftBody_Config_kSSHR_CL_get(void *c); //attribute: ::btScalar btSoftBody_Config->kSSHR_CL
void btSoftBody_Config_kSR_SPLT_CL_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kSR_SPLT_CL
float btSoftBody_Config_kSR_SPLT_CL_get(void *c); //attribute: ::btScalar btSoftBody_Config->kSR_SPLT_CL
void btSoftBody_Config_kSK_SPLT_CL_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kSK_SPLT_CL
float btSoftBody_Config_kSK_SPLT_CL_get(void *c); //attribute: ::btScalar btSoftBody_Config->kSK_SPLT_CL
void btSoftBody_Config_kSS_SPLT_CL_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->kSS_SPLT_CL
float btSoftBody_Config_kSS_SPLT_CL_get(void *c); //attribute: ::btScalar btSoftBody_Config->kSS_SPLT_CL
void btSoftBody_Config_maxvolume_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->maxvolume
float btSoftBody_Config_maxvolume_get(void *c); //attribute: ::btScalar btSoftBody_Config->maxvolume
void btSoftBody_Config_timescale_set(void *c,float a); //attribute: ::btScalar btSoftBody_Config->timescale
float btSoftBody_Config_timescale_get(void *c); //attribute: ::btScalar btSoftBody_Config->timescale
void btSoftBody_Config_viterations_set(void *c,int a); //attribute: int btSoftBody_Config->viterations
int btSoftBody_Config_viterations_get(void *c); //attribute: int btSoftBody_Config->viterations
void btSoftBody_Config_piterations_set(void *c,int a); //attribute: int btSoftBody_Config->piterations
int btSoftBody_Config_piterations_get(void *c); //attribute: int btSoftBody_Config->piterations
void btSoftBody_Config_diterations_set(void *c,int a); //attribute: int btSoftBody_Config->diterations
int btSoftBody_Config_diterations_get(void *c); //attribute: int btSoftBody_Config->diterations
void btSoftBody_Config_citerations_set(void *c,int a); //attribute: int btSoftBody_Config->citerations
int btSoftBody_Config_citerations_get(void *c); //attribute: int btSoftBody_Config->citerations
void btSoftBody_Config_collisions_set(void *c,int a); //attribute: int btSoftBody_Config->collisions
int btSoftBody_Config_collisions_get(void *c); //attribute: int btSoftBody_Config->collisions
void btSoftBody_Config_m_vsequence_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSoftBody::eVSolver::_> btSoftBody_Config->m_vsequence
void* btSoftBody_Config_m_vsequence_get(void *c); //attribute: ::btAlignedObjectArray<btSoftBody::eVSolver::_> btSoftBody_Config->m_vsequence
void btSoftBody_Config_m_psequence_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSoftBody::ePSolver::_> btSoftBody_Config->m_psequence
void* btSoftBody_Config_m_psequence_get(void *c); //attribute: ::btAlignedObjectArray<btSoftBody::ePSolver::_> btSoftBody_Config->m_psequence
void btSoftBody_Config_m_dsequence_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSoftBody::ePSolver::_> btSoftBody_Config->m_dsequence
void* btSoftBody_Config_m_dsequence_get(void *c); //attribute: ::btAlignedObjectArray<btSoftBody::ePSolver::_> btSoftBody_Config->m_dsequence
void* btSoftBody_Element_new(); //constructor: Element  ( ::btSoftBody::Element::* )(  ) 
void btSoftBody_Element_free(void *c); 
void btSoftBody_Element_m_tag_set(void *c,void* a); //attribute: void * btSoftBody_Element->m_tag
void* btSoftBody_Element_m_tag_get(void *c); //attribute: void * btSoftBody_Element->m_tag
void* btSoftBody_Face_new(); //constructor: Face  ( ::btSoftBody::Face::* )(  ) 
void btSoftBody_Face_free(void *c); 
// attribute not supported: //attribute: ::btSoftBody::Node *[3] btSoftBody_Face->m_n
void btSoftBody_Face_m_normal_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Face->m_normal
void btSoftBody_Face_m_normal_get(void *c,float* a);
void btSoftBody_Face_m_ra_set(void *c,float a); //attribute: ::btScalar btSoftBody_Face->m_ra
float btSoftBody_Face_m_ra_get(void *c); //attribute: ::btScalar btSoftBody_Face->m_ra
void btSoftBody_Face_m_leaf_set(void *c,void* a); //attribute: ::btDbvtNode * btSoftBody_Face->m_leaf
void* btSoftBody_Face_m_leaf_get(void *c); //attribute: ::btDbvtNode * btSoftBody_Face->m_leaf
void* btSoftBody_Feature_new(); //constructor: Feature  ( ::btSoftBody::Feature::* )(  ) 
void btSoftBody_Feature_free(void *c); 
void btSoftBody_Feature_m_material_set(void *c,void* a); //attribute: ::btSoftBody::Material * btSoftBody_Feature->m_material
void* btSoftBody_Feature_m_material_get(void *c); //attribute: ::btSoftBody::Material * btSoftBody_Feature->m_material
void* btSoftBody_AJoint_IControl_new(); //constructor: IControl  ( ::btSoftBody::AJoint::IControl::* )(  ) 
void btSoftBody_AJoint_IControl_free(void *c); 
void* btSoftBody_AJoint_IControl_Default(); //method: Default ::btSoftBody::AJoint::IControl * (*)(  )
float btSoftBody_AJoint_IControl_Speed(void *c,void* p0,float p1); //method: Speed ::btScalar ( ::btSoftBody::AJoint::IControl::* )( ::btSoftBody::AJoint *,::btScalar ) 
void btSoftBody_AJoint_IControl_Prepare(void *c,void* p0); //method: Prepare void ( ::btSoftBody::AJoint::IControl::* )( ::btSoftBody::AJoint * ) 
float btSoftBody_ImplicitFn_Eval(void *c,float* p0); //method: Eval ::btScalar ( ::btSoftBody::ImplicitFn::* )( ::btVector3 const & ) 
void* btSoftBody_Impulse_new(); //constructor: Impulse  ( ::btSoftBody::Impulse::* )(  ) 
void btSoftBody_Impulse_free(void *c); 
void btSoftBody_Impulse_m_asDrift_set(void *c,int a); //attribute: int btSoftBody_Impulse->m_asDrift
int btSoftBody_Impulse_m_asDrift_get(void *c); //attribute: int btSoftBody_Impulse->m_asDrift
void btSoftBody_Impulse_m_asVelocity_set(void *c,int a); //attribute: int btSoftBody_Impulse->m_asVelocity
int btSoftBody_Impulse_m_asVelocity_get(void *c); //attribute: int btSoftBody_Impulse->m_asVelocity
void btSoftBody_Impulse_m_drift_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Impulse->m_drift
void btSoftBody_Impulse_m_drift_get(void *c,float* a);
void btSoftBody_Impulse_m_velocity_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Impulse->m_velocity
void btSoftBody_Impulse_m_velocity_get(void *c,float* a);
void btSoftBody_Joint_Terminate(void *c,float p0); //method: Terminate void ( ::btSoftBody::Joint::* )( ::btScalar ) 
//not supported method: Type ::btSoftBody::Joint::eType::_ ( ::btSoftBody::Joint::* )(  ) const
// error:  - unsupported

void btSoftBody_Joint_Solve(void *c,float p0,float p1); //method: Solve void ( ::btSoftBody::Joint::* )( ::btScalar,::btScalar ) 
void btSoftBody_Joint_Prepare(void *c,float p0,int p1); //method: Prepare void ( ::btSoftBody::Joint::* )( ::btScalar,int ) 
// attribute not supported: //attribute: ::btSoftBody::Body[2] btSoftBody_Joint->m_bodies
// attribute not supported: //attribute: ::btVector3[2] btSoftBody_Joint->m_refs
void btSoftBody_Joint_m_cfm_set(void *c,float a); //attribute: ::btScalar btSoftBody_Joint->m_cfm
float btSoftBody_Joint_m_cfm_get(void *c); //attribute: ::btScalar btSoftBody_Joint->m_cfm
void btSoftBody_Joint_m_erp_set(void *c,float a); //attribute: ::btScalar btSoftBody_Joint->m_erp
float btSoftBody_Joint_m_erp_get(void *c); //attribute: ::btScalar btSoftBody_Joint->m_erp
void btSoftBody_Joint_m_split_set(void *c,float a); //attribute: ::btScalar btSoftBody_Joint->m_split
float btSoftBody_Joint_m_split_get(void *c); //attribute: ::btScalar btSoftBody_Joint->m_split
void btSoftBody_Joint_m_drift_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Joint->m_drift
void btSoftBody_Joint_m_drift_get(void *c,float* a);
void btSoftBody_Joint_m_sdrift_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Joint->m_sdrift
void btSoftBody_Joint_m_sdrift_get(void *c,float* a);
void btSoftBody_Joint_m_massmatrix_set(void *c,float* a); //attribute: ::btMatrix3x3 btSoftBody_Joint->m_massmatrix
void btSoftBody_Joint_m_massmatrix_get(void *c,float* a);
void btSoftBody_Joint_m_delete_set(void *c,int a); //attribute: bool btSoftBody_Joint->m_delete
int btSoftBody_Joint_m_delete_get(void *c); //attribute: bool btSoftBody_Joint->m_delete
void* btSoftBody_LJoint_new(); //constructor: LJoint  ( ::btSoftBody::LJoint::* )(  ) 
void btSoftBody_LJoint_free(void *c); 
void btSoftBody_LJoint_Terminate(void *c,float p0); //method: Terminate void ( ::btSoftBody::LJoint::* )( ::btScalar ) 
//not supported method: Type ::btSoftBody::Joint::eType::_ ( ::btSoftBody::LJoint::* )(  ) const
// error:  - unsupported

void btSoftBody_LJoint_Solve(void *c,float p0,float p1); //method: Solve void ( ::btSoftBody::LJoint::* )( ::btScalar,::btScalar ) 
void btSoftBody_LJoint_Prepare(void *c,float p0,int p1); //method: Prepare void ( ::btSoftBody::LJoint::* )( ::btScalar,int ) 
// attribute not supported: //attribute: ::btVector3[2] btSoftBody_LJoint->m_rpos
void* btSoftBody_Link_new(); //constructor: Link  ( ::btSoftBody::Link::* )(  ) 
void btSoftBody_Link_free(void *c); 
// attribute not supported: //attribute: ::btSoftBody::Node *[2] btSoftBody_Link->m_n
void btSoftBody_Link_m_rl_set(void *c,float a); //attribute: ::btScalar btSoftBody_Link->m_rl
float btSoftBody_Link_m_rl_get(void *c); //attribute: ::btScalar btSoftBody_Link->m_rl
void btSoftBody_Link_m_bbending_set(void *c,int a); //attribute: int btSoftBody_Link->m_bbending
int btSoftBody_Link_m_bbending_get(void *c); //attribute: int btSoftBody_Link->m_bbending
void btSoftBody_Link_m_c0_set(void *c,float a); //attribute: ::btScalar btSoftBody_Link->m_c0
float btSoftBody_Link_m_c0_get(void *c); //attribute: ::btScalar btSoftBody_Link->m_c0
void btSoftBody_Link_m_c1_set(void *c,float a); //attribute: ::btScalar btSoftBody_Link->m_c1
float btSoftBody_Link_m_c1_get(void *c); //attribute: ::btScalar btSoftBody_Link->m_c1
void btSoftBody_Link_m_c2_set(void *c,float a); //attribute: ::btScalar btSoftBody_Link->m_c2
float btSoftBody_Link_m_c2_get(void *c); //attribute: ::btScalar btSoftBody_Link->m_c2
void btSoftBody_Link_m_c3_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Link->m_c3
void btSoftBody_Link_m_c3_get(void *c,float* a);
void* btSoftBody_Material_new(); //constructor: Material  ( ::btSoftBody::Material::* )(  ) 
void btSoftBody_Material_free(void *c); 
void btSoftBody_Material_m_flags_set(void *c,int a); //attribute: int btSoftBody_Material->m_flags
int btSoftBody_Material_m_flags_get(void *c); //attribute: int btSoftBody_Material->m_flags
void btSoftBody_Material_m_kAST_set(void *c,float a); //attribute: ::btScalar btSoftBody_Material->m_kAST
float btSoftBody_Material_m_kAST_get(void *c); //attribute: ::btScalar btSoftBody_Material->m_kAST
void btSoftBody_Material_m_kLST_set(void *c,float a); //attribute: ::btScalar btSoftBody_Material->m_kLST
float btSoftBody_Material_m_kLST_get(void *c); //attribute: ::btScalar btSoftBody_Material->m_kLST
void btSoftBody_Material_m_kVST_set(void *c,float a); //attribute: ::btScalar btSoftBody_Material->m_kVST
float btSoftBody_Material_m_kVST_get(void *c); //attribute: ::btScalar btSoftBody_Material->m_kVST
void* btSoftBody_Node_new(); //constructor: Node  ( ::btSoftBody::Node::* )(  ) 
void btSoftBody_Node_free(void *c); 
void btSoftBody_Node_m_area_set(void *c,float a); //attribute: ::btScalar btSoftBody_Node->m_area
float btSoftBody_Node_m_area_get(void *c); //attribute: ::btScalar btSoftBody_Node->m_area
void btSoftBody_Node_m_battach_set(void *c,int a); //attribute: int btSoftBody_Node->m_battach
int btSoftBody_Node_m_battach_get(void *c); //attribute: int btSoftBody_Node->m_battach
void btSoftBody_Node_m_f_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Node->m_f
void btSoftBody_Node_m_f_get(void *c,float* a);
void btSoftBody_Node_m_im_set(void *c,float a); //attribute: ::btScalar btSoftBody_Node->m_im
float btSoftBody_Node_m_im_get(void *c); //attribute: ::btScalar btSoftBody_Node->m_im
void btSoftBody_Node_m_leaf_set(void *c,void* a); //attribute: ::btDbvtNode * btSoftBody_Node->m_leaf
void* btSoftBody_Node_m_leaf_get(void *c); //attribute: ::btDbvtNode * btSoftBody_Node->m_leaf
void btSoftBody_Node_m_n_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Node->m_n
void btSoftBody_Node_m_n_get(void *c,float* a);
void btSoftBody_Node_m_q_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Node->m_q
void btSoftBody_Node_m_q_get(void *c,float* a);
void btSoftBody_Node_m_v_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Node->m_v
void btSoftBody_Node_m_v_get(void *c,float* a);
void btSoftBody_Node_m_x_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Node->m_x
void btSoftBody_Node_m_x_get(void *c,float* a);
void* btSoftBody_Note_new(); //constructor: Note  ( ::btSoftBody::Note::* )(  ) 
void btSoftBody_Note_free(void *c); 
void btSoftBody_Note_m_text_set(void *c,char const * a); //attribute: char const * btSoftBody_Note->m_text
char const * btSoftBody_Note_m_text_get(void *c); //attribute: char const * btSoftBody_Note->m_text
void btSoftBody_Note_m_offset_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Note->m_offset
void btSoftBody_Note_m_offset_get(void *c,float* a);
void btSoftBody_Note_m_rank_set(void *c,int a); //attribute: int btSoftBody_Note->m_rank
int btSoftBody_Note_m_rank_get(void *c); //attribute: int btSoftBody_Note->m_rank
// attribute not supported: //attribute: ::btSoftBody::Node *[4] btSoftBody_Note->m_nodes
// attribute not supported: //attribute: ::btScalar[4] btSoftBody_Note->m_coords
void* btSoftBody_Pose_new(); //constructor: Pose  ( ::btSoftBody::Pose::* )(  ) 
void btSoftBody_Pose_free(void *c); 
void btSoftBody_Pose_m_bvolume_set(void *c,int a); //attribute: bool btSoftBody_Pose->m_bvolume
int btSoftBody_Pose_m_bvolume_get(void *c); //attribute: bool btSoftBody_Pose->m_bvolume
void btSoftBody_Pose_m_bframe_set(void *c,int a); //attribute: bool btSoftBody_Pose->m_bframe
int btSoftBody_Pose_m_bframe_get(void *c); //attribute: bool btSoftBody_Pose->m_bframe
void btSoftBody_Pose_m_volume_set(void *c,float a); //attribute: ::btScalar btSoftBody_Pose->m_volume
float btSoftBody_Pose_m_volume_get(void *c); //attribute: ::btScalar btSoftBody_Pose->m_volume
void btSoftBody_Pose_m_pos_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btVector3> btSoftBody_Pose->m_pos
void* btSoftBody_Pose_m_pos_get(void *c); //attribute: ::btAlignedObjectArray<btVector3> btSoftBody_Pose->m_pos
void btSoftBody_Pose_m_wgh_set(void *c,void* a); //attribute: ::btAlignedObjectArray<float> btSoftBody_Pose->m_wgh
void* btSoftBody_Pose_m_wgh_get(void *c); //attribute: ::btAlignedObjectArray<float> btSoftBody_Pose->m_wgh
void btSoftBody_Pose_m_com_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_Pose->m_com
void btSoftBody_Pose_m_com_get(void *c,float* a);
void btSoftBody_Pose_m_rot_set(void *c,float* a); //attribute: ::btMatrix3x3 btSoftBody_Pose->m_rot
void btSoftBody_Pose_m_rot_get(void *c,float* a);
void btSoftBody_Pose_m_scl_set(void *c,float* a); //attribute: ::btMatrix3x3 btSoftBody_Pose->m_scl
void btSoftBody_Pose_m_scl_get(void *c,float* a);
void btSoftBody_Pose_m_aqq_set(void *c,float* a); //attribute: ::btMatrix3x3 btSoftBody_Pose->m_aqq
void btSoftBody_Pose_m_aqq_get(void *c,float* a);
void* btSoftBody_RContact_new(); //constructor: RContact  ( ::btSoftBody::RContact::* )(  ) 
void btSoftBody_RContact_free(void *c); 
void btSoftBody_RContact_m_cti_set(void *c,void* a); //attribute: ::btSoftBody::sCti btSoftBody_RContact->m_cti
void* btSoftBody_RContact_m_cti_get(void *c); //attribute: ::btSoftBody::sCti btSoftBody_RContact->m_cti
void btSoftBody_RContact_m_node_set(void *c,void* a); //attribute: ::btSoftBody::Node * btSoftBody_RContact->m_node
void* btSoftBody_RContact_m_node_get(void *c); //attribute: ::btSoftBody::Node * btSoftBody_RContact->m_node
void btSoftBody_RContact_m_c0_set(void *c,float* a); //attribute: ::btMatrix3x3 btSoftBody_RContact->m_c0
void btSoftBody_RContact_m_c0_get(void *c,float* a);
void btSoftBody_RContact_m_c1_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_RContact->m_c1
void btSoftBody_RContact_m_c1_get(void *c,float* a);
void btSoftBody_RContact_m_c2_set(void *c,float a); //attribute: ::btScalar btSoftBody_RContact->m_c2
float btSoftBody_RContact_m_c2_get(void *c); //attribute: ::btScalar btSoftBody_RContact->m_c2
void btSoftBody_RContact_m_c3_set(void *c,float a); //attribute: ::btScalar btSoftBody_RContact->m_c3
float btSoftBody_RContact_m_c3_get(void *c); //attribute: ::btScalar btSoftBody_RContact->m_c3
void btSoftBody_RContact_m_c4_set(void *c,float a); //attribute: ::btScalar btSoftBody_RContact->m_c4
float btSoftBody_RContact_m_c4_get(void *c); //attribute: ::btScalar btSoftBody_RContact->m_c4
void* btSoftBody_RayFromToCaster_new(float* p0,float* p1,float p2); //constructor: RayFromToCaster  ( ::btSoftBody::RayFromToCaster::* )( ::btVector3 const &,::btVector3 const &,::btScalar ) 
void btSoftBody_RayFromToCaster_free(void *c); 
void btSoftBody_RayFromToCaster_Process(void *c,void* p0); //method: Process void ( ::btSoftBody::RayFromToCaster::* )( ::btDbvtNode const * ) 
void btSoftBody_RayFromToCaster_m_rayFrom_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_RayFromToCaster->m_rayFrom
void btSoftBody_RayFromToCaster_m_rayFrom_get(void *c,float* a);
void btSoftBody_RayFromToCaster_m_rayTo_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_RayFromToCaster->m_rayTo
void btSoftBody_RayFromToCaster_m_rayTo_get(void *c,float* a);
void btSoftBody_RayFromToCaster_m_rayNormalizedDirection_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_RayFromToCaster->m_rayNormalizedDirection
void btSoftBody_RayFromToCaster_m_rayNormalizedDirection_get(void *c,float* a);
void btSoftBody_RayFromToCaster_m_mint_set(void *c,float a); //attribute: ::btScalar btSoftBody_RayFromToCaster->m_mint
float btSoftBody_RayFromToCaster_m_mint_get(void *c); //attribute: ::btScalar btSoftBody_RayFromToCaster->m_mint
void btSoftBody_RayFromToCaster_m_face_set(void *c,void* a); //attribute: ::btSoftBody::Face * btSoftBody_RayFromToCaster->m_face
void* btSoftBody_RayFromToCaster_m_face_get(void *c); //attribute: ::btSoftBody::Face * btSoftBody_RayFromToCaster->m_face
void btSoftBody_RayFromToCaster_m_tests_set(void *c,int a); //attribute: int btSoftBody_RayFromToCaster->m_tests
int btSoftBody_RayFromToCaster_m_tests_get(void *c); //attribute: int btSoftBody_RayFromToCaster->m_tests
void* btSoftBody_SContact_new(); //constructor: SContact  ( ::btSoftBody::SContact::* )(  ) 
void btSoftBody_SContact_free(void *c); 
void btSoftBody_SContact_m_node_set(void *c,void* a); //attribute: ::btSoftBody::Node * btSoftBody_SContact->m_node
void* btSoftBody_SContact_m_node_get(void *c); //attribute: ::btSoftBody::Node * btSoftBody_SContact->m_node
void btSoftBody_SContact_m_face_set(void *c,void* a); //attribute: ::btSoftBody::Face * btSoftBody_SContact->m_face
void* btSoftBody_SContact_m_face_get(void *c); //attribute: ::btSoftBody::Face * btSoftBody_SContact->m_face
void btSoftBody_SContact_m_weights_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_SContact->m_weights
void btSoftBody_SContact_m_weights_get(void *c,float* a);
void btSoftBody_SContact_m_normal_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_SContact->m_normal
void btSoftBody_SContact_m_normal_get(void *c,float* a);
void btSoftBody_SContact_m_margin_set(void *c,float a); //attribute: ::btScalar btSoftBody_SContact->m_margin
float btSoftBody_SContact_m_margin_get(void *c); //attribute: ::btScalar btSoftBody_SContact->m_margin
void btSoftBody_SContact_m_friction_set(void *c,float a); //attribute: ::btScalar btSoftBody_SContact->m_friction
float btSoftBody_SContact_m_friction_get(void *c); //attribute: ::btScalar btSoftBody_SContact->m_friction
// attribute not supported: //attribute: ::btScalar[2] btSoftBody_SContact->m_cfm
void* btSoftBody_SolverState_new(); //constructor: SolverState  ( ::btSoftBody::SolverState::* )(  ) 
void btSoftBody_SolverState_free(void *c); 
void btSoftBody_SolverState_sdt_set(void *c,float a); //attribute: ::btScalar btSoftBody_SolverState->sdt
float btSoftBody_SolverState_sdt_get(void *c); //attribute: ::btScalar btSoftBody_SolverState->sdt
void btSoftBody_SolverState_isdt_set(void *c,float a); //attribute: ::btScalar btSoftBody_SolverState->isdt
float btSoftBody_SolverState_isdt_get(void *c); //attribute: ::btScalar btSoftBody_SolverState->isdt
void btSoftBody_SolverState_velmrg_set(void *c,float a); //attribute: ::btScalar btSoftBody_SolverState->velmrg
float btSoftBody_SolverState_velmrg_get(void *c); //attribute: ::btScalar btSoftBody_SolverState->velmrg
void btSoftBody_SolverState_radmrg_set(void *c,float a); //attribute: ::btScalar btSoftBody_SolverState->radmrg
float btSoftBody_SolverState_radmrg_get(void *c); //attribute: ::btScalar btSoftBody_SolverState->radmrg
void btSoftBody_SolverState_updmrg_set(void *c,float a); //attribute: ::btScalar btSoftBody_SolverState->updmrg
float btSoftBody_SolverState_updmrg_get(void *c); //attribute: ::btScalar btSoftBody_SolverState->updmrg
void* btSoftBody_Joint_Specs_new(); //constructor: Specs  ( ::btSoftBody::Joint::Specs::* )(  ) 
void btSoftBody_Joint_Specs_free(void *c); 
void btSoftBody_Joint_Specs_erp_set(void *c,float a); //attribute: ::btScalar btSoftBody_Joint_Specs->erp
float btSoftBody_Joint_Specs_erp_get(void *c); //attribute: ::btScalar btSoftBody_Joint_Specs->erp
void btSoftBody_Joint_Specs_cfm_set(void *c,float a); //attribute: ::btScalar btSoftBody_Joint_Specs->cfm
float btSoftBody_Joint_Specs_cfm_get(void *c); //attribute: ::btScalar btSoftBody_Joint_Specs->cfm
void btSoftBody_Joint_Specs_split_set(void *c,float a); //attribute: ::btScalar btSoftBody_Joint_Specs->split
float btSoftBody_Joint_Specs_split_get(void *c); //attribute: ::btScalar btSoftBody_Joint_Specs->split
void* btSoftBody_LJoint_Specs_new(); //constructor: Specs  ( ::btSoftBody::LJoint::Specs::* )(  ) 
void btSoftBody_LJoint_Specs_free(void *c); 
void btSoftBody_LJoint_Specs_position_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_LJoint_Specs->position
void btSoftBody_LJoint_Specs_position_get(void *c,float* a);
void* btSoftBody_AJoint_Specs_new(); //constructor: Specs  ( ::btSoftBody::AJoint::Specs::* )(  ) 
void btSoftBody_AJoint_Specs_free(void *c); 
void btSoftBody_AJoint_Specs_axis_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_AJoint_Specs->axis
void btSoftBody_AJoint_Specs_axis_get(void *c,float* a);
void btSoftBody_AJoint_Specs_icontrol_set(void *c,void* a); //attribute: ::btSoftBody::AJoint::IControl * btSoftBody_AJoint_Specs->icontrol
void* btSoftBody_AJoint_Specs_icontrol_get(void *c); //attribute: ::btSoftBody::AJoint::IControl * btSoftBody_AJoint_Specs->icontrol
void* btSoftBody_Tetra_new(); //constructor: Tetra  ( ::btSoftBody::Tetra::* )(  ) 
void btSoftBody_Tetra_free(void *c); 
// attribute not supported: //attribute: ::btSoftBody::Node *[4] btSoftBody_Tetra->m_n
void btSoftBody_Tetra_m_rv_set(void *c,float a); //attribute: ::btScalar btSoftBody_Tetra->m_rv
float btSoftBody_Tetra_m_rv_get(void *c); //attribute: ::btScalar btSoftBody_Tetra->m_rv
void btSoftBody_Tetra_m_leaf_set(void *c,void* a); //attribute: ::btDbvtNode * btSoftBody_Tetra->m_leaf
void* btSoftBody_Tetra_m_leaf_get(void *c); //attribute: ::btDbvtNode * btSoftBody_Tetra->m_leaf
// attribute not supported: //attribute: ::btVector3[4] btSoftBody_Tetra->m_c0
void btSoftBody_Tetra_m_c1_set(void *c,float a); //attribute: ::btScalar btSoftBody_Tetra->m_c1
float btSoftBody_Tetra_m_c1_get(void *c); //attribute: ::btScalar btSoftBody_Tetra->m_c1
void btSoftBody_Tetra_m_c2_set(void *c,float a); //attribute: ::btScalar btSoftBody_Tetra->m_c2
float btSoftBody_Tetra_m_c2_get(void *c); //attribute: ::btScalar btSoftBody_Tetra->m_c2
//not supported constructor: btSoftBody  ( ::btSoftBody::* )( ::btSoftBodyWorldInfo *,int,::btVector3 const *,::btScalar const * ) 
// error: ::btSoftBodyWorldInfo * - ok, int - ok,  - unsupported,  - unsupported

void* btSoftBody_new1(void* p0); //constructor: btSoftBody  ( ::btSoftBody::* )( ::btSoftBodyWorldInfo * ) 
void btSoftBody_free(void *c); 
float btSoftBody_getVolume(void *c); //method: getVolume ::btScalar ( ::btSoftBody::* )(  ) const
int btSoftBody_cutLink(void *c,int p0,int p1,float p2); //method: cutLink bool ( ::btSoftBody::* )( int,int,::btScalar ) 
int btSoftBody_cutLink0(void *c,int p0,int p1,float p2); //method: cutLink bool ( ::btSoftBody::* )( int,int,::btScalar ) 
int btSoftBody_cutLink1(void *c,void* p0,void* p1,float p2); //method: cutLink bool ( ::btSoftBody::* )( ::btSoftBody::Node const *,::btSoftBody::Node const *,::btScalar ) 
void btSoftBody_PSolve_Links(void* p0,float p1,float p2); //method: PSolve_Links void (*)( ::btSoftBody *,::btScalar,::btScalar )
int btSoftBody_generateClusters(void *c,int p0,int p1); //method: generateClusters int ( ::btSoftBody::* )( int,int ) 
void btSoftBody_setCollisionShape(void *c,void* p0); //method: setCollisionShape void ( ::btSoftBody::* )( ::btCollisionShape * ) 
void btSoftBody_initializeClusters(void *c); //method: initializeClusters void ( ::btSoftBody::* )(  ) 
void btSoftBody_clusterVAImpulse(void* p0,float* p1); //method: clusterVAImpulse void (*)( ::btSoftBody::Cluster *,::btVector3 const & )
void btSoftBody_addForce(void *c,float* p0); //method: addForce void ( ::btSoftBody::* )( ::btVector3 const & ) 
void btSoftBody_addForce0(void *c,float* p0); //method: addForce void ( ::btSoftBody::* )( ::btVector3 const & ) 
void btSoftBody_addForce1(void *c,float* p0,int p1); //method: addForce void ( ::btSoftBody::* )( ::btVector3 const &,int ) 
char const * btSoftBody_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btSoftBody::* )( void *,::btSerializer * ) const
void btSoftBody_updateBounds(void *c); //method: updateBounds void ( ::btSoftBody::* )(  ) 
void btSoftBody_rotate(void *c,float* p0); //method: rotate void ( ::btSoftBody::* )( ::btQuaternion const & ) 
void btSoftBody_releaseCluster(void *c,int p0); //method: releaseCluster void ( ::btSoftBody::* )( int ) 
void btSoftBody_updateNormals(void *c); //method: updateNormals void ( ::btSoftBody::* )(  ) 
void btSoftBody_prepareClusters(void *c,int p0); //method: prepareClusters void ( ::btSoftBody::* )( int ) 
void btSoftBody_releaseClusters(void *c); //method: releaseClusters void ( ::btSoftBody::* )(  ) 
float btSoftBody_getTotalMass(void *c); //method: getTotalMass ::btScalar ( ::btSoftBody::* )(  ) const
int btSoftBody_checkContact(void *c,void* p0,float* p1,float p2,void* p3); //method: checkContact bool ( ::btSoftBody::* )( ::btCollisionObject *,::btVector3 const &,::btScalar,::btSoftBody::sCti & ) const
//not supported method: indicesToPointers void ( ::btSoftBody::* )( int const * ) 
// error:  - unsupported, void - ok

void btSoftBody_clusterDImpulse(void* p0,float* p1,float* p2); //method: clusterDImpulse void (*)( ::btSoftBody::Cluster *,::btVector3 const &,::btVector3 const & )
void btSoftBody_initDefaults(void *c); //method: initDefaults void ( ::btSoftBody::* )(  ) 
int btSoftBody_checkLink(void *c,int p0,int p1); //method: checkLink bool ( ::btSoftBody::* )( int,int ) const
int btSoftBody_checkLink0(void *c,int p0,int p1); //method: checkLink bool ( ::btSoftBody::* )( int,int ) const
int btSoftBody_checkLink1(void *c,void* p0,void* p1); //method: checkLink bool ( ::btSoftBody::* )( ::btSoftBody::Node const *,::btSoftBody::Node const * ) const
void btSoftBody_setVolumeMass(void *c,float p0); //method: setVolumeMass void ( ::btSoftBody::* )( ::btScalar ) 
void btSoftBody_clusterImpulse(void* p0,float* p1,void* p2); //method: clusterImpulse void (*)( ::btSoftBody::Cluster *,::btVector3 const &,::btSoftBody::Impulse const & )
int btSoftBody_checkFace(void *c,int p0,int p1,int p2); //method: checkFace bool ( ::btSoftBody::* )( int,int,int ) const
void btSoftBody_evaluateCom(void *c,float* ret); //method: evaluateCom ::btVector3 ( ::btSoftBody::* )(  ) const
void btSoftBody_clusterDAImpulse(void* p0,float* p1); //method: clusterDAImpulse void (*)( ::btSoftBody::Cluster *,::btVector3 const & )
void btSoftBody_VSolve_Links(void* p0,float p1); //method: VSolve_Links void (*)( ::btSoftBody *,::btScalar )
void btSoftBody_setTotalMass(void *c,float p0,int p1); //method: setTotalMass void ( ::btSoftBody::* )( ::btScalar,bool ) 
void btSoftBody_clusterDCImpulse(void* p0,float* p1); //method: clusterDCImpulse void (*)( ::btSoftBody::Cluster *,::btVector3 const & )
void btSoftBody_clusterVelocity(void* p0,float* p1,float* ret); //method: clusterVelocity ::btVector3 (*)( ::btSoftBody::Cluster const *,::btVector3 const & )
int btSoftBody_generateBendingConstraints(void *c,int p0,void* p1); //method: generateBendingConstraints int ( ::btSoftBody::* )( int,::btSoftBody::Material * ) 
void btSoftBody_updateClusters(void *c); //method: updateClusters void ( ::btSoftBody::* )(  ) 
void btSoftBody_appendAnchor(void *c,int p0,void* p1,int p2,float p3); //method: appendAnchor void ( ::btSoftBody::* )( int,::btRigidBody *,bool,::btScalar ) 
void btSoftBody_appendAnchor0(void *c,int p0,void* p1,int p2,float p3); //method: appendAnchor void ( ::btSoftBody::* )( int,::btRigidBody *,bool,::btScalar ) 
void btSoftBody_appendAnchor1(void *c,int p0,void* p1,float* p2,int p3,float p4); //method: appendAnchor void ( ::btSoftBody::* )( int,::btRigidBody *,::btVector3 const &,bool,::btScalar ) 
void btSoftBody_applyClusters(void *c,int p0); //method: applyClusters void ( ::btSoftBody::* )( bool ) 
void btSoftBody_setVelocity(void *c,float* p0); //method: setVelocity void ( ::btSoftBody::* )( ::btVector3 const & ) 
int btSoftBody_clusterCount(void *c); //method: clusterCount int ( ::btSoftBody::* )(  ) const
void* btSoftBody_upcast(void* p0); //method: upcast ::btSoftBody const * (*)( ::btCollisionObject const * )
void* btSoftBody_upcast0(void* p0); //method: upcast ::btSoftBody const * (*)( ::btCollisionObject const * )
void* btSoftBody_upcast1(void* p0); //method: upcast ::btSoftBody * (*)( ::btCollisionObject * )
void btSoftBody_getWindVelocity(void *c,float* ret); //method: getWindVelocity ::btVector3 const & ( ::btSoftBody::* )(  ) 
void btSoftBody_predictMotion(void *c,float p0); //method: predictMotion void ( ::btSoftBody::* )( ::btScalar ) 
void btSoftBody_pointersToIndices(void *c); //method: pointersToIndices void ( ::btSoftBody::* )(  ) 
float btSoftBody_getMass(void *c,int p0); //method: getMass ::btScalar ( ::btSoftBody::* )( int ) const
void btSoftBody_PSolve_RContacts(void* p0,float p1,float p2); //method: PSolve_RContacts void (*)( ::btSoftBody *,::btScalar,::btScalar )
void btSoftBody_initializeFaceTree(void *c); //method: initializeFaceTree void ( ::btSoftBody::* )(  ) 
void btSoftBody_addVelocity(void *c,float* p0); //method: addVelocity void ( ::btSoftBody::* )( ::btVector3 const & ) 
void btSoftBody_addVelocity0(void *c,float* p0); //method: addVelocity void ( ::btSoftBody::* )( ::btVector3 const & ) 
void btSoftBody_addVelocity1(void *c,float* p0,int p1); //method: addVelocity void ( ::btSoftBody::* )( ::btVector3 const &,int ) 
void btSoftBody_PSolve_Anchors(void* p0,float p1,float p2); //method: PSolve_Anchors void (*)( ::btSoftBody *,::btScalar,::btScalar )
void btSoftBody_cleanupClusters(void *c); //method: cleanupClusters void ( ::btSoftBody::* )(  ) 
void btSoftBody_transform(void *c,float* p0); //method: transform void ( ::btSoftBody::* )( ::btTransform const & ) 
//not supported method: appendLinearJoint void ( ::btSoftBody::* )( ::btSoftBody::LJoint::Specs const &,::btSoftBody::Cluster *,::btSoftBody::Body ) 
// error: ::btSoftBody::LJoint::Specs const & - ok, ::btSoftBody::Cluster * - ok,  - unsupported, void - ok

//not supported method: appendLinearJoint void ( ::btSoftBody::* )( ::btSoftBody::LJoint::Specs const &,::btSoftBody::Cluster *,::btSoftBody::Body ) 
// error: ::btSoftBody::LJoint::Specs const & - ok, ::btSoftBody::Cluster * - ok,  - unsupported, void - ok

//not supported method: appendLinearJoint void ( ::btSoftBody::* )( ::btSoftBody::LJoint::Specs const &,::btSoftBody::Body ) 
// error: ::btSoftBody::LJoint::Specs const & - ok,  - unsupported, void - ok

void btSoftBody_appendLinearJoint2(void *c,void* p0,void* p1); //method: appendLinearJoint void ( ::btSoftBody::* )( ::btSoftBody::LJoint::Specs const &,::btSoftBody * ) 
void btSoftBody_randomizeConstraints(void *c); //method: randomizeConstraints void ( ::btSoftBody::* )(  ) 
void btSoftBody_updatePose(void *c); //method: updatePose void ( ::btSoftBody::* )(  ) 
void btSoftBody_translate(void *c,float* p0); //method: translate void ( ::btSoftBody::* )( ::btVector3 const & ) 
void btSoftBody_getAabb(void *c,float* p0,float* p1); //method: getAabb void ( ::btSoftBody::* )( ::btVector3 &,::btVector3 & ) const
void btSoftBody_PSolve_SContacts(void* p0,float p1,float p2); //method: PSolve_SContacts void (*)( ::btSoftBody *,::btScalar,::btScalar )
void* btSoftBody_appendMaterial(void *c); //method: appendMaterial ::btSoftBody::Material * ( ::btSoftBody::* )(  ) 
void btSoftBody_appendNode(void *c,float* p0,float p1); //method: appendNode void ( ::btSoftBody::* )( ::btVector3 const &,::btScalar ) 
void btSoftBody_setMass(void *c,int p0,float p1); //method: setMass void ( ::btSoftBody::* )( int,::btScalar ) 
void btSoftBody_integrateMotion(void *c); //method: integrateMotion void ( ::btSoftBody::* )(  ) 
void btSoftBody_defaultCollisionHandler(void *c,void* p0); //method: defaultCollisionHandler void ( ::btSoftBody::* )( ::btCollisionObject * ) 
void btSoftBody_defaultCollisionHandler0(void *c,void* p0); //method: defaultCollisionHandler void ( ::btSoftBody::* )( ::btCollisionObject * ) 
void btSoftBody_defaultCollisionHandler1(void *c,void* p0); //method: defaultCollisionHandler void ( ::btSoftBody::* )( ::btSoftBody * ) 
void btSoftBody_solveConstraints(void *c); //method: solveConstraints void ( ::btSoftBody::* )(  ) 
void btSoftBody_setTotalDensity(void *c,float p0); //method: setTotalDensity void ( ::btSoftBody::* )( ::btScalar ) 
void btSoftBody_appendNote(void *c,char const * p0,float* p1,float* p2,void* p3,void* p4,void* p5,void* p6); //method: appendNote void ( ::btSoftBody::* )( char const *,::btVector3 const &,::btVector4 const &,::btSoftBody::Node *,::btSoftBody::Node *,::btSoftBody::Node *,::btSoftBody::Node * ) 
void btSoftBody_appendNote0(void *c,char const * p0,float* p1,float* p2,void* p3,void* p4,void* p5,void* p6); //method: appendNote void ( ::btSoftBody::* )( char const *,::btVector3 const &,::btVector4 const &,::btSoftBody::Node *,::btSoftBody::Node *,::btSoftBody::Node *,::btSoftBody::Node * ) 
void btSoftBody_appendNote1(void *c,char const * p0,float* p1,void* p2); //method: appendNote void ( ::btSoftBody::* )( char const *,::btVector3 const &,::btSoftBody::Node * ) 
void btSoftBody_appendNote2(void *c,char const * p0,float* p1,void* p2); //method: appendNote void ( ::btSoftBody::* )( char const *,::btVector3 const &,::btSoftBody::Link * ) 
void btSoftBody_appendNote3(void *c,char const * p0,float* p1,void* p2); //method: appendNote void ( ::btSoftBody::* )( char const *,::btVector3 const &,::btSoftBody::Face * ) 
void btSoftBody_setVolumeDensity(void *c,float p0); //method: setVolumeDensity void ( ::btSoftBody::* )( ::btScalar ) 
//not supported method: solveCommonConstraints void (*)( ::btSoftBody * *,int,int )
// error:  - unsupported, int - ok, int - ok, void - ok

void btSoftBody_updateConstants(void *c); //method: updateConstants void ( ::btSoftBody::* )(  ) 
void btSoftBody_staticSolve(void *c,int p0); //method: staticSolve void ( ::btSoftBody::* )( int ) 
//not supported method: getSoftBodySolver ::btSoftBodySolver * ( ::btSoftBody::* )(  ) 
// error:  - unsupported

//not supported method: getSoftBodySolver ::btSoftBodySolver * ( ::btSoftBody::* )(  ) 
// error:  - unsupported

//not supported method: getSoftBodySolver ::btSoftBodySolver * ( ::btSoftBody::* )(  ) const
// error:  - unsupported

void btSoftBody_refine(void *c,void* p0,float p1,int p2); //method: refine void ( ::btSoftBody::* )( ::btSoftBody::ImplicitFn *,::btScalar,bool ) 
void btSoftBody_appendLink(void *c,int p0,void* p1); //method: appendLink void ( ::btSoftBody::* )( int,::btSoftBody::Material * ) 
void btSoftBody_appendLink0(void *c,int p0,void* p1); //method: appendLink void ( ::btSoftBody::* )( int,::btSoftBody::Material * ) 
void btSoftBody_appendLink1(void *c,int p0,int p1,void* p2,int p3); //method: appendLink void ( ::btSoftBody::* )( int,int,::btSoftBody::Material *,bool ) 
void btSoftBody_appendLink2(void *c,void* p0,void* p1,void* p2,int p3); //method: appendLink void ( ::btSoftBody::* )( ::btSoftBody::Node *,::btSoftBody::Node *,::btSoftBody::Material *,bool ) 
int btSoftBody_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btSoftBody::* )(  ) const
void btSoftBody_solveClusters(void* p0); //method: solveClusters void (*)( ::btAlignedObjectArray<btSoftBody*> const & )
void btSoftBody_solveClusters0(void* p0); //method: solveClusters void (*)( ::btAlignedObjectArray<btSoftBody*> const & )
void btSoftBody_solveClusters1(void *c,float p0); //method: solveClusters void ( ::btSoftBody::* )( ::btScalar ) 
int btSoftBody_rayTest(void *c,float* p0,float* p1,void* p2); //method: rayTest bool ( ::btSoftBody::* )( ::btVector3 const &,::btVector3 const &,::btSoftBody::sRayCast & ) 
int btSoftBody_rayTest0(void *c,float* p0,float* p1,void* p2); //method: rayTest bool ( ::btSoftBody::* )( ::btVector3 const &,::btVector3 const &,::btSoftBody::sRayCast & ) 
//not supported method: rayTest int ( ::btSoftBody::* )( ::btVector3 const &,::btVector3 const &,::btScalar &,::btSoftBody::eFeature::_ &,int &,bool ) const
// error: ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported,  - unsupported,  - unsupported, bool - ok, int - ok

void btSoftBody_setPose(void *c,int p0,int p1); //method: setPose void ( ::btSoftBody::* )( bool,bool ) 
void btSoftBody_appendFace(void *c,int p0,void* p1); //method: appendFace void ( ::btSoftBody::* )( int,::btSoftBody::Material * ) 
void btSoftBody_appendFace0(void *c,int p0,void* p1); //method: appendFace void ( ::btSoftBody::* )( int,::btSoftBody::Material * ) 
void btSoftBody_appendFace1(void *c,int p0,int p1,int p2,void* p3); //method: appendFace void ( ::btSoftBody::* )( int,int,int,::btSoftBody::Material * ) 
void btSoftBody_dampClusters(void *c); //method: dampClusters void ( ::btSoftBody::* )(  ) 
void* btSoftBody_getWorldInfo(void *c); //method: getWorldInfo ::btSoftBodyWorldInfo * ( ::btSoftBody::* )(  ) 
//not supported method: appendAngularJoint void ( ::btSoftBody::* )( ::btSoftBody::AJoint::Specs const &,::btSoftBody::Cluster *,::btSoftBody::Body ) 
// error: ::btSoftBody::AJoint::Specs const & - ok, ::btSoftBody::Cluster * - ok,  - unsupported, void - ok

//not supported method: appendAngularJoint void ( ::btSoftBody::* )( ::btSoftBody::AJoint::Specs const &,::btSoftBody::Cluster *,::btSoftBody::Body ) 
// error: ::btSoftBody::AJoint::Specs const & - ok, ::btSoftBody::Cluster * - ok,  - unsupported, void - ok

//not supported method: appendAngularJoint void ( ::btSoftBody::* )( ::btSoftBody::AJoint::Specs const &,::btSoftBody::Body ) 
// error: ::btSoftBody::AJoint::Specs const & - ok,  - unsupported, void - ok

void btSoftBody_appendAngularJoint2(void *c,void* p0,void* p1); //method: appendAngularJoint void ( ::btSoftBody::* )( ::btSoftBody::AJoint::Specs const &,::btSoftBody * ) 
//not supported method: setSolver void ( ::btSoftBody::* )( ::btSoftBody::eSolverPresets::_ ) 
// error:  - unsupported, void - ok

void btSoftBody_clusterVImpulse(void* p0,float* p1,float* p2); //method: clusterVImpulse void (*)( ::btSoftBody::Cluster *,::btVector3 const &,::btVector3 const & )
void btSoftBody_scale(void *c,float* p0); //method: scale void ( ::btSoftBody::* )( ::btVector3 const & ) 
void btSoftBody_clusterAImpulse(void* p0,void* p1); //method: clusterAImpulse void (*)( ::btSoftBody::Cluster *,::btSoftBody::Impulse const & )
void btSoftBody_clusterCom(void* p0,float* ret); //method: clusterCom ::btVector3 (*)( ::btSoftBody::Cluster const * )
void btSoftBody_clusterCom0(void* p0,float* ret); //method: clusterCom ::btVector3 (*)( ::btSoftBody::Cluster const * )
void btSoftBody_clusterCom1(void *c,int p0,float* ret); //method: clusterCom ::btVector3 ( ::btSoftBody::* )( int ) const
//not supported method: setSoftBodySolver void ( ::btSoftBody::* )( ::btSoftBodySolver * ) 
// error:  - unsupported, void - ok

void btSoftBody_setWindVelocity(void *c,float* p0); //method: setWindVelocity void ( ::btSoftBody::* )( ::btVector3 const & ) 
//not supported method: getSolver void (*)( ::btSoftBody *,::btScalar,::btScalar ) * (*)( ::btSoftBody::ePSolver::_ )
// error:  - unsupported,  - unsupported

//not supported method: getSolver void (*)( ::btSoftBody *,::btScalar,::btScalar ) * (*)( ::btSoftBody::ePSolver::_ )
// error:  - unsupported,  - unsupported

//not supported method: getSolver void (*)( ::btSoftBody *,::btScalar ) * (*)( ::btSoftBody::eVSolver::_ )
// error:  - unsupported,  - unsupported

void btSoftBody_applyForces(void *c); //method: applyForces void ( ::btSoftBody::* )(  ) 
void btSoftBody_appendTetra(void *c,int p0,void* p1); //method: appendTetra void ( ::btSoftBody::* )( int,::btSoftBody::Material * ) 
void btSoftBody_appendTetra0(void *c,int p0,void* p1); //method: appendTetra void ( ::btSoftBody::* )( int,::btSoftBody::Material * ) 
void btSoftBody_appendTetra1(void *c,int p0,int p1,int p2,int p3,void* p4); //method: appendTetra void ( ::btSoftBody::* )( int,int,int,int,::btSoftBody::Material * ) 
void btSoftBody_m_anchors_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSoftBody::Anchor> btSoftBody->m_anchors
void* btSoftBody_m_anchors_get(void *c); //attribute: ::btAlignedObjectArray<btSoftBody::Anchor> btSoftBody->m_anchors
void btSoftBody_m_bUpdateRtCst_set(void *c,int a); //attribute: bool btSoftBody->m_bUpdateRtCst
int btSoftBody_m_bUpdateRtCst_get(void *c); //attribute: bool btSoftBody->m_bUpdateRtCst
// attribute not supported: //attribute: ::btVector3[2] btSoftBody->m_bounds
void btSoftBody_m_cdbvt_set(void *c,void* a); //attribute: ::btDbvt btSoftBody->m_cdbvt
void* btSoftBody_m_cdbvt_get(void *c); //attribute: ::btDbvt btSoftBody->m_cdbvt
void btSoftBody_m_cfg_set(void *c,void* a); //attribute: ::btSoftBody::Config btSoftBody->m_cfg
void* btSoftBody_m_cfg_get(void *c); //attribute: ::btSoftBody::Config btSoftBody->m_cfg
void btSoftBody_m_clusterConnectivity_set(void *c,void* a); //attribute: ::btAlignedObjectArray<bool> btSoftBody->m_clusterConnectivity
void* btSoftBody_m_clusterConnectivity_get(void *c); //attribute: ::btAlignedObjectArray<bool> btSoftBody->m_clusterConnectivity
void btSoftBody_m_clusters_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSoftBody::Cluster*> btSoftBody->m_clusters
void* btSoftBody_m_clusters_get(void *c); //attribute: ::btAlignedObjectArray<btSoftBody::Cluster*> btSoftBody->m_clusters
void btSoftBody_m_collisionDisabledObjects_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btCollisionObject*> btSoftBody->m_collisionDisabledObjects
void* btSoftBody_m_collisionDisabledObjects_get(void *c); //attribute: ::btAlignedObjectArray<btCollisionObject*> btSoftBody->m_collisionDisabledObjects
void btSoftBody_m_faces_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSoftBody::Face> btSoftBody->m_faces
void* btSoftBody_m_faces_get(void *c); //attribute: ::btAlignedObjectArray<btSoftBody::Face> btSoftBody->m_faces
void btSoftBody_m_fdbvt_set(void *c,void* a); //attribute: ::btDbvt btSoftBody->m_fdbvt
void* btSoftBody_m_fdbvt_get(void *c); //attribute: ::btDbvt btSoftBody->m_fdbvt
void btSoftBody_m_initialWorldTransform_set(void *c,float* a); //attribute: ::btTransform btSoftBody->m_initialWorldTransform
void btSoftBody_m_initialWorldTransform_get(void *c,float* a);
void btSoftBody_m_joints_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSoftBody::Joint*> btSoftBody->m_joints
void* btSoftBody_m_joints_get(void *c); //attribute: ::btAlignedObjectArray<btSoftBody::Joint*> btSoftBody->m_joints
void btSoftBody_m_links_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSoftBody::Link> btSoftBody->m_links
void* btSoftBody_m_links_get(void *c); //attribute: ::btAlignedObjectArray<btSoftBody::Link> btSoftBody->m_links
void btSoftBody_m_materials_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSoftBody::Material*> btSoftBody->m_materials
void* btSoftBody_m_materials_get(void *c); //attribute: ::btAlignedObjectArray<btSoftBody::Material*> btSoftBody->m_materials
void btSoftBody_m_ndbvt_set(void *c,void* a); //attribute: ::btDbvt btSoftBody->m_ndbvt
void* btSoftBody_m_ndbvt_get(void *c); //attribute: ::btDbvt btSoftBody->m_ndbvt
void btSoftBody_m_nodes_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSoftBody::Node> btSoftBody->m_nodes
void* btSoftBody_m_nodes_get(void *c); //attribute: ::btAlignedObjectArray<btSoftBody::Node> btSoftBody->m_nodes
void btSoftBody_m_notes_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSoftBody::Note> btSoftBody->m_notes
void* btSoftBody_m_notes_get(void *c); //attribute: ::btAlignedObjectArray<btSoftBody::Note> btSoftBody->m_notes
void btSoftBody_m_pose_set(void *c,void* a); //attribute: ::btSoftBody::Pose btSoftBody->m_pose
void* btSoftBody_m_pose_get(void *c); //attribute: ::btSoftBody::Pose btSoftBody->m_pose
void btSoftBody_m_rcontacts_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSoftBody::RContact> btSoftBody->m_rcontacts
void* btSoftBody_m_rcontacts_get(void *c); //attribute: ::btAlignedObjectArray<btSoftBody::RContact> btSoftBody->m_rcontacts
void btSoftBody_m_scontacts_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSoftBody::SContact> btSoftBody->m_scontacts
void* btSoftBody_m_scontacts_get(void *c); //attribute: ::btAlignedObjectArray<btSoftBody::SContact> btSoftBody->m_scontacts
// attribute not supported: //attribute: ::btSoftBodySolver * btSoftBody->m_softBodySolver
void btSoftBody_m_sst_set(void *c,void* a); //attribute: ::btSoftBody::SolverState btSoftBody->m_sst
void* btSoftBody_m_sst_get(void *c); //attribute: ::btSoftBody::SolverState btSoftBody->m_sst
void btSoftBody_m_tag_set(void *c,void* a); //attribute: void * btSoftBody->m_tag
void* btSoftBody_m_tag_get(void *c); //attribute: void * btSoftBody->m_tag
void btSoftBody_m_tetras_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSoftBody::Tetra> btSoftBody->m_tetras
void* btSoftBody_m_tetras_get(void *c); //attribute: ::btAlignedObjectArray<btSoftBody::Tetra> btSoftBody->m_tetras
void btSoftBody_m_timeacc_set(void *c,float a); //attribute: ::btScalar btSoftBody->m_timeacc
float btSoftBody_m_timeacc_get(void *c); //attribute: ::btScalar btSoftBody->m_timeacc
void btSoftBody_m_userIndexMapping_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btSoftBody->m_userIndexMapping
void* btSoftBody_m_userIndexMapping_get(void *c); //attribute: ::btAlignedObjectArray<int> btSoftBody->m_userIndexMapping
void btSoftBody_m_windVelocity_set(void *c,float* a); //attribute: ::btVector3 btSoftBody->m_windVelocity
void btSoftBody_m_windVelocity_get(void *c,float* a);
void btSoftBody_m_worldInfo_set(void *c,void* a); //attribute: ::btSoftBodyWorldInfo * btSoftBody->m_worldInfo
void* btSoftBody_m_worldInfo_get(void *c); //attribute: ::btSoftBodyWorldInfo * btSoftBody->m_worldInfo
void* btSoftBodyHelpers_new(); //constructor: btSoftBodyHelpers  ( ::btSoftBodyHelpers::* )(  ) 
void btSoftBodyHelpers_free(void *c); 
void btSoftBodyHelpers_DrawInfos(void* p0,void* p1,int p2,int p3,int p4); //method: DrawInfos void (*)( ::btSoftBody *,::btIDebugDraw *,bool,bool,bool )
void btSoftBodyHelpers_Draw(void* p0,void* p1,int p2); //method: Draw void (*)( ::btSoftBody *,::btIDebugDraw *,int )
void* btSoftBodyHelpers_CreateEllipsoid(void* p0,float* p1,float* p2,int p3); //method: CreateEllipsoid ::btSoftBody * (*)( ::btSoftBodyWorldInfo &,::btVector3 const &,::btVector3 const &,int )
void* btSoftBodyHelpers_CreateFromTetGenData(void* p0,char const * p1,char const * p2,char const * p3,int p4,int p5,int p6); //method: CreateFromTetGenData ::btSoftBody * (*)( ::btSoftBodyWorldInfo &,char const *,char const *,char const *,bool,bool,bool )
void btSoftBodyHelpers_DrawFrame(void* p0,void* p1); //method: DrawFrame void (*)( ::btSoftBody *,::btIDebugDraw * )
void* btSoftBodyHelpers_CreateRope(void* p0,float* p1,float* p2,int p3,int p4); //method: CreateRope ::btSoftBody * (*)( ::btSoftBodyWorldInfo &,::btVector3 const &,::btVector3 const &,int,int )
float btSoftBodyHelpers_CalculateUV(int p0,int p1,int p2,int p3,int p4); //method: CalculateUV float (*)( int,int,int,int,int )
void btSoftBodyHelpers_DrawFaceTree(void* p0,void* p1,int p2,int p3); //method: DrawFaceTree void (*)( ::btSoftBody *,::btIDebugDraw *,int,int )
void btSoftBodyHelpers_DrawClusterTree(void* p0,void* p1,int p2,int p3); //method: DrawClusterTree void (*)( ::btSoftBody *,::btIDebugDraw *,int,int )
//not supported method: CreateFromTriMesh ::btSoftBody * (*)( ::btSoftBodyWorldInfo &,::btScalar const *,int const *,int,bool )
// error: ::btSoftBodyWorldInfo & - ok,  - unsupported,  - unsupported, int - ok, bool - ok, ::btSoftBody * - ok

void btSoftBodyHelpers_DrawNodeTree(void* p0,void* p1,int p2,int p3); //method: DrawNodeTree void (*)( ::btSoftBody *,::btIDebugDraw *,int,int )
//not supported method: CreateFromConvexHull ::btSoftBody * (*)( ::btSoftBodyWorldInfo &,::btVector3 const *,int,bool )
// error: ::btSoftBodyWorldInfo & - ok,  - unsupported, int - ok, bool - ok, ::btSoftBody * - ok

void* btSoftBodyHelpers_CreatePatch(void* p0,float* p1,float* p2,float* p3,float* p4,int p5,int p6,int p7,int p8); //method: CreatePatch ::btSoftBody * (*)( ::btSoftBodyWorldInfo &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,int,int,int,bool )
//not supported method: CreatePatchUV ::btSoftBody * (*)( ::btSoftBodyWorldInfo &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,int,int,int,bool,float * )
// error: ::btSoftBodyWorldInfo & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, int - ok, int - ok, int - ok, bool - ok,  - unsupported, ::btSoftBody * - ok

void* btSoftBodyRigidBodyCollisionConfiguration_new(void* p0); //constructor: btSoftBodyRigidBodyCollisionConfiguration  ( ::btSoftBodyRigidBodyCollisionConfiguration::* )( ::btDefaultCollisionConstructionInfo const & ) 
void btSoftBodyRigidBodyCollisionConfiguration_free(void *c); 
void* btSoftBodyRigidBodyCollisionConfiguration_getCollisionAlgorithmCreateFunc(void *c,int p0,int p1); //method: getCollisionAlgorithmCreateFunc ::btCollisionAlgorithmCreateFunc * ( ::btSoftBodyRigidBodyCollisionConfiguration::* )( int,int ) 
void btSoftBodyRigidBodyCollisionConfiguration_m_softSoftCreateFunc_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btSoftBodyRigidBodyCollisionConfiguration->m_softSoftCreateFunc
void* btSoftBodyRigidBodyCollisionConfiguration_m_softSoftCreateFunc_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btSoftBodyRigidBodyCollisionConfiguration->m_softSoftCreateFunc
void btSoftBodyRigidBodyCollisionConfiguration_m_softRigidConvexCreateFunc_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btSoftBodyRigidBodyCollisionConfiguration->m_softRigidConvexCreateFunc
void* btSoftBodyRigidBodyCollisionConfiguration_m_softRigidConvexCreateFunc_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btSoftBodyRigidBodyCollisionConfiguration->m_softRigidConvexCreateFunc
void btSoftBodyRigidBodyCollisionConfiguration_m_swappedSoftRigidConvexCreateFunc_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btSoftBodyRigidBodyCollisionConfiguration->m_swappedSoftRigidConvexCreateFunc
void* btSoftBodyRigidBodyCollisionConfiguration_m_swappedSoftRigidConvexCreateFunc_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btSoftBodyRigidBodyCollisionConfiguration->m_swappedSoftRigidConvexCreateFunc
void btSoftBodyRigidBodyCollisionConfiguration_m_softRigidConcaveCreateFunc_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btSoftBodyRigidBodyCollisionConfiguration->m_softRigidConcaveCreateFunc
void* btSoftBodyRigidBodyCollisionConfiguration_m_softRigidConcaveCreateFunc_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btSoftBodyRigidBodyCollisionConfiguration->m_softRigidConcaveCreateFunc
void btSoftBodyRigidBodyCollisionConfiguration_m_swappedSoftRigidConcaveCreateFunc_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btSoftBodyRigidBodyCollisionConfiguration->m_swappedSoftRigidConcaveCreateFunc
void* btSoftBodyRigidBodyCollisionConfiguration_m_swappedSoftRigidConcaveCreateFunc_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btSoftBodyRigidBodyCollisionConfiguration->m_swappedSoftRigidConcaveCreateFunc
void* btSoftBodyWorldInfo_new(); //constructor: btSoftBodyWorldInfo  ( ::btSoftBodyWorldInfo::* )(  ) 
void btSoftBodyWorldInfo_free(void *c); 
void btSoftBodyWorldInfo_air_density_set(void *c,float a); //attribute: ::btScalar btSoftBodyWorldInfo->air_density
float btSoftBodyWorldInfo_air_density_get(void *c); //attribute: ::btScalar btSoftBodyWorldInfo->air_density
void btSoftBodyWorldInfo_m_broadphase_set(void *c,void* a); //attribute: ::btBroadphaseInterface * btSoftBodyWorldInfo->m_broadphase
void* btSoftBodyWorldInfo_m_broadphase_get(void *c); //attribute: ::btBroadphaseInterface * btSoftBodyWorldInfo->m_broadphase
void btSoftBodyWorldInfo_m_dispatcher_set(void *c,void* a); //attribute: ::btDispatcher * btSoftBodyWorldInfo->m_dispatcher
void* btSoftBodyWorldInfo_m_dispatcher_get(void *c); //attribute: ::btDispatcher * btSoftBodyWorldInfo->m_dispatcher
void btSoftBodyWorldInfo_m_gravity_set(void *c,float* a); //attribute: ::btVector3 btSoftBodyWorldInfo->m_gravity
void btSoftBodyWorldInfo_m_gravity_get(void *c,float* a);
void btSoftBodyWorldInfo_m_sparsesdf_set(void *c,void* a); //attribute: ::btSparseSdf<3> btSoftBodyWorldInfo->m_sparsesdf
void* btSoftBodyWorldInfo_m_sparsesdf_get(void *c); //attribute: ::btSparseSdf<3> btSoftBodyWorldInfo->m_sparsesdf
void btSoftBodyWorldInfo_water_density_set(void *c,float a); //attribute: ::btScalar btSoftBodyWorldInfo->water_density
float btSoftBodyWorldInfo_water_density_get(void *c); //attribute: ::btScalar btSoftBodyWorldInfo->water_density
void btSoftBodyWorldInfo_water_normal_set(void *c,float* a); //attribute: ::btVector3 btSoftBodyWorldInfo->water_normal
void btSoftBodyWorldInfo_water_normal_get(void *c,float* a);
void btSoftBodyWorldInfo_water_offset_set(void *c,float a); //attribute: ::btScalar btSoftBodyWorldInfo->water_offset
float btSoftBodyWorldInfo_water_offset_get(void *c); //attribute: ::btScalar btSoftBodyWorldInfo->water_offset
//not supported constructor: btSoftRigidDynamicsWorld  ( ::btSoftRigidDynamicsWorld::* )( ::btDispatcher *,::btBroadphaseInterface *,::btConstraintSolver *,::btCollisionConfiguration *,::btSoftBodySolver * ) 
// error: ::btDispatcher * - ok, ::btBroadphaseInterface * - ok, ::btConstraintSolver * - ok, ::btCollisionConfiguration * - ok,  - unsupported

void btSoftRigidDynamicsWorld_free(void *c); 
void btSoftRigidDynamicsWorld_predictUnconstraintMotion(void *c,float p0); //method: predictUnconstraintMotion void ( ::btSoftRigidDynamicsWorld::* )( ::btScalar ) 
void* btSoftRigidDynamicsWorld_getWorldInfo(void *c); //method: getWorldInfo ::btSoftBodyWorldInfo & ( ::btSoftRigidDynamicsWorld::* )(  ) 
void* btSoftRigidDynamicsWorld_getWorldInfo0(void *c); //method: getWorldInfo ::btSoftBodyWorldInfo & ( ::btSoftRigidDynamicsWorld::* )(  ) 
void* btSoftRigidDynamicsWorld_getWorldInfo1(void *c); //method: getWorldInfo ::btSoftBodyWorldInfo const & ( ::btSoftRigidDynamicsWorld::* )(  ) const
void btSoftRigidDynamicsWorld_setDrawFlags(void *c,int p0); //method: setDrawFlags void ( ::btSoftRigidDynamicsWorld::* )( int ) 
void* btSoftRigidDynamicsWorld_getSoftBodyArray(void *c); //method: getSoftBodyArray ::btSoftBodyArray & ( ::btSoftRigidDynamicsWorld::* )(  ) 
void* btSoftRigidDynamicsWorld_getSoftBodyArray0(void *c); //method: getSoftBodyArray ::btSoftBodyArray & ( ::btSoftRigidDynamicsWorld::* )(  ) 
void* btSoftRigidDynamicsWorld_getSoftBodyArray1(void *c); //method: getSoftBodyArray ::btSoftBodyArray const & ( ::btSoftRigidDynamicsWorld::* )(  ) const
void btSoftRigidDynamicsWorld_serialize(void *c,void* p0); //method: serialize void ( ::btSoftRigidDynamicsWorld::* )( ::btSerializer * ) 
void btSoftRigidDynamicsWorld_rayTest(void *c,float* p0,float* p1,void* p2); //method: rayTest void ( ::btSoftRigidDynamicsWorld::* )( ::btVector3 const &,::btVector3 const &,::btCollisionWorld::RayResultCallback & ) const
//not supported method: getWorldType ::btDynamicsWorldType ( ::btSoftRigidDynamicsWorld::* )(  ) const
// error:  - unsupported

void btSoftRigidDynamicsWorld_solveSoftBodiesConstraints(void *c,float p0); //method: solveSoftBodiesConstraints void ( ::btSoftRigidDynamicsWorld::* )( ::btScalar ) 
void btSoftRigidDynamicsWorld_removeCollisionObject(void *c,void* p0); //method: removeCollisionObject void ( ::btSoftRigidDynamicsWorld::* )( ::btCollisionObject * ) 
void btSoftRigidDynamicsWorld_addSoftBody(void *c,void* p0,short int p1,short int p2); //method: addSoftBody void ( ::btSoftRigidDynamicsWorld::* )( ::btSoftBody *,short int,short int ) 
void btSoftRigidDynamicsWorld_rayTestSingle(float* p0,float* p1,void* p2,void* p3,float* p4,void* p5); //method: rayTestSingle void (*)( ::btTransform const &,::btTransform const &,::btCollisionObject *,::btCollisionShape const *,::btTransform const &,::btCollisionWorld::RayResultCallback & )
void btSoftRigidDynamicsWorld_internalSingleStepSimulation(void *c,float p0); //method: internalSingleStepSimulation void ( ::btSoftRigidDynamicsWorld::* )( ::btScalar ) 
void btSoftRigidDynamicsWorld_serializeSoftBodies(void *c,void* p0); //method: serializeSoftBodies void ( ::btSoftRigidDynamicsWorld::* )( ::btSerializer * ) 
void btSoftRigidDynamicsWorld_removeSoftBody(void *c,void* p0); //method: removeSoftBody void ( ::btSoftRigidDynamicsWorld::* )( ::btSoftBody * ) 
int btSoftRigidDynamicsWorld_getDrawFlags(void *c); //method: getDrawFlags int ( ::btSoftRigidDynamicsWorld::* )(  ) const
void btSoftRigidDynamicsWorld_debugDrawWorld(void *c); //method: debugDrawWorld void ( ::btSoftRigidDynamicsWorld::* )(  ) 
void btSoftRigidDynamicsWorld_m_softBodies_set(void *c,void* a); //attribute: ::btSoftBodyArray btSoftRigidDynamicsWorld->m_softBodies
void* btSoftRigidDynamicsWorld_m_softBodies_get(void *c); //attribute: ::btSoftBodyArray btSoftRigidDynamicsWorld->m_softBodies
void btSoftRigidDynamicsWorld_m_drawFlags_set(void *c,int a); //attribute: int btSoftRigidDynamicsWorld->m_drawFlags
int btSoftRigidDynamicsWorld_m_drawFlags_get(void *c); //attribute: int btSoftRigidDynamicsWorld->m_drawFlags
void btSoftRigidDynamicsWorld_m_drawNodeTree_set(void *c,int a); //attribute: bool btSoftRigidDynamicsWorld->m_drawNodeTree
int btSoftRigidDynamicsWorld_m_drawNodeTree_get(void *c); //attribute: bool btSoftRigidDynamicsWorld->m_drawNodeTree
void btSoftRigidDynamicsWorld_m_drawFaceTree_set(void *c,int a); //attribute: bool btSoftRigidDynamicsWorld->m_drawFaceTree
int btSoftRigidDynamicsWorld_m_drawFaceTree_get(void *c); //attribute: bool btSoftRigidDynamicsWorld->m_drawFaceTree
void btSoftRigidDynamicsWorld_m_drawClusterTree_set(void *c,int a); //attribute: bool btSoftRigidDynamicsWorld->m_drawClusterTree
int btSoftRigidDynamicsWorld_m_drawClusterTree_get(void *c); //attribute: bool btSoftRigidDynamicsWorld->m_drawClusterTree
void btSoftRigidDynamicsWorld_m_sbi_set(void *c,void* a); //attribute: ::btSoftBodyWorldInfo btSoftRigidDynamicsWorld->m_sbi
void* btSoftRigidDynamicsWorld_m_sbi_get(void *c); //attribute: ::btSoftBodyWorldInfo btSoftRigidDynamicsWorld->m_sbi
// attribute not supported: //attribute: ::btSoftBodySolver * btSoftRigidDynamicsWorld->m_softBodySolver
void btSoftRigidDynamicsWorld_m_ownsSolver_set(void *c,int a); //attribute: bool btSoftRigidDynamicsWorld->m_ownsSolver
int btSoftRigidDynamicsWorld_m_ownsSolver_get(void *c); //attribute: bool btSoftRigidDynamicsWorld->m_ownsSolver
void* btSparseSdf_3__new(); //constructor: btSparseSdf  ( ::btSparseSdf<3>::* )(  ) 
void btSparseSdf_3__free(void *c); 
void btSparseSdf_3__Reset(void *c); //method: Reset void ( ::btSparseSdf<3>::* )(  ) 
unsigned int btSparseSdf_3__Hash(int p0,int p1,int p2,void* p3); //method: Hash unsigned int (*)( int,int,int,::btCollisionShape * )
int btSparseSdf_3__RemoveReferences(void *c,void* p0); //method: RemoveReferences int ( ::btSparseSdf<3>::* )( ::btCollisionShape * ) 
float btSparseSdf_3__Lerp(float p0,float p1,float p2); //method: Lerp ::btScalar (*)( ::btScalar,::btScalar,::btScalar )
float btSparseSdf_3__Evaluate(void *c,float* p0,void* p1,float* p2,float p3); //method: Evaluate ::btScalar ( ::btSparseSdf<3>::* )( ::btVector3 const &,::btCollisionShape *,::btVector3 &,::btScalar ) 
void btSparseSdf_3__GarbageCollect(void *c,int p0); //method: GarbageCollect void ( ::btSparseSdf<3>::* )( int ) 
//not supported method: BuildCell void ( ::btSparseSdf<3>::* )( ::btSparseSdf<3>::Cell & ) 
// error:  - unsupported, void - ok

float btSparseSdf_3__DistanceToShape(float* p0,void* p1); //method: DistanceToShape ::btScalar (*)( ::btVector3 const &,::btCollisionShape * )
void btSparseSdf_3__Initialize(void *c,int p0); //method: Initialize void ( ::btSparseSdf<3>::* )( int ) 
//not supported method: Decompose ::btSparseSdf<3>::IntFrac (*)( ::btScalar )
// error: ::btScalar - ok,  - unsupported

void btSparseSdf_3__cells_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btSparseSdf<3>::Cell*> btSparseSdf_3_->cells
void* btSparseSdf_3__cells_get(void *c); //attribute: ::btAlignedObjectArray<btSparseSdf<3>::Cell*> btSparseSdf_3_->cells
void btSparseSdf_3__ncells_set(void *c,int a); //attribute: int btSparseSdf_3_->ncells
int btSparseSdf_3__ncells_get(void *c); //attribute: int btSparseSdf_3_->ncells
void btSparseSdf_3__nprobes_set(void *c,int a); //attribute: int btSparseSdf_3_->nprobes
int btSparseSdf_3__nprobes_get(void *c); //attribute: int btSparseSdf_3_->nprobes
void btSparseSdf_3__nqueries_set(void *c,int a); //attribute: int btSparseSdf_3_->nqueries
int btSparseSdf_3__nqueries_get(void *c); //attribute: int btSparseSdf_3_->nqueries
void btSparseSdf_3__puid_set(void *c,int a); //attribute: int btSparseSdf_3_->puid
int btSparseSdf_3__puid_get(void *c); //attribute: int btSparseSdf_3_->puid
void btSparseSdf_3__voxelsz_set(void *c,float a); //attribute: ::btScalar btSparseSdf_3_->voxelsz
float btSparseSdf_3__voxelsz_get(void *c); //attribute: ::btScalar btSparseSdf_3_->voxelsz
void* btSoftBody_eAeroModel_new(); //constructor: eAeroModel  ( ::btSoftBody::eAeroModel::* )(  ) 
void btSoftBody_eAeroModel_free(void *c); 
void* btSoftBody_eFeature_new(); //constructor: eFeature  ( ::btSoftBody::eFeature::* )(  ) 
void btSoftBody_eFeature_free(void *c); 
void* btSoftBody_ePSolver_new(); //constructor: ePSolver  ( ::btSoftBody::ePSolver::* )(  ) 
void btSoftBody_ePSolver_free(void *c); 
void* btSoftBody_eSolverPresets_new(); //constructor: eSolverPresets  ( ::btSoftBody::eSolverPresets::* )(  ) 
void btSoftBody_eSolverPresets_free(void *c); 
void* btSoftBody_Joint_eType_new(); //constructor: eType  ( ::btSoftBody::Joint::eType::* )(  ) 
void btSoftBody_Joint_eType_free(void *c); 
void* btSoftBody_eVSolver_new(); //constructor: eVSolver  ( ::btSoftBody::eVSolver::* )(  ) 
void btSoftBody_eVSolver_free(void *c); 
void* btSoftBody_fCollision_new(); //constructor: fCollision  ( ::btSoftBody::fCollision::* )(  ) 
void btSoftBody_fCollision_free(void *c); 
void* fDrawFlags_new(); //constructor: fDrawFlags  ( ::fDrawFlags::* )(  ) 
void fDrawFlags_free(void *c); 
void* btSoftBody_fMaterial_new(); //constructor: fMaterial  ( ::btSoftBody::fMaterial::* )(  ) 
void btSoftBody_fMaterial_free(void *c); 
void* btSoftBody_sCti_new(); //constructor: sCti  ( ::btSoftBody::sCti::* )(  ) 
void btSoftBody_sCti_free(void *c); 
void btSoftBody_sCti_m_colObj_set(void *c,void* a); //attribute: ::btCollisionObject * btSoftBody_sCti->m_colObj
void* btSoftBody_sCti_m_colObj_get(void *c); //attribute: ::btCollisionObject * btSoftBody_sCti->m_colObj
void btSoftBody_sCti_m_normal_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_sCti->m_normal
void btSoftBody_sCti_m_normal_get(void *c,float* a);
void btSoftBody_sCti_m_offset_set(void *c,float a); //attribute: ::btScalar btSoftBody_sCti->m_offset
float btSoftBody_sCti_m_offset_get(void *c); //attribute: ::btScalar btSoftBody_sCti->m_offset
void* btSoftBody_sMedium_new(); //constructor: sMedium  ( ::btSoftBody::sMedium::* )(  ) 
void btSoftBody_sMedium_free(void *c); 
void btSoftBody_sMedium_m_density_set(void *c,float a); //attribute: ::btScalar btSoftBody_sMedium->m_density
float btSoftBody_sMedium_m_density_get(void *c); //attribute: ::btScalar btSoftBody_sMedium->m_density
void btSoftBody_sMedium_m_pressure_set(void *c,float a); //attribute: ::btScalar btSoftBody_sMedium->m_pressure
float btSoftBody_sMedium_m_pressure_get(void *c); //attribute: ::btScalar btSoftBody_sMedium->m_pressure
void btSoftBody_sMedium_m_velocity_set(void *c,float* a); //attribute: ::btVector3 btSoftBody_sMedium->m_velocity
void btSoftBody_sMedium_m_velocity_get(void *c,float* a);
void* btSoftBody_sRayCast_new(); //constructor: sRayCast  ( ::btSoftBody::sRayCast::* )(  ) 
void btSoftBody_sRayCast_free(void *c); 
void btSoftBody_sRayCast_body_set(void *c,void* a); //attribute: ::btSoftBody * btSoftBody_sRayCast->body
void* btSoftBody_sRayCast_body_get(void *c); //attribute: ::btSoftBody * btSoftBody_sRayCast->body
// attribute not supported: //attribute: ::btSoftBody::eFeature::_ btSoftBody_sRayCast->feature
void btSoftBody_sRayCast_fraction_set(void *c,float a); //attribute: ::btScalar btSoftBody_sRayCast->fraction
float btSoftBody_sRayCast_fraction_get(void *c); //attribute: ::btScalar btSoftBody_sRayCast->fraction
void btSoftBody_sRayCast_index_set(void *c,int a); //attribute: int btSoftBody_sRayCast->index
int btSoftBody_sRayCast_index_get(void *c); //attribute: int btSoftBody_sRayCast->index
void* cProfileIterator_new(void* p0); //constructor: CProfileIterator  ( ::CProfileIterator::* )( ::CProfileNode * ) 
void cProfileIterator_free(void *c); 
char const * cProfileIterator_Get_Current_Name(void *c); //method: Get_Current_Name char const * ( ::CProfileIterator::* )(  ) 
int cProfileIterator_Get_Current_Total_Calls(void *c); //method: Get_Current_Total_Calls int ( ::CProfileIterator::* )(  ) 
float cProfileIterator_Get_Current_Total_Time(void *c); //method: Get_Current_Total_Time float ( ::CProfileIterator::* )(  ) 
void cProfileIterator_Enter_Child(void *c,int p0); //method: Enter_Child void ( ::CProfileIterator::* )( int ) 
int cProfileIterator_Is_Done(void *c); //method: Is_Done bool ( ::CProfileIterator::* )(  ) 
void cProfileIterator_Next(void *c); //method: Next void ( ::CProfileIterator::* )(  ) 
int cProfileIterator_Is_Root(void *c); //method: Is_Root bool ( ::CProfileIterator::* )(  ) 
char const * cProfileIterator_Get_Current_Parent_Name(void *c); //method: Get_Current_Parent_Name char const * ( ::CProfileIterator::* )(  ) 
void* cProfileIterator_Get_Current_UserPointer(void *c); //method: Get_Current_UserPointer void * ( ::CProfileIterator::* )(  ) 
int cProfileIterator_Get_Current_Parent_Total_Calls(void *c); //method: Get_Current_Parent_Total_Calls int ( ::CProfileIterator::* )(  ) 
void cProfileIterator_Set_Current_UserPointer(void *c,void* p0); //method: Set_Current_UserPointer void ( ::CProfileIterator::* )( void * ) 
float cProfileIterator_Get_Current_Parent_Total_Time(void *c); //method: Get_Current_Parent_Total_Time float ( ::CProfileIterator::* )(  ) 
void cProfileIterator_Enter_Parent(void *c); //method: Enter_Parent void ( ::CProfileIterator::* )(  ) 
void cProfileIterator_First(void *c); //method: First void ( ::CProfileIterator::* )(  ) 
void cProfileIterator_CurrentParent_set(void *c,void* a); //attribute: ::CProfileNode * cProfileIterator->CurrentParent
void* cProfileIterator_CurrentParent_get(void *c); //attribute: ::CProfileNode * cProfileIterator->CurrentParent
void cProfileIterator_CurrentChild_set(void *c,void* a); //attribute: ::CProfileNode * cProfileIterator->CurrentChild
void* cProfileIterator_CurrentChild_get(void *c); //attribute: ::CProfileNode * cProfileIterator->CurrentChild
void* cProfileManager_new(); //constructor: CProfileManager  ( ::CProfileManager::* )(  ) 
void cProfileManager_free(void *c); 
void cProfileManager_Reset(); //method: Reset void (*)(  )
void cProfileManager_dumpAll(); //method: dumpAll void (*)(  )
int cProfileManager_Get_Frame_Count_Since_Reset(); //method: Get_Frame_Count_Since_Reset int (*)(  )
void cProfileManager_Release_Iterator(void* p0); //method: Release_Iterator void (*)( ::CProfileIterator * )
void cProfileManager_Stop_Profile(); //method: Stop_Profile void (*)(  )
void cProfileManager_CleanupMemory(); //method: CleanupMemory void (*)(  )
float cProfileManager_Get_Time_Since_Reset(); //method: Get_Time_Since_Reset float (*)(  )
void cProfileManager_Start_Profile(char const * p0); //method: Start_Profile void (*)( char const * )
void cProfileManager_Increment_Frame_Counter(); //method: Increment_Frame_Counter void (*)(  )
void cProfileManager_dumpRecursive(void* p0,int p1); //method: dumpRecursive void (*)( ::CProfileIterator *,int )
void* cProfileManager_Get_Iterator(); //method: Get_Iterator ::CProfileIterator * (*)(  )
void cProfileManager_Root_set(void *c,void* a); //attribute: ::CProfileNode cProfileManager->Root
void* cProfileManager_Root_get(void *c); //attribute: ::CProfileNode cProfileManager->Root
void cProfileManager_CurrentNode_set(void *c,void* a); //attribute: ::CProfileNode * cProfileManager->CurrentNode
void* cProfileManager_CurrentNode_get(void *c); //attribute: ::CProfileNode * cProfileManager->CurrentNode
void cProfileManager_FrameCounter_set(void *c,int a); //attribute: int cProfileManager->FrameCounter
int cProfileManager_FrameCounter_get(void *c); //attribute: int cProfileManager->FrameCounter
void cProfileManager_ResetTime_set(void *c,long unsigned int a); //attribute: long unsigned int cProfileManager->ResetTime
long unsigned int cProfileManager_ResetTime_get(void *c); //attribute: long unsigned int cProfileManager->ResetTime
void* cProfileNode_new(char const * p0,void* p1); //constructor: CProfileNode  ( ::CProfileNode::* )( char const *,::CProfileNode * ) 
void cProfileNode_free(void *c); 
void cProfileNode_Reset(void *c); //method: Reset void ( ::CProfileNode::* )(  ) 
int cProfileNode_Return(void *c); //method: Return bool ( ::CProfileNode::* )(  ) 
void cProfileNode_SetUserPointer(void *c,void* p0); //method: SetUserPointer void ( ::CProfileNode::* )( void * ) 
void* cProfileNode_Get_Sub_Node(void *c,char const * p0); //method: Get_Sub_Node ::CProfileNode * ( ::CProfileNode::* )( char const * ) 
void cProfileNode_CleanupMemory(void *c); //method: CleanupMemory void ( ::CProfileNode::* )(  ) 
void* cProfileNode_Get_Parent(void *c); //method: Get_Parent ::CProfileNode * ( ::CProfileNode::* )(  ) 
void* cProfileNode_GetUserPointer(void *c); //method: GetUserPointer void * ( ::CProfileNode::* )(  ) const
char const * cProfileNode_Get_Name(void *c); //method: Get_Name char const * ( ::CProfileNode::* )(  ) 
float cProfileNode_Get_Total_Time(void *c); //method: Get_Total_Time float ( ::CProfileNode::* )(  ) 
void cProfileNode_Call(void *c); //method: Call void ( ::CProfileNode::* )(  ) 
void* cProfileNode_Get_Sibling(void *c); //method: Get_Sibling ::CProfileNode * ( ::CProfileNode::* )(  ) 
void* cProfileNode_Get_Child(void *c); //method: Get_Child ::CProfileNode * ( ::CProfileNode::* )(  ) 
int cProfileNode_Get_Total_Calls(void *c); //method: Get_Total_Calls int ( ::CProfileNode::* )(  ) 
void cProfileNode_Child_set(void *c,void* a); //attribute: ::CProfileNode * cProfileNode->Child
void* cProfileNode_Child_get(void *c); //attribute: ::CProfileNode * cProfileNode->Child
void cProfileNode_Name_set(void *c,char const * a); //attribute: char const * cProfileNode->Name
char const * cProfileNode_Name_get(void *c); //attribute: char const * cProfileNode->Name
void cProfileNode_Parent_set(void *c,void* a); //attribute: ::CProfileNode * cProfileNode->Parent
void* cProfileNode_Parent_get(void *c); //attribute: ::CProfileNode * cProfileNode->Parent
void cProfileNode_RecursionCounter_set(void *c,int a); //attribute: int cProfileNode->RecursionCounter
int cProfileNode_RecursionCounter_get(void *c); //attribute: int cProfileNode->RecursionCounter
void cProfileNode_Sibling_set(void *c,void* a); //attribute: ::CProfileNode * cProfileNode->Sibling
void* cProfileNode_Sibling_get(void *c); //attribute: ::CProfileNode * cProfileNode->Sibling
void cProfileNode_StartTime_set(void *c,long unsigned int a); //attribute: long unsigned int cProfileNode->StartTime
long unsigned int cProfileNode_StartTime_get(void *c); //attribute: long unsigned int cProfileNode->StartTime
void cProfileNode_TotalCalls_set(void *c,int a); //attribute: int cProfileNode->TotalCalls
int cProfileNode_TotalCalls_get(void *c); //attribute: int cProfileNode->TotalCalls
void cProfileNode_TotalTime_set(void *c,float a); //attribute: float cProfileNode->TotalTime
float cProfileNode_TotalTime_get(void *c); //attribute: float cProfileNode->TotalTime
void cProfileNode_m_userPtr_set(void *c,void* a); //attribute: void * cProfileNode->m_userPtr
void* cProfileNode_m_userPtr_get(void *c); //attribute: void * cProfileNode->m_userPtr
void* cProfileSample_new(char const * p0); //constructor: CProfileSample  ( ::CProfileSample::* )( char const * ) 
void cProfileSample_free(void *c); 
void* btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )(  ) 
void btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__free(void *c); 
void btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )( ::BT_QUANTIZED_BVH_NODE * ) 
void btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )( ::BT_QUANTIZED_BVH_NODE * ) 
//not supported method: allocate ::BT_QUANTIZED_BVH_NODE * ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )( ::size_type,::BT_QUANTIZED_BVH_NODE const * * ) 
// error:  - unsupported,  - unsupported, ::BT_QUANTIZED_BVH_NODE * - ok

void btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )( ::BT_QUANTIZED_BVH_NODE *,::BT_QUANTIZED_BVH_NODE const & ) 
void* btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__address(void *c,void* p0); //method: address ::BT_QUANTIZED_BVH_NODE * ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )( ::BT_QUANTIZED_BVH_NODE & ) const
void* btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__address0(void *c,void* p0); //method: address ::BT_QUANTIZED_BVH_NODE * ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )( ::BT_QUANTIZED_BVH_NODE & ) const
void* btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u__address1(void *c,void* p0); //method: address ::BT_QUANTIZED_BVH_NODE const * ( ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>::* )( ::BT_QUANTIZED_BVH_NODE const & ) const
void* btAlignedAllocator_GIM_BVH_DATA_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )(  ) 
void btAlignedAllocator_GIM_BVH_DATA_16u__free(void *c); 
void btAlignedAllocator_GIM_BVH_DATA_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )( ::GIM_BVH_DATA * ) 
void btAlignedAllocator_GIM_BVH_DATA_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )( ::GIM_BVH_DATA * ) 
//not supported method: allocate ::GIM_BVH_DATA * ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )( ::size_type,::GIM_BVH_DATA const * * ) 
// error:  - unsupported,  - unsupported, ::GIM_BVH_DATA * - ok

void btAlignedAllocator_GIM_BVH_DATA_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )( ::GIM_BVH_DATA *,::GIM_BVH_DATA const & ) 
void* btAlignedAllocator_GIM_BVH_DATA_16u__address(void *c,void* p0); //method: address ::GIM_BVH_DATA * ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )( ::GIM_BVH_DATA & ) const
void* btAlignedAllocator_GIM_BVH_DATA_16u__address0(void *c,void* p0); //method: address ::GIM_BVH_DATA * ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )( ::GIM_BVH_DATA & ) const
void* btAlignedAllocator_GIM_BVH_DATA_16u__address1(void *c,void* p0); //method: address ::GIM_BVH_DATA const * ( ::btAlignedAllocator<GIM_BVH_DATA, 16u>::* )( ::GIM_BVH_DATA const & ) const
void* btAlignedAllocator_GIM_BVH_TREE_NODE_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )(  ) 
void btAlignedAllocator_GIM_BVH_TREE_NODE_16u__free(void *c); 
void btAlignedAllocator_GIM_BVH_TREE_NODE_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )( ::GIM_BVH_TREE_NODE * ) 
void btAlignedAllocator_GIM_BVH_TREE_NODE_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )( ::GIM_BVH_TREE_NODE * ) 
//not supported method: allocate ::GIM_BVH_TREE_NODE * ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )( ::size_type,::GIM_BVH_TREE_NODE const * * ) 
// error:  - unsupported,  - unsupported, ::GIM_BVH_TREE_NODE * - ok

void btAlignedAllocator_GIM_BVH_TREE_NODE_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )( ::GIM_BVH_TREE_NODE *,::GIM_BVH_TREE_NODE const & ) 
void* btAlignedAllocator_GIM_BVH_TREE_NODE_16u__address(void *c,void* p0); //method: address ::GIM_BVH_TREE_NODE * ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )( ::GIM_BVH_TREE_NODE & ) const
void* btAlignedAllocator_GIM_BVH_TREE_NODE_16u__address0(void *c,void* p0); //method: address ::GIM_BVH_TREE_NODE * ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )( ::GIM_BVH_TREE_NODE & ) const
void* btAlignedAllocator_GIM_BVH_TREE_NODE_16u__address1(void *c,void* p0); //method: address ::GIM_BVH_TREE_NODE const * ( ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>::* )( ::GIM_BVH_TREE_NODE const & ) const
void* btAlignedAllocator_GIM_PAIR_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )(  ) 
void btAlignedAllocator_GIM_PAIR_16u__free(void *c); 
void btAlignedAllocator_GIM_PAIR_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )( ::GIM_PAIR * ) 
void btAlignedAllocator_GIM_PAIR_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )( ::GIM_PAIR * ) 
//not supported method: allocate ::GIM_PAIR * ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )( ::size_type,::GIM_PAIR const * * ) 
// error:  - unsupported,  - unsupported, ::GIM_PAIR * - ok

void btAlignedAllocator_GIM_PAIR_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )( ::GIM_PAIR *,::GIM_PAIR const & ) 
void* btAlignedAllocator_GIM_PAIR_16u__address(void *c,void* p0); //method: address ::GIM_PAIR * ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )( ::GIM_PAIR & ) const
void* btAlignedAllocator_GIM_PAIR_16u__address0(void *c,void* p0); //method: address ::GIM_PAIR * ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )( ::GIM_PAIR & ) const
void* btAlignedAllocator_GIM_PAIR_16u__address1(void *c,void* p0); //method: address ::GIM_PAIR const * ( ::btAlignedAllocator<GIM_PAIR, 16u>::* )( ::GIM_PAIR const & ) const
void* btAlignedAllocator_bool_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<bool, 16u>::* )(  ) 
void btAlignedAllocator_bool_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<bool, 16u>::* )( bool * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<bool, 16u>::* )( bool * ) 
// error:  - unsupported, void - ok

//not supported method: allocate bool * ( ::btAlignedAllocator<bool, 16u>::* )( ::size_type,bool const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<bool, 16u>::* )( bool *,bool const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address bool * ( ::btAlignedAllocator<bool, 16u>::* )( bool & ) const
// error:  - unsupported,  - unsupported

//not supported method: address bool * ( ::btAlignedAllocator<bool, 16u>::* )( bool & ) const
// error:  - unsupported,  - unsupported

//not supported method: address bool const * ( ::btAlignedAllocator<bool, 16u>::* )( bool const & ) const
// error:  - unsupported,  - unsupported

void* btAlignedAllocator_btActionInterface_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btActionInterface*, 16u>::* )(  ) 
void btAlignedAllocator_btActionInterface_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btActionInterface*, 16u>::* )( ::btActionInterface * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btActionInterface*, 16u>::* )( ::btActionInterface * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btActionInterface * * ( ::btAlignedAllocator<btActionInterface*, 16u>::* )( ::size_type,::btActionInterface * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btActionInterface*, 16u>::* )( ::btActionInterface * *,::btActionInterface * const & ) 
// error:  - unsupported, ::btActionInterface * - ok, void - ok

//not supported method: address ::btActionInterface * * ( ::btAlignedAllocator<btActionInterface*, 16u>::* )( ::btActionInterface * & ) const
// error: ::btActionInterface * - ok,  - unsupported

//not supported method: address ::btActionInterface * * ( ::btAlignedAllocator<btActionInterface*, 16u>::* )( ::btActionInterface * & ) const
// error: ::btActionInterface * - ok,  - unsupported

//not supported method: address ::btActionInterface * const * ( ::btAlignedAllocator<btActionInterface*, 16u>::* )( ::btActionInterface * const & ) const
// error: ::btActionInterface * - ok,  - unsupported

void* btAlignedAllocator_btBroadphaseInterface_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )(  ) 
void btAlignedAllocator_btBroadphaseInterface_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )( ::btBroadphaseInterface * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )( ::btBroadphaseInterface * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btBroadphaseInterface * * ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )( ::size_type,::btBroadphaseInterface * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )( ::btBroadphaseInterface * *,::btBroadphaseInterface * const & ) 
// error:  - unsupported, ::btBroadphaseInterface * - ok, void - ok

//not supported method: address ::btBroadphaseInterface * * ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )( ::btBroadphaseInterface * & ) const
// error: ::btBroadphaseInterface * - ok,  - unsupported

//not supported method: address ::btBroadphaseInterface * * ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )( ::btBroadphaseInterface * & ) const
// error: ::btBroadphaseInterface * - ok,  - unsupported

//not supported method: address ::btBroadphaseInterface * const * ( ::btAlignedAllocator<btBroadphaseInterface*, 16u>::* )( ::btBroadphaseInterface * const & ) const
// error: ::btBroadphaseInterface * - ok,  - unsupported

void* btAlignedAllocator_btBroadphasePair_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )(  ) 
void btAlignedAllocator_btBroadphasePair_16u__free(void *c); 
void btAlignedAllocator_btBroadphasePair_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )( ::btBroadphasePair * ) 
void btAlignedAllocator_btBroadphasePair_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )( ::btBroadphasePair * ) 
//not supported method: allocate ::btBroadphasePair * ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )( ::size_type,::btBroadphasePair const * * ) 
// error:  - unsupported,  - unsupported, ::btBroadphasePair * - ok

void btAlignedAllocator_btBroadphasePair_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )( ::btBroadphasePair *,::btBroadphasePair const & ) 
void* btAlignedAllocator_btBroadphasePair_16u__address(void *c,void* p0); //method: address ::btBroadphasePair * ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )( ::btBroadphasePair & ) const
void* btAlignedAllocator_btBroadphasePair_16u__address0(void *c,void* p0); //method: address ::btBroadphasePair * ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )( ::btBroadphasePair & ) const
void* btAlignedAllocator_btBroadphasePair_16u__address1(void *c,void* p0); //method: address ::btBroadphasePair const * ( ::btAlignedAllocator<btBroadphasePair, 16u>::* )( ::btBroadphasePair const & ) const
void* btAlignedAllocator_btBvhSubtreeInfo_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )(  ) 
void btAlignedAllocator_btBvhSubtreeInfo_16u__free(void *c); 
void btAlignedAllocator_btBvhSubtreeInfo_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )( ::btBvhSubtreeInfo * ) 
void btAlignedAllocator_btBvhSubtreeInfo_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )( ::btBvhSubtreeInfo * ) 
//not supported method: allocate ::btBvhSubtreeInfo * ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )( ::size_type,::btBvhSubtreeInfo const * * ) 
// error:  - unsupported,  - unsupported, ::btBvhSubtreeInfo * - ok

void btAlignedAllocator_btBvhSubtreeInfo_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )( ::btBvhSubtreeInfo *,::btBvhSubtreeInfo const & ) 
void* btAlignedAllocator_btBvhSubtreeInfo_16u__address(void *c,void* p0); //method: address ::btBvhSubtreeInfo * ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )( ::btBvhSubtreeInfo & ) const
void* btAlignedAllocator_btBvhSubtreeInfo_16u__address0(void *c,void* p0); //method: address ::btBvhSubtreeInfo * ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )( ::btBvhSubtreeInfo & ) const
void* btAlignedAllocator_btBvhSubtreeInfo_16u__address1(void *c,void* p0); //method: address ::btBvhSubtreeInfo const * ( ::btAlignedAllocator<btBvhSubtreeInfo, 16u>::* )( ::btBvhSubtreeInfo const & ) const
void* btAlignedAllocator_btChunk_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btChunk*, 16u>::* )(  ) 
void btAlignedAllocator_btChunk_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btChunk*, 16u>::* )( ::btChunk * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btChunk*, 16u>::* )( ::btChunk * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btChunk * * ( ::btAlignedAllocator<btChunk*, 16u>::* )( ::size_type,::btChunk * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btChunk*, 16u>::* )( ::btChunk * *,::btChunk * const & ) 
// error:  - unsupported, ::btChunk * - ok, void - ok

//not supported method: address ::btChunk * * ( ::btAlignedAllocator<btChunk*, 16u>::* )( ::btChunk * & ) const
// error: ::btChunk * - ok,  - unsupported

//not supported method: address ::btChunk * * ( ::btAlignedAllocator<btChunk*, 16u>::* )( ::btChunk * & ) const
// error: ::btChunk * - ok,  - unsupported

//not supported method: address ::btChunk * const * ( ::btAlignedAllocator<btChunk*, 16u>::* )( ::btChunk * const & ) const
// error: ::btChunk * - ok,  - unsupported

void* btAlignedAllocator_btCollisionObject_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )(  ) 
void btAlignedAllocator_btCollisionObject_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )( ::btCollisionObject * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )( ::btCollisionObject * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btCollisionObject * * ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )( ::size_type,::btCollisionObject * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )( ::btCollisionObject * *,::btCollisionObject * const & ) 
// error:  - unsupported, ::btCollisionObject * - ok, void - ok

//not supported method: address ::btCollisionObject * * ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )( ::btCollisionObject * & ) const
// error: ::btCollisionObject * - ok,  - unsupported

//not supported method: address ::btCollisionObject * * ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )( ::btCollisionObject * & ) const
// error: ::btCollisionObject * - ok,  - unsupported

//not supported method: address ::btCollisionObject * const * ( ::btAlignedAllocator<btCollisionObject*, 16u>::* )( ::btCollisionObject * const & ) const
// error: ::btCollisionObject * - ok,  - unsupported

void* btAlignedAllocator_btCollisionShape_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )(  ) 
void btAlignedAllocator_btCollisionShape_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )( ::btCollisionShape * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )( ::btCollisionShape * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btCollisionShape * * ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )( ::size_type,::btCollisionShape * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )( ::btCollisionShape * *,::btCollisionShape * const & ) 
// error:  - unsupported, ::btCollisionShape * - ok, void - ok

//not supported method: address ::btCollisionShape * * ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )( ::btCollisionShape * & ) const
// error: ::btCollisionShape * - ok,  - unsupported

//not supported method: address ::btCollisionShape * * ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )( ::btCollisionShape * & ) const
// error: ::btCollisionShape * - ok,  - unsupported

//not supported method: address ::btCollisionShape * const * ( ::btAlignedAllocator<btCollisionShape*, 16u>::* )( ::btCollisionShape * const & ) const
// error: ::btCollisionShape * - ok,  - unsupported

void* btAlignedAllocator_btCompoundShapeChild_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )(  ) 
void btAlignedAllocator_btCompoundShapeChild_16u__free(void *c); 
void btAlignedAllocator_btCompoundShapeChild_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )( ::btCompoundShapeChild * ) 
void btAlignedAllocator_btCompoundShapeChild_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )( ::btCompoundShapeChild * ) 
//not supported method: allocate ::btCompoundShapeChild * ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )( ::size_type,::btCompoundShapeChild const * * ) 
// error:  - unsupported,  - unsupported, ::btCompoundShapeChild * - ok

void btAlignedAllocator_btCompoundShapeChild_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )( ::btCompoundShapeChild *,::btCompoundShapeChild const & ) 
void* btAlignedAllocator_btCompoundShapeChild_16u__address(void *c,void* p0); //method: address ::btCompoundShapeChild * ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )( ::btCompoundShapeChild & ) const
void* btAlignedAllocator_btCompoundShapeChild_16u__address0(void *c,void* p0); //method: address ::btCompoundShapeChild * ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )( ::btCompoundShapeChild & ) const
void* btAlignedAllocator_btCompoundShapeChild_16u__address1(void *c,void* p0); //method: address ::btCompoundShapeChild const * ( ::btAlignedAllocator<btCompoundShapeChild, 16u>::* )( ::btCompoundShapeChild const & ) const
void* btAlignedAllocator_btDbvt_sStkNN_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )(  ) 
void btAlignedAllocator_btDbvt_sStkNN_16u__free(void *c); 
void btAlignedAllocator_btDbvt_sStkNN_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )( ::btDbvt::sStkNN * ) 
void btAlignedAllocator_btDbvt_sStkNN_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )( ::btDbvt::sStkNN * ) 
//not supported method: allocate ::btDbvt::sStkNN * ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )( ::size_type,::btDbvt::sStkNN const * * ) 
// error:  - unsupported,  - unsupported, ::btDbvt::sStkNN * - ok

void btAlignedAllocator_btDbvt_sStkNN_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )( ::btDbvt::sStkNN *,::btDbvt::sStkNN const & ) 
void* btAlignedAllocator_btDbvt_sStkNN_16u__address(void *c,void* p0); //method: address ::btDbvt::sStkNN * ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )( ::btDbvt::sStkNN & ) const
void* btAlignedAllocator_btDbvt_sStkNN_16u__address0(void *c,void* p0); //method: address ::btDbvt::sStkNN * ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )( ::btDbvt::sStkNN & ) const
void* btAlignedAllocator_btDbvt_sStkNN_16u__address1(void *c,void* p0); //method: address ::btDbvt::sStkNN const * ( ::btAlignedAllocator<btDbvt::sStkNN, 16u>::* )( ::btDbvt::sStkNN const & ) const
void* btAlignedAllocator_btDbvt_sStkNP_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )(  ) 
void btAlignedAllocator_btDbvt_sStkNP_16u__free(void *c); 
void btAlignedAllocator_btDbvt_sStkNP_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )( ::btDbvt::sStkNP * ) 
void btAlignedAllocator_btDbvt_sStkNP_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )( ::btDbvt::sStkNP * ) 
//not supported method: allocate ::btDbvt::sStkNP * ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )( ::size_type,::btDbvt::sStkNP const * * ) 
// error:  - unsupported,  - unsupported, ::btDbvt::sStkNP * - ok

void btAlignedAllocator_btDbvt_sStkNP_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )( ::btDbvt::sStkNP *,::btDbvt::sStkNP const & ) 
void* btAlignedAllocator_btDbvt_sStkNP_16u__address(void *c,void* p0); //method: address ::btDbvt::sStkNP * ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )( ::btDbvt::sStkNP & ) const
void* btAlignedAllocator_btDbvt_sStkNP_16u__address0(void *c,void* p0); //method: address ::btDbvt::sStkNP * ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )( ::btDbvt::sStkNP & ) const
void* btAlignedAllocator_btDbvt_sStkNP_16u__address1(void *c,void* p0); //method: address ::btDbvt::sStkNP const * ( ::btAlignedAllocator<btDbvt::sStkNP, 16u>::* )( ::btDbvt::sStkNP const & ) const
void* btAlignedAllocator_btDbvt_sStkNPS_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )(  ) 
void btAlignedAllocator_btDbvt_sStkNPS_16u__free(void *c); 
void btAlignedAllocator_btDbvt_sStkNPS_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )( ::btDbvt::sStkNPS * ) 
void btAlignedAllocator_btDbvt_sStkNPS_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )( ::btDbvt::sStkNPS * ) 
//not supported method: allocate ::btDbvt::sStkNPS * ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )( ::size_type,::btDbvt::sStkNPS const * * ) 
// error:  - unsupported,  - unsupported, ::btDbvt::sStkNPS * - ok

void btAlignedAllocator_btDbvt_sStkNPS_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )( ::btDbvt::sStkNPS *,::btDbvt::sStkNPS const & ) 
void* btAlignedAllocator_btDbvt_sStkNPS_16u__address(void *c,void* p0); //method: address ::btDbvt::sStkNPS * ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )( ::btDbvt::sStkNPS & ) const
void* btAlignedAllocator_btDbvt_sStkNPS_16u__address0(void *c,void* p0); //method: address ::btDbvt::sStkNPS * ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )( ::btDbvt::sStkNPS & ) const
void* btAlignedAllocator_btDbvt_sStkNPS_16u__address1(void *c,void* p0); //method: address ::btDbvt::sStkNPS const * ( ::btAlignedAllocator<btDbvt::sStkNPS, 16u>::* )( ::btDbvt::sStkNPS const & ) const
void* btAlignedAllocator_btDbvtNodeconst_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )(  ) 
void btAlignedAllocator_btDbvtNodeconst_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )( ::btDbvtNode const * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )( ::btDbvtNode const * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btDbvtNode const * * ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )( ::size_type,::btDbvtNode const * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )( ::btDbvtNode const * *,::btDbvtNode const * const & ) 
// error:  - unsupported, ::btDbvtNode const * - ok, void - ok

//not supported method: address ::btDbvtNode const * * ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )( ::btDbvtNode const * & ) const
// error: ::btDbvtNode const * - ok,  - unsupported

//not supported method: address ::btDbvtNode const * * ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )( ::btDbvtNode const * & ) const
// error: ::btDbvtNode const * - ok,  - unsupported

//not supported method: address ::btDbvtNode const * const * ( ::btAlignedAllocator<btDbvtNode const*, 16u>::* )( ::btDbvtNode const * const & ) const
// error: ::btDbvtNode const * - ok,  - unsupported

void* btAlignedAllocator_btGImpactMeshShapePart_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )(  ) 
void btAlignedAllocator_btGImpactMeshShapePart_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )( ::btGImpactMeshShapePart * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )( ::btGImpactMeshShapePart * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btGImpactMeshShapePart * * ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )( ::size_type,::btGImpactMeshShapePart * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )( ::btGImpactMeshShapePart * *,::btGImpactMeshShapePart * const & ) 
// error:  - unsupported, ::btGImpactMeshShapePart * - ok, void - ok

//not supported method: address ::btGImpactMeshShapePart * * ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )( ::btGImpactMeshShapePart * & ) const
// error: ::btGImpactMeshShapePart * - ok,  - unsupported

//not supported method: address ::btGImpactMeshShapePart * * ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )( ::btGImpactMeshShapePart * & ) const
// error: ::btGImpactMeshShapePart * - ok,  - unsupported

//not supported method: address ::btGImpactMeshShapePart * const * ( ::btAlignedAllocator<btGImpactMeshShapePart*, 16u>::* )( ::btGImpactMeshShapePart * const & ) const
// error: ::btGImpactMeshShapePart * - ok,  - unsupported

void* btAlignedAllocator_btHashInt_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btHashInt, 16u>::* )(  ) 
void btAlignedAllocator_btHashInt_16u__free(void *c); 
void btAlignedAllocator_btHashInt_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btHashInt, 16u>::* )( ::btHashInt * ) 
void btAlignedAllocator_btHashInt_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btHashInt, 16u>::* )( ::btHashInt * ) 
//not supported method: allocate ::btHashInt * ( ::btAlignedAllocator<btHashInt, 16u>::* )( ::size_type,::btHashInt const * * ) 
// error:  - unsupported,  - unsupported, ::btHashInt * - ok

void btAlignedAllocator_btHashInt_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btHashInt, 16u>::* )( ::btHashInt *,::btHashInt const & ) 
void* btAlignedAllocator_btHashInt_16u__address(void *c,void* p0); //method: address ::btHashInt * ( ::btAlignedAllocator<btHashInt, 16u>::* )( ::btHashInt & ) const
void* btAlignedAllocator_btHashInt_16u__address0(void *c,void* p0); //method: address ::btHashInt * ( ::btAlignedAllocator<btHashInt, 16u>::* )( ::btHashInt & ) const
void* btAlignedAllocator_btHashInt_16u__address1(void *c,void* p0); //method: address ::btHashInt const * ( ::btAlignedAllocator<btHashInt, 16u>::* )( ::btHashInt const & ) const
void* btAlignedAllocator_btHashPtr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btHashPtr, 16u>::* )(  ) 
void btAlignedAllocator_btHashPtr_16u__free(void *c); 
void btAlignedAllocator_btHashPtr_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btHashPtr, 16u>::* )( ::btHashPtr * ) 
void btAlignedAllocator_btHashPtr_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btHashPtr, 16u>::* )( ::btHashPtr * ) 
//not supported method: allocate ::btHashPtr * ( ::btAlignedAllocator<btHashPtr, 16u>::* )( ::size_type,::btHashPtr const * * ) 
// error:  - unsupported,  - unsupported, ::btHashPtr * - ok

void btAlignedAllocator_btHashPtr_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btHashPtr, 16u>::* )( ::btHashPtr *,::btHashPtr const & ) 
void* btAlignedAllocator_btHashPtr_16u__address(void *c,void* p0); //method: address ::btHashPtr * ( ::btAlignedAllocator<btHashPtr, 16u>::* )( ::btHashPtr & ) const
void* btAlignedAllocator_btHashPtr_16u__address0(void *c,void* p0); //method: address ::btHashPtr * ( ::btAlignedAllocator<btHashPtr, 16u>::* )( ::btHashPtr & ) const
void* btAlignedAllocator_btHashPtr_16u__address1(void *c,void* p0); //method: address ::btHashPtr const * ( ::btAlignedAllocator<btHashPtr, 16u>::* )( ::btHashPtr const & ) const
void* btAlignedAllocator_btHashString_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btHashString, 16u>::* )(  ) 
void btAlignedAllocator_btHashString_16u__free(void *c); 
void btAlignedAllocator_btHashString_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btHashString, 16u>::* )( ::btHashString * ) 
void btAlignedAllocator_btHashString_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btHashString, 16u>::* )( ::btHashString * ) 
//not supported method: allocate ::btHashString * ( ::btAlignedAllocator<btHashString, 16u>::* )( ::size_type,::btHashString const * * ) 
// error:  - unsupported,  - unsupported, ::btHashString * - ok

void btAlignedAllocator_btHashString_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btHashString, 16u>::* )( ::btHashString *,::btHashString const & ) 
void* btAlignedAllocator_btHashString_16u__address(void *c,void* p0); //method: address ::btHashString * ( ::btAlignedAllocator<btHashString, 16u>::* )( ::btHashString & ) const
void* btAlignedAllocator_btHashString_16u__address0(void *c,void* p0); //method: address ::btHashString * ( ::btAlignedAllocator<btHashString, 16u>::* )( ::btHashString & ) const
void* btAlignedAllocator_btHashString_16u__address1(void *c,void* p0); //method: address ::btHashString const * ( ::btAlignedAllocator<btHashString, 16u>::* )( ::btHashString const & ) const
void* btAlignedAllocator_btIndexedMesh_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )(  ) 
void btAlignedAllocator_btIndexedMesh_16u__free(void *c); 
void btAlignedAllocator_btIndexedMesh_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )( ::btIndexedMesh * ) 
void btAlignedAllocator_btIndexedMesh_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )( ::btIndexedMesh * ) 
//not supported method: allocate ::btIndexedMesh * ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )( ::size_type,::btIndexedMesh const * * ) 
// error:  - unsupported,  - unsupported, ::btIndexedMesh * - ok

void btAlignedAllocator_btIndexedMesh_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )( ::btIndexedMesh *,::btIndexedMesh const & ) 
void* btAlignedAllocator_btIndexedMesh_16u__address(void *c,void* p0); //method: address ::btIndexedMesh * ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )( ::btIndexedMesh & ) const
void* btAlignedAllocator_btIndexedMesh_16u__address0(void *c,void* p0); //method: address ::btIndexedMesh * ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )( ::btIndexedMesh & ) const
void* btAlignedAllocator_btIndexedMesh_16u__address1(void *c,void* p0); //method: address ::btIndexedMesh const * ( ::btAlignedAllocator<btIndexedMesh, 16u>::* )( ::btIndexedMesh const & ) const
void* btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )(  ) 
void btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )( ::btMultiSapBroadphase::btBridgeProxy * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )( ::btMultiSapBroadphase::btBridgeProxy * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btMultiSapBroadphase::btBridgeProxy * * ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )( ::size_type,::btMultiSapBroadphase::btBridgeProxy * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )( ::btMultiSapBroadphase::btBridgeProxy * *,::btMultiSapBroadphase::btBridgeProxy * const & ) 
// error:  - unsupported, ::btMultiSapBroadphase::btBridgeProxy * - ok, void - ok

//not supported method: address ::btMultiSapBroadphase::btBridgeProxy * * ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )( ::btMultiSapBroadphase::btBridgeProxy * & ) const
// error: ::btMultiSapBroadphase::btBridgeProxy * - ok,  - unsupported

//not supported method: address ::btMultiSapBroadphase::btBridgeProxy * * ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )( ::btMultiSapBroadphase::btBridgeProxy * & ) const
// error: ::btMultiSapBroadphase::btBridgeProxy * - ok,  - unsupported

//not supported method: address ::btMultiSapBroadphase::btBridgeProxy * const * ( ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>::* )( ::btMultiSapBroadphase::btBridgeProxy * const & ) const
// error: ::btMultiSapBroadphase::btBridgeProxy * - ok,  - unsupported

void* btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )(  ) 
void btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )( ::btMultiSapBroadphase::btMultiSapProxy * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )( ::btMultiSapBroadphase::btMultiSapProxy * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btMultiSapBroadphase::btMultiSapProxy * * ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )( ::size_type,::btMultiSapBroadphase::btMultiSapProxy * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )( ::btMultiSapBroadphase::btMultiSapProxy * *,::btMultiSapBroadphase::btMultiSapProxy * const & ) 
// error:  - unsupported, ::btMultiSapBroadphase::btMultiSapProxy * - ok, void - ok

//not supported method: address ::btMultiSapBroadphase::btMultiSapProxy * * ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )( ::btMultiSapBroadphase::btMultiSapProxy * & ) const
// error: ::btMultiSapBroadphase::btMultiSapProxy * - ok,  - unsupported

//not supported method: address ::btMultiSapBroadphase::btMultiSapProxy * * ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )( ::btMultiSapBroadphase::btMultiSapProxy * & ) const
// error: ::btMultiSapBroadphase::btMultiSapProxy * - ok,  - unsupported

//not supported method: address ::btMultiSapBroadphase::btMultiSapProxy * const * ( ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>::* )( ::btMultiSapBroadphase::btMultiSapProxy * const & ) const
// error: ::btMultiSapBroadphase::btMultiSapProxy * - ok,  - unsupported

void* btAlignedAllocator_btOptimizedBvhNode_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )(  ) 
void btAlignedAllocator_btOptimizedBvhNode_16u__free(void *c); 
void btAlignedAllocator_btOptimizedBvhNode_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )( ::btOptimizedBvhNode * ) 
void btAlignedAllocator_btOptimizedBvhNode_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )( ::btOptimizedBvhNode * ) 
//not supported method: allocate ::btOptimizedBvhNode * ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )( ::size_type,::btOptimizedBvhNode const * * ) 
// error:  - unsupported,  - unsupported, ::btOptimizedBvhNode * - ok

void btAlignedAllocator_btOptimizedBvhNode_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )( ::btOptimizedBvhNode *,::btOptimizedBvhNode const & ) 
void* btAlignedAllocator_btOptimizedBvhNode_16u__address(void *c,void* p0); //method: address ::btOptimizedBvhNode * ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )( ::btOptimizedBvhNode & ) const
void* btAlignedAllocator_btOptimizedBvhNode_16u__address0(void *c,void* p0); //method: address ::btOptimizedBvhNode * ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )( ::btOptimizedBvhNode & ) const
void* btAlignedAllocator_btOptimizedBvhNode_16u__address1(void *c,void* p0); //method: address ::btOptimizedBvhNode const * ( ::btAlignedAllocator<btOptimizedBvhNode, 16u>::* )( ::btOptimizedBvhNode const & ) const
void* btAlignedAllocator_btPersistentManifold_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )(  ) 
void btAlignedAllocator_btPersistentManifold_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )( ::btPersistentManifold * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )( ::btPersistentManifold * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btPersistentManifold * * ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )( ::size_type,::btPersistentManifold * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )( ::btPersistentManifold * *,::btPersistentManifold * const & ) 
// error:  - unsupported, ::btPersistentManifold * - ok, void - ok

//not supported method: address ::btPersistentManifold * * ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )( ::btPersistentManifold * & ) const
// error: ::btPersistentManifold * - ok,  - unsupported

//not supported method: address ::btPersistentManifold * * ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )( ::btPersistentManifold * & ) const
// error: ::btPersistentManifold * - ok,  - unsupported

//not supported method: address ::btPersistentManifold * const * ( ::btAlignedAllocator<btPersistentManifold*, 16u>::* )( ::btPersistentManifold * const & ) const
// error: ::btPersistentManifold * - ok,  - unsupported

void* btAlignedAllocator_btPointerUid_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btPointerUid, 16u>::* )(  ) 
void btAlignedAllocator_btPointerUid_16u__free(void *c); 
void btAlignedAllocator_btPointerUid_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btPointerUid, 16u>::* )( ::btPointerUid * ) 
void btAlignedAllocator_btPointerUid_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btPointerUid, 16u>::* )( ::btPointerUid * ) 
//not supported method: allocate ::btPointerUid * ( ::btAlignedAllocator<btPointerUid, 16u>::* )( ::size_type,::btPointerUid const * * ) 
// error:  - unsupported,  - unsupported, ::btPointerUid * - ok

void btAlignedAllocator_btPointerUid_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btPointerUid, 16u>::* )( ::btPointerUid *,::btPointerUid const & ) 
void* btAlignedAllocator_btPointerUid_16u__address(void *c,void* p0); //method: address ::btPointerUid * ( ::btAlignedAllocator<btPointerUid, 16u>::* )( ::btPointerUid & ) const
void* btAlignedAllocator_btPointerUid_16u__address0(void *c,void* p0); //method: address ::btPointerUid * ( ::btAlignedAllocator<btPointerUid, 16u>::* )( ::btPointerUid & ) const
void* btAlignedAllocator_btPointerUid_16u__address1(void *c,void* p0); //method: address ::btPointerUid const * ( ::btAlignedAllocator<btPointerUid, 16u>::* )( ::btPointerUid const & ) const
void* btAlignedAllocator_btQuantizedBvhNode_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )(  ) 
void btAlignedAllocator_btQuantizedBvhNode_16u__free(void *c); 
void btAlignedAllocator_btQuantizedBvhNode_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )( ::btQuantizedBvhNode * ) 
void btAlignedAllocator_btQuantizedBvhNode_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )( ::btQuantizedBvhNode * ) 
//not supported method: allocate ::btQuantizedBvhNode * ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )( ::size_type,::btQuantizedBvhNode const * * ) 
// error:  - unsupported,  - unsupported, ::btQuantizedBvhNode * - ok

void btAlignedAllocator_btQuantizedBvhNode_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )( ::btQuantizedBvhNode *,::btQuantizedBvhNode const & ) 
void* btAlignedAllocator_btQuantizedBvhNode_16u__address(void *c,void* p0); //method: address ::btQuantizedBvhNode * ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )( ::btQuantizedBvhNode & ) const
void* btAlignedAllocator_btQuantizedBvhNode_16u__address0(void *c,void* p0); //method: address ::btQuantizedBvhNode * ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )( ::btQuantizedBvhNode & ) const
void* btAlignedAllocator_btQuantizedBvhNode_16u__address1(void *c,void* p0); //method: address ::btQuantizedBvhNode const * ( ::btAlignedAllocator<btQuantizedBvhNode, 16u>::* )( ::btQuantizedBvhNode const & ) const
void* btAlignedAllocator_btRigidBody_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btRigidBody*, 16u>::* )(  ) 
void btAlignedAllocator_btRigidBody_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btRigidBody*, 16u>::* )( ::btRigidBody * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btRigidBody*, 16u>::* )( ::btRigidBody * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btRigidBody * * ( ::btAlignedAllocator<btRigidBody*, 16u>::* )( ::size_type,::btRigidBody * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btRigidBody*, 16u>::* )( ::btRigidBody * *,::btRigidBody * const & ) 
// error:  - unsupported, ::btRigidBody * - ok, void - ok

//not supported method: address ::btRigidBody * * ( ::btAlignedAllocator<btRigidBody*, 16u>::* )( ::btRigidBody * & ) const
// error: ::btRigidBody * - ok,  - unsupported

//not supported method: address ::btRigidBody * * ( ::btAlignedAllocator<btRigidBody*, 16u>::* )( ::btRigidBody * & ) const
// error: ::btRigidBody * - ok,  - unsupported

//not supported method: address ::btRigidBody * const * ( ::btAlignedAllocator<btRigidBody*, 16u>::* )( ::btRigidBody * const & ) const
// error: ::btRigidBody * - ok,  - unsupported

void* btAlignedAllocator_btSoftBody_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody*, 16u>::* )(  ) 
void btAlignedAllocator_btSoftBody_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btSoftBody*, 16u>::* )( ::btSoftBody * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSoftBody*, 16u>::* )( ::btSoftBody * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSoftBody * * ( ::btAlignedAllocator<btSoftBody*, 16u>::* )( ::size_type,::btSoftBody * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSoftBody*, 16u>::* )( ::btSoftBody * *,::btSoftBody * const & ) 
// error:  - unsupported, ::btSoftBody * - ok, void - ok

//not supported method: address ::btSoftBody * * ( ::btAlignedAllocator<btSoftBody*, 16u>::* )( ::btSoftBody * & ) const
// error: ::btSoftBody * - ok,  - unsupported

//not supported method: address ::btSoftBody * * ( ::btAlignedAllocator<btSoftBody*, 16u>::* )( ::btSoftBody * & ) const
// error: ::btSoftBody * - ok,  - unsupported

//not supported method: address ::btSoftBody * const * ( ::btAlignedAllocator<btSoftBody*, 16u>::* )( ::btSoftBody * const & ) const
// error: ::btSoftBody * - ok,  - unsupported

void* btAlignedAllocator_btSoftBody_Anchor_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )(  ) 
void btAlignedAllocator_btSoftBody_Anchor_16u__free(void *c); 
void btAlignedAllocator_btSoftBody_Anchor_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )( ::btSoftBody::Anchor * ) 
void btAlignedAllocator_btSoftBody_Anchor_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )( ::btSoftBody::Anchor * ) 
//not supported method: allocate ::btSoftBody::Anchor * ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )( ::size_type,::btSoftBody::Anchor const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::Anchor * - ok

void btAlignedAllocator_btSoftBody_Anchor_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )( ::btSoftBody::Anchor *,::btSoftBody::Anchor const & ) 
void* btAlignedAllocator_btSoftBody_Anchor_16u__address(void *c,void* p0); //method: address ::btSoftBody::Anchor * ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )( ::btSoftBody::Anchor & ) const
void* btAlignedAllocator_btSoftBody_Anchor_16u__address0(void *c,void* p0); //method: address ::btSoftBody::Anchor * ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )( ::btSoftBody::Anchor & ) const
void* btAlignedAllocator_btSoftBody_Anchor_16u__address1(void *c,void* p0); //method: address ::btSoftBody::Anchor const * ( ::btAlignedAllocator<btSoftBody::Anchor, 16u>::* )( ::btSoftBody::Anchor const & ) const
void* btAlignedAllocator_btSoftBody_Cluster_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )(  ) 
void btAlignedAllocator_btSoftBody_Cluster_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )( ::btSoftBody::Cluster * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )( ::btSoftBody::Cluster * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSoftBody::Cluster * * ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )( ::size_type,::btSoftBody::Cluster * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )( ::btSoftBody::Cluster * *,::btSoftBody::Cluster * const & ) 
// error:  - unsupported, ::btSoftBody::Cluster * - ok, void - ok

//not supported method: address ::btSoftBody::Cluster * * ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )( ::btSoftBody::Cluster * & ) const
// error: ::btSoftBody::Cluster * - ok,  - unsupported

//not supported method: address ::btSoftBody::Cluster * * ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )( ::btSoftBody::Cluster * & ) const
// error: ::btSoftBody::Cluster * - ok,  - unsupported

//not supported method: address ::btSoftBody::Cluster * const * ( ::btAlignedAllocator<btSoftBody::Cluster*, 16u>::* )( ::btSoftBody::Cluster * const & ) const
// error: ::btSoftBody::Cluster * - ok,  - unsupported

void* btAlignedAllocator_btSoftBody_Face_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )(  ) 
void btAlignedAllocator_btSoftBody_Face_16u__free(void *c); 
void btAlignedAllocator_btSoftBody_Face_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )( ::btSoftBody::Face * ) 
void btAlignedAllocator_btSoftBody_Face_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )( ::btSoftBody::Face * ) 
//not supported method: allocate ::btSoftBody::Face * ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )( ::size_type,::btSoftBody::Face const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::Face * - ok

void btAlignedAllocator_btSoftBody_Face_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )( ::btSoftBody::Face *,::btSoftBody::Face const & ) 
void* btAlignedAllocator_btSoftBody_Face_16u__address(void *c,void* p0); //method: address ::btSoftBody::Face * ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )( ::btSoftBody::Face & ) const
void* btAlignedAllocator_btSoftBody_Face_16u__address0(void *c,void* p0); //method: address ::btSoftBody::Face * ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )( ::btSoftBody::Face & ) const
void* btAlignedAllocator_btSoftBody_Face_16u__address1(void *c,void* p0); //method: address ::btSoftBody::Face const * ( ::btAlignedAllocator<btSoftBody::Face, 16u>::* )( ::btSoftBody::Face const & ) const
void* btAlignedAllocator_btSoftBody_Joint_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )(  ) 
void btAlignedAllocator_btSoftBody_Joint_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )( ::btSoftBody::Joint * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )( ::btSoftBody::Joint * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSoftBody::Joint * * ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )( ::size_type,::btSoftBody::Joint * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )( ::btSoftBody::Joint * *,::btSoftBody::Joint * const & ) 
// error:  - unsupported, ::btSoftBody::Joint * - ok, void - ok

//not supported method: address ::btSoftBody::Joint * * ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )( ::btSoftBody::Joint * & ) const
// error: ::btSoftBody::Joint * - ok,  - unsupported

//not supported method: address ::btSoftBody::Joint * * ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )( ::btSoftBody::Joint * & ) const
// error: ::btSoftBody::Joint * - ok,  - unsupported

//not supported method: address ::btSoftBody::Joint * const * ( ::btAlignedAllocator<btSoftBody::Joint*, 16u>::* )( ::btSoftBody::Joint * const & ) const
// error: ::btSoftBody::Joint * - ok,  - unsupported

void* btAlignedAllocator_btSoftBody_Link_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )(  ) 
void btAlignedAllocator_btSoftBody_Link_16u__free(void *c); 
void btAlignedAllocator_btSoftBody_Link_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )( ::btSoftBody::Link * ) 
void btAlignedAllocator_btSoftBody_Link_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )( ::btSoftBody::Link * ) 
//not supported method: allocate ::btSoftBody::Link * ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )( ::size_type,::btSoftBody::Link const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::Link * - ok

void btAlignedAllocator_btSoftBody_Link_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )( ::btSoftBody::Link *,::btSoftBody::Link const & ) 
void* btAlignedAllocator_btSoftBody_Link_16u__address(void *c,void* p0); //method: address ::btSoftBody::Link * ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )( ::btSoftBody::Link & ) const
void* btAlignedAllocator_btSoftBody_Link_16u__address0(void *c,void* p0); //method: address ::btSoftBody::Link * ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )( ::btSoftBody::Link & ) const
void* btAlignedAllocator_btSoftBody_Link_16u__address1(void *c,void* p0); //method: address ::btSoftBody::Link const * ( ::btAlignedAllocator<btSoftBody::Link, 16u>::* )( ::btSoftBody::Link const & ) const
void* btAlignedAllocator_btSoftBody_Material_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )(  ) 
void btAlignedAllocator_btSoftBody_Material_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )( ::btSoftBody::Material * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )( ::btSoftBody::Material * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSoftBody::Material * * ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )( ::size_type,::btSoftBody::Material * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )( ::btSoftBody::Material * *,::btSoftBody::Material * const & ) 
// error:  - unsupported, ::btSoftBody::Material * - ok, void - ok

//not supported method: address ::btSoftBody::Material * * ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )( ::btSoftBody::Material * & ) const
// error: ::btSoftBody::Material * - ok,  - unsupported

//not supported method: address ::btSoftBody::Material * * ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )( ::btSoftBody::Material * & ) const
// error: ::btSoftBody::Material * - ok,  - unsupported

//not supported method: address ::btSoftBody::Material * const * ( ::btAlignedAllocator<btSoftBody::Material*, 16u>::* )( ::btSoftBody::Material * const & ) const
// error: ::btSoftBody::Material * - ok,  - unsupported

void* btAlignedAllocator_btSoftBody_Node_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )(  ) 
void btAlignedAllocator_btSoftBody_Node_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )( ::btSoftBody::Node * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )( ::btSoftBody::Node * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSoftBody::Node * * ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )( ::size_type,::btSoftBody::Node * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )( ::btSoftBody::Node * *,::btSoftBody::Node * const & ) 
// error:  - unsupported, ::btSoftBody::Node * - ok, void - ok

//not supported method: address ::btSoftBody::Node * * ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )( ::btSoftBody::Node * & ) const
// error: ::btSoftBody::Node * - ok,  - unsupported

//not supported method: address ::btSoftBody::Node * * ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )( ::btSoftBody::Node * & ) const
// error: ::btSoftBody::Node * - ok,  - unsupported

//not supported method: address ::btSoftBody::Node * const * ( ::btAlignedAllocator<btSoftBody::Node*, 16u>::* )( ::btSoftBody::Node * const & ) const
// error: ::btSoftBody::Node * - ok,  - unsupported

void* btAlignedAllocator_btSoftBody_Node_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )(  ) 
void btAlignedAllocator_btSoftBody_Node_16u__free(void *c); 
void btAlignedAllocator_btSoftBody_Node_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )( ::btSoftBody::Node * ) 
void btAlignedAllocator_btSoftBody_Node_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )( ::btSoftBody::Node * ) 
//not supported method: allocate ::btSoftBody::Node * ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )( ::size_type,::btSoftBody::Node const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::Node * - ok

void btAlignedAllocator_btSoftBody_Node_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )( ::btSoftBody::Node *,::btSoftBody::Node const & ) 
void* btAlignedAllocator_btSoftBody_Node_16u__address(void *c,void* p0); //method: address ::btSoftBody::Node * ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )( ::btSoftBody::Node & ) const
void* btAlignedAllocator_btSoftBody_Node_16u__address0(void *c,void* p0); //method: address ::btSoftBody::Node * ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )( ::btSoftBody::Node & ) const
void* btAlignedAllocator_btSoftBody_Node_16u__address1(void *c,void* p0); //method: address ::btSoftBody::Node const * ( ::btAlignedAllocator<btSoftBody::Node, 16u>::* )( ::btSoftBody::Node const & ) const
void* btAlignedAllocator_btSoftBody_Note_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )(  ) 
void btAlignedAllocator_btSoftBody_Note_16u__free(void *c); 
void btAlignedAllocator_btSoftBody_Note_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )( ::btSoftBody::Note * ) 
void btAlignedAllocator_btSoftBody_Note_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )( ::btSoftBody::Note * ) 
//not supported method: allocate ::btSoftBody::Note * ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )( ::size_type,::btSoftBody::Note const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::Note * - ok

void btAlignedAllocator_btSoftBody_Note_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )( ::btSoftBody::Note *,::btSoftBody::Note const & ) 
void* btAlignedAllocator_btSoftBody_Note_16u__address(void *c,void* p0); //method: address ::btSoftBody::Note * ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )( ::btSoftBody::Note & ) const
void* btAlignedAllocator_btSoftBody_Note_16u__address0(void *c,void* p0); //method: address ::btSoftBody::Note * ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )( ::btSoftBody::Note & ) const
void* btAlignedAllocator_btSoftBody_Note_16u__address1(void *c,void* p0); //method: address ::btSoftBody::Note const * ( ::btAlignedAllocator<btSoftBody::Note, 16u>::* )( ::btSoftBody::Note const & ) const
void* btAlignedAllocator_btSoftBody_RContact_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )(  ) 
void btAlignedAllocator_btSoftBody_RContact_16u__free(void *c); 
void btAlignedAllocator_btSoftBody_RContact_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )( ::btSoftBody::RContact * ) 
void btAlignedAllocator_btSoftBody_RContact_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )( ::btSoftBody::RContact * ) 
//not supported method: allocate ::btSoftBody::RContact * ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )( ::size_type,::btSoftBody::RContact const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::RContact * - ok

void btAlignedAllocator_btSoftBody_RContact_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )( ::btSoftBody::RContact *,::btSoftBody::RContact const & ) 
void* btAlignedAllocator_btSoftBody_RContact_16u__address(void *c,void* p0); //method: address ::btSoftBody::RContact * ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )( ::btSoftBody::RContact & ) const
void* btAlignedAllocator_btSoftBody_RContact_16u__address0(void *c,void* p0); //method: address ::btSoftBody::RContact * ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )( ::btSoftBody::RContact & ) const
void* btAlignedAllocator_btSoftBody_RContact_16u__address1(void *c,void* p0); //method: address ::btSoftBody::RContact const * ( ::btAlignedAllocator<btSoftBody::RContact, 16u>::* )( ::btSoftBody::RContact const & ) const
void* btAlignedAllocator_btSoftBody_SContact_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )(  ) 
void btAlignedAllocator_btSoftBody_SContact_16u__free(void *c); 
void btAlignedAllocator_btSoftBody_SContact_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )( ::btSoftBody::SContact * ) 
void btAlignedAllocator_btSoftBody_SContact_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )( ::btSoftBody::SContact * ) 
//not supported method: allocate ::btSoftBody::SContact * ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )( ::size_type,::btSoftBody::SContact const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::SContact * - ok

void btAlignedAllocator_btSoftBody_SContact_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )( ::btSoftBody::SContact *,::btSoftBody::SContact const & ) 
void* btAlignedAllocator_btSoftBody_SContact_16u__address(void *c,void* p0); //method: address ::btSoftBody::SContact * ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )( ::btSoftBody::SContact & ) const
void* btAlignedAllocator_btSoftBody_SContact_16u__address0(void *c,void* p0); //method: address ::btSoftBody::SContact * ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )( ::btSoftBody::SContact & ) const
void* btAlignedAllocator_btSoftBody_SContact_16u__address1(void *c,void* p0); //method: address ::btSoftBody::SContact const * ( ::btAlignedAllocator<btSoftBody::SContact, 16u>::* )( ::btSoftBody::SContact const & ) const
void* btAlignedAllocator_btSoftBody_Tetra_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )(  ) 
void btAlignedAllocator_btSoftBody_Tetra_16u__free(void *c); 
void btAlignedAllocator_btSoftBody_Tetra_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )( ::btSoftBody::Tetra * ) 
void btAlignedAllocator_btSoftBody_Tetra_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )( ::btSoftBody::Tetra * ) 
//not supported method: allocate ::btSoftBody::Tetra * ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )( ::size_type,::btSoftBody::Tetra const * * ) 
// error:  - unsupported,  - unsupported, ::btSoftBody::Tetra * - ok

void btAlignedAllocator_btSoftBody_Tetra_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )( ::btSoftBody::Tetra *,::btSoftBody::Tetra const & ) 
void* btAlignedAllocator_btSoftBody_Tetra_16u__address(void *c,void* p0); //method: address ::btSoftBody::Tetra * ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )( ::btSoftBody::Tetra & ) const
void* btAlignedAllocator_btSoftBody_Tetra_16u__address0(void *c,void* p0); //method: address ::btSoftBody::Tetra * ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )( ::btSoftBody::Tetra & ) const
void* btAlignedAllocator_btSoftBody_Tetra_16u__address1(void *c,void* p0); //method: address ::btSoftBody::Tetra const * ( ::btAlignedAllocator<btSoftBody::Tetra, 16u>::* )( ::btSoftBody::Tetra const & ) const
void* btAlignedAllocator_btSoftBody_ePSolver___16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )(  ) 
void btAlignedAllocator_btSoftBody_ePSolver___16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )( ::btSoftBody::ePSolver::_ * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )( ::btSoftBody::ePSolver::_ * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSoftBody::ePSolver::_ * ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )( ::size_type,::btSoftBody::ePSolver::_ const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )( ::btSoftBody::ePSolver::_ *,::btSoftBody::ePSolver::_ const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address ::btSoftBody::ePSolver::_ * ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )( ::btSoftBody::ePSolver::_ & ) const
// error:  - unsupported,  - unsupported

//not supported method: address ::btSoftBody::ePSolver::_ * ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )( ::btSoftBody::ePSolver::_ & ) const
// error:  - unsupported,  - unsupported

//not supported method: address ::btSoftBody::ePSolver::_ const * ( ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>::* )( ::btSoftBody::ePSolver::_ const & ) const
// error:  - unsupported,  - unsupported

void* btAlignedAllocator_btSoftBody_eVSolver___16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )(  ) 
void btAlignedAllocator_btSoftBody_eVSolver___16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )( ::btSoftBody::eVSolver::_ * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )( ::btSoftBody::eVSolver::_ * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSoftBody::eVSolver::_ * ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )( ::size_type,::btSoftBody::eVSolver::_ const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )( ::btSoftBody::eVSolver::_ *,::btSoftBody::eVSolver::_ const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address ::btSoftBody::eVSolver::_ * ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )( ::btSoftBody::eVSolver::_ & ) const
// error:  - unsupported,  - unsupported

//not supported method: address ::btSoftBody::eVSolver::_ * ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )( ::btSoftBody::eVSolver::_ & ) const
// error:  - unsupported,  - unsupported

//not supported method: address ::btSoftBody::eVSolver::_ const * ( ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>::* )( ::btSoftBody::eVSolver::_ const & ) const
// error:  - unsupported,  - unsupported

void* btAlignedAllocator_btSolverConstraint_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )(  ) 
void btAlignedAllocator_btSolverConstraint_16u__free(void *c); 
void btAlignedAllocator_btSolverConstraint_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )( ::btSolverConstraint * ) 
void btAlignedAllocator_btSolverConstraint_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )( ::btSolverConstraint * ) 
//not supported method: allocate ::btSolverConstraint * ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )( ::size_type,::btSolverConstraint const * * ) 
// error:  - unsupported,  - unsupported, ::btSolverConstraint * - ok

void btAlignedAllocator_btSolverConstraint_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )( ::btSolverConstraint *,::btSolverConstraint const & ) 
void* btAlignedAllocator_btSolverConstraint_16u__address(void *c,void* p0); //method: address ::btSolverConstraint * ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )( ::btSolverConstraint & ) const
void* btAlignedAllocator_btSolverConstraint_16u__address0(void *c,void* p0); //method: address ::btSolverConstraint * ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )( ::btSolverConstraint & ) const
void* btAlignedAllocator_btSolverConstraint_16u__address1(void *c,void* p0); //method: address ::btSolverConstraint const * ( ::btAlignedAllocator<btSolverConstraint, 16u>::* )( ::btSolverConstraint const & ) const
void* btAlignedAllocator_btSparseSdf_3__Cell_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )(  ) 
void btAlignedAllocator_btSparseSdf_3__Cell_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )( ::btSparseSdf<3>::Cell * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )( ::btSparseSdf<3>::Cell * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btSparseSdf<3>::Cell * * ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )( ::size_type,::btSparseSdf<3>::Cell * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )( ::btSparseSdf<3>::Cell * *,::btSparseSdf<3>::Cell * const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address ::btSparseSdf<3>::Cell * * ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )( ::btSparseSdf<3>::Cell * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address ::btSparseSdf<3>::Cell * * ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )( ::btSparseSdf<3>::Cell * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address ::btSparseSdf<3>::Cell * const * ( ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>::* )( ::btSparseSdf<3>::Cell * const & ) const
// error:  - unsupported,  - unsupported

void* btAlignedAllocator_btTransform_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btTransform, 16u>::* )(  ) 
void btAlignedAllocator_btTransform_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btTransform, 16u>::* )( ::btTransform * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btTransform, 16u>::* )( ::btTransform * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btTransform * ( ::btAlignedAllocator<btTransform, 16u>::* )( ::size_type,::btTransform const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btTransform, 16u>::* )( ::btTransform *,::btTransform const & ) 
// error:  - unsupported, ::btTransform const & - ok, void - ok

//not supported method: address ::btTransform * ( ::btAlignedAllocator<btTransform, 16u>::* )( ::btTransform & ) const
// error: ::btTransform & - ok,  - unsupported

//not supported method: address ::btTransform * ( ::btAlignedAllocator<btTransform, 16u>::* )( ::btTransform & ) const
// error: ::btTransform & - ok,  - unsupported

//not supported method: address ::btTransform const * ( ::btAlignedAllocator<btTransform, 16u>::* )( ::btTransform const & ) const
// error: ::btTransform const & - ok,  - unsupported

void* btAlignedAllocator_btTriangleInfo_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )(  ) 
void btAlignedAllocator_btTriangleInfo_16u__free(void *c); 
void btAlignedAllocator_btTriangleInfo_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )( ::btTriangleInfo * ) 
void btAlignedAllocator_btTriangleInfo_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )( ::btTriangleInfo * ) 
//not supported method: allocate ::btTriangleInfo * ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )( ::size_type,::btTriangleInfo const * * ) 
// error:  - unsupported,  - unsupported, ::btTriangleInfo * - ok

void btAlignedAllocator_btTriangleInfo_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )( ::btTriangleInfo *,::btTriangleInfo const & ) 
void* btAlignedAllocator_btTriangleInfo_16u__address(void *c,void* p0); //method: address ::btTriangleInfo * ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )( ::btTriangleInfo & ) const
void* btAlignedAllocator_btTriangleInfo_16u__address0(void *c,void* p0); //method: address ::btTriangleInfo * ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )( ::btTriangleInfo & ) const
void* btAlignedAllocator_btTriangleInfo_16u__address1(void *c,void* p0); //method: address ::btTriangleInfo const * ( ::btAlignedAllocator<btTriangleInfo, 16u>::* )( ::btTriangleInfo const & ) const
void* btAlignedAllocator_btTypedConstraint_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )(  ) 
void btAlignedAllocator_btTypedConstraint_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )( ::btTypedConstraint * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )( ::btTypedConstraint * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btTypedConstraint * * ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )( ::size_type,::btTypedConstraint * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )( ::btTypedConstraint * *,::btTypedConstraint * const & ) 
// error:  - unsupported, ::btTypedConstraint * - ok, void - ok

//not supported method: address ::btTypedConstraint * * ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )( ::btTypedConstraint * & ) const
// error: ::btTypedConstraint * - ok,  - unsupported

//not supported method: address ::btTypedConstraint * * ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )( ::btTypedConstraint * & ) const
// error: ::btTypedConstraint * - ok,  - unsupported

//not supported method: address ::btTypedConstraint * const * ( ::btAlignedAllocator<btTypedConstraint*, 16u>::* )( ::btTypedConstraint * const & ) const
// error: ::btTypedConstraint * - ok,  - unsupported

void* btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )(  ) 
void btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__free(void *c); 
void btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
//not supported method: allocate ::btTypedConstraint::btConstraintInfo1 * ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )( ::size_type,::btTypedConstraint::btConstraintInfo1 const * * ) 
// error:  - unsupported,  - unsupported, ::btTypedConstraint::btConstraintInfo1 * - ok

void btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )( ::btTypedConstraint::btConstraintInfo1 *,::btTypedConstraint::btConstraintInfo1 const & ) 
void* btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__address(void *c,void* p0); //method: address ::btTypedConstraint::btConstraintInfo1 * ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )( ::btTypedConstraint::btConstraintInfo1 & ) const
void* btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__address0(void *c,void* p0); //method: address ::btTypedConstraint::btConstraintInfo1 * ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )( ::btTypedConstraint::btConstraintInfo1 & ) const
void* btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u__address1(void *c,void* p0); //method: address ::btTypedConstraint::btConstraintInfo1 const * ( ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>::* )( ::btTypedConstraint::btConstraintInfo1 const & ) const
void* btAlignedAllocator_btVector3_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btVector3, 16u>::* )(  ) 
void btAlignedAllocator_btVector3_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<btVector3, 16u>::* )( ::btVector3 * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<btVector3, 16u>::* )( ::btVector3 * ) 
// error:  - unsupported, void - ok

//not supported method: allocate ::btVector3 * ( ::btAlignedAllocator<btVector3, 16u>::* )( ::size_type,::btVector3 const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<btVector3, 16u>::* )( ::btVector3 *,::btVector3 const & ) 
// error:  - unsupported, ::btVector3 const & - ok, void - ok

//not supported method: address ::btVector3 * ( ::btAlignedAllocator<btVector3, 16u>::* )( ::btVector3 & ) const
// error: ::btVector3 & - ok,  - unsupported

//not supported method: address ::btVector3 * ( ::btAlignedAllocator<btVector3, 16u>::* )( ::btVector3 & ) const
// error: ::btVector3 & - ok,  - unsupported

//not supported method: address ::btVector3 const * ( ::btAlignedAllocator<btVector3, 16u>::* )( ::btVector3 const & ) const
// error: ::btVector3 const & - ok,  - unsupported

void* btAlignedAllocator_btWheelInfo_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<btWheelInfo, 16u>::* )(  ) 
void btAlignedAllocator_btWheelInfo_16u__free(void *c); 
void btAlignedAllocator_btWheelInfo_16u__destroy(void *c,void* p0); //method: destroy void ( ::btAlignedAllocator<btWheelInfo, 16u>::* )( ::btWheelInfo * ) 
void btAlignedAllocator_btWheelInfo_16u__deallocate(void *c,void* p0); //method: deallocate void ( ::btAlignedAllocator<btWheelInfo, 16u>::* )( ::btWheelInfo * ) 
//not supported method: allocate ::btWheelInfo * ( ::btAlignedAllocator<btWheelInfo, 16u>::* )( ::size_type,::btWheelInfo const * * ) 
// error:  - unsupported,  - unsupported, ::btWheelInfo * - ok

void btAlignedAllocator_btWheelInfo_16u__construct(void *c,void* p0,void* p1); //method: construct void ( ::btAlignedAllocator<btWheelInfo, 16u>::* )( ::btWheelInfo *,::btWheelInfo const & ) 
void* btAlignedAllocator_btWheelInfo_16u__address(void *c,void* p0); //method: address ::btWheelInfo * ( ::btAlignedAllocator<btWheelInfo, 16u>::* )( ::btWheelInfo & ) const
void* btAlignedAllocator_btWheelInfo_16u__address0(void *c,void* p0); //method: address ::btWheelInfo * ( ::btAlignedAllocator<btWheelInfo, 16u>::* )( ::btWheelInfo & ) const
void* btAlignedAllocator_btWheelInfo_16u__address1(void *c,void* p0); //method: address ::btWheelInfo const * ( ::btAlignedAllocator<btWheelInfo, 16u>::* )( ::btWheelInfo const & ) const
void* btAlignedAllocator_charconst_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<char const*, 16u>::* )(  ) 
void btAlignedAllocator_charconst_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<char const*, 16u>::* )( char const * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<char const*, 16u>::* )( char const * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate char const * * ( ::btAlignedAllocator<char const*, 16u>::* )( ::size_type,char const * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<char const*, 16u>::* )( char const * *,char const * const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address char const * * ( ::btAlignedAllocator<char const*, 16u>::* )( char const * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address char const * * ( ::btAlignedAllocator<char const*, 16u>::* )( char const * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address char const * const * ( ::btAlignedAllocator<char const*, 16u>::* )( char const * const & ) const
// error:  - unsupported,  - unsupported

void* btAlignedAllocator_char_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<char*, 16u>::* )(  ) 
void btAlignedAllocator_char_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<char*, 16u>::* )( char * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<char*, 16u>::* )( char * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate char * * ( ::btAlignedAllocator<char*, 16u>::* )( ::size_type,char * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<char*, 16u>::* )( char * *,char * const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address char * * ( ::btAlignedAllocator<char*, 16u>::* )( char * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address char * * ( ::btAlignedAllocator<char*, 16u>::* )( char * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address char * const * ( ::btAlignedAllocator<char*, 16u>::* )( char * const & ) const
// error:  - unsupported,  - unsupported

void* btAlignedAllocator_float_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<float, 16u>::* )(  ) 
void btAlignedAllocator_float_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<float, 16u>::* )( float * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<float, 16u>::* )( float * ) 
// error:  - unsupported, void - ok

//not supported method: allocate float * ( ::btAlignedAllocator<float, 16u>::* )( ::size_type,float const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<float, 16u>::* )( float *,float const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address float * ( ::btAlignedAllocator<float, 16u>::* )( float & ) const
// error:  - unsupported,  - unsupported

//not supported method: address float * ( ::btAlignedAllocator<float, 16u>::* )( float & ) const
// error:  - unsupported,  - unsupported

//not supported method: address float const * ( ::btAlignedAllocator<float, 16u>::* )( float const & ) const
// error:  - unsupported,  - unsupported

void* btAlignedAllocator_int_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<int, 16u>::* )(  ) 
void btAlignedAllocator_int_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<int, 16u>::* )( int * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<int, 16u>::* )( int * ) 
// error:  - unsupported, void - ok

//not supported method: allocate int * ( ::btAlignedAllocator<int, 16u>::* )( ::size_type,int const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<int, 16u>::* )( int *,int const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address int * ( ::btAlignedAllocator<int, 16u>::* )( int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address int * ( ::btAlignedAllocator<int, 16u>::* )( int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address int const * ( ::btAlignedAllocator<int, 16u>::* )( int const & ) const
// error:  - unsupported,  - unsupported

void* btAlignedAllocator_short_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<short*, 16u>::* )(  ) 
void btAlignedAllocator_short_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<short*, 16u>::* )( short int * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<short*, 16u>::* )( short int * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate short int * * ( ::btAlignedAllocator<short*, 16u>::* )( ::size_type,short int * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<short*, 16u>::* )( short int * *,short int * const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address short int * * ( ::btAlignedAllocator<short*, 16u>::* )( short int * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address short int * * ( ::btAlignedAllocator<short*, 16u>::* )( short int * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address short int * const * ( ::btAlignedAllocator<short*, 16u>::* )( short int * const & ) const
// error:  - unsupported,  - unsupported

void* btAlignedAllocator_short_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<short, 16u>::* )(  ) 
void btAlignedAllocator_short_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<short, 16u>::* )( short int * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<short, 16u>::* )( short int * ) 
// error:  - unsupported, void - ok

//not supported method: allocate short int * ( ::btAlignedAllocator<short, 16u>::* )( ::size_type,short int const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<short, 16u>::* )( short int *,short int const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address short int * ( ::btAlignedAllocator<short, 16u>::* )( short int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address short int * ( ::btAlignedAllocator<short, 16u>::* )( short int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address short int const * ( ::btAlignedAllocator<short, 16u>::* )( short int const & ) const
// error:  - unsupported,  - unsupported

void* btAlignedAllocator_unsignedint_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<unsigned int, 16u>::* )(  ) 
void btAlignedAllocator_unsignedint_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<unsigned int, 16u>::* )( unsigned int * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<unsigned int, 16u>::* )( unsigned int * ) 
// error:  - unsupported, void - ok

//not supported method: allocate unsigned int * ( ::btAlignedAllocator<unsigned int, 16u>::* )( ::size_type,unsigned int const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<unsigned int, 16u>::* )( unsigned int *,unsigned int const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address unsigned int * ( ::btAlignedAllocator<unsigned int, 16u>::* )( unsigned int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address unsigned int * ( ::btAlignedAllocator<unsigned int, 16u>::* )( unsigned int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address unsigned int const * ( ::btAlignedAllocator<unsigned int, 16u>::* )( unsigned int const & ) const
// error:  - unsupported,  - unsupported

void* btAlignedAllocator_unsignedshort_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<unsigned short, 16u>::* )(  ) 
void btAlignedAllocator_unsignedshort_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<unsigned short, 16u>::* )( short unsigned int * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<unsigned short, 16u>::* )( short unsigned int * ) 
// error:  - unsupported, void - ok

//not supported method: allocate short unsigned int * ( ::btAlignedAllocator<unsigned short, 16u>::* )( ::size_type,short unsigned int const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<unsigned short, 16u>::* )( short unsigned int *,short unsigned int const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address short unsigned int * ( ::btAlignedAllocator<unsigned short, 16u>::* )( short unsigned int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address short unsigned int * ( ::btAlignedAllocator<unsigned short, 16u>::* )( short unsigned int & ) const
// error:  - unsupported,  - unsupported

//not supported method: address short unsigned int const * ( ::btAlignedAllocator<unsigned short, 16u>::* )( short unsigned int const & ) const
// error:  - unsupported,  - unsupported

void* btAlignedAllocator_void_ptr_16u__new(); //constructor: btAlignedAllocator  ( ::btAlignedAllocator<void*, 16u>::* )(  ) 
void btAlignedAllocator_void_ptr_16u__free(void *c); 
//not supported method: destroy void ( ::btAlignedAllocator<void*, 16u>::* )( void * * ) 
// error:  - unsupported, void - ok

//not supported method: deallocate void ( ::btAlignedAllocator<void*, 16u>::* )( void * * ) 
// error:  - unsupported, void - ok

//not supported method: allocate void * * ( ::btAlignedAllocator<void*, 16u>::* )( ::size_type,void * const * * ) 
// error:  - unsupported,  - unsupported,  - unsupported

//not supported method: construct void ( ::btAlignedAllocator<void*, 16u>::* )( void * *,void * const & ) 
// error:  - unsupported,  - unsupported, void - ok

//not supported method: address void * * ( ::btAlignedAllocator<void*, 16u>::* )( void * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address void * * ( ::btAlignedAllocator<void*, 16u>::* )( void * & ) const
// error:  - unsupported,  - unsupported

//not supported method: address void * const * ( ::btAlignedAllocator<void*, 16u>::* )( void * const & ) const
// error:  - unsupported,  - unsupported

void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__free(void *c); 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( ::BT_QUANTIZED_BVH_NODE const & ) 
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__at(void *c,int p0); //method: at ::BT_QUANTIZED_BVH_NODE const & ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int ) const
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__at0(void *c,int p0); //method: at ::BT_QUANTIZED_BVH_NODE const & ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int ) const
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__at1(void *c,int p0); //method: at ::BT_QUANTIZED_BVH_NODE & ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int ) 
int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__size(void *c); //method: size int ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) const
int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) const
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__init(void *c); //method: init void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) 
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int,int ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( void *,int,int ) 
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__expandNonInitializing(void *c); //method: expandNonInitializing ::BT_QUANTIZED_BVH_NODE & ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int,::BT_QUANTIZED_BVH_NODE const & ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int,int ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int,int,::BT_QUANTIZED_BVH_NODE * ) const
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__expand(void *c,void* p0); //method: expand ::BT_QUANTIZED_BVH_NODE & ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( ::BT_QUANTIZED_BVH_NODE const & ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__clear(void *c); //method: clear void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )(  ) 
int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::* )( int ) 
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u> btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_->m_allocator
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u> btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_->m_allocator
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_->m_size
int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_size_get(void *c); //attribute: int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_->m_size
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_->m_capacity
int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_->m_capacity
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_data_set(void *c,void* a); //attribute: ::BT_QUANTIZED_BVH_NODE * btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_->m_data
void* btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_data_get(void *c); //attribute: ::BT_QUANTIZED_BVH_NODE * btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_->m_data
void btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_->m_ownsMemory
int btAlignedObjectArray_BT_QUANTIZED_BVH_NODE__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_->m_ownsMemory
void* btAlignedObjectArray_GIM_BVH_DATA__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_DATA__free(void *c); 
void btAlignedObjectArray_GIM_BVH_DATA__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( ::GIM_BVH_DATA const & ) 
void* btAlignedObjectArray_GIM_BVH_DATA__at(void *c,int p0); //method: at ::GIM_BVH_DATA const & ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int ) const
void* btAlignedObjectArray_GIM_BVH_DATA__at0(void *c,int p0); //method: at ::GIM_BVH_DATA const & ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int ) const
void* btAlignedObjectArray_GIM_BVH_DATA__at1(void *c,int p0); //method: at ::GIM_BVH_DATA & ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int ) 
int btAlignedObjectArray_GIM_BVH_DATA__size(void *c); //method: size int ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) const
int btAlignedObjectArray_GIM_BVH_DATA__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) const
void btAlignedObjectArray_GIM_BVH_DATA__init(void *c); //method: init void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) 
void* btAlignedObjectArray_GIM_BVH_DATA__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int ) 
void btAlignedObjectArray_GIM_BVH_DATA__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_DATA__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_DATA__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int,int ) 
void btAlignedObjectArray_GIM_BVH_DATA__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( void *,int,int ) 
void* btAlignedObjectArray_GIM_BVH_DATA__expandNonInitializing(void *c); //method: expandNonInitializing ::GIM_BVH_DATA & ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_DATA__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int,::GIM_BVH_DATA const & ) 
void btAlignedObjectArray_GIM_BVH_DATA__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int,int ) 
void btAlignedObjectArray_GIM_BVH_DATA__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int,int,::GIM_BVH_DATA * ) const
void* btAlignedObjectArray_GIM_BVH_DATA__expand(void *c,void* p0); //method: expand ::GIM_BVH_DATA & ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( ::GIM_BVH_DATA const & ) 
void btAlignedObjectArray_GIM_BVH_DATA__clear(void *c); //method: clear void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )(  ) 
int btAlignedObjectArray_GIM_BVH_DATA__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int ) 
void btAlignedObjectArray_GIM_BVH_DATA__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<GIM_BVH_DATA>::* )( int ) 
void btAlignedObjectArray_GIM_BVH_DATA__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<GIM_BVH_DATA, 16u> btAlignedObjectArray_GIM_BVH_DATA_->m_allocator
void* btAlignedObjectArray_GIM_BVH_DATA__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<GIM_BVH_DATA, 16u> btAlignedObjectArray_GIM_BVH_DATA_->m_allocator
void btAlignedObjectArray_GIM_BVH_DATA__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_GIM_BVH_DATA_->m_size
int btAlignedObjectArray_GIM_BVH_DATA__m_size_get(void *c); //attribute: int btAlignedObjectArray_GIM_BVH_DATA_->m_size
void btAlignedObjectArray_GIM_BVH_DATA__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_GIM_BVH_DATA_->m_capacity
int btAlignedObjectArray_GIM_BVH_DATA__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_GIM_BVH_DATA_->m_capacity
void btAlignedObjectArray_GIM_BVH_DATA__m_data_set(void *c,void* a); //attribute: ::GIM_BVH_DATA * btAlignedObjectArray_GIM_BVH_DATA_->m_data
void* btAlignedObjectArray_GIM_BVH_DATA__m_data_get(void *c); //attribute: ::GIM_BVH_DATA * btAlignedObjectArray_GIM_BVH_DATA_->m_data
void btAlignedObjectArray_GIM_BVH_DATA__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_GIM_BVH_DATA_->m_ownsMemory
int btAlignedObjectArray_GIM_BVH_DATA__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_GIM_BVH_DATA_->m_ownsMemory
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__free(void *c); 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( ::GIM_BVH_TREE_NODE const & ) 
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__at(void *c,int p0); //method: at ::GIM_BVH_TREE_NODE const & ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int ) const
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__at0(void *c,int p0); //method: at ::GIM_BVH_TREE_NODE const & ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int ) const
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__at1(void *c,int p0); //method: at ::GIM_BVH_TREE_NODE & ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int ) 
int btAlignedObjectArray_GIM_BVH_TREE_NODE__size(void *c); //method: size int ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) const
int btAlignedObjectArray_GIM_BVH_TREE_NODE__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) const
void btAlignedObjectArray_GIM_BVH_TREE_NODE__init(void *c); //method: init void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) 
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int,int ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( void *,int,int ) 
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__expandNonInitializing(void *c); //method: expandNonInitializing ::GIM_BVH_TREE_NODE & ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int,::GIM_BVH_TREE_NODE const & ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int,int ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int,int,::GIM_BVH_TREE_NODE * ) const
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__expand(void *c,void* p0); //method: expand ::GIM_BVH_TREE_NODE & ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( ::GIM_BVH_TREE_NODE const & ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__clear(void *c); //method: clear void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )(  ) 
int btAlignedObjectArray_GIM_BVH_TREE_NODE__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<GIM_BVH_TREE_NODE>::* )( int ) 
void btAlignedObjectArray_GIM_BVH_TREE_NODE__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u> btAlignedObjectArray_GIM_BVH_TREE_NODE_->m_allocator
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u> btAlignedObjectArray_GIM_BVH_TREE_NODE_->m_allocator
void btAlignedObjectArray_GIM_BVH_TREE_NODE__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_GIM_BVH_TREE_NODE_->m_size
int btAlignedObjectArray_GIM_BVH_TREE_NODE__m_size_get(void *c); //attribute: int btAlignedObjectArray_GIM_BVH_TREE_NODE_->m_size
void btAlignedObjectArray_GIM_BVH_TREE_NODE__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_GIM_BVH_TREE_NODE_->m_capacity
int btAlignedObjectArray_GIM_BVH_TREE_NODE__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_GIM_BVH_TREE_NODE_->m_capacity
void btAlignedObjectArray_GIM_BVH_TREE_NODE__m_data_set(void *c,void* a); //attribute: ::GIM_BVH_TREE_NODE * btAlignedObjectArray_GIM_BVH_TREE_NODE_->m_data
void* btAlignedObjectArray_GIM_BVH_TREE_NODE__m_data_get(void *c); //attribute: ::GIM_BVH_TREE_NODE * btAlignedObjectArray_GIM_BVH_TREE_NODE_->m_data
void btAlignedObjectArray_GIM_BVH_TREE_NODE__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_GIM_BVH_TREE_NODE_->m_ownsMemory
int btAlignedObjectArray_GIM_BVH_TREE_NODE__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_GIM_BVH_TREE_NODE_->m_ownsMemory
void* btAlignedObjectArray_GIM_PAIR__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) 
void btAlignedObjectArray_GIM_PAIR__free(void *c); 
void btAlignedObjectArray_GIM_PAIR__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<GIM_PAIR>::* )( ::GIM_PAIR const & ) 
void* btAlignedObjectArray_GIM_PAIR__at(void *c,int p0); //method: at ::GIM_PAIR const & ( ::btAlignedObjectArray<GIM_PAIR>::* )( int ) const
void* btAlignedObjectArray_GIM_PAIR__at0(void *c,int p0); //method: at ::GIM_PAIR const & ( ::btAlignedObjectArray<GIM_PAIR>::* )( int ) const
void* btAlignedObjectArray_GIM_PAIR__at1(void *c,int p0); //method: at ::GIM_PAIR & ( ::btAlignedObjectArray<GIM_PAIR>::* )( int ) 
int btAlignedObjectArray_GIM_PAIR__size(void *c); //method: size int ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) const
int btAlignedObjectArray_GIM_PAIR__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) const
void btAlignedObjectArray_GIM_PAIR__init(void *c); //method: init void ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) 
void* btAlignedObjectArray_GIM_PAIR__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<GIM_PAIR>::* )( int ) 
void btAlignedObjectArray_GIM_PAIR__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) 
void btAlignedObjectArray_GIM_PAIR__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) 
void btAlignedObjectArray_GIM_PAIR__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<GIM_PAIR>::* )( int,int ) 
void btAlignedObjectArray_GIM_PAIR__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<GIM_PAIR>::* )( void *,int,int ) 
void* btAlignedObjectArray_GIM_PAIR__expandNonInitializing(void *c); //method: expandNonInitializing ::GIM_PAIR & ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) 
void btAlignedObjectArray_GIM_PAIR__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<GIM_PAIR>::* )( int,::GIM_PAIR const & ) 
void btAlignedObjectArray_GIM_PAIR__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<GIM_PAIR>::* )( int,int ) 
void btAlignedObjectArray_GIM_PAIR__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<GIM_PAIR>::* )( int,int,::GIM_PAIR * ) const
void* btAlignedObjectArray_GIM_PAIR__expand(void *c,void* p0); //method: expand ::GIM_PAIR & ( ::btAlignedObjectArray<GIM_PAIR>::* )( ::GIM_PAIR const & ) 
void btAlignedObjectArray_GIM_PAIR__clear(void *c); //method: clear void ( ::btAlignedObjectArray<GIM_PAIR>::* )(  ) 
int btAlignedObjectArray_GIM_PAIR__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<GIM_PAIR>::* )( int ) 
void btAlignedObjectArray_GIM_PAIR__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<GIM_PAIR>::* )( int ) 
void btAlignedObjectArray_GIM_PAIR__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<GIM_PAIR, 16u> btAlignedObjectArray_GIM_PAIR_->m_allocator
void* btAlignedObjectArray_GIM_PAIR__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<GIM_PAIR, 16u> btAlignedObjectArray_GIM_PAIR_->m_allocator
void btAlignedObjectArray_GIM_PAIR__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_GIM_PAIR_->m_size
int btAlignedObjectArray_GIM_PAIR__m_size_get(void *c); //attribute: int btAlignedObjectArray_GIM_PAIR_->m_size
void btAlignedObjectArray_GIM_PAIR__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_GIM_PAIR_->m_capacity
int btAlignedObjectArray_GIM_PAIR__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_GIM_PAIR_->m_capacity
void btAlignedObjectArray_GIM_PAIR__m_data_set(void *c,void* a); //attribute: ::GIM_PAIR * btAlignedObjectArray_GIM_PAIR_->m_data
void* btAlignedObjectArray_GIM_PAIR__m_data_get(void *c); //attribute: ::GIM_PAIR * btAlignedObjectArray_GIM_PAIR_->m_data
void btAlignedObjectArray_GIM_PAIR__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_GIM_PAIR_->m_ownsMemory
int btAlignedObjectArray_GIM_PAIR__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_GIM_PAIR_->m_ownsMemory
void* btAlignedObjectArray_bool__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<bool>::* )(  ) 
void btAlignedObjectArray_bool__free(void *c); 
//not supported method: push_back void ( ::btAlignedObjectArray<bool>::* )( bool const & ) 
// error:  - unsupported, void - ok

//not supported method: at bool const & ( ::btAlignedObjectArray<bool>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at bool const & ( ::btAlignedObjectArray<bool>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at bool & ( ::btAlignedObjectArray<bool>::* )( int ) 
// error: int - ok,  - unsupported

int btAlignedObjectArray_bool__size(void *c); //method: size int ( ::btAlignedObjectArray<bool>::* )(  ) const
int btAlignedObjectArray_bool__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<bool>::* )(  ) const
void btAlignedObjectArray_bool__init(void *c); //method: init void ( ::btAlignedObjectArray<bool>::* )(  ) 
void btAlignedObjectArray_bool__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<bool>::* )( int,int ) 
void btAlignedObjectArray_bool__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<bool>::* )(  ) 
void btAlignedObjectArray_bool__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<bool>::* )(  ) 
void* btAlignedObjectArray_bool__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<bool>::* )( int ) 
void btAlignedObjectArray_bool__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<bool>::* )( void *,int,int ) 
//not supported method: expandNonInitializing bool & ( ::btAlignedObjectArray<bool>::* )(  ) 
// error:  - unsupported

void btAlignedObjectArray_bool__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<bool>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<bool>::* )( int,int,bool * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: resize void ( ::btAlignedObjectArray<bool>::* )( int,bool const & ) 
// error: int - ok,  - unsupported, void - ok

void btAlignedObjectArray_bool__clear(void *c); //method: clear void ( ::btAlignedObjectArray<bool>::* )(  ) 
int btAlignedObjectArray_bool__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<bool>::* )( int ) 
//not supported method: expand bool & ( ::btAlignedObjectArray<bool>::* )( bool const & ) 
// error:  - unsupported,  - unsupported

void btAlignedObjectArray_bool__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<bool>::* )( int ) 
void btAlignedObjectArray_bool__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<bool, 16u> btAlignedObjectArray_bool_->m_allocator
void* btAlignedObjectArray_bool__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<bool, 16u> btAlignedObjectArray_bool_->m_allocator
void btAlignedObjectArray_bool__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_bool_->m_capacity
int btAlignedObjectArray_bool__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_bool_->m_capacity
// attribute not supported: //attribute: bool * btAlignedObjectArray_bool_->m_data
void btAlignedObjectArray_bool__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_bool_->m_ownsMemory
int btAlignedObjectArray_bool__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_bool_->m_ownsMemory
void btAlignedObjectArray_bool__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_bool_->m_size
int btAlignedObjectArray_bool__m_size_get(void *c); //attribute: int btAlignedObjectArray_bool_->m_size
void* btAlignedObjectArray_btActionInterface_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) 
void btAlignedObjectArray_btActionInterface_ptr__free(void *c); 
void btAlignedObjectArray_btActionInterface_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btActionInterface*>::* )( ::btActionInterface * const & ) 
void* btAlignedObjectArray_btActionInterface_ptr__at(void *c,int p0); //method: at ::btActionInterface * const & ( ::btAlignedObjectArray<btActionInterface*>::* )( int ) const
void* btAlignedObjectArray_btActionInterface_ptr__at0(void *c,int p0); //method: at ::btActionInterface * const & ( ::btAlignedObjectArray<btActionInterface*>::* )( int ) const
void* btAlignedObjectArray_btActionInterface_ptr__at1(void *c,int p0); //method: at ::btActionInterface * & ( ::btAlignedObjectArray<btActionInterface*>::* )( int ) 
int btAlignedObjectArray_btActionInterface_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) const
int btAlignedObjectArray_btActionInterface_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) const
void btAlignedObjectArray_btActionInterface_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) 
void* btAlignedObjectArray_btActionInterface_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btActionInterface*>::* )( int ) 
void btAlignedObjectArray_btActionInterface_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) 
void btAlignedObjectArray_btActionInterface_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) 
void btAlignedObjectArray_btActionInterface_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btActionInterface*>::* )( int,int ) 
void btAlignedObjectArray_btActionInterface_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btActionInterface*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btActionInterface_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btActionInterface * & ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) 
void btAlignedObjectArray_btActionInterface_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btActionInterface*>::* )( int,::btActionInterface * const & ) 
void btAlignedObjectArray_btActionInterface_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btActionInterface*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btActionInterface*>::* )( int,int,::btActionInterface * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void* btAlignedObjectArray_btActionInterface_ptr__expand(void *c,void* p0); //method: expand ::btActionInterface * & ( ::btAlignedObjectArray<btActionInterface*>::* )( ::btActionInterface * const & ) 
void btAlignedObjectArray_btActionInterface_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btActionInterface*>::* )(  ) 
int btAlignedObjectArray_btActionInterface_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btActionInterface*>::* )( int ) 
void btAlignedObjectArray_btActionInterface_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btActionInterface*>::* )( int ) 
void btAlignedObjectArray_btActionInterface_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btActionInterface*, 16u> btAlignedObjectArray_btActionInterface_ptr_->m_allocator
void* btAlignedObjectArray_btActionInterface_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btActionInterface*, 16u> btAlignedObjectArray_btActionInterface_ptr_->m_allocator
void btAlignedObjectArray_btActionInterface_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btActionInterface_ptr_->m_size
int btAlignedObjectArray_btActionInterface_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btActionInterface_ptr_->m_size
void btAlignedObjectArray_btActionInterface_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btActionInterface_ptr_->m_capacity
int btAlignedObjectArray_btActionInterface_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btActionInterface_ptr_->m_capacity
// attribute not supported: //attribute: ::btActionInterface * * btAlignedObjectArray_btActionInterface_ptr_->m_data
void btAlignedObjectArray_btActionInterface_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btActionInterface_ptr_->m_ownsMemory
int btAlignedObjectArray_btActionInterface_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btActionInterface_ptr_->m_ownsMemory
void* btAlignedObjectArray_btBroadphaseInterface_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__free(void *c); 
void btAlignedObjectArray_btBroadphaseInterface_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( ::btBroadphaseInterface * const & ) 
void* btAlignedObjectArray_btBroadphaseInterface_ptr__at(void *c,int p0); //method: at ::btBroadphaseInterface * const & ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int ) const
void* btAlignedObjectArray_btBroadphaseInterface_ptr__at0(void *c,int p0); //method: at ::btBroadphaseInterface * const & ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int ) const
void* btAlignedObjectArray_btBroadphaseInterface_ptr__at1(void *c,int p0); //method: at ::btBroadphaseInterface * & ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int ) 
int btAlignedObjectArray_btBroadphaseInterface_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) const
int btAlignedObjectArray_btBroadphaseInterface_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) const
void btAlignedObjectArray_btBroadphaseInterface_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) 
void* btAlignedObjectArray_btBroadphaseInterface_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int,int ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btBroadphaseInterface_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btBroadphaseInterface * & ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int,::btBroadphaseInterface * const & ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int,int,::btBroadphaseInterface * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void* btAlignedObjectArray_btBroadphaseInterface_ptr__expand(void *c,void* p0); //method: expand ::btBroadphaseInterface * & ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( ::btBroadphaseInterface * const & ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )(  ) 
int btAlignedObjectArray_btBroadphaseInterface_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btBroadphaseInterface*>::* )( int ) 
void btAlignedObjectArray_btBroadphaseInterface_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btBroadphaseInterface*, 16u> btAlignedObjectArray_btBroadphaseInterface_ptr_->m_allocator
void* btAlignedObjectArray_btBroadphaseInterface_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btBroadphaseInterface*, 16u> btAlignedObjectArray_btBroadphaseInterface_ptr_->m_allocator
void btAlignedObjectArray_btBroadphaseInterface_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btBroadphaseInterface_ptr_->m_size
int btAlignedObjectArray_btBroadphaseInterface_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btBroadphaseInterface_ptr_->m_size
void btAlignedObjectArray_btBroadphaseInterface_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btBroadphaseInterface_ptr_->m_capacity
int btAlignedObjectArray_btBroadphaseInterface_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btBroadphaseInterface_ptr_->m_capacity
// attribute not supported: //attribute: ::btBroadphaseInterface * * btAlignedObjectArray_btBroadphaseInterface_ptr_->m_data
void btAlignedObjectArray_btBroadphaseInterface_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btBroadphaseInterface_ptr_->m_ownsMemory
int btAlignedObjectArray_btBroadphaseInterface_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btBroadphaseInterface_ptr_->m_ownsMemory
void* btAlignedObjectArray_btBroadphasePair__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) 
void btAlignedObjectArray_btBroadphasePair__free(void *c); 
void btAlignedObjectArray_btBroadphasePair__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btBroadphasePair>::* )( ::btBroadphasePair const & ) 
void* btAlignedObjectArray_btBroadphasePair__at(void *c,int p0); //method: at ::btBroadphasePair const & ( ::btAlignedObjectArray<btBroadphasePair>::* )( int ) const
void* btAlignedObjectArray_btBroadphasePair__at0(void *c,int p0); //method: at ::btBroadphasePair const & ( ::btAlignedObjectArray<btBroadphasePair>::* )( int ) const
void* btAlignedObjectArray_btBroadphasePair__at1(void *c,int p0); //method: at ::btBroadphasePair & ( ::btAlignedObjectArray<btBroadphasePair>::* )( int ) 
int btAlignedObjectArray_btBroadphasePair__size(void *c); //method: size int ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) const
int btAlignedObjectArray_btBroadphasePair__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) const
void btAlignedObjectArray_btBroadphasePair__init(void *c); //method: init void ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) 
void* btAlignedObjectArray_btBroadphasePair__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btBroadphasePair>::* )( int ) 
void btAlignedObjectArray_btBroadphasePair__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) 
void btAlignedObjectArray_btBroadphasePair__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) 
void btAlignedObjectArray_btBroadphasePair__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btBroadphasePair>::* )( int,int ) 
void btAlignedObjectArray_btBroadphasePair__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btBroadphasePair>::* )( void *,int,int ) 
void* btAlignedObjectArray_btBroadphasePair__expandNonInitializing(void *c); //method: expandNonInitializing ::btBroadphasePair & ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) 
void btAlignedObjectArray_btBroadphasePair__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btBroadphasePair>::* )( int,::btBroadphasePair const & ) 
void btAlignedObjectArray_btBroadphasePair__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btBroadphasePair>::* )( int,int ) 
void btAlignedObjectArray_btBroadphasePair__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btBroadphasePair>::* )( int,int,::btBroadphasePair * ) const
void* btAlignedObjectArray_btBroadphasePair__expand(void *c,void* p0); //method: expand ::btBroadphasePair & ( ::btAlignedObjectArray<btBroadphasePair>::* )( ::btBroadphasePair const & ) 
void btAlignedObjectArray_btBroadphasePair__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btBroadphasePair>::* )(  ) 
int btAlignedObjectArray_btBroadphasePair__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btBroadphasePair>::* )( int ) 
void btAlignedObjectArray_btBroadphasePair__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btBroadphasePair>::* )( int ) 
void btAlignedObjectArray_btBroadphasePair__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btBroadphasePair, 16u> btAlignedObjectArray_btBroadphasePair_->m_allocator
void* btAlignedObjectArray_btBroadphasePair__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btBroadphasePair, 16u> btAlignedObjectArray_btBroadphasePair_->m_allocator
void btAlignedObjectArray_btBroadphasePair__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btBroadphasePair_->m_size
int btAlignedObjectArray_btBroadphasePair__m_size_get(void *c); //attribute: int btAlignedObjectArray_btBroadphasePair_->m_size
void btAlignedObjectArray_btBroadphasePair__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btBroadphasePair_->m_capacity
int btAlignedObjectArray_btBroadphasePair__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btBroadphasePair_->m_capacity
void btAlignedObjectArray_btBroadphasePair__m_data_set(void *c,void* a); //attribute: ::btBroadphasePair * btAlignedObjectArray_btBroadphasePair_->m_data
void* btAlignedObjectArray_btBroadphasePair__m_data_get(void *c); //attribute: ::btBroadphasePair * btAlignedObjectArray_btBroadphasePair_->m_data
void btAlignedObjectArray_btBroadphasePair__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btBroadphasePair_->m_ownsMemory
int btAlignedObjectArray_btBroadphasePair__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btBroadphasePair_->m_ownsMemory
void* btAlignedObjectArray_btBvhSubtreeInfo__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) 
void btAlignedObjectArray_btBvhSubtreeInfo__free(void *c); 
void btAlignedObjectArray_btBvhSubtreeInfo__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( ::btBvhSubtreeInfo const & ) 
void* btAlignedObjectArray_btBvhSubtreeInfo__at(void *c,int p0); //method: at ::btBvhSubtreeInfo const & ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int ) const
void* btAlignedObjectArray_btBvhSubtreeInfo__at0(void *c,int p0); //method: at ::btBvhSubtreeInfo const & ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int ) const
void* btAlignedObjectArray_btBvhSubtreeInfo__at1(void *c,int p0); //method: at ::btBvhSubtreeInfo & ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int ) 
int btAlignedObjectArray_btBvhSubtreeInfo__size(void *c); //method: size int ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) const
int btAlignedObjectArray_btBvhSubtreeInfo__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) const
void btAlignedObjectArray_btBvhSubtreeInfo__init(void *c); //method: init void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) 
void* btAlignedObjectArray_btBvhSubtreeInfo__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int ) 
void btAlignedObjectArray_btBvhSubtreeInfo__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) 
void btAlignedObjectArray_btBvhSubtreeInfo__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) 
void btAlignedObjectArray_btBvhSubtreeInfo__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int,int ) 
void btAlignedObjectArray_btBvhSubtreeInfo__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( void *,int,int ) 
void* btAlignedObjectArray_btBvhSubtreeInfo__expandNonInitializing(void *c); //method: expandNonInitializing ::btBvhSubtreeInfo & ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) 
void btAlignedObjectArray_btBvhSubtreeInfo__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int,::btBvhSubtreeInfo const & ) 
void btAlignedObjectArray_btBvhSubtreeInfo__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int,int ) 
void btAlignedObjectArray_btBvhSubtreeInfo__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int,int,::btBvhSubtreeInfo * ) const
void* btAlignedObjectArray_btBvhSubtreeInfo__expand(void *c,void* p0); //method: expand ::btBvhSubtreeInfo & ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( ::btBvhSubtreeInfo const & ) 
void btAlignedObjectArray_btBvhSubtreeInfo__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )(  ) 
int btAlignedObjectArray_btBvhSubtreeInfo__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int ) 
void btAlignedObjectArray_btBvhSubtreeInfo__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btBvhSubtreeInfo>::* )( int ) 
void btAlignedObjectArray_btBvhSubtreeInfo__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btBvhSubtreeInfo, 16u> btAlignedObjectArray_btBvhSubtreeInfo_->m_allocator
void* btAlignedObjectArray_btBvhSubtreeInfo__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btBvhSubtreeInfo, 16u> btAlignedObjectArray_btBvhSubtreeInfo_->m_allocator
void btAlignedObjectArray_btBvhSubtreeInfo__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btBvhSubtreeInfo_->m_size
int btAlignedObjectArray_btBvhSubtreeInfo__m_size_get(void *c); //attribute: int btAlignedObjectArray_btBvhSubtreeInfo_->m_size
void btAlignedObjectArray_btBvhSubtreeInfo__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btBvhSubtreeInfo_->m_capacity
int btAlignedObjectArray_btBvhSubtreeInfo__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btBvhSubtreeInfo_->m_capacity
void btAlignedObjectArray_btBvhSubtreeInfo__m_data_set(void *c,void* a); //attribute: ::btBvhSubtreeInfo * btAlignedObjectArray_btBvhSubtreeInfo_->m_data
void* btAlignedObjectArray_btBvhSubtreeInfo__m_data_get(void *c); //attribute: ::btBvhSubtreeInfo * btAlignedObjectArray_btBvhSubtreeInfo_->m_data
void btAlignedObjectArray_btBvhSubtreeInfo__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btBvhSubtreeInfo_->m_ownsMemory
int btAlignedObjectArray_btBvhSubtreeInfo__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btBvhSubtreeInfo_->m_ownsMemory
void* btAlignedObjectArray_btChunk_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btChunk*>::* )(  ) 
void btAlignedObjectArray_btChunk_ptr__free(void *c); 
void btAlignedObjectArray_btChunk_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btChunk*>::* )( ::btChunk * const & ) 
void* btAlignedObjectArray_btChunk_ptr__at(void *c,int p0); //method: at ::btChunk * const & ( ::btAlignedObjectArray<btChunk*>::* )( int ) const
void* btAlignedObjectArray_btChunk_ptr__at0(void *c,int p0); //method: at ::btChunk * const & ( ::btAlignedObjectArray<btChunk*>::* )( int ) const
void* btAlignedObjectArray_btChunk_ptr__at1(void *c,int p0); //method: at ::btChunk * & ( ::btAlignedObjectArray<btChunk*>::* )( int ) 
int btAlignedObjectArray_btChunk_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btChunk*>::* )(  ) const
int btAlignedObjectArray_btChunk_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btChunk*>::* )(  ) const
void btAlignedObjectArray_btChunk_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btChunk*>::* )(  ) 
void* btAlignedObjectArray_btChunk_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btChunk*>::* )( int ) 
void btAlignedObjectArray_btChunk_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btChunk*>::* )(  ) 
void btAlignedObjectArray_btChunk_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btChunk*>::* )(  ) 
void btAlignedObjectArray_btChunk_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btChunk*>::* )( int,int ) 
void btAlignedObjectArray_btChunk_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btChunk*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btChunk_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btChunk * & ( ::btAlignedObjectArray<btChunk*>::* )(  ) 
void btAlignedObjectArray_btChunk_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btChunk*>::* )( int,::btChunk * const & ) 
void btAlignedObjectArray_btChunk_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btChunk*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btChunk*>::* )( int,int,::btChunk * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void* btAlignedObjectArray_btChunk_ptr__expand(void *c,void* p0); //method: expand ::btChunk * & ( ::btAlignedObjectArray<btChunk*>::* )( ::btChunk * const & ) 
void btAlignedObjectArray_btChunk_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btChunk*>::* )(  ) 
int btAlignedObjectArray_btChunk_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btChunk*>::* )( int ) 
void btAlignedObjectArray_btChunk_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btChunk*>::* )( int ) 
void btAlignedObjectArray_btChunk_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btChunk*, 16u> btAlignedObjectArray_btChunk_ptr_->m_allocator
void* btAlignedObjectArray_btChunk_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btChunk*, 16u> btAlignedObjectArray_btChunk_ptr_->m_allocator
void btAlignedObjectArray_btChunk_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btChunk_ptr_->m_size
int btAlignedObjectArray_btChunk_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btChunk_ptr_->m_size
void btAlignedObjectArray_btChunk_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btChunk_ptr_->m_capacity
int btAlignedObjectArray_btChunk_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btChunk_ptr_->m_capacity
// attribute not supported: //attribute: ::btChunk * * btAlignedObjectArray_btChunk_ptr_->m_data
void btAlignedObjectArray_btChunk_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btChunk_ptr_->m_ownsMemory
int btAlignedObjectArray_btChunk_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btChunk_ptr_->m_ownsMemory
void* btAlignedObjectArray_btCollisionObject_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) 
void btAlignedObjectArray_btCollisionObject_ptr__free(void *c); 
void btAlignedObjectArray_btCollisionObject_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btCollisionObject*>::* )( ::btCollisionObject * const & ) 
void* btAlignedObjectArray_btCollisionObject_ptr__at(void *c,int p0); //method: at ::btCollisionObject * const & ( ::btAlignedObjectArray<btCollisionObject*>::* )( int ) const
void* btAlignedObjectArray_btCollisionObject_ptr__at0(void *c,int p0); //method: at ::btCollisionObject * const & ( ::btAlignedObjectArray<btCollisionObject*>::* )( int ) const
void* btAlignedObjectArray_btCollisionObject_ptr__at1(void *c,int p0); //method: at ::btCollisionObject * & ( ::btAlignedObjectArray<btCollisionObject*>::* )( int ) 
int btAlignedObjectArray_btCollisionObject_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) const
int btAlignedObjectArray_btCollisionObject_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) const
void btAlignedObjectArray_btCollisionObject_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) 
void btAlignedObjectArray_btCollisionObject_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btCollisionObject*>::* )( int,int ) 
void btAlignedObjectArray_btCollisionObject_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) 
void btAlignedObjectArray_btCollisionObject_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) 
void* btAlignedObjectArray_btCollisionObject_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btCollisionObject*>::* )( int ) 
void btAlignedObjectArray_btCollisionObject_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btCollisionObject*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btCollisionObject_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btCollisionObject * & ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) 
void btAlignedObjectArray_btCollisionObject_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btCollisionObject*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btCollisionObject*>::* )( int,int,::btCollisionObject * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void btAlignedObjectArray_btCollisionObject_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btCollisionObject*>::* )( int,::btCollisionObject * const & ) 
void btAlignedObjectArray_btCollisionObject_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btCollisionObject*>::* )(  ) 
int btAlignedObjectArray_btCollisionObject_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btCollisionObject*>::* )( int ) 
void* btAlignedObjectArray_btCollisionObject_ptr__expand(void *c,void* p0); //method: expand ::btCollisionObject * & ( ::btAlignedObjectArray<btCollisionObject*>::* )( ::btCollisionObject * const & ) 
void btAlignedObjectArray_btCollisionObject_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btCollisionObject*>::* )( int ) 
void btAlignedObjectArray_btCollisionObject_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btCollisionObject*, 16u> btAlignedObjectArray_btCollisionObject_ptr_->m_allocator
void* btAlignedObjectArray_btCollisionObject_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btCollisionObject*, 16u> btAlignedObjectArray_btCollisionObject_ptr_->m_allocator
void btAlignedObjectArray_btCollisionObject_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btCollisionObject_ptr_->m_capacity
int btAlignedObjectArray_btCollisionObject_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btCollisionObject_ptr_->m_capacity
// attribute not supported: //attribute: ::btCollisionObject * * btAlignedObjectArray_btCollisionObject_ptr_->m_data
void btAlignedObjectArray_btCollisionObject_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btCollisionObject_ptr_->m_ownsMemory
int btAlignedObjectArray_btCollisionObject_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btCollisionObject_ptr_->m_ownsMemory
void btAlignedObjectArray_btCollisionObject_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btCollisionObject_ptr_->m_size
int btAlignedObjectArray_btCollisionObject_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btCollisionObject_ptr_->m_size
void* btAlignedObjectArray_btCollisionShape_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) 
void btAlignedObjectArray_btCollisionShape_ptr__free(void *c); 
void btAlignedObjectArray_btCollisionShape_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btCollisionShape*>::* )( ::btCollisionShape * const & ) 
void* btAlignedObjectArray_btCollisionShape_ptr__at(void *c,int p0); //method: at ::btCollisionShape * const & ( ::btAlignedObjectArray<btCollisionShape*>::* )( int ) const
void* btAlignedObjectArray_btCollisionShape_ptr__at0(void *c,int p0); //method: at ::btCollisionShape * const & ( ::btAlignedObjectArray<btCollisionShape*>::* )( int ) const
void* btAlignedObjectArray_btCollisionShape_ptr__at1(void *c,int p0); //method: at ::btCollisionShape * & ( ::btAlignedObjectArray<btCollisionShape*>::* )( int ) 
int btAlignedObjectArray_btCollisionShape_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) const
int btAlignedObjectArray_btCollisionShape_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) const
void btAlignedObjectArray_btCollisionShape_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) 
void* btAlignedObjectArray_btCollisionShape_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btCollisionShape*>::* )( int ) 
void btAlignedObjectArray_btCollisionShape_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) 
void btAlignedObjectArray_btCollisionShape_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) 
void btAlignedObjectArray_btCollisionShape_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btCollisionShape*>::* )( int,int ) 
void btAlignedObjectArray_btCollisionShape_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btCollisionShape*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btCollisionShape_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btCollisionShape * & ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) 
void btAlignedObjectArray_btCollisionShape_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btCollisionShape*>::* )( int,::btCollisionShape * const & ) 
void btAlignedObjectArray_btCollisionShape_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btCollisionShape*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btCollisionShape*>::* )( int,int,::btCollisionShape * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void* btAlignedObjectArray_btCollisionShape_ptr__expand(void *c,void* p0); //method: expand ::btCollisionShape * & ( ::btAlignedObjectArray<btCollisionShape*>::* )( ::btCollisionShape * const & ) 
void btAlignedObjectArray_btCollisionShape_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btCollisionShape*>::* )(  ) 
int btAlignedObjectArray_btCollisionShape_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btCollisionShape*>::* )( int ) 
void btAlignedObjectArray_btCollisionShape_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btCollisionShape*>::* )( int ) 
void btAlignedObjectArray_btCollisionShape_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btCollisionShape*, 16u> btAlignedObjectArray_btCollisionShape_ptr_->m_allocator
void* btAlignedObjectArray_btCollisionShape_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btCollisionShape*, 16u> btAlignedObjectArray_btCollisionShape_ptr_->m_allocator
void btAlignedObjectArray_btCollisionShape_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btCollisionShape_ptr_->m_size
int btAlignedObjectArray_btCollisionShape_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btCollisionShape_ptr_->m_size
void btAlignedObjectArray_btCollisionShape_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btCollisionShape_ptr_->m_capacity
int btAlignedObjectArray_btCollisionShape_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btCollisionShape_ptr_->m_capacity
// attribute not supported: //attribute: ::btCollisionShape * * btAlignedObjectArray_btCollisionShape_ptr_->m_data
void btAlignedObjectArray_btCollisionShape_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btCollisionShape_ptr_->m_ownsMemory
int btAlignedObjectArray_btCollisionShape_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btCollisionShape_ptr_->m_ownsMemory
void* btAlignedObjectArray_btCompoundShapeChild__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) 
void btAlignedObjectArray_btCompoundShapeChild__free(void *c); 
void btAlignedObjectArray_btCompoundShapeChild__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( ::btCompoundShapeChild const & ) 
void* btAlignedObjectArray_btCompoundShapeChild__at(void *c,int p0); //method: at ::btCompoundShapeChild const & ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int ) const
void* btAlignedObjectArray_btCompoundShapeChild__at0(void *c,int p0); //method: at ::btCompoundShapeChild const & ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int ) const
void* btAlignedObjectArray_btCompoundShapeChild__at1(void *c,int p0); //method: at ::btCompoundShapeChild & ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int ) 
int btAlignedObjectArray_btCompoundShapeChild__size(void *c); //method: size int ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) const
int btAlignedObjectArray_btCompoundShapeChild__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) const
void btAlignedObjectArray_btCompoundShapeChild__init(void *c); //method: init void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) 
void* btAlignedObjectArray_btCompoundShapeChild__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int ) 
void btAlignedObjectArray_btCompoundShapeChild__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) 
void btAlignedObjectArray_btCompoundShapeChild__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) 
void btAlignedObjectArray_btCompoundShapeChild__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int,int ) 
void btAlignedObjectArray_btCompoundShapeChild__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( void *,int,int ) 
void* btAlignedObjectArray_btCompoundShapeChild__expandNonInitializing(void *c); //method: expandNonInitializing ::btCompoundShapeChild & ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) 
void btAlignedObjectArray_btCompoundShapeChild__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int,::btCompoundShapeChild const & ) 
void btAlignedObjectArray_btCompoundShapeChild__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int,int ) 
void btAlignedObjectArray_btCompoundShapeChild__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int,int,::btCompoundShapeChild * ) const
void* btAlignedObjectArray_btCompoundShapeChild__expand(void *c,void* p0); //method: expand ::btCompoundShapeChild & ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( ::btCompoundShapeChild const & ) 
void btAlignedObjectArray_btCompoundShapeChild__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )(  ) 
int btAlignedObjectArray_btCompoundShapeChild__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int ) 
void btAlignedObjectArray_btCompoundShapeChild__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btCompoundShapeChild>::* )( int ) 
void btAlignedObjectArray_btCompoundShapeChild__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btCompoundShapeChild, 16u> btAlignedObjectArray_btCompoundShapeChild_->m_allocator
void* btAlignedObjectArray_btCompoundShapeChild__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btCompoundShapeChild, 16u> btAlignedObjectArray_btCompoundShapeChild_->m_allocator
void btAlignedObjectArray_btCompoundShapeChild__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btCompoundShapeChild_->m_size
int btAlignedObjectArray_btCompoundShapeChild__m_size_get(void *c); //attribute: int btAlignedObjectArray_btCompoundShapeChild_->m_size
void btAlignedObjectArray_btCompoundShapeChild__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btCompoundShapeChild_->m_capacity
int btAlignedObjectArray_btCompoundShapeChild__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btCompoundShapeChild_->m_capacity
void btAlignedObjectArray_btCompoundShapeChild__m_data_set(void *c,void* a); //attribute: ::btCompoundShapeChild * btAlignedObjectArray_btCompoundShapeChild_->m_data
void* btAlignedObjectArray_btCompoundShapeChild__m_data_get(void *c); //attribute: ::btCompoundShapeChild * btAlignedObjectArray_btCompoundShapeChild_->m_data
void btAlignedObjectArray_btCompoundShapeChild__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btCompoundShapeChild_->m_ownsMemory
int btAlignedObjectArray_btCompoundShapeChild__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btCompoundShapeChild_->m_ownsMemory
void* btAlignedObjectArray_btDbvt_sStkNN__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNN__free(void *c); 
void btAlignedObjectArray_btDbvt_sStkNN__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( ::btDbvt::sStkNN const & ) 
void* btAlignedObjectArray_btDbvt_sStkNN__at(void *c,int p0); //method: at ::btDbvt::sStkNN const & ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int ) const
void* btAlignedObjectArray_btDbvt_sStkNN__at0(void *c,int p0); //method: at ::btDbvt::sStkNN const & ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int ) const
void* btAlignedObjectArray_btDbvt_sStkNN__at1(void *c,int p0); //method: at ::btDbvt::sStkNN & ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int ) 
int btAlignedObjectArray_btDbvt_sStkNN__size(void *c); //method: size int ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) const
int btAlignedObjectArray_btDbvt_sStkNN__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) const
void btAlignedObjectArray_btDbvt_sStkNN__init(void *c); //method: init void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) 
void* btAlignedObjectArray_btDbvt_sStkNN__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int ) 
void btAlignedObjectArray_btDbvt_sStkNN__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNN__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNN__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int,int ) 
void btAlignedObjectArray_btDbvt_sStkNN__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( void *,int,int ) 
void* btAlignedObjectArray_btDbvt_sStkNN__expandNonInitializing(void *c); //method: expandNonInitializing ::btDbvt::sStkNN & ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNN__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int,::btDbvt::sStkNN const & ) 
void btAlignedObjectArray_btDbvt_sStkNN__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int,int ) 
void btAlignedObjectArray_btDbvt_sStkNN__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int,int,::btDbvt::sStkNN * ) const
void* btAlignedObjectArray_btDbvt_sStkNN__expand(void *c,void* p0); //method: expand ::btDbvt::sStkNN & ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( ::btDbvt::sStkNN const & ) 
void btAlignedObjectArray_btDbvt_sStkNN__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )(  ) 
int btAlignedObjectArray_btDbvt_sStkNN__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int ) 
void btAlignedObjectArray_btDbvt_sStkNN__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btDbvt::sStkNN>::* )( int ) 
void btAlignedObjectArray_btDbvt_sStkNN__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btDbvt::sStkNN, 16u> btAlignedObjectArray_btDbvt_sStkNN_->m_allocator
void* btAlignedObjectArray_btDbvt_sStkNN__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btDbvt::sStkNN, 16u> btAlignedObjectArray_btDbvt_sStkNN_->m_allocator
void btAlignedObjectArray_btDbvt_sStkNN__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btDbvt_sStkNN_->m_size
int btAlignedObjectArray_btDbvt_sStkNN__m_size_get(void *c); //attribute: int btAlignedObjectArray_btDbvt_sStkNN_->m_size
void btAlignedObjectArray_btDbvt_sStkNN__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btDbvt_sStkNN_->m_capacity
int btAlignedObjectArray_btDbvt_sStkNN__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btDbvt_sStkNN_->m_capacity
void btAlignedObjectArray_btDbvt_sStkNN__m_data_set(void *c,void* a); //attribute: ::btDbvt::sStkNN * btAlignedObjectArray_btDbvt_sStkNN_->m_data
void* btAlignedObjectArray_btDbvt_sStkNN__m_data_get(void *c); //attribute: ::btDbvt::sStkNN * btAlignedObjectArray_btDbvt_sStkNN_->m_data
void btAlignedObjectArray_btDbvt_sStkNN__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btDbvt_sStkNN_->m_ownsMemory
int btAlignedObjectArray_btDbvt_sStkNN__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btDbvt_sStkNN_->m_ownsMemory
void* btAlignedObjectArray_btDbvt_sStkNP__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNP__free(void *c); 
void btAlignedObjectArray_btDbvt_sStkNP__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( ::btDbvt::sStkNP const & ) 
void* btAlignedObjectArray_btDbvt_sStkNP__at(void *c,int p0); //method: at ::btDbvt::sStkNP const & ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int ) const
void* btAlignedObjectArray_btDbvt_sStkNP__at0(void *c,int p0); //method: at ::btDbvt::sStkNP const & ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int ) const
void* btAlignedObjectArray_btDbvt_sStkNP__at1(void *c,int p0); //method: at ::btDbvt::sStkNP & ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int ) 
int btAlignedObjectArray_btDbvt_sStkNP__size(void *c); //method: size int ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) const
int btAlignedObjectArray_btDbvt_sStkNP__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) const
void btAlignedObjectArray_btDbvt_sStkNP__init(void *c); //method: init void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) 
void* btAlignedObjectArray_btDbvt_sStkNP__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int ) 
void btAlignedObjectArray_btDbvt_sStkNP__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNP__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNP__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int,int ) 
void btAlignedObjectArray_btDbvt_sStkNP__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( void *,int,int ) 
void* btAlignedObjectArray_btDbvt_sStkNP__expandNonInitializing(void *c); //method: expandNonInitializing ::btDbvt::sStkNP & ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNP__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int,::btDbvt::sStkNP const & ) 
void btAlignedObjectArray_btDbvt_sStkNP__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int,int ) 
void btAlignedObjectArray_btDbvt_sStkNP__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int,int,::btDbvt::sStkNP * ) const
void* btAlignedObjectArray_btDbvt_sStkNP__expand(void *c,void* p0); //method: expand ::btDbvt::sStkNP & ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( ::btDbvt::sStkNP const & ) 
void btAlignedObjectArray_btDbvt_sStkNP__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )(  ) 
int btAlignedObjectArray_btDbvt_sStkNP__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int ) 
void btAlignedObjectArray_btDbvt_sStkNP__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btDbvt::sStkNP>::* )( int ) 
void btAlignedObjectArray_btDbvt_sStkNP__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btDbvt::sStkNP, 16u> btAlignedObjectArray_btDbvt_sStkNP_->m_allocator
void* btAlignedObjectArray_btDbvt_sStkNP__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btDbvt::sStkNP, 16u> btAlignedObjectArray_btDbvt_sStkNP_->m_allocator
void btAlignedObjectArray_btDbvt_sStkNP__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btDbvt_sStkNP_->m_size
int btAlignedObjectArray_btDbvt_sStkNP__m_size_get(void *c); //attribute: int btAlignedObjectArray_btDbvt_sStkNP_->m_size
void btAlignedObjectArray_btDbvt_sStkNP__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btDbvt_sStkNP_->m_capacity
int btAlignedObjectArray_btDbvt_sStkNP__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btDbvt_sStkNP_->m_capacity
void btAlignedObjectArray_btDbvt_sStkNP__m_data_set(void *c,void* a); //attribute: ::btDbvt::sStkNP * btAlignedObjectArray_btDbvt_sStkNP_->m_data
void* btAlignedObjectArray_btDbvt_sStkNP__m_data_get(void *c); //attribute: ::btDbvt::sStkNP * btAlignedObjectArray_btDbvt_sStkNP_->m_data
void btAlignedObjectArray_btDbvt_sStkNP__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btDbvt_sStkNP_->m_ownsMemory
int btAlignedObjectArray_btDbvt_sStkNP__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btDbvt_sStkNP_->m_ownsMemory
void* btAlignedObjectArray_btDbvt_sStkNPS__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNPS__free(void *c); 
void btAlignedObjectArray_btDbvt_sStkNPS__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( ::btDbvt::sStkNPS const & ) 
void* btAlignedObjectArray_btDbvt_sStkNPS__at(void *c,int p0); //method: at ::btDbvt::sStkNPS const & ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int ) const
void* btAlignedObjectArray_btDbvt_sStkNPS__at0(void *c,int p0); //method: at ::btDbvt::sStkNPS const & ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int ) const
void* btAlignedObjectArray_btDbvt_sStkNPS__at1(void *c,int p0); //method: at ::btDbvt::sStkNPS & ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int ) 
int btAlignedObjectArray_btDbvt_sStkNPS__size(void *c); //method: size int ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) const
int btAlignedObjectArray_btDbvt_sStkNPS__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) const
void btAlignedObjectArray_btDbvt_sStkNPS__init(void *c); //method: init void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) 
void* btAlignedObjectArray_btDbvt_sStkNPS__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int ) 
void btAlignedObjectArray_btDbvt_sStkNPS__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNPS__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNPS__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int,int ) 
void btAlignedObjectArray_btDbvt_sStkNPS__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( void *,int,int ) 
void* btAlignedObjectArray_btDbvt_sStkNPS__expandNonInitializing(void *c); //method: expandNonInitializing ::btDbvt::sStkNPS & ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) 
void btAlignedObjectArray_btDbvt_sStkNPS__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int,::btDbvt::sStkNPS const & ) 
void btAlignedObjectArray_btDbvt_sStkNPS__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int,int ) 
void btAlignedObjectArray_btDbvt_sStkNPS__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int,int,::btDbvt::sStkNPS * ) const
void* btAlignedObjectArray_btDbvt_sStkNPS__expand(void *c,void* p0); //method: expand ::btDbvt::sStkNPS & ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( ::btDbvt::sStkNPS const & ) 
void btAlignedObjectArray_btDbvt_sStkNPS__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )(  ) 
int btAlignedObjectArray_btDbvt_sStkNPS__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int ) 
void btAlignedObjectArray_btDbvt_sStkNPS__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btDbvt::sStkNPS>::* )( int ) 
void btAlignedObjectArray_btDbvt_sStkNPS__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btDbvt::sStkNPS, 16u> btAlignedObjectArray_btDbvt_sStkNPS_->m_allocator
void* btAlignedObjectArray_btDbvt_sStkNPS__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btDbvt::sStkNPS, 16u> btAlignedObjectArray_btDbvt_sStkNPS_->m_allocator
void btAlignedObjectArray_btDbvt_sStkNPS__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btDbvt_sStkNPS_->m_size
int btAlignedObjectArray_btDbvt_sStkNPS__m_size_get(void *c); //attribute: int btAlignedObjectArray_btDbvt_sStkNPS_->m_size
void btAlignedObjectArray_btDbvt_sStkNPS__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btDbvt_sStkNPS_->m_capacity
int btAlignedObjectArray_btDbvt_sStkNPS__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btDbvt_sStkNPS_->m_capacity
void btAlignedObjectArray_btDbvt_sStkNPS__m_data_set(void *c,void* a); //attribute: ::btDbvt::sStkNPS * btAlignedObjectArray_btDbvt_sStkNPS_->m_data
void* btAlignedObjectArray_btDbvt_sStkNPS__m_data_get(void *c); //attribute: ::btDbvt::sStkNPS * btAlignedObjectArray_btDbvt_sStkNPS_->m_data
void btAlignedObjectArray_btDbvt_sStkNPS__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btDbvt_sStkNPS_->m_ownsMemory
int btAlignedObjectArray_btDbvt_sStkNPS__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btDbvt_sStkNPS_->m_ownsMemory
void* btAlignedObjectArray_btDbvtNodeconst_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__free(void *c); 
void btAlignedObjectArray_btDbvtNodeconst_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btDbvtNode const*>::* )( ::btDbvtNode const * const & ) 
void* btAlignedObjectArray_btDbvtNodeconst_ptr__at(void *c,int p0); //method: at ::btDbvtNode const * const & ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int ) const
void* btAlignedObjectArray_btDbvtNodeconst_ptr__at0(void *c,int p0); //method: at ::btDbvtNode const * const & ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int ) const
void* btAlignedObjectArray_btDbvtNodeconst_ptr__at1(void *c,int p0); //method: at ::btDbvtNode const * & ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int ) 
int btAlignedObjectArray_btDbvtNodeconst_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) const
int btAlignedObjectArray_btDbvtNodeconst_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) const
void btAlignedObjectArray_btDbvtNodeconst_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) 
void* btAlignedObjectArray_btDbvtNodeconst_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int,int ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btDbvtNode const*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btDbvtNodeconst_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btDbvtNode const * & ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int,::btDbvtNode const * const & ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int,int,::btDbvtNode const * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void* btAlignedObjectArray_btDbvtNodeconst_ptr__expand(void *c,void* p0); //method: expand ::btDbvtNode const * & ( ::btAlignedObjectArray<btDbvtNode const*>::* )( ::btDbvtNode const * const & ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btDbvtNode const*>::* )(  ) 
int btAlignedObjectArray_btDbvtNodeconst_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btDbvtNode const*>::* )( int ) 
void btAlignedObjectArray_btDbvtNodeconst_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btDbvtNode const*, 16u> btAlignedObjectArray_btDbvtNodeconst_ptr_->m_allocator
void* btAlignedObjectArray_btDbvtNodeconst_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btDbvtNode const*, 16u> btAlignedObjectArray_btDbvtNodeconst_ptr_->m_allocator
void btAlignedObjectArray_btDbvtNodeconst_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btDbvtNodeconst_ptr_->m_size
int btAlignedObjectArray_btDbvtNodeconst_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btDbvtNodeconst_ptr_->m_size
void btAlignedObjectArray_btDbvtNodeconst_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btDbvtNodeconst_ptr_->m_capacity
int btAlignedObjectArray_btDbvtNodeconst_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btDbvtNodeconst_ptr_->m_capacity
// attribute not supported: //attribute: ::btDbvtNode const * * btAlignedObjectArray_btDbvtNodeconst_ptr_->m_data
void btAlignedObjectArray_btDbvtNodeconst_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btDbvtNodeconst_ptr_->m_ownsMemory
int btAlignedObjectArray_btDbvtNodeconst_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btDbvtNodeconst_ptr_->m_ownsMemory
void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__free(void *c); 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( ::btGImpactMeshShapePart * const & ) 
void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__at(void *c,int p0); //method: at ::btGImpactMeshShapePart * const & ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int ) const
void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__at0(void *c,int p0); //method: at ::btGImpactMeshShapePart * const & ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int ) const
void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__at1(void *c,int p0); //method: at ::btGImpactMeshShapePart * & ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int ) 
int btAlignedObjectArray_btGImpactMeshShapePart_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) const
int btAlignedObjectArray_btGImpactMeshShapePart_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) const
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) 
void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int,int ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btGImpactMeshShapePart * & ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int,::btGImpactMeshShapePart * const & ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int,int,::btGImpactMeshShapePart * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__expand(void *c,void* p0); //method: expand ::btGImpactMeshShapePart * & ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( ::btGImpactMeshShapePart * const & ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )(  ) 
int btAlignedObjectArray_btGImpactMeshShapePart_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btGImpactMeshShapePart*>::* )( int ) 
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btGImpactMeshShapePart*, 16u> btAlignedObjectArray_btGImpactMeshShapePart_ptr_->m_allocator
void* btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btGImpactMeshShapePart*, 16u> btAlignedObjectArray_btGImpactMeshShapePart_ptr_->m_allocator
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btGImpactMeshShapePart_ptr_->m_size
int btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btGImpactMeshShapePart_ptr_->m_size
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btGImpactMeshShapePart_ptr_->m_capacity
int btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btGImpactMeshShapePart_ptr_->m_capacity
// attribute not supported: //attribute: ::btGImpactMeshShapePart * * btAlignedObjectArray_btGImpactMeshShapePart_ptr_->m_data
void btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btGImpactMeshShapePart_ptr_->m_ownsMemory
int btAlignedObjectArray_btGImpactMeshShapePart_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btGImpactMeshShapePart_ptr_->m_ownsMemory
void* btAlignedObjectArray_btHashInt__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btHashInt>::* )(  ) 
void btAlignedObjectArray_btHashInt__free(void *c); 
void btAlignedObjectArray_btHashInt__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btHashInt>::* )( ::btHashInt const & ) 
void* btAlignedObjectArray_btHashInt__at(void *c,int p0); //method: at ::btHashInt const & ( ::btAlignedObjectArray<btHashInt>::* )( int ) const
void* btAlignedObjectArray_btHashInt__at0(void *c,int p0); //method: at ::btHashInt const & ( ::btAlignedObjectArray<btHashInt>::* )( int ) const
void* btAlignedObjectArray_btHashInt__at1(void *c,int p0); //method: at ::btHashInt & ( ::btAlignedObjectArray<btHashInt>::* )( int ) 
int btAlignedObjectArray_btHashInt__size(void *c); //method: size int ( ::btAlignedObjectArray<btHashInt>::* )(  ) const
int btAlignedObjectArray_btHashInt__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btHashInt>::* )(  ) const
void btAlignedObjectArray_btHashInt__init(void *c); //method: init void ( ::btAlignedObjectArray<btHashInt>::* )(  ) 
void* btAlignedObjectArray_btHashInt__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btHashInt>::* )( int ) 
void btAlignedObjectArray_btHashInt__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btHashInt>::* )(  ) 
void btAlignedObjectArray_btHashInt__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btHashInt>::* )(  ) 
void btAlignedObjectArray_btHashInt__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btHashInt>::* )( int,int ) 
void btAlignedObjectArray_btHashInt__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btHashInt>::* )( void *,int,int ) 
void* btAlignedObjectArray_btHashInt__expandNonInitializing(void *c); //method: expandNonInitializing ::btHashInt & ( ::btAlignedObjectArray<btHashInt>::* )(  ) 
void btAlignedObjectArray_btHashInt__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btHashInt>::* )( int,::btHashInt const & ) 
void btAlignedObjectArray_btHashInt__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btHashInt>::* )( int,int ) 
void btAlignedObjectArray_btHashInt__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btHashInt>::* )( int,int,::btHashInt * ) const
void* btAlignedObjectArray_btHashInt__expand(void *c,void* p0); //method: expand ::btHashInt & ( ::btAlignedObjectArray<btHashInt>::* )( ::btHashInt const & ) 
void btAlignedObjectArray_btHashInt__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btHashInt>::* )(  ) 
int btAlignedObjectArray_btHashInt__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btHashInt>::* )( int ) 
void btAlignedObjectArray_btHashInt__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btHashInt>::* )( int ) 
void btAlignedObjectArray_btHashInt__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btHashInt, 16u> btAlignedObjectArray_btHashInt_->m_allocator
void* btAlignedObjectArray_btHashInt__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btHashInt, 16u> btAlignedObjectArray_btHashInt_->m_allocator
void btAlignedObjectArray_btHashInt__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btHashInt_->m_size
int btAlignedObjectArray_btHashInt__m_size_get(void *c); //attribute: int btAlignedObjectArray_btHashInt_->m_size
void btAlignedObjectArray_btHashInt__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btHashInt_->m_capacity
int btAlignedObjectArray_btHashInt__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btHashInt_->m_capacity
void btAlignedObjectArray_btHashInt__m_data_set(void *c,void* a); //attribute: ::btHashInt * btAlignedObjectArray_btHashInt_->m_data
void* btAlignedObjectArray_btHashInt__m_data_get(void *c); //attribute: ::btHashInt * btAlignedObjectArray_btHashInt_->m_data
void btAlignedObjectArray_btHashInt__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btHashInt_->m_ownsMemory
int btAlignedObjectArray_btHashInt__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btHashInt_->m_ownsMemory
void* btAlignedObjectArray_btHashPtr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btHashPtr>::* )(  ) 
void btAlignedObjectArray_btHashPtr__free(void *c); 
void btAlignedObjectArray_btHashPtr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btHashPtr>::* )( ::btHashPtr const & ) 
void* btAlignedObjectArray_btHashPtr__at(void *c,int p0); //method: at ::btHashPtr const & ( ::btAlignedObjectArray<btHashPtr>::* )( int ) const
void* btAlignedObjectArray_btHashPtr__at0(void *c,int p0); //method: at ::btHashPtr const & ( ::btAlignedObjectArray<btHashPtr>::* )( int ) const
void* btAlignedObjectArray_btHashPtr__at1(void *c,int p0); //method: at ::btHashPtr & ( ::btAlignedObjectArray<btHashPtr>::* )( int ) 
int btAlignedObjectArray_btHashPtr__size(void *c); //method: size int ( ::btAlignedObjectArray<btHashPtr>::* )(  ) const
int btAlignedObjectArray_btHashPtr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btHashPtr>::* )(  ) const
void btAlignedObjectArray_btHashPtr__init(void *c); //method: init void ( ::btAlignedObjectArray<btHashPtr>::* )(  ) 
void* btAlignedObjectArray_btHashPtr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btHashPtr>::* )( int ) 
void btAlignedObjectArray_btHashPtr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btHashPtr>::* )(  ) 
void btAlignedObjectArray_btHashPtr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btHashPtr>::* )(  ) 
void btAlignedObjectArray_btHashPtr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btHashPtr>::* )( int,int ) 
void btAlignedObjectArray_btHashPtr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btHashPtr>::* )( void *,int,int ) 
void* btAlignedObjectArray_btHashPtr__expandNonInitializing(void *c); //method: expandNonInitializing ::btHashPtr & ( ::btAlignedObjectArray<btHashPtr>::* )(  ) 
void btAlignedObjectArray_btHashPtr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btHashPtr>::* )( int,::btHashPtr const & ) 
void btAlignedObjectArray_btHashPtr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btHashPtr>::* )( int,int ) 
void btAlignedObjectArray_btHashPtr__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btHashPtr>::* )( int,int,::btHashPtr * ) const
void* btAlignedObjectArray_btHashPtr__expand(void *c,void* p0); //method: expand ::btHashPtr & ( ::btAlignedObjectArray<btHashPtr>::* )( ::btHashPtr const & ) 
void btAlignedObjectArray_btHashPtr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btHashPtr>::* )(  ) 
int btAlignedObjectArray_btHashPtr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btHashPtr>::* )( int ) 
void btAlignedObjectArray_btHashPtr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btHashPtr>::* )( int ) 
void btAlignedObjectArray_btHashPtr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btHashPtr, 16u> btAlignedObjectArray_btHashPtr_->m_allocator
void* btAlignedObjectArray_btHashPtr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btHashPtr, 16u> btAlignedObjectArray_btHashPtr_->m_allocator
void btAlignedObjectArray_btHashPtr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btHashPtr_->m_size
int btAlignedObjectArray_btHashPtr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btHashPtr_->m_size
void btAlignedObjectArray_btHashPtr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btHashPtr_->m_capacity
int btAlignedObjectArray_btHashPtr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btHashPtr_->m_capacity
void btAlignedObjectArray_btHashPtr__m_data_set(void *c,void* a); //attribute: ::btHashPtr * btAlignedObjectArray_btHashPtr_->m_data
void* btAlignedObjectArray_btHashPtr__m_data_get(void *c); //attribute: ::btHashPtr * btAlignedObjectArray_btHashPtr_->m_data
void btAlignedObjectArray_btHashPtr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btHashPtr_->m_ownsMemory
int btAlignedObjectArray_btHashPtr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btHashPtr_->m_ownsMemory
void* btAlignedObjectArray_btHashString__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btHashString>::* )(  ) 
void btAlignedObjectArray_btHashString__free(void *c); 
void btAlignedObjectArray_btHashString__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btHashString>::* )( ::btHashString const & ) 
void* btAlignedObjectArray_btHashString__at(void *c,int p0); //method: at ::btHashString const & ( ::btAlignedObjectArray<btHashString>::* )( int ) const
void* btAlignedObjectArray_btHashString__at0(void *c,int p0); //method: at ::btHashString const & ( ::btAlignedObjectArray<btHashString>::* )( int ) const
void* btAlignedObjectArray_btHashString__at1(void *c,int p0); //method: at ::btHashString & ( ::btAlignedObjectArray<btHashString>::* )( int ) 
int btAlignedObjectArray_btHashString__size(void *c); //method: size int ( ::btAlignedObjectArray<btHashString>::* )(  ) const
int btAlignedObjectArray_btHashString__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btHashString>::* )(  ) const
void btAlignedObjectArray_btHashString__init(void *c); //method: init void ( ::btAlignedObjectArray<btHashString>::* )(  ) 
void* btAlignedObjectArray_btHashString__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btHashString>::* )( int ) 
void btAlignedObjectArray_btHashString__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btHashString>::* )(  ) 
void btAlignedObjectArray_btHashString__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btHashString>::* )(  ) 
void btAlignedObjectArray_btHashString__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btHashString>::* )( int,int ) 
void btAlignedObjectArray_btHashString__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btHashString>::* )( void *,int,int ) 
void* btAlignedObjectArray_btHashString__expandNonInitializing(void *c); //method: expandNonInitializing ::btHashString & ( ::btAlignedObjectArray<btHashString>::* )(  ) 
void btAlignedObjectArray_btHashString__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btHashString>::* )( int,::btHashString const & ) 
void btAlignedObjectArray_btHashString__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btHashString>::* )( int,int ) 
void btAlignedObjectArray_btHashString__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btHashString>::* )( int,int,::btHashString * ) const
void* btAlignedObjectArray_btHashString__expand(void *c,void* p0); //method: expand ::btHashString & ( ::btAlignedObjectArray<btHashString>::* )( ::btHashString const & ) 
void btAlignedObjectArray_btHashString__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btHashString>::* )(  ) 
int btAlignedObjectArray_btHashString__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btHashString>::* )( int ) 
void btAlignedObjectArray_btHashString__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btHashString>::* )( int ) 
void btAlignedObjectArray_btHashString__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btHashString, 16u> btAlignedObjectArray_btHashString_->m_allocator
void* btAlignedObjectArray_btHashString__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btHashString, 16u> btAlignedObjectArray_btHashString_->m_allocator
void btAlignedObjectArray_btHashString__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btHashString_->m_size
int btAlignedObjectArray_btHashString__m_size_get(void *c); //attribute: int btAlignedObjectArray_btHashString_->m_size
void btAlignedObjectArray_btHashString__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btHashString_->m_capacity
int btAlignedObjectArray_btHashString__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btHashString_->m_capacity
void btAlignedObjectArray_btHashString__m_data_set(void *c,void* a); //attribute: ::btHashString * btAlignedObjectArray_btHashString_->m_data
void* btAlignedObjectArray_btHashString__m_data_get(void *c); //attribute: ::btHashString * btAlignedObjectArray_btHashString_->m_data
void btAlignedObjectArray_btHashString__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btHashString_->m_ownsMemory
int btAlignedObjectArray_btHashString__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btHashString_->m_ownsMemory
void* btAlignedObjectArray_btIndexedMesh__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) 
void btAlignedObjectArray_btIndexedMesh__free(void *c); 
void btAlignedObjectArray_btIndexedMesh__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btIndexedMesh>::* )( ::btIndexedMesh const & ) 
void* btAlignedObjectArray_btIndexedMesh__at(void *c,int p0); //method: at ::btIndexedMesh const & ( ::btAlignedObjectArray<btIndexedMesh>::* )( int ) const
void* btAlignedObjectArray_btIndexedMesh__at0(void *c,int p0); //method: at ::btIndexedMesh const & ( ::btAlignedObjectArray<btIndexedMesh>::* )( int ) const
void* btAlignedObjectArray_btIndexedMesh__at1(void *c,int p0); //method: at ::btIndexedMesh & ( ::btAlignedObjectArray<btIndexedMesh>::* )( int ) 
int btAlignedObjectArray_btIndexedMesh__size(void *c); //method: size int ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) const
int btAlignedObjectArray_btIndexedMesh__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) const
void btAlignedObjectArray_btIndexedMesh__init(void *c); //method: init void ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) 
void* btAlignedObjectArray_btIndexedMesh__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btIndexedMesh>::* )( int ) 
void btAlignedObjectArray_btIndexedMesh__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) 
void btAlignedObjectArray_btIndexedMesh__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) 
void btAlignedObjectArray_btIndexedMesh__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btIndexedMesh>::* )( int,int ) 
void btAlignedObjectArray_btIndexedMesh__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btIndexedMesh>::* )( void *,int,int ) 
void* btAlignedObjectArray_btIndexedMesh__expandNonInitializing(void *c); //method: expandNonInitializing ::btIndexedMesh & ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) 
void btAlignedObjectArray_btIndexedMesh__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btIndexedMesh>::* )( int,::btIndexedMesh const & ) 
void btAlignedObjectArray_btIndexedMesh__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btIndexedMesh>::* )( int,int ) 
void btAlignedObjectArray_btIndexedMesh__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btIndexedMesh>::* )( int,int,::btIndexedMesh * ) const
void* btAlignedObjectArray_btIndexedMesh__expand(void *c,void* p0); //method: expand ::btIndexedMesh & ( ::btAlignedObjectArray<btIndexedMesh>::* )( ::btIndexedMesh const & ) 
void btAlignedObjectArray_btIndexedMesh__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btIndexedMesh>::* )(  ) 
int btAlignedObjectArray_btIndexedMesh__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btIndexedMesh>::* )( int ) 
void btAlignedObjectArray_btIndexedMesh__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btIndexedMesh>::* )( int ) 
void btAlignedObjectArray_btIndexedMesh__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btIndexedMesh, 16u> btAlignedObjectArray_btIndexedMesh_->m_allocator
void* btAlignedObjectArray_btIndexedMesh__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btIndexedMesh, 16u> btAlignedObjectArray_btIndexedMesh_->m_allocator
void btAlignedObjectArray_btIndexedMesh__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btIndexedMesh_->m_size
int btAlignedObjectArray_btIndexedMesh__m_size_get(void *c); //attribute: int btAlignedObjectArray_btIndexedMesh_->m_size
void btAlignedObjectArray_btIndexedMesh__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btIndexedMesh_->m_capacity
int btAlignedObjectArray_btIndexedMesh__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btIndexedMesh_->m_capacity
void btAlignedObjectArray_btIndexedMesh__m_data_set(void *c,void* a); //attribute: ::btIndexedMesh * btAlignedObjectArray_btIndexedMesh_->m_data
void* btAlignedObjectArray_btIndexedMesh__m_data_get(void *c); //attribute: ::btIndexedMesh * btAlignedObjectArray_btIndexedMesh_->m_data
void btAlignedObjectArray_btIndexedMesh__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btIndexedMesh_->m_ownsMemory
int btAlignedObjectArray_btIndexedMesh__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btIndexedMesh_->m_ownsMemory
void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__free(void *c); 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( ::btMultiSapBroadphase::btBridgeProxy * const & ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__at(void *c,int p0); //method: at ::btMultiSapBroadphase::btBridgeProxy * const & ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int ) const
void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__at0(void *c,int p0); //method: at ::btMultiSapBroadphase::btBridgeProxy * const & ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int ) const
void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__at1(void *c,int p0); //method: at ::btMultiSapBroadphase::btBridgeProxy * & ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int ) 
int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) const
int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) const
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int,int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btMultiSapBroadphase::btBridgeProxy * & ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int,::btMultiSapBroadphase::btBridgeProxy * const & ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int,int,::btMultiSapBroadphase::btBridgeProxy * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__expand(void *c,void* p0); //method: expand ::btMultiSapBroadphase::btBridgeProxy * & ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( ::btMultiSapBroadphase::btBridgeProxy * const & ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )(  ) 
int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::* )( int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u> btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_->m_allocator
void* btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u> btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_->m_allocator
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_->m_size
int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_->m_size
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_->m_capacity
int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_->m_capacity
// attribute not supported: //attribute: ::btMultiSapBroadphase::btBridgeProxy * * btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_->m_data
void btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_->m_ownsMemory
int btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_ptr_->m_ownsMemory
void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__free(void *c); 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( ::btMultiSapBroadphase::btMultiSapProxy * const & ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__at(void *c,int p0); //method: at ::btMultiSapBroadphase::btMultiSapProxy * const & ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int ) const
void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__at0(void *c,int p0); //method: at ::btMultiSapBroadphase::btMultiSapProxy * const & ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int ) const
void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__at1(void *c,int p0); //method: at ::btMultiSapBroadphase::btMultiSapProxy * & ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int ) 
int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) const
int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) const
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int,int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btMultiSapBroadphase::btMultiSapProxy * & ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int,::btMultiSapBroadphase::btMultiSapProxy * const & ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int,int,::btMultiSapBroadphase::btMultiSapProxy * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__expand(void *c,void* p0); //method: expand ::btMultiSapBroadphase::btMultiSapProxy * & ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( ::btMultiSapBroadphase::btMultiSapProxy * const & ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )(  ) 
int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::* )( int ) 
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u> btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_->m_allocator
void* btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u> btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_->m_allocator
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_->m_size
int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_->m_size
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_->m_capacity
int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_->m_capacity
// attribute not supported: //attribute: ::btMultiSapBroadphase::btMultiSapProxy * * btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_->m_data
void btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_->m_ownsMemory
int btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_ptr_->m_ownsMemory
void* btAlignedObjectArray_btOptimizedBvhNode__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btOptimizedBvhNode__free(void *c); 
void btAlignedObjectArray_btOptimizedBvhNode__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( ::btOptimizedBvhNode const & ) 
void* btAlignedObjectArray_btOptimizedBvhNode__at(void *c,int p0); //method: at ::btOptimizedBvhNode const & ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int ) const
void* btAlignedObjectArray_btOptimizedBvhNode__at0(void *c,int p0); //method: at ::btOptimizedBvhNode const & ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int ) const
void* btAlignedObjectArray_btOptimizedBvhNode__at1(void *c,int p0); //method: at ::btOptimizedBvhNode & ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int ) 
int btAlignedObjectArray_btOptimizedBvhNode__size(void *c); //method: size int ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) const
int btAlignedObjectArray_btOptimizedBvhNode__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) const
void btAlignedObjectArray_btOptimizedBvhNode__init(void *c); //method: init void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) 
void* btAlignedObjectArray_btOptimizedBvhNode__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int ) 
void btAlignedObjectArray_btOptimizedBvhNode__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btOptimizedBvhNode__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btOptimizedBvhNode__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int,int ) 
void btAlignedObjectArray_btOptimizedBvhNode__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( void *,int,int ) 
void* btAlignedObjectArray_btOptimizedBvhNode__expandNonInitializing(void *c); //method: expandNonInitializing ::btOptimizedBvhNode & ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btOptimizedBvhNode__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int,::btOptimizedBvhNode const & ) 
void btAlignedObjectArray_btOptimizedBvhNode__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int,int ) 
void btAlignedObjectArray_btOptimizedBvhNode__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int,int,::btOptimizedBvhNode * ) const
void* btAlignedObjectArray_btOptimizedBvhNode__expand(void *c,void* p0); //method: expand ::btOptimizedBvhNode & ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( ::btOptimizedBvhNode const & ) 
void btAlignedObjectArray_btOptimizedBvhNode__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )(  ) 
int btAlignedObjectArray_btOptimizedBvhNode__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int ) 
void btAlignedObjectArray_btOptimizedBvhNode__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btOptimizedBvhNode>::* )( int ) 
void btAlignedObjectArray_btOptimizedBvhNode__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btOptimizedBvhNode, 16u> btAlignedObjectArray_btOptimizedBvhNode_->m_allocator
void* btAlignedObjectArray_btOptimizedBvhNode__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btOptimizedBvhNode, 16u> btAlignedObjectArray_btOptimizedBvhNode_->m_allocator
void btAlignedObjectArray_btOptimizedBvhNode__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btOptimizedBvhNode_->m_size
int btAlignedObjectArray_btOptimizedBvhNode__m_size_get(void *c); //attribute: int btAlignedObjectArray_btOptimizedBvhNode_->m_size
void btAlignedObjectArray_btOptimizedBvhNode__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btOptimizedBvhNode_->m_capacity
int btAlignedObjectArray_btOptimizedBvhNode__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btOptimizedBvhNode_->m_capacity
void btAlignedObjectArray_btOptimizedBvhNode__m_data_set(void *c,void* a); //attribute: ::btOptimizedBvhNode * btAlignedObjectArray_btOptimizedBvhNode_->m_data
void* btAlignedObjectArray_btOptimizedBvhNode__m_data_get(void *c); //attribute: ::btOptimizedBvhNode * btAlignedObjectArray_btOptimizedBvhNode_->m_data
void btAlignedObjectArray_btOptimizedBvhNode__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btOptimizedBvhNode_->m_ownsMemory
int btAlignedObjectArray_btOptimizedBvhNode__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btOptimizedBvhNode_->m_ownsMemory
void* btAlignedObjectArray_btPersistentManifold_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) 
void btAlignedObjectArray_btPersistentManifold_ptr__free(void *c); 
void btAlignedObjectArray_btPersistentManifold_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btPersistentManifold*>::* )( ::btPersistentManifold * const & ) 
void* btAlignedObjectArray_btPersistentManifold_ptr__at(void *c,int p0); //method: at ::btPersistentManifold * const & ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int ) const
void* btAlignedObjectArray_btPersistentManifold_ptr__at0(void *c,int p0); //method: at ::btPersistentManifold * const & ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int ) const
void* btAlignedObjectArray_btPersistentManifold_ptr__at1(void *c,int p0); //method: at ::btPersistentManifold * & ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int ) 
int btAlignedObjectArray_btPersistentManifold_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) const
int btAlignedObjectArray_btPersistentManifold_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) const
void btAlignedObjectArray_btPersistentManifold_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) 
void* btAlignedObjectArray_btPersistentManifold_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int ) 
void btAlignedObjectArray_btPersistentManifold_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) 
void btAlignedObjectArray_btPersistentManifold_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) 
void btAlignedObjectArray_btPersistentManifold_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int,int ) 
void btAlignedObjectArray_btPersistentManifold_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btPersistentManifold*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btPersistentManifold_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btPersistentManifold * & ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) 
void btAlignedObjectArray_btPersistentManifold_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int,::btPersistentManifold * const & ) 
void btAlignedObjectArray_btPersistentManifold_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int,int,::btPersistentManifold * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void* btAlignedObjectArray_btPersistentManifold_ptr__expand(void *c,void* p0); //method: expand ::btPersistentManifold * & ( ::btAlignedObjectArray<btPersistentManifold*>::* )( ::btPersistentManifold * const & ) 
void btAlignedObjectArray_btPersistentManifold_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btPersistentManifold*>::* )(  ) 
int btAlignedObjectArray_btPersistentManifold_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int ) 
void btAlignedObjectArray_btPersistentManifold_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btPersistentManifold*>::* )( int ) 
void btAlignedObjectArray_btPersistentManifold_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btPersistentManifold*, 16u> btAlignedObjectArray_btPersistentManifold_ptr_->m_allocator
void* btAlignedObjectArray_btPersistentManifold_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btPersistentManifold*, 16u> btAlignedObjectArray_btPersistentManifold_ptr_->m_allocator
void btAlignedObjectArray_btPersistentManifold_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btPersistentManifold_ptr_->m_size
int btAlignedObjectArray_btPersistentManifold_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btPersistentManifold_ptr_->m_size
void btAlignedObjectArray_btPersistentManifold_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btPersistentManifold_ptr_->m_capacity
int btAlignedObjectArray_btPersistentManifold_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btPersistentManifold_ptr_->m_capacity
// attribute not supported: //attribute: ::btPersistentManifold * * btAlignedObjectArray_btPersistentManifold_ptr_->m_data
void btAlignedObjectArray_btPersistentManifold_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btPersistentManifold_ptr_->m_ownsMemory
int btAlignedObjectArray_btPersistentManifold_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btPersistentManifold_ptr_->m_ownsMemory
void* btAlignedObjectArray_btPointerUid__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btPointerUid>::* )(  ) 
void btAlignedObjectArray_btPointerUid__free(void *c); 
void btAlignedObjectArray_btPointerUid__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btPointerUid>::* )( ::btPointerUid const & ) 
void* btAlignedObjectArray_btPointerUid__at(void *c,int p0); //method: at ::btPointerUid const & ( ::btAlignedObjectArray<btPointerUid>::* )( int ) const
void* btAlignedObjectArray_btPointerUid__at0(void *c,int p0); //method: at ::btPointerUid const & ( ::btAlignedObjectArray<btPointerUid>::* )( int ) const
void* btAlignedObjectArray_btPointerUid__at1(void *c,int p0); //method: at ::btPointerUid & ( ::btAlignedObjectArray<btPointerUid>::* )( int ) 
int btAlignedObjectArray_btPointerUid__size(void *c); //method: size int ( ::btAlignedObjectArray<btPointerUid>::* )(  ) const
int btAlignedObjectArray_btPointerUid__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btPointerUid>::* )(  ) const
void btAlignedObjectArray_btPointerUid__init(void *c); //method: init void ( ::btAlignedObjectArray<btPointerUid>::* )(  ) 
void* btAlignedObjectArray_btPointerUid__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btPointerUid>::* )( int ) 
void btAlignedObjectArray_btPointerUid__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btPointerUid>::* )(  ) 
void btAlignedObjectArray_btPointerUid__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btPointerUid>::* )(  ) 
void btAlignedObjectArray_btPointerUid__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btPointerUid>::* )( int,int ) 
void btAlignedObjectArray_btPointerUid__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btPointerUid>::* )( void *,int,int ) 
void* btAlignedObjectArray_btPointerUid__expandNonInitializing(void *c); //method: expandNonInitializing ::btPointerUid & ( ::btAlignedObjectArray<btPointerUid>::* )(  ) 
void btAlignedObjectArray_btPointerUid__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btPointerUid>::* )( int,::btPointerUid const & ) 
void btAlignedObjectArray_btPointerUid__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btPointerUid>::* )( int,int ) 
void btAlignedObjectArray_btPointerUid__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btPointerUid>::* )( int,int,::btPointerUid * ) const
void* btAlignedObjectArray_btPointerUid__expand(void *c,void* p0); //method: expand ::btPointerUid & ( ::btAlignedObjectArray<btPointerUid>::* )( ::btPointerUid const & ) 
void btAlignedObjectArray_btPointerUid__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btPointerUid>::* )(  ) 
int btAlignedObjectArray_btPointerUid__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btPointerUid>::* )( int ) 
void btAlignedObjectArray_btPointerUid__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btPointerUid>::* )( int ) 
void btAlignedObjectArray_btPointerUid__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btPointerUid, 16u> btAlignedObjectArray_btPointerUid_->m_allocator
void* btAlignedObjectArray_btPointerUid__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btPointerUid, 16u> btAlignedObjectArray_btPointerUid_->m_allocator
void btAlignedObjectArray_btPointerUid__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btPointerUid_->m_size
int btAlignedObjectArray_btPointerUid__m_size_get(void *c); //attribute: int btAlignedObjectArray_btPointerUid_->m_size
void btAlignedObjectArray_btPointerUid__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btPointerUid_->m_capacity
int btAlignedObjectArray_btPointerUid__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btPointerUid_->m_capacity
void btAlignedObjectArray_btPointerUid__m_data_set(void *c,void* a); //attribute: ::btPointerUid * btAlignedObjectArray_btPointerUid_->m_data
void* btAlignedObjectArray_btPointerUid__m_data_get(void *c); //attribute: ::btPointerUid * btAlignedObjectArray_btPointerUid_->m_data
void btAlignedObjectArray_btPointerUid__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btPointerUid_->m_ownsMemory
int btAlignedObjectArray_btPointerUid__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btPointerUid_->m_ownsMemory
void* btAlignedObjectArray_btQuantizedBvhNode__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btQuantizedBvhNode__free(void *c); 
void btAlignedObjectArray_btQuantizedBvhNode__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( ::btQuantizedBvhNode const & ) 
void* btAlignedObjectArray_btQuantizedBvhNode__at(void *c,int p0); //method: at ::btQuantizedBvhNode const & ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int ) const
void* btAlignedObjectArray_btQuantizedBvhNode__at0(void *c,int p0); //method: at ::btQuantizedBvhNode const & ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int ) const
void* btAlignedObjectArray_btQuantizedBvhNode__at1(void *c,int p0); //method: at ::btQuantizedBvhNode & ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int ) 
int btAlignedObjectArray_btQuantizedBvhNode__size(void *c); //method: size int ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) const
int btAlignedObjectArray_btQuantizedBvhNode__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) const
void btAlignedObjectArray_btQuantizedBvhNode__init(void *c); //method: init void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) 
void* btAlignedObjectArray_btQuantizedBvhNode__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int ) 
void btAlignedObjectArray_btQuantizedBvhNode__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btQuantizedBvhNode__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btQuantizedBvhNode__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int,int ) 
void btAlignedObjectArray_btQuantizedBvhNode__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( void *,int,int ) 
void* btAlignedObjectArray_btQuantizedBvhNode__expandNonInitializing(void *c); //method: expandNonInitializing ::btQuantizedBvhNode & ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) 
void btAlignedObjectArray_btQuantizedBvhNode__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int,::btQuantizedBvhNode const & ) 
void btAlignedObjectArray_btQuantizedBvhNode__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int,int ) 
void btAlignedObjectArray_btQuantizedBvhNode__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int,int,::btQuantizedBvhNode * ) const
void* btAlignedObjectArray_btQuantizedBvhNode__expand(void *c,void* p0); //method: expand ::btQuantizedBvhNode & ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( ::btQuantizedBvhNode const & ) 
void btAlignedObjectArray_btQuantizedBvhNode__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )(  ) 
int btAlignedObjectArray_btQuantizedBvhNode__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int ) 
void btAlignedObjectArray_btQuantizedBvhNode__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btQuantizedBvhNode>::* )( int ) 
void btAlignedObjectArray_btQuantizedBvhNode__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btQuantizedBvhNode, 16u> btAlignedObjectArray_btQuantizedBvhNode_->m_allocator
void* btAlignedObjectArray_btQuantizedBvhNode__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btQuantizedBvhNode, 16u> btAlignedObjectArray_btQuantizedBvhNode_->m_allocator
void btAlignedObjectArray_btQuantizedBvhNode__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btQuantizedBvhNode_->m_size
int btAlignedObjectArray_btQuantizedBvhNode__m_size_get(void *c); //attribute: int btAlignedObjectArray_btQuantizedBvhNode_->m_size
void btAlignedObjectArray_btQuantizedBvhNode__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btQuantizedBvhNode_->m_capacity
int btAlignedObjectArray_btQuantizedBvhNode__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btQuantizedBvhNode_->m_capacity
void btAlignedObjectArray_btQuantizedBvhNode__m_data_set(void *c,void* a); //attribute: ::btQuantizedBvhNode * btAlignedObjectArray_btQuantizedBvhNode_->m_data
void* btAlignedObjectArray_btQuantizedBvhNode__m_data_get(void *c); //attribute: ::btQuantizedBvhNode * btAlignedObjectArray_btQuantizedBvhNode_->m_data
void btAlignedObjectArray_btQuantizedBvhNode__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btQuantizedBvhNode_->m_ownsMemory
int btAlignedObjectArray_btQuantizedBvhNode__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btQuantizedBvhNode_->m_ownsMemory
void* btAlignedObjectArray_btRigidBody_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) 
void btAlignedObjectArray_btRigidBody_ptr__free(void *c); 
void btAlignedObjectArray_btRigidBody_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btRigidBody*>::* )( ::btRigidBody * const & ) 
void* btAlignedObjectArray_btRigidBody_ptr__at(void *c,int p0); //method: at ::btRigidBody * const & ( ::btAlignedObjectArray<btRigidBody*>::* )( int ) const
void* btAlignedObjectArray_btRigidBody_ptr__at0(void *c,int p0); //method: at ::btRigidBody * const & ( ::btAlignedObjectArray<btRigidBody*>::* )( int ) const
void* btAlignedObjectArray_btRigidBody_ptr__at1(void *c,int p0); //method: at ::btRigidBody * & ( ::btAlignedObjectArray<btRigidBody*>::* )( int ) 
int btAlignedObjectArray_btRigidBody_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) const
int btAlignedObjectArray_btRigidBody_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) const
void btAlignedObjectArray_btRigidBody_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) 
void* btAlignedObjectArray_btRigidBody_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btRigidBody*>::* )( int ) 
void btAlignedObjectArray_btRigidBody_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) 
void btAlignedObjectArray_btRigidBody_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) 
void btAlignedObjectArray_btRigidBody_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btRigidBody*>::* )( int,int ) 
void btAlignedObjectArray_btRigidBody_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btRigidBody*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btRigidBody_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btRigidBody * & ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) 
void btAlignedObjectArray_btRigidBody_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btRigidBody*>::* )( int,::btRigidBody * const & ) 
void btAlignedObjectArray_btRigidBody_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btRigidBody*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btRigidBody*>::* )( int,int,::btRigidBody * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void* btAlignedObjectArray_btRigidBody_ptr__expand(void *c,void* p0); //method: expand ::btRigidBody * & ( ::btAlignedObjectArray<btRigidBody*>::* )( ::btRigidBody * const & ) 
void btAlignedObjectArray_btRigidBody_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btRigidBody*>::* )(  ) 
int btAlignedObjectArray_btRigidBody_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btRigidBody*>::* )( int ) 
void btAlignedObjectArray_btRigidBody_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btRigidBody*>::* )( int ) 
void btAlignedObjectArray_btRigidBody_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btRigidBody*, 16u> btAlignedObjectArray_btRigidBody_ptr_->m_allocator
void* btAlignedObjectArray_btRigidBody_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btRigidBody*, 16u> btAlignedObjectArray_btRigidBody_ptr_->m_allocator
void btAlignedObjectArray_btRigidBody_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btRigidBody_ptr_->m_size
int btAlignedObjectArray_btRigidBody_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btRigidBody_ptr_->m_size
void btAlignedObjectArray_btRigidBody_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btRigidBody_ptr_->m_capacity
int btAlignedObjectArray_btRigidBody_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btRigidBody_ptr_->m_capacity
// attribute not supported: //attribute: ::btRigidBody * * btAlignedObjectArray_btRigidBody_ptr_->m_data
void btAlignedObjectArray_btRigidBody_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btRigidBody_ptr_->m_ownsMemory
int btAlignedObjectArray_btRigidBody_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btRigidBody_ptr_->m_ownsMemory
void* btAlignedObjectArray_btSoftBody_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_ptr__free(void *c); 
void btAlignedObjectArray_btSoftBody_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btSoftBody*>::* )( ::btSoftBody * const & ) 
void* btAlignedObjectArray_btSoftBody_ptr__at(void *c,int p0); //method: at ::btSoftBody * const & ( ::btAlignedObjectArray<btSoftBody*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_ptr__at0(void *c,int p0); //method: at ::btSoftBody * const & ( ::btAlignedObjectArray<btSoftBody*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_ptr__at1(void *c,int p0); //method: at ::btSoftBody * & ( ::btAlignedObjectArray<btSoftBody*>::* )( int ) 
int btAlignedObjectArray_btSoftBody_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) const
int btAlignedObjectArray_btSoftBody_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) const
void btAlignedObjectArray_btSoftBody_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSoftBody*>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSoftBody*>::* )( int ) 
void btAlignedObjectArray_btSoftBody_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btSoftBody_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btSoftBody * & ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSoftBody*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btSoftBody*>::* )( int,int,::btSoftBody * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void btAlignedObjectArray_btSoftBody_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btSoftBody*>::* )( int,::btSoftBody * const & ) 
void btAlignedObjectArray_btSoftBody_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSoftBody*>::* )(  ) 
int btAlignedObjectArray_btSoftBody_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSoftBody*>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_ptr__expand(void *c,void* p0); //method: expand ::btSoftBody * & ( ::btAlignedObjectArray<btSoftBody*>::* )( ::btSoftBody * const & ) 
void btAlignedObjectArray_btSoftBody_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSoftBody*>::* )( int ) 
void btAlignedObjectArray_btSoftBody_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSoftBody*, 16u> btAlignedObjectArray_btSoftBody_ptr_->m_allocator
void* btAlignedObjectArray_btSoftBody_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSoftBody*, 16u> btAlignedObjectArray_btSoftBody_ptr_->m_allocator
void btAlignedObjectArray_btSoftBody_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_ptr_->m_capacity
int btAlignedObjectArray_btSoftBody_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_ptr_->m_capacity
// attribute not supported: //attribute: ::btSoftBody * * btAlignedObjectArray_btSoftBody_ptr_->m_data
void btAlignedObjectArray_btSoftBody_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSoftBody_ptr_->m_ownsMemory
int btAlignedObjectArray_btSoftBody_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSoftBody_ptr_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_ptr_->m_size
int btAlignedObjectArray_btSoftBody_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_ptr_->m_size
void* btAlignedObjectArray_btSoftBody_Anchor__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Anchor__free(void *c); 
void btAlignedObjectArray_btSoftBody_Anchor__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( ::btSoftBody::Anchor const & ) 
void* btAlignedObjectArray_btSoftBody_Anchor__at(void *c,int p0); //method: at ::btSoftBody::Anchor const & ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Anchor__at0(void *c,int p0); //method: at ::btSoftBody::Anchor const & ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Anchor__at1(void *c,int p0); //method: at ::btSoftBody::Anchor & ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Anchor__size(void *c); //method: size int ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Anchor__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) const
void btAlignedObjectArray_btSoftBody_Anchor__init(void *c); //method: init void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Anchor__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Anchor__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Anchor__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Anchor__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Anchor__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( void *,int,int ) 
void* btAlignedObjectArray_btSoftBody_Anchor__expandNonInitializing(void *c); //method: expandNonInitializing ::btSoftBody::Anchor & ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Anchor__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Anchor__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int,int,::btSoftBody::Anchor * ) const
void btAlignedObjectArray_btSoftBody_Anchor__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int,::btSoftBody::Anchor const & ) 
void btAlignedObjectArray_btSoftBody_Anchor__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )(  ) 
int btAlignedObjectArray_btSoftBody_Anchor__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Anchor__expand(void *c,void* p0); //method: expand ::btSoftBody::Anchor & ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( ::btSoftBody::Anchor const & ) 
void btAlignedObjectArray_btSoftBody_Anchor__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSoftBody::Anchor>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Anchor__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSoftBody::Anchor, 16u> btAlignedObjectArray_btSoftBody_Anchor_->m_allocator
void* btAlignedObjectArray_btSoftBody_Anchor__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSoftBody::Anchor, 16u> btAlignedObjectArray_btSoftBody_Anchor_->m_allocator
void btAlignedObjectArray_btSoftBody_Anchor__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Anchor_->m_capacity
int btAlignedObjectArray_btSoftBody_Anchor__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Anchor_->m_capacity
void btAlignedObjectArray_btSoftBody_Anchor__m_data_set(void *c,void* a); //attribute: ::btSoftBody::Anchor * btAlignedObjectArray_btSoftBody_Anchor_->m_data
void* btAlignedObjectArray_btSoftBody_Anchor__m_data_get(void *c); //attribute: ::btSoftBody::Anchor * btAlignedObjectArray_btSoftBody_Anchor_->m_data
void btAlignedObjectArray_btSoftBody_Anchor__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSoftBody_Anchor_->m_ownsMemory
int btAlignedObjectArray_btSoftBody_Anchor__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSoftBody_Anchor_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Anchor__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Anchor_->m_size
int btAlignedObjectArray_btSoftBody_Anchor__m_size_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Anchor_->m_size
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__free(void *c); 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( ::btSoftBody::Cluster * const & ) 
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__at(void *c,int p0); //method: at ::btSoftBody::Cluster * const & ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__at0(void *c,int p0); //method: at ::btSoftBody::Cluster * const & ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__at1(void *c,int p0); //method: at ::btSoftBody::Cluster * & ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Cluster_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Cluster_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) const
void btAlignedObjectArray_btSoftBody_Cluster_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btSoftBody::Cluster * & ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int,int,::btSoftBody::Cluster * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void btAlignedObjectArray_btSoftBody_Cluster_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int,::btSoftBody::Cluster * const & ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )(  ) 
int btAlignedObjectArray_btSoftBody_Cluster_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__expand(void *c,void* p0); //method: expand ::btSoftBody::Cluster * & ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( ::btSoftBody::Cluster * const & ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSoftBody::Cluster*>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Cluster_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSoftBody::Cluster*, 16u> btAlignedObjectArray_btSoftBody_Cluster_ptr_->m_allocator
void* btAlignedObjectArray_btSoftBody_Cluster_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSoftBody::Cluster*, 16u> btAlignedObjectArray_btSoftBody_Cluster_ptr_->m_allocator
void btAlignedObjectArray_btSoftBody_Cluster_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Cluster_ptr_->m_capacity
int btAlignedObjectArray_btSoftBody_Cluster_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Cluster_ptr_->m_capacity
// attribute not supported: //attribute: ::btSoftBody::Cluster * * btAlignedObjectArray_btSoftBody_Cluster_ptr_->m_data
void btAlignedObjectArray_btSoftBody_Cluster_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSoftBody_Cluster_ptr_->m_ownsMemory
int btAlignedObjectArray_btSoftBody_Cluster_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSoftBody_Cluster_ptr_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Cluster_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Cluster_ptr_->m_size
int btAlignedObjectArray_btSoftBody_Cluster_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Cluster_ptr_->m_size
void* btAlignedObjectArray_btSoftBody_Face__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Face__free(void *c); 
void btAlignedObjectArray_btSoftBody_Face__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btSoftBody::Face>::* )( ::btSoftBody::Face const & ) 
void* btAlignedObjectArray_btSoftBody_Face__at(void *c,int p0); //method: at ::btSoftBody::Face const & ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Face__at0(void *c,int p0); //method: at ::btSoftBody::Face const & ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Face__at1(void *c,int p0); //method: at ::btSoftBody::Face & ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Face__size(void *c); //method: size int ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Face__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) const
void btAlignedObjectArray_btSoftBody_Face__init(void *c); //method: init void ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Face__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Face__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Face__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Face__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Face__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Face>::* )( void *,int,int ) 
void* btAlignedObjectArray_btSoftBody_Face__expandNonInitializing(void *c); //method: expandNonInitializing ::btSoftBody::Face & ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Face__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Face__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int,int,::btSoftBody::Face * ) const
void btAlignedObjectArray_btSoftBody_Face__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int,::btSoftBody::Face const & ) 
void btAlignedObjectArray_btSoftBody_Face__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSoftBody::Face>::* )(  ) 
int btAlignedObjectArray_btSoftBody_Face__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Face__expand(void *c,void* p0); //method: expand ::btSoftBody::Face & ( ::btAlignedObjectArray<btSoftBody::Face>::* )( ::btSoftBody::Face const & ) 
void btAlignedObjectArray_btSoftBody_Face__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSoftBody::Face>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Face__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSoftBody::Face, 16u> btAlignedObjectArray_btSoftBody_Face_->m_allocator
void* btAlignedObjectArray_btSoftBody_Face__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSoftBody::Face, 16u> btAlignedObjectArray_btSoftBody_Face_->m_allocator
void btAlignedObjectArray_btSoftBody_Face__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Face_->m_capacity
int btAlignedObjectArray_btSoftBody_Face__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Face_->m_capacity
void btAlignedObjectArray_btSoftBody_Face__m_data_set(void *c,void* a); //attribute: ::btSoftBody::Face * btAlignedObjectArray_btSoftBody_Face_->m_data
void* btAlignedObjectArray_btSoftBody_Face__m_data_get(void *c); //attribute: ::btSoftBody::Face * btAlignedObjectArray_btSoftBody_Face_->m_data
void btAlignedObjectArray_btSoftBody_Face__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSoftBody_Face_->m_ownsMemory
int btAlignedObjectArray_btSoftBody_Face__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSoftBody_Face_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Face__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Face_->m_size
int btAlignedObjectArray_btSoftBody_Face__m_size_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Face_->m_size
void* btAlignedObjectArray_btSoftBody_Joint_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__free(void *c); 
void btAlignedObjectArray_btSoftBody_Joint_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( ::btSoftBody::Joint * const & ) 
void* btAlignedObjectArray_btSoftBody_Joint_ptr__at(void *c,int p0); //method: at ::btSoftBody::Joint * const & ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Joint_ptr__at0(void *c,int p0); //method: at ::btSoftBody::Joint * const & ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Joint_ptr__at1(void *c,int p0); //method: at ::btSoftBody::Joint * & ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Joint_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Joint_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) const
void btAlignedObjectArray_btSoftBody_Joint_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Joint_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btSoftBody_Joint_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btSoftBody::Joint * & ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int,int,::btSoftBody::Joint * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void btAlignedObjectArray_btSoftBody_Joint_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int,::btSoftBody::Joint * const & ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )(  ) 
int btAlignedObjectArray_btSoftBody_Joint_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Joint_ptr__expand(void *c,void* p0); //method: expand ::btSoftBody::Joint * & ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( ::btSoftBody::Joint * const & ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSoftBody::Joint*>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Joint_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSoftBody::Joint*, 16u> btAlignedObjectArray_btSoftBody_Joint_ptr_->m_allocator
void* btAlignedObjectArray_btSoftBody_Joint_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSoftBody::Joint*, 16u> btAlignedObjectArray_btSoftBody_Joint_ptr_->m_allocator
void btAlignedObjectArray_btSoftBody_Joint_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Joint_ptr_->m_capacity
int btAlignedObjectArray_btSoftBody_Joint_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Joint_ptr_->m_capacity
// attribute not supported: //attribute: ::btSoftBody::Joint * * btAlignedObjectArray_btSoftBody_Joint_ptr_->m_data
void btAlignedObjectArray_btSoftBody_Joint_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSoftBody_Joint_ptr_->m_ownsMemory
int btAlignedObjectArray_btSoftBody_Joint_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSoftBody_Joint_ptr_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Joint_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Joint_ptr_->m_size
int btAlignedObjectArray_btSoftBody_Joint_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Joint_ptr_->m_size
void* btAlignedObjectArray_btSoftBody_Link__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Link__free(void *c); 
void btAlignedObjectArray_btSoftBody_Link__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btSoftBody::Link>::* )( ::btSoftBody::Link const & ) 
void* btAlignedObjectArray_btSoftBody_Link__at(void *c,int p0); //method: at ::btSoftBody::Link const & ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Link__at0(void *c,int p0); //method: at ::btSoftBody::Link const & ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Link__at1(void *c,int p0); //method: at ::btSoftBody::Link & ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Link__size(void *c); //method: size int ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Link__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) const
void btAlignedObjectArray_btSoftBody_Link__init(void *c); //method: init void ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Link__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Link__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Link__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Link__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Link__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Link>::* )( void *,int,int ) 
void* btAlignedObjectArray_btSoftBody_Link__expandNonInitializing(void *c); //method: expandNonInitializing ::btSoftBody::Link & ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Link__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Link__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int,int,::btSoftBody::Link * ) const
void btAlignedObjectArray_btSoftBody_Link__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int,::btSoftBody::Link const & ) 
void btAlignedObjectArray_btSoftBody_Link__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSoftBody::Link>::* )(  ) 
int btAlignedObjectArray_btSoftBody_Link__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Link__expand(void *c,void* p0); //method: expand ::btSoftBody::Link & ( ::btAlignedObjectArray<btSoftBody::Link>::* )( ::btSoftBody::Link const & ) 
void btAlignedObjectArray_btSoftBody_Link__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSoftBody::Link>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Link__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSoftBody::Link, 16u> btAlignedObjectArray_btSoftBody_Link_->m_allocator
void* btAlignedObjectArray_btSoftBody_Link__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSoftBody::Link, 16u> btAlignedObjectArray_btSoftBody_Link_->m_allocator
void btAlignedObjectArray_btSoftBody_Link__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Link_->m_capacity
int btAlignedObjectArray_btSoftBody_Link__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Link_->m_capacity
void btAlignedObjectArray_btSoftBody_Link__m_data_set(void *c,void* a); //attribute: ::btSoftBody::Link * btAlignedObjectArray_btSoftBody_Link_->m_data
void* btAlignedObjectArray_btSoftBody_Link__m_data_get(void *c); //attribute: ::btSoftBody::Link * btAlignedObjectArray_btSoftBody_Link_->m_data
void btAlignedObjectArray_btSoftBody_Link__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSoftBody_Link_->m_ownsMemory
int btAlignedObjectArray_btSoftBody_Link__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSoftBody_Link_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Link__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Link_->m_size
int btAlignedObjectArray_btSoftBody_Link__m_size_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Link_->m_size
void* btAlignedObjectArray_btSoftBody_Material_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__free(void *c); 
void btAlignedObjectArray_btSoftBody_Material_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( ::btSoftBody::Material * const & ) 
void* btAlignedObjectArray_btSoftBody_Material_ptr__at(void *c,int p0); //method: at ::btSoftBody::Material * const & ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Material_ptr__at0(void *c,int p0); //method: at ::btSoftBody::Material * const & ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Material_ptr__at1(void *c,int p0); //method: at ::btSoftBody::Material * & ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Material_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Material_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) const
void btAlignedObjectArray_btSoftBody_Material_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Material_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btSoftBody_Material_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btSoftBody::Material * & ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int,int,::btSoftBody::Material * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void btAlignedObjectArray_btSoftBody_Material_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int,::btSoftBody::Material * const & ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )(  ) 
int btAlignedObjectArray_btSoftBody_Material_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Material_ptr__expand(void *c,void* p0); //method: expand ::btSoftBody::Material * & ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( ::btSoftBody::Material * const & ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSoftBody::Material*>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Material_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSoftBody::Material*, 16u> btAlignedObjectArray_btSoftBody_Material_ptr_->m_allocator
void* btAlignedObjectArray_btSoftBody_Material_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSoftBody::Material*, 16u> btAlignedObjectArray_btSoftBody_Material_ptr_->m_allocator
void btAlignedObjectArray_btSoftBody_Material_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Material_ptr_->m_capacity
int btAlignedObjectArray_btSoftBody_Material_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Material_ptr_->m_capacity
// attribute not supported: //attribute: ::btSoftBody::Material * * btAlignedObjectArray_btSoftBody_Material_ptr_->m_data
void btAlignedObjectArray_btSoftBody_Material_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSoftBody_Material_ptr_->m_ownsMemory
int btAlignedObjectArray_btSoftBody_Material_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSoftBody_Material_ptr_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Material_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Material_ptr_->m_size
int btAlignedObjectArray_btSoftBody_Material_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Material_ptr_->m_size
void* btAlignedObjectArray_btSoftBody_Node_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__free(void *c); 
void btAlignedObjectArray_btSoftBody_Node_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( ::btSoftBody::Node * const & ) 
void* btAlignedObjectArray_btSoftBody_Node_ptr__at(void *c,int p0); //method: at ::btSoftBody::Node * const & ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Node_ptr__at0(void *c,int p0); //method: at ::btSoftBody::Node * const & ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Node_ptr__at1(void *c,int p0); //method: at ::btSoftBody::Node * & ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Node_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Node_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) const
void btAlignedObjectArray_btSoftBody_Node_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Node_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btSoftBody_Node_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btSoftBody::Node * & ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int,int,::btSoftBody::Node * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void btAlignedObjectArray_btSoftBody_Node_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int,::btSoftBody::Node * const & ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )(  ) 
int btAlignedObjectArray_btSoftBody_Node_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Node_ptr__expand(void *c,void* p0); //method: expand ::btSoftBody::Node * & ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( ::btSoftBody::Node * const & ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSoftBody::Node*>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Node_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSoftBody::Node*, 16u> btAlignedObjectArray_btSoftBody_Node_ptr_->m_allocator
void* btAlignedObjectArray_btSoftBody_Node_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSoftBody::Node*, 16u> btAlignedObjectArray_btSoftBody_Node_ptr_->m_allocator
void btAlignedObjectArray_btSoftBody_Node_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Node_ptr_->m_capacity
int btAlignedObjectArray_btSoftBody_Node_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Node_ptr_->m_capacity
// attribute not supported: //attribute: ::btSoftBody::Node * * btAlignedObjectArray_btSoftBody_Node_ptr_->m_data
void btAlignedObjectArray_btSoftBody_Node_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSoftBody_Node_ptr_->m_ownsMemory
int btAlignedObjectArray_btSoftBody_Node_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSoftBody_Node_ptr_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Node_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Node_ptr_->m_size
int btAlignedObjectArray_btSoftBody_Node_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Node_ptr_->m_size
void* btAlignedObjectArray_btSoftBody_Node__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node__free(void *c); 
void btAlignedObjectArray_btSoftBody_Node__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btSoftBody::Node>::* )( ::btSoftBody::Node const & ) 
void* btAlignedObjectArray_btSoftBody_Node__at(void *c,int p0); //method: at ::btSoftBody::Node const & ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Node__at0(void *c,int p0); //method: at ::btSoftBody::Node const & ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Node__at1(void *c,int p0); //method: at ::btSoftBody::Node & ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Node__size(void *c); //method: size int ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Node__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) const
void btAlignedObjectArray_btSoftBody_Node__init(void *c); //method: init void ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Node__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Node__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Node__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Node>::* )( void *,int,int ) 
void* btAlignedObjectArray_btSoftBody_Node__expandNonInitializing(void *c); //method: expandNonInitializing ::btSoftBody::Node & ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Node__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Node__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int,int,::btSoftBody::Node * ) const
void btAlignedObjectArray_btSoftBody_Node__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int,::btSoftBody::Node const & ) 
void btAlignedObjectArray_btSoftBody_Node__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSoftBody::Node>::* )(  ) 
int btAlignedObjectArray_btSoftBody_Node__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Node__expand(void *c,void* p0); //method: expand ::btSoftBody::Node & ( ::btAlignedObjectArray<btSoftBody::Node>::* )( ::btSoftBody::Node const & ) 
void btAlignedObjectArray_btSoftBody_Node__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSoftBody::Node>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Node__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSoftBody::Node, 16u> btAlignedObjectArray_btSoftBody_Node_->m_allocator
void* btAlignedObjectArray_btSoftBody_Node__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSoftBody::Node, 16u> btAlignedObjectArray_btSoftBody_Node_->m_allocator
void btAlignedObjectArray_btSoftBody_Node__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Node_->m_capacity
int btAlignedObjectArray_btSoftBody_Node__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Node_->m_capacity
void btAlignedObjectArray_btSoftBody_Node__m_data_set(void *c,void* a); //attribute: ::btSoftBody::Node * btAlignedObjectArray_btSoftBody_Node_->m_data
void* btAlignedObjectArray_btSoftBody_Node__m_data_get(void *c); //attribute: ::btSoftBody::Node * btAlignedObjectArray_btSoftBody_Node_->m_data
void btAlignedObjectArray_btSoftBody_Node__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSoftBody_Node_->m_ownsMemory
int btAlignedObjectArray_btSoftBody_Node__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSoftBody_Node_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Node__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Node_->m_size
int btAlignedObjectArray_btSoftBody_Node__m_size_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Node_->m_size
void* btAlignedObjectArray_btSoftBody_Note__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Note__free(void *c); 
void btAlignedObjectArray_btSoftBody_Note__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btSoftBody::Note>::* )( ::btSoftBody::Note const & ) 
void* btAlignedObjectArray_btSoftBody_Note__at(void *c,int p0); //method: at ::btSoftBody::Note const & ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Note__at0(void *c,int p0); //method: at ::btSoftBody::Note const & ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Note__at1(void *c,int p0); //method: at ::btSoftBody::Note & ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Note__size(void *c); //method: size int ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Note__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) const
void btAlignedObjectArray_btSoftBody_Note__init(void *c); //method: init void ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Note__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Note__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Note__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Note__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Note__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Note>::* )( void *,int,int ) 
void* btAlignedObjectArray_btSoftBody_Note__expandNonInitializing(void *c); //method: expandNonInitializing ::btSoftBody::Note & ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Note__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Note__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int,int,::btSoftBody::Note * ) const
void btAlignedObjectArray_btSoftBody_Note__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int,::btSoftBody::Note const & ) 
void btAlignedObjectArray_btSoftBody_Note__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSoftBody::Note>::* )(  ) 
int btAlignedObjectArray_btSoftBody_Note__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Note__expand(void *c,void* p0); //method: expand ::btSoftBody::Note & ( ::btAlignedObjectArray<btSoftBody::Note>::* )( ::btSoftBody::Note const & ) 
void btAlignedObjectArray_btSoftBody_Note__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSoftBody::Note>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Note__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSoftBody::Note, 16u> btAlignedObjectArray_btSoftBody_Note_->m_allocator
void* btAlignedObjectArray_btSoftBody_Note__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSoftBody::Note, 16u> btAlignedObjectArray_btSoftBody_Note_->m_allocator
void btAlignedObjectArray_btSoftBody_Note__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Note_->m_capacity
int btAlignedObjectArray_btSoftBody_Note__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Note_->m_capacity
void btAlignedObjectArray_btSoftBody_Note__m_data_set(void *c,void* a); //attribute: ::btSoftBody::Note * btAlignedObjectArray_btSoftBody_Note_->m_data
void* btAlignedObjectArray_btSoftBody_Note__m_data_get(void *c); //attribute: ::btSoftBody::Note * btAlignedObjectArray_btSoftBody_Note_->m_data
void btAlignedObjectArray_btSoftBody_Note__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSoftBody_Note_->m_ownsMemory
int btAlignedObjectArray_btSoftBody_Note__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSoftBody_Note_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Note__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Note_->m_size
int btAlignedObjectArray_btSoftBody_Note__m_size_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Note_->m_size
void* btAlignedObjectArray_btSoftBody_RContact__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_RContact__free(void *c); 
void btAlignedObjectArray_btSoftBody_RContact__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( ::btSoftBody::RContact const & ) 
void* btAlignedObjectArray_btSoftBody_RContact__at(void *c,int p0); //method: at ::btSoftBody::RContact const & ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_RContact__at0(void *c,int p0); //method: at ::btSoftBody::RContact const & ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_RContact__at1(void *c,int p0); //method: at ::btSoftBody::RContact & ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int ) 
int btAlignedObjectArray_btSoftBody_RContact__size(void *c); //method: size int ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) const
int btAlignedObjectArray_btSoftBody_RContact__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) const
void btAlignedObjectArray_btSoftBody_RContact__init(void *c); //method: init void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_RContact__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_RContact__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_RContact__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_RContact__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int ) 
void btAlignedObjectArray_btSoftBody_RContact__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( void *,int,int ) 
void* btAlignedObjectArray_btSoftBody_RContact__expandNonInitializing(void *c); //method: expandNonInitializing ::btSoftBody::RContact & ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_RContact__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_RContact__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int,int,::btSoftBody::RContact * ) const
void btAlignedObjectArray_btSoftBody_RContact__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int,::btSoftBody::RContact const & ) 
void btAlignedObjectArray_btSoftBody_RContact__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )(  ) 
int btAlignedObjectArray_btSoftBody_RContact__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_RContact__expand(void *c,void* p0); //method: expand ::btSoftBody::RContact & ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( ::btSoftBody::RContact const & ) 
void btAlignedObjectArray_btSoftBody_RContact__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSoftBody::RContact>::* )( int ) 
void btAlignedObjectArray_btSoftBody_RContact__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSoftBody::RContact, 16u> btAlignedObjectArray_btSoftBody_RContact_->m_allocator
void* btAlignedObjectArray_btSoftBody_RContact__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSoftBody::RContact, 16u> btAlignedObjectArray_btSoftBody_RContact_->m_allocator
void btAlignedObjectArray_btSoftBody_RContact__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_RContact_->m_capacity
int btAlignedObjectArray_btSoftBody_RContact__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_RContact_->m_capacity
void btAlignedObjectArray_btSoftBody_RContact__m_data_set(void *c,void* a); //attribute: ::btSoftBody::RContact * btAlignedObjectArray_btSoftBody_RContact_->m_data
void* btAlignedObjectArray_btSoftBody_RContact__m_data_get(void *c); //attribute: ::btSoftBody::RContact * btAlignedObjectArray_btSoftBody_RContact_->m_data
void btAlignedObjectArray_btSoftBody_RContact__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSoftBody_RContact_->m_ownsMemory
int btAlignedObjectArray_btSoftBody_RContact__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSoftBody_RContact_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_RContact__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_RContact_->m_size
int btAlignedObjectArray_btSoftBody_RContact__m_size_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_RContact_->m_size
void* btAlignedObjectArray_btSoftBody_SContact__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_SContact__free(void *c); 
void btAlignedObjectArray_btSoftBody_SContact__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( ::btSoftBody::SContact const & ) 
void* btAlignedObjectArray_btSoftBody_SContact__at(void *c,int p0); //method: at ::btSoftBody::SContact const & ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_SContact__at0(void *c,int p0); //method: at ::btSoftBody::SContact const & ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_SContact__at1(void *c,int p0); //method: at ::btSoftBody::SContact & ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int ) 
int btAlignedObjectArray_btSoftBody_SContact__size(void *c); //method: size int ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) const
int btAlignedObjectArray_btSoftBody_SContact__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) const
void btAlignedObjectArray_btSoftBody_SContact__init(void *c); //method: init void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_SContact__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_SContact__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_SContact__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_SContact__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int ) 
void btAlignedObjectArray_btSoftBody_SContact__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( void *,int,int ) 
void* btAlignedObjectArray_btSoftBody_SContact__expandNonInitializing(void *c); //method: expandNonInitializing ::btSoftBody::SContact & ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) 
void btAlignedObjectArray_btSoftBody_SContact__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_SContact__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int,int,::btSoftBody::SContact * ) const
void btAlignedObjectArray_btSoftBody_SContact__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int,::btSoftBody::SContact const & ) 
void btAlignedObjectArray_btSoftBody_SContact__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )(  ) 
int btAlignedObjectArray_btSoftBody_SContact__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_SContact__expand(void *c,void* p0); //method: expand ::btSoftBody::SContact & ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( ::btSoftBody::SContact const & ) 
void btAlignedObjectArray_btSoftBody_SContact__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSoftBody::SContact>::* )( int ) 
void btAlignedObjectArray_btSoftBody_SContact__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSoftBody::SContact, 16u> btAlignedObjectArray_btSoftBody_SContact_->m_allocator
void* btAlignedObjectArray_btSoftBody_SContact__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSoftBody::SContact, 16u> btAlignedObjectArray_btSoftBody_SContact_->m_allocator
void btAlignedObjectArray_btSoftBody_SContact__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_SContact_->m_capacity
int btAlignedObjectArray_btSoftBody_SContact__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_SContact_->m_capacity
void btAlignedObjectArray_btSoftBody_SContact__m_data_set(void *c,void* a); //attribute: ::btSoftBody::SContact * btAlignedObjectArray_btSoftBody_SContact_->m_data
void* btAlignedObjectArray_btSoftBody_SContact__m_data_get(void *c); //attribute: ::btSoftBody::SContact * btAlignedObjectArray_btSoftBody_SContact_->m_data
void btAlignedObjectArray_btSoftBody_SContact__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSoftBody_SContact_->m_ownsMemory
int btAlignedObjectArray_btSoftBody_SContact__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSoftBody_SContact_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_SContact__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_SContact_->m_size
int btAlignedObjectArray_btSoftBody_SContact__m_size_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_SContact_->m_size
void* btAlignedObjectArray_btSoftBody_Tetra__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Tetra__free(void *c); 
void btAlignedObjectArray_btSoftBody_Tetra__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( ::btSoftBody::Tetra const & ) 
void* btAlignedObjectArray_btSoftBody_Tetra__at(void *c,int p0); //method: at ::btSoftBody::Tetra const & ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Tetra__at0(void *c,int p0); //method: at ::btSoftBody::Tetra const & ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int ) const
void* btAlignedObjectArray_btSoftBody_Tetra__at1(void *c,int p0); //method: at ::btSoftBody::Tetra & ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int ) 
int btAlignedObjectArray_btSoftBody_Tetra__size(void *c); //method: size int ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) const
int btAlignedObjectArray_btSoftBody_Tetra__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) const
void btAlignedObjectArray_btSoftBody_Tetra__init(void *c); //method: init void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Tetra__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Tetra__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Tetra__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_Tetra__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Tetra__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( void *,int,int ) 
void* btAlignedObjectArray_btSoftBody_Tetra__expandNonInitializing(void *c); //method: expandNonInitializing ::btSoftBody::Tetra & ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) 
void btAlignedObjectArray_btSoftBody_Tetra__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_Tetra__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int,int,::btSoftBody::Tetra * ) const
void btAlignedObjectArray_btSoftBody_Tetra__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int,::btSoftBody::Tetra const & ) 
void btAlignedObjectArray_btSoftBody_Tetra__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )(  ) 
int btAlignedObjectArray_btSoftBody_Tetra__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int ) 
void* btAlignedObjectArray_btSoftBody_Tetra__expand(void *c,void* p0); //method: expand ::btSoftBody::Tetra & ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( ::btSoftBody::Tetra const & ) 
void btAlignedObjectArray_btSoftBody_Tetra__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSoftBody::Tetra>::* )( int ) 
void btAlignedObjectArray_btSoftBody_Tetra__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSoftBody::Tetra, 16u> btAlignedObjectArray_btSoftBody_Tetra_->m_allocator
void* btAlignedObjectArray_btSoftBody_Tetra__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSoftBody::Tetra, 16u> btAlignedObjectArray_btSoftBody_Tetra_->m_allocator
void btAlignedObjectArray_btSoftBody_Tetra__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Tetra_->m_capacity
int btAlignedObjectArray_btSoftBody_Tetra__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Tetra_->m_capacity
void btAlignedObjectArray_btSoftBody_Tetra__m_data_set(void *c,void* a); //attribute: ::btSoftBody::Tetra * btAlignedObjectArray_btSoftBody_Tetra_->m_data
void* btAlignedObjectArray_btSoftBody_Tetra__m_data_get(void *c); //attribute: ::btSoftBody::Tetra * btAlignedObjectArray_btSoftBody_Tetra_->m_data
void btAlignedObjectArray_btSoftBody_Tetra__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSoftBody_Tetra_->m_ownsMemory
int btAlignedObjectArray_btSoftBody_Tetra__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSoftBody_Tetra_->m_ownsMemory
void btAlignedObjectArray_btSoftBody_Tetra__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_Tetra_->m_size
int btAlignedObjectArray_btSoftBody_Tetra__m_size_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_Tetra_->m_size
void* btAlignedObjectArray_btSoftBody_ePSolver____new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) 
void btAlignedObjectArray_btSoftBody_ePSolver____free(void *c); 
//not supported method: push_back void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( ::btSoftBody::ePSolver::_ const & ) 
// error:  - unsupported, void - ok

//not supported method: at ::btSoftBody::ePSolver::_ const & ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at ::btSoftBody::ePSolver::_ const & ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at ::btSoftBody::ePSolver::_ & ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int ) 
// error: int - ok,  - unsupported

int btAlignedObjectArray_btSoftBody_ePSolver____size(void *c); //method: size int ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) const
int btAlignedObjectArray_btSoftBody_ePSolver____capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) const
void btAlignedObjectArray_btSoftBody_ePSolver____init(void *c); //method: init void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) 
void btAlignedObjectArray_btSoftBody_ePSolver____swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_ePSolver____pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) 
void btAlignedObjectArray_btSoftBody_ePSolver____deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_ePSolver____allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int ) 
void btAlignedObjectArray_btSoftBody_ePSolver____initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( void *,int,int ) 
//not supported method: expandNonInitializing ::btSoftBody::ePSolver::_ & ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) 
// error:  - unsupported

void btAlignedObjectArray_btSoftBody_ePSolver____destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int,int,::btSoftBody::ePSolver::_ * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: resize void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int,::btSoftBody::ePSolver::_ const & ) 
// error: int - ok,  - unsupported, void - ok

void btAlignedObjectArray_btSoftBody_ePSolver____clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )(  ) 
int btAlignedObjectArray_btSoftBody_ePSolver____allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int ) 
//not supported method: expand ::btSoftBody::ePSolver::_ & ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( ::btSoftBody::ePSolver::_ const & ) 
// error:  - unsupported,  - unsupported

void btAlignedObjectArray_btSoftBody_ePSolver____reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSoftBody::ePSolver::_>::* )( int ) 
void btAlignedObjectArray_btSoftBody_ePSolver____m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u> btAlignedObjectArray_btSoftBody_ePSolver___->m_allocator
void* btAlignedObjectArray_btSoftBody_ePSolver____m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSoftBody::ePSolver::_, 16u> btAlignedObjectArray_btSoftBody_ePSolver___->m_allocator
void btAlignedObjectArray_btSoftBody_ePSolver____m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_ePSolver___->m_capacity
int btAlignedObjectArray_btSoftBody_ePSolver____m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_ePSolver___->m_capacity
// attribute not supported: //attribute: ::btSoftBody::ePSolver::_ * btAlignedObjectArray_btSoftBody_ePSolver___->m_data
void btAlignedObjectArray_btSoftBody_ePSolver____m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSoftBody_ePSolver___->m_ownsMemory
int btAlignedObjectArray_btSoftBody_ePSolver____m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSoftBody_ePSolver___->m_ownsMemory
void btAlignedObjectArray_btSoftBody_ePSolver____m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_ePSolver___->m_size
int btAlignedObjectArray_btSoftBody_ePSolver____m_size_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_ePSolver___->m_size
void* btAlignedObjectArray_btSoftBody_eVSolver____new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) 
void btAlignedObjectArray_btSoftBody_eVSolver____free(void *c); 
//not supported method: push_back void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( ::btSoftBody::eVSolver::_ const & ) 
// error:  - unsupported, void - ok

//not supported method: at ::btSoftBody::eVSolver::_ const & ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at ::btSoftBody::eVSolver::_ const & ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at ::btSoftBody::eVSolver::_ & ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int ) 
// error: int - ok,  - unsupported

int btAlignedObjectArray_btSoftBody_eVSolver____size(void *c); //method: size int ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) const
int btAlignedObjectArray_btSoftBody_eVSolver____capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) const
void btAlignedObjectArray_btSoftBody_eVSolver____init(void *c); //method: init void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) 
void btAlignedObjectArray_btSoftBody_eVSolver____swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int,int ) 
void btAlignedObjectArray_btSoftBody_eVSolver____pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) 
void btAlignedObjectArray_btSoftBody_eVSolver____deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) 
void* btAlignedObjectArray_btSoftBody_eVSolver____allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int ) 
void btAlignedObjectArray_btSoftBody_eVSolver____initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( void *,int,int ) 
//not supported method: expandNonInitializing ::btSoftBody::eVSolver::_ & ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) 
// error:  - unsupported

void btAlignedObjectArray_btSoftBody_eVSolver____destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int,int,::btSoftBody::eVSolver::_ * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: resize void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int,::btSoftBody::eVSolver::_ const & ) 
// error: int - ok,  - unsupported, void - ok

void btAlignedObjectArray_btSoftBody_eVSolver____clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )(  ) 
int btAlignedObjectArray_btSoftBody_eVSolver____allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int ) 
//not supported method: expand ::btSoftBody::eVSolver::_ & ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( ::btSoftBody::eVSolver::_ const & ) 
// error:  - unsupported,  - unsupported

void btAlignedObjectArray_btSoftBody_eVSolver____reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSoftBody::eVSolver::_>::* )( int ) 
void btAlignedObjectArray_btSoftBody_eVSolver____m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u> btAlignedObjectArray_btSoftBody_eVSolver___->m_allocator
void* btAlignedObjectArray_btSoftBody_eVSolver____m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSoftBody::eVSolver::_, 16u> btAlignedObjectArray_btSoftBody_eVSolver___->m_allocator
void btAlignedObjectArray_btSoftBody_eVSolver____m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_eVSolver___->m_capacity
int btAlignedObjectArray_btSoftBody_eVSolver____m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_eVSolver___->m_capacity
// attribute not supported: //attribute: ::btSoftBody::eVSolver::_ * btAlignedObjectArray_btSoftBody_eVSolver___->m_data
void btAlignedObjectArray_btSoftBody_eVSolver____m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSoftBody_eVSolver___->m_ownsMemory
int btAlignedObjectArray_btSoftBody_eVSolver____m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSoftBody_eVSolver___->m_ownsMemory
void btAlignedObjectArray_btSoftBody_eVSolver____m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSoftBody_eVSolver___->m_size
int btAlignedObjectArray_btSoftBody_eVSolver____m_size_get(void *c); //attribute: int btAlignedObjectArray_btSoftBody_eVSolver___->m_size
void* btAlignedObjectArray_btSolverConstraint__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) 
void btAlignedObjectArray_btSolverConstraint__free(void *c); 
void btAlignedObjectArray_btSolverConstraint__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btSolverConstraint>::* )( ::btSolverConstraint const & ) 
void* btAlignedObjectArray_btSolverConstraint__at(void *c,int p0); //method: at ::btSolverConstraint const & ( ::btAlignedObjectArray<btSolverConstraint>::* )( int ) const
void* btAlignedObjectArray_btSolverConstraint__at0(void *c,int p0); //method: at ::btSolverConstraint const & ( ::btAlignedObjectArray<btSolverConstraint>::* )( int ) const
void* btAlignedObjectArray_btSolverConstraint__at1(void *c,int p0); //method: at ::btSolverConstraint & ( ::btAlignedObjectArray<btSolverConstraint>::* )( int ) 
int btAlignedObjectArray_btSolverConstraint__size(void *c); //method: size int ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) const
int btAlignedObjectArray_btSolverConstraint__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) const
void btAlignedObjectArray_btSolverConstraint__init(void *c); //method: init void ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) 
void* btAlignedObjectArray_btSolverConstraint__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSolverConstraint>::* )( int ) 
void btAlignedObjectArray_btSolverConstraint__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) 
void btAlignedObjectArray_btSolverConstraint__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) 
void btAlignedObjectArray_btSolverConstraint__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSolverConstraint>::* )( int,int ) 
void btAlignedObjectArray_btSolverConstraint__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSolverConstraint>::* )( void *,int,int ) 
void* btAlignedObjectArray_btSolverConstraint__expandNonInitializing(void *c); //method: expandNonInitializing ::btSolverConstraint & ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) 
void btAlignedObjectArray_btSolverConstraint__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btSolverConstraint>::* )( int,::btSolverConstraint const & ) 
void btAlignedObjectArray_btSolverConstraint__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSolverConstraint>::* )( int,int ) 
void btAlignedObjectArray_btSolverConstraint__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btSolverConstraint>::* )( int,int,::btSolverConstraint * ) const
void* btAlignedObjectArray_btSolverConstraint__expand(void *c,void* p0); //method: expand ::btSolverConstraint & ( ::btAlignedObjectArray<btSolverConstraint>::* )( ::btSolverConstraint const & ) 
void btAlignedObjectArray_btSolverConstraint__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSolverConstraint>::* )(  ) 
int btAlignedObjectArray_btSolverConstraint__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSolverConstraint>::* )( int ) 
void btAlignedObjectArray_btSolverConstraint__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSolverConstraint>::* )( int ) 
void btAlignedObjectArray_btSolverConstraint__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSolverConstraint, 16u> btAlignedObjectArray_btSolverConstraint_->m_allocator
void* btAlignedObjectArray_btSolverConstraint__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSolverConstraint, 16u> btAlignedObjectArray_btSolverConstraint_->m_allocator
void btAlignedObjectArray_btSolverConstraint__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSolverConstraint_->m_size
int btAlignedObjectArray_btSolverConstraint__m_size_get(void *c); //attribute: int btAlignedObjectArray_btSolverConstraint_->m_size
void btAlignedObjectArray_btSolverConstraint__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSolverConstraint_->m_capacity
int btAlignedObjectArray_btSolverConstraint__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSolverConstraint_->m_capacity
void btAlignedObjectArray_btSolverConstraint__m_data_set(void *c,void* a); //attribute: ::btSolverConstraint * btAlignedObjectArray_btSolverConstraint_->m_data
void* btAlignedObjectArray_btSolverConstraint__m_data_get(void *c); //attribute: ::btSolverConstraint * btAlignedObjectArray_btSolverConstraint_->m_data
void btAlignedObjectArray_btSolverConstraint__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSolverConstraint_->m_ownsMemory
int btAlignedObjectArray_btSolverConstraint__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSolverConstraint_->m_ownsMemory
void* btAlignedObjectArray_btSparseSdf_3__Cell_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) 
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__free(void *c); 
//not supported method: push_back void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( ::btSparseSdf<3>::Cell * const & ) 
// error:  - unsupported, void - ok

//not supported method: at ::btSparseSdf<3>::Cell * const & ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at ::btSparseSdf<3>::Cell * const & ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at ::btSparseSdf<3>::Cell * & ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int ) 
// error: int - ok,  - unsupported

int btAlignedObjectArray_btSparseSdf_3__Cell_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) const
int btAlignedObjectArray_btSparseSdf_3__Cell_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) const
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) 
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int,int ) 
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) 
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) 
void* btAlignedObjectArray_btSparseSdf_3__Cell_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int ) 
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( void *,int,int ) 
//not supported method: expandNonInitializing ::btSparseSdf<3>::Cell * & ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) 
// error:  - unsupported

void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int,int,::btSparseSdf<3>::Cell * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: resize void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int,::btSparseSdf<3>::Cell * const & ) 
// error: int - ok,  - unsupported, void - ok

void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )(  ) 
int btAlignedObjectArray_btSparseSdf_3__Cell_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int ) 
//not supported method: expand ::btSparseSdf<3>::Cell * & ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( ::btSparseSdf<3>::Cell * const & ) 
// error:  - unsupported,  - unsupported

void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btSparseSdf<3>::Cell*>::* )( int ) 
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u> btAlignedObjectArray_btSparseSdf_3__Cell_ptr_->m_allocator
void* btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u> btAlignedObjectArray_btSparseSdf_3__Cell_ptr_->m_allocator
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btSparseSdf_3__Cell_ptr_->m_capacity
int btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btSparseSdf_3__Cell_ptr_->m_capacity
// attribute not supported: //attribute: ::btSparseSdf<3>::Cell * * btAlignedObjectArray_btSparseSdf_3__Cell_ptr_->m_data
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btSparseSdf_3__Cell_ptr_->m_ownsMemory
int btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btSparseSdf_3__Cell_ptr_->m_ownsMemory
void btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btSparseSdf_3__Cell_ptr_->m_size
int btAlignedObjectArray_btSparseSdf_3__Cell_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btSparseSdf_3__Cell_ptr_->m_size
void* btAlignedObjectArray_btTransform__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btTransform>::* )(  ) 
void btAlignedObjectArray_btTransform__free(void *c); 
void btAlignedObjectArray_btTransform__push_back(void *c,float* p0); //method: push_back void ( ::btAlignedObjectArray<btTransform>::* )( ::btTransform const & ) 
void btAlignedObjectArray_btTransform__at(void *c,int p0,float* ret); //method: at ::btTransform const & ( ::btAlignedObjectArray<btTransform>::* )( int ) const
void btAlignedObjectArray_btTransform__at0(void *c,int p0,float* ret); //method: at ::btTransform const & ( ::btAlignedObjectArray<btTransform>::* )( int ) const
void btAlignedObjectArray_btTransform__at1(void *c,int p0,float* ret); //method: at ::btTransform & ( ::btAlignedObjectArray<btTransform>::* )( int ) 
int btAlignedObjectArray_btTransform__size(void *c); //method: size int ( ::btAlignedObjectArray<btTransform>::* )(  ) const
int btAlignedObjectArray_btTransform__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btTransform>::* )(  ) const
void btAlignedObjectArray_btTransform__init(void *c); //method: init void ( ::btAlignedObjectArray<btTransform>::* )(  ) 
void* btAlignedObjectArray_btTransform__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btTransform>::* )( int ) 
void btAlignedObjectArray_btTransform__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btTransform>::* )(  ) 
void btAlignedObjectArray_btTransform__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btTransform>::* )(  ) 
void btAlignedObjectArray_btTransform__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btTransform>::* )( int,int ) 
void btAlignedObjectArray_btTransform__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btTransform>::* )( void *,int,int ) 
void btAlignedObjectArray_btTransform__expandNonInitializing(void *c,float* ret); //method: expandNonInitializing ::btTransform & ( ::btAlignedObjectArray<btTransform>::* )(  ) 
void btAlignedObjectArray_btTransform__resize(void *c,int p0,float* p1); //method: resize void ( ::btAlignedObjectArray<btTransform>::* )( int,::btTransform const & ) 
void btAlignedObjectArray_btTransform__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btTransform>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btTransform>::* )( int,int,::btTransform * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void btAlignedObjectArray_btTransform__expand(void *c,float* p0,float* ret); //method: expand ::btTransform & ( ::btAlignedObjectArray<btTransform>::* )( ::btTransform const & ) 
void btAlignedObjectArray_btTransform__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btTransform>::* )(  ) 
int btAlignedObjectArray_btTransform__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btTransform>::* )( int ) 
void btAlignedObjectArray_btTransform__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btTransform>::* )( int ) 
void btAlignedObjectArray_btTransform__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btTransform, 16u> btAlignedObjectArray_btTransform_->m_allocator
void* btAlignedObjectArray_btTransform__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btTransform, 16u> btAlignedObjectArray_btTransform_->m_allocator
void btAlignedObjectArray_btTransform__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btTransform_->m_size
int btAlignedObjectArray_btTransform__m_size_get(void *c); //attribute: int btAlignedObjectArray_btTransform_->m_size
void btAlignedObjectArray_btTransform__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btTransform_->m_capacity
int btAlignedObjectArray_btTransform__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btTransform_->m_capacity
// attribute not supported: //attribute: ::btTransform * btAlignedObjectArray_btTransform_->m_data
void btAlignedObjectArray_btTransform__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btTransform_->m_ownsMemory
int btAlignedObjectArray_btTransform__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btTransform_->m_ownsMemory
void* btAlignedObjectArray_btTriangleInfo__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) 
void btAlignedObjectArray_btTriangleInfo__free(void *c); 
void btAlignedObjectArray_btTriangleInfo__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btTriangleInfo>::* )( ::btTriangleInfo const & ) 
void* btAlignedObjectArray_btTriangleInfo__at(void *c,int p0); //method: at ::btTriangleInfo const & ( ::btAlignedObjectArray<btTriangleInfo>::* )( int ) const
void* btAlignedObjectArray_btTriangleInfo__at0(void *c,int p0); //method: at ::btTriangleInfo const & ( ::btAlignedObjectArray<btTriangleInfo>::* )( int ) const
void* btAlignedObjectArray_btTriangleInfo__at1(void *c,int p0); //method: at ::btTriangleInfo & ( ::btAlignedObjectArray<btTriangleInfo>::* )( int ) 
int btAlignedObjectArray_btTriangleInfo__size(void *c); //method: size int ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) const
int btAlignedObjectArray_btTriangleInfo__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) const
void btAlignedObjectArray_btTriangleInfo__init(void *c); //method: init void ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) 
void* btAlignedObjectArray_btTriangleInfo__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btTriangleInfo>::* )( int ) 
void btAlignedObjectArray_btTriangleInfo__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) 
void btAlignedObjectArray_btTriangleInfo__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) 
void btAlignedObjectArray_btTriangleInfo__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btTriangleInfo>::* )( int,int ) 
void btAlignedObjectArray_btTriangleInfo__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btTriangleInfo>::* )( void *,int,int ) 
void* btAlignedObjectArray_btTriangleInfo__expandNonInitializing(void *c); //method: expandNonInitializing ::btTriangleInfo & ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) 
void btAlignedObjectArray_btTriangleInfo__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btTriangleInfo>::* )( int,::btTriangleInfo const & ) 
void btAlignedObjectArray_btTriangleInfo__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btTriangleInfo>::* )( int,int ) 
void btAlignedObjectArray_btTriangleInfo__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btTriangleInfo>::* )( int,int,::btTriangleInfo * ) const
void* btAlignedObjectArray_btTriangleInfo__expand(void *c,void* p0); //method: expand ::btTriangleInfo & ( ::btAlignedObjectArray<btTriangleInfo>::* )( ::btTriangleInfo const & ) 
void btAlignedObjectArray_btTriangleInfo__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btTriangleInfo>::* )(  ) 
int btAlignedObjectArray_btTriangleInfo__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btTriangleInfo>::* )( int ) 
void btAlignedObjectArray_btTriangleInfo__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btTriangleInfo>::* )( int ) 
void btAlignedObjectArray_btTriangleInfo__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btTriangleInfo, 16u> btAlignedObjectArray_btTriangleInfo_->m_allocator
void* btAlignedObjectArray_btTriangleInfo__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btTriangleInfo, 16u> btAlignedObjectArray_btTriangleInfo_->m_allocator
void btAlignedObjectArray_btTriangleInfo__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btTriangleInfo_->m_size
int btAlignedObjectArray_btTriangleInfo__m_size_get(void *c); //attribute: int btAlignedObjectArray_btTriangleInfo_->m_size
void btAlignedObjectArray_btTriangleInfo__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btTriangleInfo_->m_capacity
int btAlignedObjectArray_btTriangleInfo__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btTriangleInfo_->m_capacity
void btAlignedObjectArray_btTriangleInfo__m_data_set(void *c,void* a); //attribute: ::btTriangleInfo * btAlignedObjectArray_btTriangleInfo_->m_data
void* btAlignedObjectArray_btTriangleInfo__m_data_get(void *c); //attribute: ::btTriangleInfo * btAlignedObjectArray_btTriangleInfo_->m_data
void btAlignedObjectArray_btTriangleInfo__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btTriangleInfo_->m_ownsMemory
int btAlignedObjectArray_btTriangleInfo__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btTriangleInfo_->m_ownsMemory
void* btAlignedObjectArray_btTypedConstraint_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_ptr__free(void *c); 
void btAlignedObjectArray_btTypedConstraint_ptr__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btTypedConstraint*>::* )( ::btTypedConstraint * const & ) 
void* btAlignedObjectArray_btTypedConstraint_ptr__at(void *c,int p0); //method: at ::btTypedConstraint * const & ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int ) const
void* btAlignedObjectArray_btTypedConstraint_ptr__at0(void *c,int p0); //method: at ::btTypedConstraint * const & ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int ) const
void* btAlignedObjectArray_btTypedConstraint_ptr__at1(void *c,int p0); //method: at ::btTypedConstraint * & ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int ) 
int btAlignedObjectArray_btTypedConstraint_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) const
int btAlignedObjectArray_btTypedConstraint_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) const
void btAlignedObjectArray_btTypedConstraint_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) 
void* btAlignedObjectArray_btTypedConstraint_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int ) 
void btAlignedObjectArray_btTypedConstraint_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int,int ) 
void btAlignedObjectArray_btTypedConstraint_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btTypedConstraint*>::* )( void *,int,int ) 
void* btAlignedObjectArray_btTypedConstraint_ptr__expandNonInitializing(void *c); //method: expandNonInitializing ::btTypedConstraint * & ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_ptr__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int,::btTypedConstraint * const & ) 
void btAlignedObjectArray_btTypedConstraint_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int,int,::btTypedConstraint * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void* btAlignedObjectArray_btTypedConstraint_ptr__expand(void *c,void* p0); //method: expand ::btTypedConstraint * & ( ::btAlignedObjectArray<btTypedConstraint*>::* )( ::btTypedConstraint * const & ) 
void btAlignedObjectArray_btTypedConstraint_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btTypedConstraint*>::* )(  ) 
int btAlignedObjectArray_btTypedConstraint_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int ) 
void btAlignedObjectArray_btTypedConstraint_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btTypedConstraint*>::* )( int ) 
void btAlignedObjectArray_btTypedConstraint_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btTypedConstraint*, 16u> btAlignedObjectArray_btTypedConstraint_ptr_->m_allocator
void* btAlignedObjectArray_btTypedConstraint_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btTypedConstraint*, 16u> btAlignedObjectArray_btTypedConstraint_ptr_->m_allocator
void btAlignedObjectArray_btTypedConstraint_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btTypedConstraint_ptr_->m_size
int btAlignedObjectArray_btTypedConstraint_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_btTypedConstraint_ptr_->m_size
void btAlignedObjectArray_btTypedConstraint_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btTypedConstraint_ptr_->m_capacity
int btAlignedObjectArray_btTypedConstraint_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btTypedConstraint_ptr_->m_capacity
// attribute not supported: //attribute: ::btTypedConstraint * * btAlignedObjectArray_btTypedConstraint_ptr_->m_data
void btAlignedObjectArray_btTypedConstraint_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btTypedConstraint_ptr_->m_ownsMemory
int btAlignedObjectArray_btTypedConstraint_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btTypedConstraint_ptr_->m_ownsMemory
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__free(void *c); 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( ::btTypedConstraint::btConstraintInfo1 const & ) 
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__at(void *c,int p0); //method: at ::btTypedConstraint::btConstraintInfo1 const & ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int ) const
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__at0(void *c,int p0); //method: at ::btTypedConstraint::btConstraintInfo1 const & ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int ) const
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__at1(void *c,int p0); //method: at ::btTypedConstraint::btConstraintInfo1 & ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int ) 
int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__size(void *c); //method: size int ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) const
int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) const
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__init(void *c); //method: init void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) 
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int,int ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( void *,int,int ) 
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__expandNonInitializing(void *c); //method: expandNonInitializing ::btTypedConstraint::btConstraintInfo1 & ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int,::btTypedConstraint::btConstraintInfo1 const & ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int,int ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int,int,::btTypedConstraint::btConstraintInfo1 * ) const
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__expand(void *c,void* p0); //method: expand ::btTypedConstraint::btConstraintInfo1 & ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( ::btTypedConstraint::btConstraintInfo1 const & ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )(  ) 
int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::* )( int ) 
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u> btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_->m_allocator
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u> btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_->m_allocator
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_->m_size
int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_size_get(void *c); //attribute: int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_->m_size
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_->m_capacity
int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_->m_capacity
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_data_set(void *c,void* a); //attribute: ::btTypedConstraint::btConstraintInfo1 * btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_->m_data
void* btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_data_get(void *c); //attribute: ::btTypedConstraint::btConstraintInfo1 * btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_->m_data
void btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_->m_ownsMemory
int btAlignedObjectArray_btTypedConstraint_btConstraintInfo1__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_->m_ownsMemory
void* btAlignedObjectArray_btVector3__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btVector3>::* )(  ) 
void btAlignedObjectArray_btVector3__free(void *c); 
void btAlignedObjectArray_btVector3__push_back(void *c,float* p0); //method: push_back void ( ::btAlignedObjectArray<btVector3>::* )( ::btVector3 const & ) 
void btAlignedObjectArray_btVector3__at(void *c,int p0,float* ret); //method: at ::btVector3 const & ( ::btAlignedObjectArray<btVector3>::* )( int ) const
void btAlignedObjectArray_btVector3__at0(void *c,int p0,float* ret); //method: at ::btVector3 const & ( ::btAlignedObjectArray<btVector3>::* )( int ) const
void btAlignedObjectArray_btVector3__at1(void *c,int p0,float* ret); //method: at ::btVector3 & ( ::btAlignedObjectArray<btVector3>::* )( int ) 
int btAlignedObjectArray_btVector3__size(void *c); //method: size int ( ::btAlignedObjectArray<btVector3>::* )(  ) const
int btAlignedObjectArray_btVector3__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btVector3>::* )(  ) const
void btAlignedObjectArray_btVector3__init(void *c); //method: init void ( ::btAlignedObjectArray<btVector3>::* )(  ) 
void btAlignedObjectArray_btVector3__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btVector3>::* )( int,int ) 
void btAlignedObjectArray_btVector3__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btVector3>::* )(  ) 
void btAlignedObjectArray_btVector3__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btVector3>::* )(  ) 
void* btAlignedObjectArray_btVector3__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btVector3>::* )( int ) 
void btAlignedObjectArray_btVector3__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btVector3>::* )( void *,int,int ) 
void btAlignedObjectArray_btVector3__expandNonInitializing(void *c,float* ret); //method: expandNonInitializing ::btVector3 & ( ::btAlignedObjectArray<btVector3>::* )(  ) 
void btAlignedObjectArray_btVector3__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btVector3>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<btVector3>::* )( int,int,::btVector3 * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

void btAlignedObjectArray_btVector3__resize(void *c,int p0,float* p1); //method: resize void ( ::btAlignedObjectArray<btVector3>::* )( int,::btVector3 const & ) 
void btAlignedObjectArray_btVector3__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btVector3>::* )(  ) 
int btAlignedObjectArray_btVector3__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btVector3>::* )( int ) 
void btAlignedObjectArray_btVector3__expand(void *c,float* p0,float* ret); //method: expand ::btVector3 & ( ::btAlignedObjectArray<btVector3>::* )( ::btVector3 const & ) 
void btAlignedObjectArray_btVector3__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btVector3>::* )( int ) 
void btAlignedObjectArray_btVector3__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btVector3, 16u> btAlignedObjectArray_btVector3_->m_allocator
void* btAlignedObjectArray_btVector3__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btVector3, 16u> btAlignedObjectArray_btVector3_->m_allocator
void btAlignedObjectArray_btVector3__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btVector3_->m_capacity
int btAlignedObjectArray_btVector3__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btVector3_->m_capacity
// attribute not supported: //attribute: ::btVector3 * btAlignedObjectArray_btVector3_->m_data
void btAlignedObjectArray_btVector3__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btVector3_->m_ownsMemory
int btAlignedObjectArray_btVector3__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btVector3_->m_ownsMemory
void btAlignedObjectArray_btVector3__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btVector3_->m_size
int btAlignedObjectArray_btVector3__m_size_get(void *c); //attribute: int btAlignedObjectArray_btVector3_->m_size
void* btAlignedObjectArray_btWheelInfo__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) 
void btAlignedObjectArray_btWheelInfo__free(void *c); 
void btAlignedObjectArray_btWheelInfo__push_back(void *c,void* p0); //method: push_back void ( ::btAlignedObjectArray<btWheelInfo>::* )( ::btWheelInfo const & ) 
void* btAlignedObjectArray_btWheelInfo__at(void *c,int p0); //method: at ::btWheelInfo const & ( ::btAlignedObjectArray<btWheelInfo>::* )( int ) const
void* btAlignedObjectArray_btWheelInfo__at0(void *c,int p0); //method: at ::btWheelInfo const & ( ::btAlignedObjectArray<btWheelInfo>::* )( int ) const
void* btAlignedObjectArray_btWheelInfo__at1(void *c,int p0); //method: at ::btWheelInfo & ( ::btAlignedObjectArray<btWheelInfo>::* )( int ) 
int btAlignedObjectArray_btWheelInfo__size(void *c); //method: size int ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) const
int btAlignedObjectArray_btWheelInfo__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) const
void btAlignedObjectArray_btWheelInfo__init(void *c); //method: init void ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) 
void* btAlignedObjectArray_btWheelInfo__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<btWheelInfo>::* )( int ) 
void btAlignedObjectArray_btWheelInfo__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) 
void btAlignedObjectArray_btWheelInfo__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) 
void btAlignedObjectArray_btWheelInfo__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<btWheelInfo>::* )( int,int ) 
void btAlignedObjectArray_btWheelInfo__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<btWheelInfo>::* )( void *,int,int ) 
void* btAlignedObjectArray_btWheelInfo__expandNonInitializing(void *c); //method: expandNonInitializing ::btWheelInfo & ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) 
void btAlignedObjectArray_btWheelInfo__resize(void *c,int p0,void* p1); //method: resize void ( ::btAlignedObjectArray<btWheelInfo>::* )( int,::btWheelInfo const & ) 
void btAlignedObjectArray_btWheelInfo__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<btWheelInfo>::* )( int,int ) 
void btAlignedObjectArray_btWheelInfo__copy(void *c,int p0,int p1,void* p2); //method: copy void ( ::btAlignedObjectArray<btWheelInfo>::* )( int,int,::btWheelInfo * ) const
void* btAlignedObjectArray_btWheelInfo__expand(void *c,void* p0); //method: expand ::btWheelInfo & ( ::btAlignedObjectArray<btWheelInfo>::* )( ::btWheelInfo const & ) 
void btAlignedObjectArray_btWheelInfo__clear(void *c); //method: clear void ( ::btAlignedObjectArray<btWheelInfo>::* )(  ) 
int btAlignedObjectArray_btWheelInfo__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<btWheelInfo>::* )( int ) 
void btAlignedObjectArray_btWheelInfo__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<btWheelInfo>::* )( int ) 
void btAlignedObjectArray_btWheelInfo__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<btWheelInfo, 16u> btAlignedObjectArray_btWheelInfo_->m_allocator
void* btAlignedObjectArray_btWheelInfo__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<btWheelInfo, 16u> btAlignedObjectArray_btWheelInfo_->m_allocator
void btAlignedObjectArray_btWheelInfo__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_btWheelInfo_->m_size
int btAlignedObjectArray_btWheelInfo__m_size_get(void *c); //attribute: int btAlignedObjectArray_btWheelInfo_->m_size
void btAlignedObjectArray_btWheelInfo__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_btWheelInfo_->m_capacity
int btAlignedObjectArray_btWheelInfo__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_btWheelInfo_->m_capacity
void btAlignedObjectArray_btWheelInfo__m_data_set(void *c,void* a); //attribute: ::btWheelInfo * btAlignedObjectArray_btWheelInfo_->m_data
void* btAlignedObjectArray_btWheelInfo__m_data_get(void *c); //attribute: ::btWheelInfo * btAlignedObjectArray_btWheelInfo_->m_data
void btAlignedObjectArray_btWheelInfo__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_btWheelInfo_->m_ownsMemory
int btAlignedObjectArray_btWheelInfo__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_btWheelInfo_->m_ownsMemory
void* btAlignedObjectArray_charconst_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<char const*>::* )(  ) 
void btAlignedObjectArray_charconst_ptr__free(void *c); 
//not supported method: push_back void ( ::btAlignedObjectArray<char const*>::* )( char const * const & ) 
// error:  - unsupported, void - ok

//not supported method: at char const * const & ( ::btAlignedObjectArray<char const*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at char const * const & ( ::btAlignedObjectArray<char const*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at char const * & ( ::btAlignedObjectArray<char const*>::* )( int ) 
// error: int - ok,  - unsupported

int btAlignedObjectArray_charconst_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<char const*>::* )(  ) const
int btAlignedObjectArray_charconst_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<char const*>::* )(  ) const
void btAlignedObjectArray_charconst_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<char const*>::* )(  ) 
void* btAlignedObjectArray_charconst_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<char const*>::* )( int ) 
void btAlignedObjectArray_charconst_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<char const*>::* )(  ) 
void btAlignedObjectArray_charconst_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<char const*>::* )(  ) 
void btAlignedObjectArray_charconst_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<char const*>::* )( int,int ) 
void btAlignedObjectArray_charconst_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<char const*>::* )( void *,int,int ) 
//not supported method: expandNonInitializing char const * & ( ::btAlignedObjectArray<char const*>::* )(  ) 
// error:  - unsupported

//not supported method: resize void ( ::btAlignedObjectArray<char const*>::* )( int,char const * const & ) 
// error: int - ok,  - unsupported, void - ok

void btAlignedObjectArray_charconst_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<char const*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<char const*>::* )( int,int,char const * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: expand char const * & ( ::btAlignedObjectArray<char const*>::* )( char const * const & ) 
// error:  - unsupported,  - unsupported

void btAlignedObjectArray_charconst_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<char const*>::* )(  ) 
int btAlignedObjectArray_charconst_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<char const*>::* )( int ) 
void btAlignedObjectArray_charconst_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<char const*>::* )( int ) 
void btAlignedObjectArray_charconst_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<char const*, 16u> btAlignedObjectArray_charconst_ptr_->m_allocator
void* btAlignedObjectArray_charconst_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<char const*, 16u> btAlignedObjectArray_charconst_ptr_->m_allocator
void btAlignedObjectArray_charconst_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_charconst_ptr_->m_size
int btAlignedObjectArray_charconst_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_charconst_ptr_->m_size
void btAlignedObjectArray_charconst_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_charconst_ptr_->m_capacity
int btAlignedObjectArray_charconst_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_charconst_ptr_->m_capacity
// attribute not supported: //attribute: char const * * btAlignedObjectArray_charconst_ptr_->m_data
void btAlignedObjectArray_charconst_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_charconst_ptr_->m_ownsMemory
int btAlignedObjectArray_charconst_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_charconst_ptr_->m_ownsMemory
void* btAlignedObjectArray_char_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<char*>::* )(  ) 
void btAlignedObjectArray_char_ptr__free(void *c); 
//not supported method: push_back void ( ::btAlignedObjectArray<char*>::* )( char * const & ) 
// error:  - unsupported, void - ok

//not supported method: at char * const & ( ::btAlignedObjectArray<char*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at char * const & ( ::btAlignedObjectArray<char*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at char * & ( ::btAlignedObjectArray<char*>::* )( int ) 
// error: int - ok,  - unsupported

int btAlignedObjectArray_char_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<char*>::* )(  ) const
int btAlignedObjectArray_char_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<char*>::* )(  ) const
void btAlignedObjectArray_char_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<char*>::* )(  ) 
void* btAlignedObjectArray_char_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<char*>::* )( int ) 
void btAlignedObjectArray_char_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<char*>::* )(  ) 
void btAlignedObjectArray_char_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<char*>::* )(  ) 
void btAlignedObjectArray_char_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<char*>::* )( int,int ) 
void btAlignedObjectArray_char_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<char*>::* )( void *,int,int ) 
//not supported method: expandNonInitializing char * & ( ::btAlignedObjectArray<char*>::* )(  ) 
// error:  - unsupported

//not supported method: resize void ( ::btAlignedObjectArray<char*>::* )( int,char * const & ) 
// error: int - ok,  - unsupported, void - ok

void btAlignedObjectArray_char_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<char*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<char*>::* )( int,int,char * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: expand char * & ( ::btAlignedObjectArray<char*>::* )( char * const & ) 
// error:  - unsupported,  - unsupported

void btAlignedObjectArray_char_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<char*>::* )(  ) 
int btAlignedObjectArray_char_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<char*>::* )( int ) 
void btAlignedObjectArray_char_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<char*>::* )( int ) 
void btAlignedObjectArray_char_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<char*, 16u> btAlignedObjectArray_char_ptr_->m_allocator
void* btAlignedObjectArray_char_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<char*, 16u> btAlignedObjectArray_char_ptr_->m_allocator
void btAlignedObjectArray_char_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_char_ptr_->m_size
int btAlignedObjectArray_char_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_char_ptr_->m_size
void btAlignedObjectArray_char_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_char_ptr_->m_capacity
int btAlignedObjectArray_char_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_char_ptr_->m_capacity
// attribute not supported: //attribute: char * * btAlignedObjectArray_char_ptr_->m_data
void btAlignedObjectArray_char_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_char_ptr_->m_ownsMemory
int btAlignedObjectArray_char_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_char_ptr_->m_ownsMemory
void* btAlignedObjectArray_float__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<float>::* )(  ) 
void btAlignedObjectArray_float__free(void *c); 
//not supported method: push_back void ( ::btAlignedObjectArray<float>::* )( float const & ) 
// error:  - unsupported, void - ok

//not supported method: at float const & ( ::btAlignedObjectArray<float>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at float const & ( ::btAlignedObjectArray<float>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at float & ( ::btAlignedObjectArray<float>::* )( int ) 
// error: int - ok,  - unsupported

int btAlignedObjectArray_float__size(void *c); //method: size int ( ::btAlignedObjectArray<float>::* )(  ) const
int btAlignedObjectArray_float__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<float>::* )(  ) const
void btAlignedObjectArray_float__init(void *c); //method: init void ( ::btAlignedObjectArray<float>::* )(  ) 
void btAlignedObjectArray_float__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<float>::* )( int,int ) 
void btAlignedObjectArray_float__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<float>::* )(  ) 
void btAlignedObjectArray_float__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<float>::* )(  ) 
void* btAlignedObjectArray_float__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<float>::* )( int ) 
void btAlignedObjectArray_float__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<float>::* )( void *,int,int ) 
//not supported method: expandNonInitializing float & ( ::btAlignedObjectArray<float>::* )(  ) 
// error:  - unsupported

void btAlignedObjectArray_float__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<float>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<float>::* )( int,int,float * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: resize void ( ::btAlignedObjectArray<float>::* )( int,float const & ) 
// error: int - ok,  - unsupported, void - ok

void btAlignedObjectArray_float__clear(void *c); //method: clear void ( ::btAlignedObjectArray<float>::* )(  ) 
int btAlignedObjectArray_float__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<float>::* )( int ) 
//not supported method: expand float & ( ::btAlignedObjectArray<float>::* )( float const & ) 
// error:  - unsupported,  - unsupported

void btAlignedObjectArray_float__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<float>::* )( int ) 
void btAlignedObjectArray_float__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<float, 16u> btAlignedObjectArray_float_->m_allocator
void* btAlignedObjectArray_float__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<float, 16u> btAlignedObjectArray_float_->m_allocator
void btAlignedObjectArray_float__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_float_->m_capacity
int btAlignedObjectArray_float__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_float_->m_capacity
// attribute not supported: //attribute: float * btAlignedObjectArray_float_->m_data
void btAlignedObjectArray_float__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_float_->m_ownsMemory
int btAlignedObjectArray_float__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_float_->m_ownsMemory
void btAlignedObjectArray_float__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_float_->m_size
int btAlignedObjectArray_float__m_size_get(void *c); //attribute: int btAlignedObjectArray_float_->m_size
void* btAlignedObjectArray_int__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<int>::* )(  ) 
void btAlignedObjectArray_int__free(void *c); 
//not supported method: push_back void ( ::btAlignedObjectArray<int>::* )( int const & ) 
// error:  - unsupported, void - ok

//not supported method: at int const & ( ::btAlignedObjectArray<int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at int const & ( ::btAlignedObjectArray<int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at int & ( ::btAlignedObjectArray<int>::* )( int ) 
// error: int - ok,  - unsupported

int btAlignedObjectArray_int__size(void *c); //method: size int ( ::btAlignedObjectArray<int>::* )(  ) const
int btAlignedObjectArray_int__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<int>::* )(  ) const
void btAlignedObjectArray_int__init(void *c); //method: init void ( ::btAlignedObjectArray<int>::* )(  ) 
void btAlignedObjectArray_int__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<int>::* )( int,int ) 
void btAlignedObjectArray_int__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<int>::* )(  ) 
void btAlignedObjectArray_int__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<int>::* )(  ) 
void* btAlignedObjectArray_int__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<int>::* )( int ) 
void btAlignedObjectArray_int__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<int>::* )( void *,int,int ) 
//not supported method: expandNonInitializing int & ( ::btAlignedObjectArray<int>::* )(  ) 
// error:  - unsupported

void btAlignedObjectArray_int__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<int>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<int>::* )( int,int,int * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: resize void ( ::btAlignedObjectArray<int>::* )( int,int const & ) 
// error: int - ok,  - unsupported, void - ok

void btAlignedObjectArray_int__clear(void *c); //method: clear void ( ::btAlignedObjectArray<int>::* )(  ) 
int btAlignedObjectArray_int__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<int>::* )( int ) 
//not supported method: expand int & ( ::btAlignedObjectArray<int>::* )( int const & ) 
// error:  - unsupported,  - unsupported

void btAlignedObjectArray_int__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<int>::* )( int ) 
void btAlignedObjectArray_int__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<int, 16u> btAlignedObjectArray_int_->m_allocator
void* btAlignedObjectArray_int__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<int, 16u> btAlignedObjectArray_int_->m_allocator
void btAlignedObjectArray_int__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_int_->m_capacity
int btAlignedObjectArray_int__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_int_->m_capacity
// attribute not supported: //attribute: int * btAlignedObjectArray_int_->m_data
void btAlignedObjectArray_int__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_int_->m_ownsMemory
int btAlignedObjectArray_int__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_int_->m_ownsMemory
void btAlignedObjectArray_int__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_int_->m_size
int btAlignedObjectArray_int__m_size_get(void *c); //attribute: int btAlignedObjectArray_int_->m_size
void* btAlignedObjectArray_short_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<short*>::* )(  ) 
void btAlignedObjectArray_short_ptr__free(void *c); 
//not supported method: push_back void ( ::btAlignedObjectArray<short*>::* )( short int * const & ) 
// error:  - unsupported, void - ok

//not supported method: at short int * const & ( ::btAlignedObjectArray<short*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at short int * const & ( ::btAlignedObjectArray<short*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at short int * & ( ::btAlignedObjectArray<short*>::* )( int ) 
// error: int - ok,  - unsupported

int btAlignedObjectArray_short_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<short*>::* )(  ) const
int btAlignedObjectArray_short_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<short*>::* )(  ) const
void btAlignedObjectArray_short_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<short*>::* )(  ) 
void* btAlignedObjectArray_short_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<short*>::* )( int ) 
void btAlignedObjectArray_short_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<short*>::* )(  ) 
void btAlignedObjectArray_short_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<short*>::* )(  ) 
void btAlignedObjectArray_short_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<short*>::* )( int,int ) 
void btAlignedObjectArray_short_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<short*>::* )( void *,int,int ) 
//not supported method: expandNonInitializing short int * & ( ::btAlignedObjectArray<short*>::* )(  ) 
// error:  - unsupported

//not supported method: resize void ( ::btAlignedObjectArray<short*>::* )( int,short int * const & ) 
// error: int - ok,  - unsupported, void - ok

void btAlignedObjectArray_short_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<short*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<short*>::* )( int,int,short int * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: expand short int * & ( ::btAlignedObjectArray<short*>::* )( short int * const & ) 
// error:  - unsupported,  - unsupported

void btAlignedObjectArray_short_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<short*>::* )(  ) 
int btAlignedObjectArray_short_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<short*>::* )( int ) 
void btAlignedObjectArray_short_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<short*>::* )( int ) 
void btAlignedObjectArray_short_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<short*, 16u> btAlignedObjectArray_short_ptr_->m_allocator
void* btAlignedObjectArray_short_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<short*, 16u> btAlignedObjectArray_short_ptr_->m_allocator
void btAlignedObjectArray_short_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_short_ptr_->m_size
int btAlignedObjectArray_short_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_short_ptr_->m_size
void btAlignedObjectArray_short_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_short_ptr_->m_capacity
int btAlignedObjectArray_short_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_short_ptr_->m_capacity
// attribute not supported: //attribute: short int * * btAlignedObjectArray_short_ptr_->m_data
void btAlignedObjectArray_short_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_short_ptr_->m_ownsMemory
int btAlignedObjectArray_short_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_short_ptr_->m_ownsMemory
void* btAlignedObjectArray_short__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<short>::* )(  ) 
void btAlignedObjectArray_short__free(void *c); 
//not supported method: push_back void ( ::btAlignedObjectArray<short>::* )( short int const & ) 
// error:  - unsupported, void - ok

//not supported method: at short int const & ( ::btAlignedObjectArray<short>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at short int const & ( ::btAlignedObjectArray<short>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at short int & ( ::btAlignedObjectArray<short>::* )( int ) 
// error: int - ok,  - unsupported

int btAlignedObjectArray_short__size(void *c); //method: size int ( ::btAlignedObjectArray<short>::* )(  ) const
int btAlignedObjectArray_short__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<short>::* )(  ) const
void btAlignedObjectArray_short__init(void *c); //method: init void ( ::btAlignedObjectArray<short>::* )(  ) 
void* btAlignedObjectArray_short__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<short>::* )( int ) 
void btAlignedObjectArray_short__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<short>::* )(  ) 
void btAlignedObjectArray_short__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<short>::* )(  ) 
void btAlignedObjectArray_short__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<short>::* )( int,int ) 
void btAlignedObjectArray_short__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<short>::* )( void *,int,int ) 
//not supported method: expandNonInitializing short int & ( ::btAlignedObjectArray<short>::* )(  ) 
// error:  - unsupported

//not supported method: resize void ( ::btAlignedObjectArray<short>::* )( int,short int const & ) 
// error: int - ok,  - unsupported, void - ok

void btAlignedObjectArray_short__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<short>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<short>::* )( int,int,short int * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: expand short int & ( ::btAlignedObjectArray<short>::* )( short int const & ) 
// error:  - unsupported,  - unsupported

void btAlignedObjectArray_short__clear(void *c); //method: clear void ( ::btAlignedObjectArray<short>::* )(  ) 
int btAlignedObjectArray_short__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<short>::* )( int ) 
void btAlignedObjectArray_short__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<short>::* )( int ) 
void btAlignedObjectArray_short__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<short, 16u> btAlignedObjectArray_short_->m_allocator
void* btAlignedObjectArray_short__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<short, 16u> btAlignedObjectArray_short_->m_allocator
void btAlignedObjectArray_short__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_short_->m_size
int btAlignedObjectArray_short__m_size_get(void *c); //attribute: int btAlignedObjectArray_short_->m_size
void btAlignedObjectArray_short__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_short_->m_capacity
int btAlignedObjectArray_short__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_short_->m_capacity
// attribute not supported: //attribute: short int * btAlignedObjectArray_short_->m_data
void btAlignedObjectArray_short__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_short_->m_ownsMemory
int btAlignedObjectArray_short__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_short_->m_ownsMemory
void* btAlignedObjectArray_unsignedint__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<unsigned int>::* )(  ) 
void btAlignedObjectArray_unsignedint__free(void *c); 
//not supported method: push_back void ( ::btAlignedObjectArray<unsigned int>::* )( unsigned int const & ) 
// error:  - unsupported, void - ok

//not supported method: at unsigned int const & ( ::btAlignedObjectArray<unsigned int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at unsigned int const & ( ::btAlignedObjectArray<unsigned int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at unsigned int & ( ::btAlignedObjectArray<unsigned int>::* )( int ) 
// error: int - ok,  - unsupported

int btAlignedObjectArray_unsignedint__size(void *c); //method: size int ( ::btAlignedObjectArray<unsigned int>::* )(  ) const
int btAlignedObjectArray_unsignedint__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<unsigned int>::* )(  ) const
void btAlignedObjectArray_unsignedint__init(void *c); //method: init void ( ::btAlignedObjectArray<unsigned int>::* )(  ) 
void* btAlignedObjectArray_unsignedint__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<unsigned int>::* )( int ) 
void btAlignedObjectArray_unsignedint__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<unsigned int>::* )(  ) 
void btAlignedObjectArray_unsignedint__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<unsigned int>::* )(  ) 
void btAlignedObjectArray_unsignedint__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<unsigned int>::* )( int,int ) 
void btAlignedObjectArray_unsignedint__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<unsigned int>::* )( void *,int,int ) 
//not supported method: expandNonInitializing unsigned int & ( ::btAlignedObjectArray<unsigned int>::* )(  ) 
// error:  - unsupported

//not supported method: resize void ( ::btAlignedObjectArray<unsigned int>::* )( int,unsigned int const & ) 
// error: int - ok,  - unsupported, void - ok

void btAlignedObjectArray_unsignedint__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<unsigned int>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<unsigned int>::* )( int,int,unsigned int * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: expand unsigned int & ( ::btAlignedObjectArray<unsigned int>::* )( unsigned int const & ) 
// error:  - unsupported,  - unsupported

void btAlignedObjectArray_unsignedint__clear(void *c); //method: clear void ( ::btAlignedObjectArray<unsigned int>::* )(  ) 
int btAlignedObjectArray_unsignedint__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<unsigned int>::* )( int ) 
void btAlignedObjectArray_unsignedint__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<unsigned int>::* )( int ) 
void btAlignedObjectArray_unsignedint__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<unsigned int, 16u> btAlignedObjectArray_unsignedint_->m_allocator
void* btAlignedObjectArray_unsignedint__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<unsigned int, 16u> btAlignedObjectArray_unsignedint_->m_allocator
void btAlignedObjectArray_unsignedint__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_unsignedint_->m_size
int btAlignedObjectArray_unsignedint__m_size_get(void *c); //attribute: int btAlignedObjectArray_unsignedint_->m_size
void btAlignedObjectArray_unsignedint__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_unsignedint_->m_capacity
int btAlignedObjectArray_unsignedint__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_unsignedint_->m_capacity
// attribute not supported: //attribute: unsigned int * btAlignedObjectArray_unsignedint_->m_data
void btAlignedObjectArray_unsignedint__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_unsignedint_->m_ownsMemory
int btAlignedObjectArray_unsignedint__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_unsignedint_->m_ownsMemory
void* btAlignedObjectArray_unsignedshort__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<unsigned short>::* )(  ) 
void btAlignedObjectArray_unsignedshort__free(void *c); 
//not supported method: push_back void ( ::btAlignedObjectArray<unsigned short>::* )( short unsigned int const & ) 
// error:  - unsupported, void - ok

//not supported method: at short unsigned int const & ( ::btAlignedObjectArray<unsigned short>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at short unsigned int const & ( ::btAlignedObjectArray<unsigned short>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at short unsigned int & ( ::btAlignedObjectArray<unsigned short>::* )( int ) 
// error: int - ok,  - unsupported

int btAlignedObjectArray_unsignedshort__size(void *c); //method: size int ( ::btAlignedObjectArray<unsigned short>::* )(  ) const
int btAlignedObjectArray_unsignedshort__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<unsigned short>::* )(  ) const
void btAlignedObjectArray_unsignedshort__init(void *c); //method: init void ( ::btAlignedObjectArray<unsigned short>::* )(  ) 
void* btAlignedObjectArray_unsignedshort__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<unsigned short>::* )( int ) 
void btAlignedObjectArray_unsignedshort__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<unsigned short>::* )(  ) 
void btAlignedObjectArray_unsignedshort__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<unsigned short>::* )(  ) 
void btAlignedObjectArray_unsignedshort__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<unsigned short>::* )( int,int ) 
void btAlignedObjectArray_unsignedshort__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<unsigned short>::* )( void *,int,int ) 
//not supported method: expandNonInitializing short unsigned int & ( ::btAlignedObjectArray<unsigned short>::* )(  ) 
// error:  - unsupported

//not supported method: resize void ( ::btAlignedObjectArray<unsigned short>::* )( int,short unsigned int const & ) 
// error: int - ok,  - unsupported, void - ok

void btAlignedObjectArray_unsignedshort__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<unsigned short>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<unsigned short>::* )( int,int,short unsigned int * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: expand short unsigned int & ( ::btAlignedObjectArray<unsigned short>::* )( short unsigned int const & ) 
// error:  - unsupported,  - unsupported

void btAlignedObjectArray_unsignedshort__clear(void *c); //method: clear void ( ::btAlignedObjectArray<unsigned short>::* )(  ) 
int btAlignedObjectArray_unsignedshort__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<unsigned short>::* )( int ) 
void btAlignedObjectArray_unsignedshort__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<unsigned short>::* )( int ) 
void btAlignedObjectArray_unsignedshort__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<unsigned short, 16u> btAlignedObjectArray_unsignedshort_->m_allocator
void* btAlignedObjectArray_unsignedshort__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<unsigned short, 16u> btAlignedObjectArray_unsignedshort_->m_allocator
void btAlignedObjectArray_unsignedshort__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_unsignedshort_->m_size
int btAlignedObjectArray_unsignedshort__m_size_get(void *c); //attribute: int btAlignedObjectArray_unsignedshort_->m_size
void btAlignedObjectArray_unsignedshort__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_unsignedshort_->m_capacity
int btAlignedObjectArray_unsignedshort__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_unsignedshort_->m_capacity
// attribute not supported: //attribute: short unsigned int * btAlignedObjectArray_unsignedshort_->m_data
void btAlignedObjectArray_unsignedshort__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_unsignedshort_->m_ownsMemory
int btAlignedObjectArray_unsignedshort__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_unsignedshort_->m_ownsMemory
void* btAlignedObjectArray_void_ptr__new(); //constructor: btAlignedObjectArray  ( ::btAlignedObjectArray<void*>::* )(  ) 
void btAlignedObjectArray_void_ptr__free(void *c); 
//not supported method: push_back void ( ::btAlignedObjectArray<void*>::* )( void * const & ) 
// error:  - unsupported, void - ok

//not supported method: at void * const & ( ::btAlignedObjectArray<void*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at void * const & ( ::btAlignedObjectArray<void*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: at void * & ( ::btAlignedObjectArray<void*>::* )( int ) 
// error: int - ok,  - unsupported

int btAlignedObjectArray_void_ptr__size(void *c); //method: size int ( ::btAlignedObjectArray<void*>::* )(  ) const
int btAlignedObjectArray_void_ptr__capacity(void *c); //method: capacity int ( ::btAlignedObjectArray<void*>::* )(  ) const
void btAlignedObjectArray_void_ptr__init(void *c); //method: init void ( ::btAlignedObjectArray<void*>::* )(  ) 
void* btAlignedObjectArray_void_ptr__allocate(void *c,int p0); //method: allocate void * ( ::btAlignedObjectArray<void*>::* )( int ) 
void btAlignedObjectArray_void_ptr__pop_back(void *c); //method: pop_back void ( ::btAlignedObjectArray<void*>::* )(  ) 
void btAlignedObjectArray_void_ptr__deallocate(void *c); //method: deallocate void ( ::btAlignedObjectArray<void*>::* )(  ) 
void btAlignedObjectArray_void_ptr__swap(void *c,int p0,int p1); //method: swap void ( ::btAlignedObjectArray<void*>::* )( int,int ) 
void btAlignedObjectArray_void_ptr__initializeFromBuffer(void *c,void* p0,int p1,int p2); //method: initializeFromBuffer void ( ::btAlignedObjectArray<void*>::* )( void *,int,int ) 
//not supported method: expandNonInitializing void * & ( ::btAlignedObjectArray<void*>::* )(  ) 
// error:  - unsupported

//not supported method: resize void ( ::btAlignedObjectArray<void*>::* )( int,void * const & ) 
// error: int - ok,  - unsupported, void - ok

void btAlignedObjectArray_void_ptr__destroy(void *c,int p0,int p1); //method: destroy void ( ::btAlignedObjectArray<void*>::* )( int,int ) 
//not supported method: copy void ( ::btAlignedObjectArray<void*>::* )( int,int,void * * ) const
// error: int - ok, int - ok,  - unsupported, void - ok

//not supported method: expand void * & ( ::btAlignedObjectArray<void*>::* )( void * const & ) 
// error:  - unsupported,  - unsupported

void btAlignedObjectArray_void_ptr__clear(void *c); //method: clear void ( ::btAlignedObjectArray<void*>::* )(  ) 
int btAlignedObjectArray_void_ptr__allocSize(void *c,int p0); //method: allocSize int ( ::btAlignedObjectArray<void*>::* )( int ) 
void btAlignedObjectArray_void_ptr__reserve(void *c,int p0); //method: reserve void ( ::btAlignedObjectArray<void*>::* )( int ) 
void btAlignedObjectArray_void_ptr__m_allocator_set(void *c,void* a); //attribute: ::btAlignedAllocator<void*, 16u> btAlignedObjectArray_void_ptr_->m_allocator
void* btAlignedObjectArray_void_ptr__m_allocator_get(void *c); //attribute: ::btAlignedAllocator<void*, 16u> btAlignedObjectArray_void_ptr_->m_allocator
void btAlignedObjectArray_void_ptr__m_size_set(void *c,int a); //attribute: int btAlignedObjectArray_void_ptr_->m_size
int btAlignedObjectArray_void_ptr__m_size_get(void *c); //attribute: int btAlignedObjectArray_void_ptr_->m_size
void btAlignedObjectArray_void_ptr__m_capacity_set(void *c,int a); //attribute: int btAlignedObjectArray_void_ptr_->m_capacity
int btAlignedObjectArray_void_ptr__m_capacity_get(void *c); //attribute: int btAlignedObjectArray_void_ptr_->m_capacity
// attribute not supported: //attribute: void * * btAlignedObjectArray_void_ptr_->m_data
void btAlignedObjectArray_void_ptr__m_ownsMemory_set(void *c,int a); //attribute: bool btAlignedObjectArray_void_ptr_->m_ownsMemory
int btAlignedObjectArray_void_ptr__m_ownsMemory_get(void *c); //attribute: bool btAlignedObjectArray_void_ptr_->m_ownsMemory
void* btBlock_new(); //constructor: btBlock  ( ::btBlock::* )(  ) 
void btBlock_free(void *c); 
void btBlock_previous_set(void *c,void* a); //attribute: ::btBlock * btBlock->previous
void* btBlock_previous_get(void *c); //attribute: ::btBlock * btBlock->previous
// attribute not supported: //attribute: unsigned char * btBlock->address
void* btChunk_new(); //constructor: btChunk  ( ::btChunk::* )(  ) 
void btChunk_free(void *c); 
void btChunk_m_chunkCode_set(void *c,int a); //attribute: int btChunk->m_chunkCode
int btChunk_m_chunkCode_get(void *c); //attribute: int btChunk->m_chunkCode
void btChunk_m_dna_nr_set(void *c,int a); //attribute: int btChunk->m_dna_nr
int btChunk_m_dna_nr_get(void *c); //attribute: int btChunk->m_dna_nr
void btChunk_m_length_set(void *c,int a); //attribute: int btChunk->m_length
int btChunk_m_length_get(void *c); //attribute: int btChunk->m_length
void btChunk_m_number_set(void *c,int a); //attribute: int btChunk->m_number
int btChunk_m_number_get(void *c); //attribute: int btChunk->m_number
void btChunk_m_oldPtr_set(void *c,void* a); //attribute: void * btChunk->m_oldPtr
void* btChunk_m_oldPtr_get(void *c); //attribute: void * btChunk->m_oldPtr
void* btClock_new(); //constructor: btClock  ( ::btClock::* )(  ) 
void btClock_free(void *c); 
void btClock_reset(void *c); //method: reset void ( ::btClock::* )(  ) 
long unsigned int btClock_getTimeMilliseconds(void *c); //method: getTimeMilliseconds long unsigned int ( ::btClock::* )(  ) 
long unsigned int btClock_getTimeMicroseconds(void *c); //method: getTimeMicroseconds long unsigned int ( ::btClock::* )(  ) 
// attribute not supported: //attribute: ::btClockData * btClock->m_data
void* btConvexSeparatingDistanceUtil_new(float p0,float p1); //constructor: btConvexSeparatingDistanceUtil  ( ::btConvexSeparatingDistanceUtil::* )( ::btScalar,::btScalar ) 
void btConvexSeparatingDistanceUtil_free(void *c); 
void btConvexSeparatingDistanceUtil_updateSeparatingDistance(void *c,float* p0,float* p1); //method: updateSeparatingDistance void ( ::btConvexSeparatingDistanceUtil::* )( ::btTransform const &,::btTransform const & ) 
float btConvexSeparatingDistanceUtil_getConservativeSeparatingDistance(void *c); //method: getConservativeSeparatingDistance ::btScalar ( ::btConvexSeparatingDistanceUtil::* )(  ) 
void btConvexSeparatingDistanceUtil_initSeparatingDistance(void *c,float* p0,float p1,float* p2,float* p3); //method: initSeparatingDistance void ( ::btConvexSeparatingDistanceUtil::* )( ::btVector3 const &,::btScalar,::btTransform const &,::btTransform const & ) 
void btConvexSeparatingDistanceUtil_m_ornA_set(void *c,float* a); //attribute: ::btQuaternion btConvexSeparatingDistanceUtil->m_ornA
void btConvexSeparatingDistanceUtil_m_ornA_get(void *c,float* a);
void btConvexSeparatingDistanceUtil_m_ornB_set(void *c,float* a); //attribute: ::btQuaternion btConvexSeparatingDistanceUtil->m_ornB
void btConvexSeparatingDistanceUtil_m_ornB_get(void *c,float* a);
void btConvexSeparatingDistanceUtil_m_posA_set(void *c,float* a); //attribute: ::btVector3 btConvexSeparatingDistanceUtil->m_posA
void btConvexSeparatingDistanceUtil_m_posA_get(void *c,float* a);
void btConvexSeparatingDistanceUtil_m_posB_set(void *c,float* a); //attribute: ::btVector3 btConvexSeparatingDistanceUtil->m_posB
void btConvexSeparatingDistanceUtil_m_posB_get(void *c,float* a);
void btConvexSeparatingDistanceUtil_m_separatingNormal_set(void *c,float* a); //attribute: ::btVector3 btConvexSeparatingDistanceUtil->m_separatingNormal
void btConvexSeparatingDistanceUtil_m_separatingNormal_get(void *c,float* a);
void btConvexSeparatingDistanceUtil_m_boundingRadiusA_set(void *c,float a); //attribute: ::btScalar btConvexSeparatingDistanceUtil->m_boundingRadiusA
float btConvexSeparatingDistanceUtil_m_boundingRadiusA_get(void *c); //attribute: ::btScalar btConvexSeparatingDistanceUtil->m_boundingRadiusA
void btConvexSeparatingDistanceUtil_m_boundingRadiusB_set(void *c,float a); //attribute: ::btScalar btConvexSeparatingDistanceUtil->m_boundingRadiusB
float btConvexSeparatingDistanceUtil_m_boundingRadiusB_get(void *c); //attribute: ::btScalar btConvexSeparatingDistanceUtil->m_boundingRadiusB
void btConvexSeparatingDistanceUtil_m_separatingDistance_set(void *c,float a); //attribute: ::btScalar btConvexSeparatingDistanceUtil->m_separatingDistance
float btConvexSeparatingDistanceUtil_m_separatingDistance_get(void *c); //attribute: ::btScalar btConvexSeparatingDistanceUtil->m_separatingDistance
void* btDefaultMotionState_new(float* p0,float* p1); //constructor: btDefaultMotionState  ( ::btDefaultMotionState::* )( ::btTransform const &,::btTransform const & ) 
void btDefaultMotionState_free(void *c); 
void btDefaultMotionState_setWorldTransform(void *c,float* p0); //method: setWorldTransform void ( ::btDefaultMotionState::* )( ::btTransform const & ) 
void btDefaultMotionState_getWorldTransform(void *c,float* p0); //method: getWorldTransform void ( ::btDefaultMotionState::* )( ::btTransform & ) const
void btDefaultMotionState_m_graphicsWorldTrans_set(void *c,float* a); //attribute: ::btTransform btDefaultMotionState->m_graphicsWorldTrans
void btDefaultMotionState_m_graphicsWorldTrans_get(void *c,float* a);
void btDefaultMotionState_m_centerOfMassOffset_set(void *c,float* a); //attribute: ::btTransform btDefaultMotionState->m_centerOfMassOffset
void btDefaultMotionState_m_centerOfMassOffset_get(void *c,float* a);
void btDefaultMotionState_m_startWorldTrans_set(void *c,float* a); //attribute: ::btTransform btDefaultMotionState->m_startWorldTrans
void btDefaultMotionState_m_startWorldTrans_get(void *c,float* a);
void btDefaultMotionState_m_userPointer_set(void *c,void* a); //attribute: void * btDefaultMotionState->m_userPointer
void* btDefaultMotionState_m_userPointer_get(void *c); //attribute: void * btDefaultMotionState->m_userPointer
void* btDefaultSerializer_new(int p0); //constructor: btDefaultSerializer  ( ::btDefaultSerializer::* )( int ) 
void btDefaultSerializer_free(void *c); 
void btDefaultSerializer_finishSerialization(void *c); //method: finishSerialization void ( ::btDefaultSerializer::* )(  ) 
//not supported method: internalAlloc unsigned char * ( ::btDefaultSerializer::* )( ::size_t ) 
// error:  - unsupported,  - unsupported

//not supported method: findNameForPointer char const * ( ::btDefaultSerializer::* )( void const * ) const
// error:  - unsupported, char const * - ok

//not supported method: writeHeader void ( ::btDefaultSerializer::* )( unsigned char * ) const
// error:  - unsupported, void - ok

void btDefaultSerializer_startSerialization(void *c); //method: startSerialization void ( ::btDefaultSerializer::* )(  ) 
int btDefaultSerializer_getSerializationFlags(void *c); //method: getSerializationFlags int ( ::btDefaultSerializer::* )(  ) const
void btDefaultSerializer_setSerializationFlags(void *c,int p0); //method: setSerializationFlags void ( ::btDefaultSerializer::* )( int ) 
int btDefaultSerializer_getReverseType(void *c,char const * p0); //method: getReverseType int ( ::btDefaultSerializer::* )( char const * ) const
void btDefaultSerializer_finalizeChunk(void *c,void* p0,char const * p1,int p2,void* p3); //method: finalizeChunk void ( ::btDefaultSerializer::* )( ::btChunk *,char const *,int,void * ) 
void btDefaultSerializer_initDNA(void *c,char const * p0,int p1); //method: initDNA void ( ::btDefaultSerializer::* )( char const *,int ) 
void btDefaultSerializer_writeDNA(void *c); //method: writeDNA void ( ::btDefaultSerializer::* )(  ) 
//not supported method: getBufferPointer unsigned char const * ( ::btDefaultSerializer::* )(  ) const
// error:  - unsupported

int btDefaultSerializer_getCurrentBufferSize(void *c); //method: getCurrentBufferSize int ( ::btDefaultSerializer::* )(  ) const
void* btDefaultSerializer_getUniquePointer(void *c,void* p0); //method: getUniquePointer void * ( ::btDefaultSerializer::* )( void * ) 
void btDefaultSerializer_serializeName(void *c,char const * p0); //method: serializeName void ( ::btDefaultSerializer::* )( char const * ) 
void* btDefaultSerializer_findPointer(void *c,void* p0); //method: findPointer void * ( ::btDefaultSerializer::* )( void * ) 
//not supported method: registerNameForPointer void ( ::btDefaultSerializer::* )( void const *,char const * ) 
// error:  - unsupported, char const * - ok, void - ok

//not supported method: allocate ::btChunk * ( ::btDefaultSerializer::* )( ::size_t,int ) 
// error:  - unsupported, int - ok, ::btChunk * - ok

void btDefaultSerializer_mTypes_set(void *c,void* a); //attribute: ::btAlignedObjectArray<char*> btDefaultSerializer->mTypes
void* btDefaultSerializer_mTypes_get(void *c); //attribute: ::btAlignedObjectArray<char*> btDefaultSerializer->mTypes
void btDefaultSerializer_mStructs_set(void *c,void* a); //attribute: ::btAlignedObjectArray<short*> btDefaultSerializer->mStructs
void* btDefaultSerializer_mStructs_get(void *c); //attribute: ::btAlignedObjectArray<short*> btDefaultSerializer->mStructs
void btDefaultSerializer_mTlens_set(void *c,void* a); //attribute: ::btAlignedObjectArray<short> btDefaultSerializer->mTlens
void* btDefaultSerializer_mTlens_get(void *c); //attribute: ::btAlignedObjectArray<short> btDefaultSerializer->mTlens
void btDefaultSerializer_mStructReverse_set(void *c,void* a); //attribute: ::btHashMap<btHashInt, int> btDefaultSerializer->mStructReverse
void* btDefaultSerializer_mStructReverse_get(void *c); //attribute: ::btHashMap<btHashInt, int> btDefaultSerializer->mStructReverse
void btDefaultSerializer_mTypeLookup_set(void *c,void* a); //attribute: ::btHashMap<btHashString, int> btDefaultSerializer->mTypeLookup
void* btDefaultSerializer_mTypeLookup_get(void *c); //attribute: ::btHashMap<btHashString, int> btDefaultSerializer->mTypeLookup
void btDefaultSerializer_m_chunkP_set(void *c,void* a); //attribute: ::btHashMap<btHashPtr, void*> btDefaultSerializer->m_chunkP
void* btDefaultSerializer_m_chunkP_get(void *c); //attribute: ::btHashMap<btHashPtr, void*> btDefaultSerializer->m_chunkP
void btDefaultSerializer_m_nameMap_set(void *c,void* a); //attribute: ::btHashMap<btHashPtr, char const*> btDefaultSerializer->m_nameMap
void* btDefaultSerializer_m_nameMap_get(void *c); //attribute: ::btHashMap<btHashPtr, char const*> btDefaultSerializer->m_nameMap
void btDefaultSerializer_m_uniquePointers_set(void *c,void* a); //attribute: ::btHashMap<btHashPtr, btPointerUid> btDefaultSerializer->m_uniquePointers
void* btDefaultSerializer_m_uniquePointers_get(void *c); //attribute: ::btHashMap<btHashPtr, btPointerUid> btDefaultSerializer->m_uniquePointers
void btDefaultSerializer_m_uniqueIdGenerator_set(void *c,int a); //attribute: int btDefaultSerializer->m_uniqueIdGenerator
int btDefaultSerializer_m_uniqueIdGenerator_get(void *c); //attribute: int btDefaultSerializer->m_uniqueIdGenerator
void btDefaultSerializer_m_totalSize_set(void *c,int a); //attribute: int btDefaultSerializer->m_totalSize
int btDefaultSerializer_m_totalSize_get(void *c); //attribute: int btDefaultSerializer->m_totalSize
// attribute not supported: //attribute: unsigned char * btDefaultSerializer->m_buffer
void btDefaultSerializer_m_currentSize_set(void *c,int a); //attribute: int btDefaultSerializer->m_currentSize
int btDefaultSerializer_m_currentSize_get(void *c); //attribute: int btDefaultSerializer->m_currentSize
void btDefaultSerializer_m_dna_set(void *c,void* a); //attribute: void * btDefaultSerializer->m_dna
void* btDefaultSerializer_m_dna_get(void *c); //attribute: void * btDefaultSerializer->m_dna
void btDefaultSerializer_m_dnaLength_set(void *c,int a); //attribute: int btDefaultSerializer->m_dnaLength
int btDefaultSerializer_m_dnaLength_get(void *c); //attribute: int btDefaultSerializer->m_dnaLength
void btDefaultSerializer_m_serializationFlags_set(void *c,int a); //attribute: int btDefaultSerializer->m_serializationFlags
int btDefaultSerializer_m_serializationFlags_get(void *c); //attribute: int btDefaultSerializer->m_serializationFlags
void btDefaultSerializer_m_chunkPtrs_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btChunk*> btDefaultSerializer->m_chunkPtrs
void* btDefaultSerializer_m_chunkPtrs_get(void *c); //attribute: ::btAlignedObjectArray<btChunk*> btDefaultSerializer->m_chunkPtrs
void* btGeometryUtil_new(); //constructor: btGeometryUtil  ( ::btGeometryUtil::* )(  ) 
void btGeometryUtil_free(void *c); 
int btGeometryUtil_isPointInsidePlanes(void* p0,float* p1,float p2); //method: isPointInsidePlanes bool (*)( ::btAlignedObjectArray<btVector3> const &,::btVector3 const &,::btScalar )
void btGeometryUtil_getVerticesFromPlaneEquations(void* p0,void* p1); //method: getVerticesFromPlaneEquations void (*)( ::btAlignedObjectArray<btVector3> const &,::btAlignedObjectArray<btVector3> & )
int btGeometryUtil_areVerticesBehindPlane(float* p0,void* p1,float p2); //method: areVerticesBehindPlane bool (*)( ::btVector3 const &,::btAlignedObjectArray<btVector3> const &,::btScalar )
void btGeometryUtil_getPlaneEquationsFromVertices(void* p0,void* p1); //method: getPlaneEquationsFromVertices void (*)( ::btAlignedObjectArray<btVector3> &,::btAlignedObjectArray<btVector3> & )
void* btHashInt_new(int p0); //constructor: btHashInt  ( ::btHashInt::* )( int ) 
void btHashInt_free(void *c); 
int btHashInt_getUid1(void *c); //method: getUid1 int ( ::btHashInt::* )(  ) const
unsigned int btHashInt_getHash(void *c); //method: getHash unsigned int ( ::btHashInt::* )(  ) const
void btHashInt_setUid1(void *c,int p0); //method: setUid1 void ( ::btHashInt::* )( int ) 
int btHashInt_equals(void *c,void* p0); //method: equals bool ( ::btHashInt::* )( ::btHashInt const & ) const
void btHashInt_m_uid_set(void *c,int a); //attribute: int btHashInt->m_uid
int btHashInt_m_uid_get(void *c); //attribute: int btHashInt->m_uid
void* btHashMap_btHashInt_btTriangleInfo__new(); //constructor: btHashMap  ( ::btHashMap<btHashInt, btTriangleInfo>::* )(  ) 
void btHashMap_btHashInt_btTriangleInfo__free(void *c); 
void btHashMap_btHashInt_btTriangleInfo__insert(void *c,void* p0,void* p1); //method: insert void ( ::btHashMap<btHashInt, btTriangleInfo>::* )( ::btHashInt const &,::btTriangleInfo const & ) 
int btHashMap_btHashInt_btTriangleInfo__findIndex(void *c,void* p0); //method: findIndex int ( ::btHashMap<btHashInt, btTriangleInfo>::* )( ::btHashInt const & ) const
void btHashMap_btHashInt_btTriangleInfo__clear(void *c); //method: clear void ( ::btHashMap<btHashInt, btTriangleInfo>::* )(  ) 
void* btHashMap_btHashInt_btTriangleInfo__getAtIndex(void *c,int p0); //method: getAtIndex ::btTriangleInfo const * ( ::btHashMap<btHashInt, btTriangleInfo>::* )( int ) const
void* btHashMap_btHashInt_btTriangleInfo__getAtIndex0(void *c,int p0); //method: getAtIndex ::btTriangleInfo const * ( ::btHashMap<btHashInt, btTriangleInfo>::* )( int ) const
void* btHashMap_btHashInt_btTriangleInfo__getAtIndex1(void *c,int p0); //method: getAtIndex ::btTriangleInfo * ( ::btHashMap<btHashInt, btTriangleInfo>::* )( int ) 
void btHashMap_btHashInt_btTriangleInfo__growTables(void *c,void* p0); //method: growTables void ( ::btHashMap<btHashInt, btTriangleInfo>::* )( ::btHashInt const & ) 
void* btHashMap_btHashInt_btTriangleInfo__find(void *c,void* p0); //method: find ::btTriangleInfo const * ( ::btHashMap<btHashInt, btTriangleInfo>::* )( ::btHashInt const & ) const
void* btHashMap_btHashInt_btTriangleInfo__find0(void *c,void* p0); //method: find ::btTriangleInfo const * ( ::btHashMap<btHashInt, btTriangleInfo>::* )( ::btHashInt const & ) const
void* btHashMap_btHashInt_btTriangleInfo__find1(void *c,void* p0); //method: find ::btTriangleInfo * ( ::btHashMap<btHashInt, btTriangleInfo>::* )( ::btHashInt const & ) 
int btHashMap_btHashInt_btTriangleInfo__size(void *c); //method: size int ( ::btHashMap<btHashInt, btTriangleInfo>::* )(  ) const
void btHashMap_btHashInt_btTriangleInfo__m_hashTable_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashInt_btTriangleInfo_->m_hashTable
void* btHashMap_btHashInt_btTriangleInfo__m_hashTable_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashInt_btTriangleInfo_->m_hashTable
void btHashMap_btHashInt_btTriangleInfo__m_next_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashInt_btTriangleInfo_->m_next
void* btHashMap_btHashInt_btTriangleInfo__m_next_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashInt_btTriangleInfo_->m_next
void btHashMap_btHashInt_btTriangleInfo__m_valueArray_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btTriangleInfo> btHashMap_btHashInt_btTriangleInfo_->m_valueArray
void* btHashMap_btHashInt_btTriangleInfo__m_valueArray_get(void *c); //attribute: ::btAlignedObjectArray<btTriangleInfo> btHashMap_btHashInt_btTriangleInfo_->m_valueArray
void btHashMap_btHashInt_btTriangleInfo__m_keyArray_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btHashInt> btHashMap_btHashInt_btTriangleInfo_->m_keyArray
void* btHashMap_btHashInt_btTriangleInfo__m_keyArray_get(void *c); //attribute: ::btAlignedObjectArray<btHashInt> btHashMap_btHashInt_btTriangleInfo_->m_keyArray
void* btHashMap_btHashInt_int__new(); //constructor: btHashMap  ( ::btHashMap<btHashInt, int>::* )(  ) 
void btHashMap_btHashInt_int__free(void *c); 
//not supported method: insert void ( ::btHashMap<btHashInt, int>::* )( ::btHashInt const &,int const & ) 
// error: ::btHashInt const & - ok,  - unsupported, void - ok

int btHashMap_btHashInt_int__findIndex(void *c,void* p0); //method: findIndex int ( ::btHashMap<btHashInt, int>::* )( ::btHashInt const & ) const
void btHashMap_btHashInt_int__clear(void *c); //method: clear void ( ::btHashMap<btHashInt, int>::* )(  ) 
//not supported method: getAtIndex int const * ( ::btHashMap<btHashInt, int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex int const * ( ::btHashMap<btHashInt, int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex int * ( ::btHashMap<btHashInt, int>::* )( int ) 
// error: int - ok,  - unsupported

void btHashMap_btHashInt_int__growTables(void *c,void* p0); //method: growTables void ( ::btHashMap<btHashInt, int>::* )( ::btHashInt const & ) 
//not supported method: find int const * ( ::btHashMap<btHashInt, int>::* )( ::btHashInt const & ) const
// error: ::btHashInt const & - ok,  - unsupported

//not supported method: find int const * ( ::btHashMap<btHashInt, int>::* )( ::btHashInt const & ) const
// error: ::btHashInt const & - ok,  - unsupported

//not supported method: find int * ( ::btHashMap<btHashInt, int>::* )( ::btHashInt const & ) 
// error: ::btHashInt const & - ok,  - unsupported

int btHashMap_btHashInt_int__size(void *c); //method: size int ( ::btHashMap<btHashInt, int>::* )(  ) const
void btHashMap_btHashInt_int__m_hashTable_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashInt_int_->m_hashTable
void* btHashMap_btHashInt_int__m_hashTable_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashInt_int_->m_hashTable
void btHashMap_btHashInt_int__m_keyArray_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btHashInt> btHashMap_btHashInt_int_->m_keyArray
void* btHashMap_btHashInt_int__m_keyArray_get(void *c); //attribute: ::btAlignedObjectArray<btHashInt> btHashMap_btHashInt_int_->m_keyArray
void btHashMap_btHashInt_int__m_next_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashInt_int_->m_next
void* btHashMap_btHashInt_int__m_next_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashInt_int_->m_next
void btHashMap_btHashInt_int__m_valueArray_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashInt_int_->m_valueArray
void* btHashMap_btHashInt_int__m_valueArray_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashInt_int_->m_valueArray
void* btHashMap_btHashPtr_btPointerUid__new(); //constructor: btHashMap  ( ::btHashMap<btHashPtr, btPointerUid>::* )(  ) 
void btHashMap_btHashPtr_btPointerUid__free(void *c); 
void btHashMap_btHashPtr_btPointerUid__insert(void *c,void* p0,void* p1); //method: insert void ( ::btHashMap<btHashPtr, btPointerUid>::* )( ::btHashPtr const &,::btPointerUid const & ) 
int btHashMap_btHashPtr_btPointerUid__findIndex(void *c,void* p0); //method: findIndex int ( ::btHashMap<btHashPtr, btPointerUid>::* )( ::btHashPtr const & ) const
void btHashMap_btHashPtr_btPointerUid__clear(void *c); //method: clear void ( ::btHashMap<btHashPtr, btPointerUid>::* )(  ) 
void* btHashMap_btHashPtr_btPointerUid__getAtIndex(void *c,int p0); //method: getAtIndex ::btPointerUid const * ( ::btHashMap<btHashPtr, btPointerUid>::* )( int ) const
void* btHashMap_btHashPtr_btPointerUid__getAtIndex0(void *c,int p0); //method: getAtIndex ::btPointerUid const * ( ::btHashMap<btHashPtr, btPointerUid>::* )( int ) const
void* btHashMap_btHashPtr_btPointerUid__getAtIndex1(void *c,int p0); //method: getAtIndex ::btPointerUid * ( ::btHashMap<btHashPtr, btPointerUid>::* )( int ) 
void btHashMap_btHashPtr_btPointerUid__growTables(void *c,void* p0); //method: growTables void ( ::btHashMap<btHashPtr, btPointerUid>::* )( ::btHashPtr const & ) 
void* btHashMap_btHashPtr_btPointerUid__find(void *c,void* p0); //method: find ::btPointerUid const * ( ::btHashMap<btHashPtr, btPointerUid>::* )( ::btHashPtr const & ) const
void* btHashMap_btHashPtr_btPointerUid__find0(void *c,void* p0); //method: find ::btPointerUid const * ( ::btHashMap<btHashPtr, btPointerUid>::* )( ::btHashPtr const & ) const
void* btHashMap_btHashPtr_btPointerUid__find1(void *c,void* p0); //method: find ::btPointerUid * ( ::btHashMap<btHashPtr, btPointerUid>::* )( ::btHashPtr const & ) 
int btHashMap_btHashPtr_btPointerUid__size(void *c); //method: size int ( ::btHashMap<btHashPtr, btPointerUid>::* )(  ) const
void btHashMap_btHashPtr_btPointerUid__m_hashTable_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_btPointerUid_->m_hashTable
void* btHashMap_btHashPtr_btPointerUid__m_hashTable_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_btPointerUid_->m_hashTable
void btHashMap_btHashPtr_btPointerUid__m_keyArray_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btHashPtr> btHashMap_btHashPtr_btPointerUid_->m_keyArray
void* btHashMap_btHashPtr_btPointerUid__m_keyArray_get(void *c); //attribute: ::btAlignedObjectArray<btHashPtr> btHashMap_btHashPtr_btPointerUid_->m_keyArray
void btHashMap_btHashPtr_btPointerUid__m_next_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_btPointerUid_->m_next
void* btHashMap_btHashPtr_btPointerUid__m_next_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_btPointerUid_->m_next
void btHashMap_btHashPtr_btPointerUid__m_valueArray_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btPointerUid> btHashMap_btHashPtr_btPointerUid_->m_valueArray
void* btHashMap_btHashPtr_btPointerUid__m_valueArray_get(void *c); //attribute: ::btAlignedObjectArray<btPointerUid> btHashMap_btHashPtr_btPointerUid_->m_valueArray
void* btHashMap_btHashPtr_charconst_ptr__new(); //constructor: btHashMap  ( ::btHashMap<btHashPtr, char const*>::* )(  ) 
void btHashMap_btHashPtr_charconst_ptr__free(void *c); 
//not supported method: insert void ( ::btHashMap<btHashPtr, char const*>::* )( ::btHashPtr const &,char const * const & ) 
// error: ::btHashPtr const & - ok,  - unsupported, void - ok

int btHashMap_btHashPtr_charconst_ptr__findIndex(void *c,void* p0); //method: findIndex int ( ::btHashMap<btHashPtr, char const*>::* )( ::btHashPtr const & ) const
void btHashMap_btHashPtr_charconst_ptr__clear(void *c); //method: clear void ( ::btHashMap<btHashPtr, char const*>::* )(  ) 
//not supported method: getAtIndex char const * const * ( ::btHashMap<btHashPtr, char const*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex char const * const * ( ::btHashMap<btHashPtr, char const*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex char const * * ( ::btHashMap<btHashPtr, char const*>::* )( int ) 
// error: int - ok,  - unsupported

void btHashMap_btHashPtr_charconst_ptr__growTables(void *c,void* p0); //method: growTables void ( ::btHashMap<btHashPtr, char const*>::* )( ::btHashPtr const & ) 
//not supported method: find char const * const * ( ::btHashMap<btHashPtr, char const*>::* )( ::btHashPtr const & ) const
// error: ::btHashPtr const & - ok,  - unsupported

//not supported method: find char const * const * ( ::btHashMap<btHashPtr, char const*>::* )( ::btHashPtr const & ) const
// error: ::btHashPtr const & - ok,  - unsupported

//not supported method: find char const * * ( ::btHashMap<btHashPtr, char const*>::* )( ::btHashPtr const & ) 
// error: ::btHashPtr const & - ok,  - unsupported

int btHashMap_btHashPtr_charconst_ptr__size(void *c); //method: size int ( ::btHashMap<btHashPtr, char const*>::* )(  ) const
void btHashMap_btHashPtr_charconst_ptr__m_hashTable_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_charconst_ptr_->m_hashTable
void* btHashMap_btHashPtr_charconst_ptr__m_hashTable_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_charconst_ptr_->m_hashTable
void btHashMap_btHashPtr_charconst_ptr__m_keyArray_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btHashPtr> btHashMap_btHashPtr_charconst_ptr_->m_keyArray
void* btHashMap_btHashPtr_charconst_ptr__m_keyArray_get(void *c); //attribute: ::btAlignedObjectArray<btHashPtr> btHashMap_btHashPtr_charconst_ptr_->m_keyArray
void btHashMap_btHashPtr_charconst_ptr__m_next_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_charconst_ptr_->m_next
void* btHashMap_btHashPtr_charconst_ptr__m_next_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_charconst_ptr_->m_next
void btHashMap_btHashPtr_charconst_ptr__m_valueArray_set(void *c,void* a); //attribute: ::btAlignedObjectArray<char const*> btHashMap_btHashPtr_charconst_ptr_->m_valueArray
void* btHashMap_btHashPtr_charconst_ptr__m_valueArray_get(void *c); //attribute: ::btAlignedObjectArray<char const*> btHashMap_btHashPtr_charconst_ptr_->m_valueArray
void* btHashMap_btHashPtr_void_ptr__new(); //constructor: btHashMap  ( ::btHashMap<btHashPtr, void*>::* )(  ) 
void btHashMap_btHashPtr_void_ptr__free(void *c); 
//not supported method: insert void ( ::btHashMap<btHashPtr, void*>::* )( ::btHashPtr const &,void * const & ) 
// error: ::btHashPtr const & - ok,  - unsupported, void - ok

int btHashMap_btHashPtr_void_ptr__findIndex(void *c,void* p0); //method: findIndex int ( ::btHashMap<btHashPtr, void*>::* )( ::btHashPtr const & ) const
void btHashMap_btHashPtr_void_ptr__clear(void *c); //method: clear void ( ::btHashMap<btHashPtr, void*>::* )(  ) 
//not supported method: getAtIndex void * const * ( ::btHashMap<btHashPtr, void*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex void * const * ( ::btHashMap<btHashPtr, void*>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex void * * ( ::btHashMap<btHashPtr, void*>::* )( int ) 
// error: int - ok,  - unsupported

void btHashMap_btHashPtr_void_ptr__growTables(void *c,void* p0); //method: growTables void ( ::btHashMap<btHashPtr, void*>::* )( ::btHashPtr const & ) 
//not supported method: find void * const * ( ::btHashMap<btHashPtr, void*>::* )( ::btHashPtr const & ) const
// error: ::btHashPtr const & - ok,  - unsupported

//not supported method: find void * const * ( ::btHashMap<btHashPtr, void*>::* )( ::btHashPtr const & ) const
// error: ::btHashPtr const & - ok,  - unsupported

//not supported method: find void * * ( ::btHashMap<btHashPtr, void*>::* )( ::btHashPtr const & ) 
// error: ::btHashPtr const & - ok,  - unsupported

int btHashMap_btHashPtr_void_ptr__size(void *c); //method: size int ( ::btHashMap<btHashPtr, void*>::* )(  ) const
void btHashMap_btHashPtr_void_ptr__m_hashTable_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_void_ptr_->m_hashTable
void* btHashMap_btHashPtr_void_ptr__m_hashTable_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_void_ptr_->m_hashTable
void btHashMap_btHashPtr_void_ptr__m_keyArray_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btHashPtr> btHashMap_btHashPtr_void_ptr_->m_keyArray
void* btHashMap_btHashPtr_void_ptr__m_keyArray_get(void *c); //attribute: ::btAlignedObjectArray<btHashPtr> btHashMap_btHashPtr_void_ptr_->m_keyArray
void btHashMap_btHashPtr_void_ptr__m_next_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_void_ptr_->m_next
void* btHashMap_btHashPtr_void_ptr__m_next_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashPtr_void_ptr_->m_next
void btHashMap_btHashPtr_void_ptr__m_valueArray_set(void *c,void* a); //attribute: ::btAlignedObjectArray<void*> btHashMap_btHashPtr_void_ptr_->m_valueArray
void* btHashMap_btHashPtr_void_ptr__m_valueArray_get(void *c); //attribute: ::btAlignedObjectArray<void*> btHashMap_btHashPtr_void_ptr_->m_valueArray
void* btHashMap_btHashString_int__new(); //constructor: btHashMap  ( ::btHashMap<btHashString, int>::* )(  ) 
void btHashMap_btHashString_int__free(void *c); 
//not supported method: insert void ( ::btHashMap<btHashString, int>::* )( ::btHashString const &,int const & ) 
// error: ::btHashString const & - ok,  - unsupported, void - ok

int btHashMap_btHashString_int__findIndex(void *c,void* p0); //method: findIndex int ( ::btHashMap<btHashString, int>::* )( ::btHashString const & ) const
void btHashMap_btHashString_int__clear(void *c); //method: clear void ( ::btHashMap<btHashString, int>::* )(  ) 
//not supported method: getAtIndex int const * ( ::btHashMap<btHashString, int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex int const * ( ::btHashMap<btHashString, int>::* )( int ) const
// error: int - ok,  - unsupported

//not supported method: getAtIndex int * ( ::btHashMap<btHashString, int>::* )( int ) 
// error: int - ok,  - unsupported

void btHashMap_btHashString_int__growTables(void *c,void* p0); //method: growTables void ( ::btHashMap<btHashString, int>::* )( ::btHashString const & ) 
//not supported method: find int const * ( ::btHashMap<btHashString, int>::* )( ::btHashString const & ) const
// error: ::btHashString const & - ok,  - unsupported

//not supported method: find int const * ( ::btHashMap<btHashString, int>::* )( ::btHashString const & ) const
// error: ::btHashString const & - ok,  - unsupported

//not supported method: find int * ( ::btHashMap<btHashString, int>::* )( ::btHashString const & ) 
// error: ::btHashString const & - ok,  - unsupported

int btHashMap_btHashString_int__size(void *c); //method: size int ( ::btHashMap<btHashString, int>::* )(  ) const
void btHashMap_btHashString_int__m_hashTable_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashString_int_->m_hashTable
void* btHashMap_btHashString_int__m_hashTable_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashString_int_->m_hashTable
void btHashMap_btHashString_int__m_keyArray_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btHashString> btHashMap_btHashString_int_->m_keyArray
void* btHashMap_btHashString_int__m_keyArray_get(void *c); //attribute: ::btAlignedObjectArray<btHashString> btHashMap_btHashString_int_->m_keyArray
void btHashMap_btHashString_int__m_next_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashString_int_->m_next
void* btHashMap_btHashString_int__m_next_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashString_int_->m_next
void btHashMap_btHashString_int__m_valueArray_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashString_int_->m_valueArray
void* btHashMap_btHashString_int__m_valueArray_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashMap_btHashString_int_->m_valueArray
//not supported constructor: btHashPtr  ( ::btHashPtr::* )( void const * ) 
// error:  - unsupported

void btHashPtr_free(void *c); 
unsigned int btHashPtr_getHash(void *c); //method: getHash unsigned int ( ::btHashPtr::* )(  ) const
int btHashPtr_equals(void *c,void* p0); //method: equals bool ( ::btHashPtr::* )( ::btHashPtr const & ) const
//not supported method: getPointer void const * ( ::btHashPtr::* )(  ) const
// error:  - unsupported

// attribute not supported: //attribute: ::btHashPtr btHashPtr->
void* btHashString_new(char const * p0); //constructor: btHashString  ( ::btHashString::* )( char const * ) 
void btHashString_free(void *c); 
unsigned int btHashString_getHash(void *c); //method: getHash unsigned int ( ::btHashString::* )(  ) const
int btHashString_equals(void *c,void* p0); //method: equals bool ( ::btHashString::* )( ::btHashString const & ) const
int btHashString_portableStringCompare(void *c,char const * p0,char const * p1); //method: portableStringCompare int ( ::btHashString::* )( char const *,char const * ) const
void btHashString_m_hash_set(void *c,unsigned int a); //attribute: unsigned int btHashString->m_hash
unsigned int btHashString_m_hash_get(void *c); //attribute: unsigned int btHashString->m_hash
void btHashString_m_string_set(void *c,char const * a); //attribute: char const * btHashString->m_string
char const * btHashString_m_string_get(void *c); //attribute: char const * btHashString->m_string
void btIDebugDraw_draw3dText(void *c,float* p0,char const * p1); //method: draw3dText void ( ::btIDebugDraw::* )( ::btVector3 const &,char const * ) 
void btIDebugDraw_drawBox(void *c,float* p0,float* p1,float* p2); //method: drawBox void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btIDebugDraw_drawBox0(void *c,float* p0,float* p1,float* p2); //method: drawBox void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btIDebugDraw_drawBox1(void *c,float* p0,float* p1,float* p2,float* p3); //method: drawBox void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btTransform const &,::btVector3 const & ) 
void btIDebugDraw_drawCone(void *c,float p0,float p1,int p2,float* p3,float* p4); //method: drawCone void ( ::btIDebugDraw::* )( ::btScalar,::btScalar,int,::btTransform const &,::btVector3 const & ) 
void btIDebugDraw_drawCapsule(void *c,float p0,float p1,int p2,float* p3,float* p4); //method: drawCapsule void ( ::btIDebugDraw::* )( ::btScalar,::btScalar,int,::btTransform const &,::btVector3 const & ) 
void btIDebugDraw_drawArc(void *c,float* p0,float* p1,float* p2,float p3,float p4,float p5,float p6,float* p7,int p8,float p9); //method: drawArc void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar,::btScalar,::btScalar,::btScalar,::btVector3 const &,bool,::btScalar ) 
void btIDebugDraw_drawCylinder(void *c,float p0,float p1,int p2,float* p3,float* p4); //method: drawCylinder void ( ::btIDebugDraw::* )( ::btScalar,::btScalar,int,::btTransform const &,::btVector3 const & ) 
void btIDebugDraw_reportErrorWarning(void *c,char const * p0); //method: reportErrorWarning void ( ::btIDebugDraw::* )( char const * ) 
void btIDebugDraw_drawTriangle(void *c,float* p0,float* p1,float* p2,float* p3,float* p4,float* p5,float* p6,float p7); //method: drawTriangle void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
void btIDebugDraw_drawTriangle0(void *c,float* p0,float* p1,float* p2,float* p3,float* p4,float* p5,float* p6,float p7); //method: drawTriangle void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
void btIDebugDraw_drawTriangle1(void *c,float* p0,float* p1,float* p2,float* p3,float p4); //method: drawTriangle void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
int btIDebugDraw_getDebugMode(void *c); //method: getDebugMode int ( ::btIDebugDraw::* )(  ) const
void btIDebugDraw_drawLine(void *c,float* p0,float* p1,float* p2); //method: drawLine void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btIDebugDraw_drawLine0(void *c,float* p0,float* p1,float* p2); //method: drawLine void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btIDebugDraw_drawLine1(void *c,float* p0,float* p1,float* p2,float* p3); //method: drawLine void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btIDebugDraw_drawTransform(void *c,float* p0,float p1); //method: drawTransform void ( ::btIDebugDraw::* )( ::btTransform const &,::btScalar ) 
void btIDebugDraw_drawAabb(void *c,float* p0,float* p1,float* p2); //method: drawAabb void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btIDebugDraw_drawPlane(void *c,float* p0,float p1,float* p2,float* p3); //method: drawPlane void ( ::btIDebugDraw::* )( ::btVector3 const &,::btScalar,::btTransform const &,::btVector3 const & ) 
void btIDebugDraw_drawContactPoint(void *c,float* p0,float* p1,float p2,int p3,float* p4); //method: drawContactPoint void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btScalar,int,::btVector3 const & ) 
void btIDebugDraw_setDebugMode(void *c,int p0); //method: setDebugMode void ( ::btIDebugDraw::* )( int ) 
void btIDebugDraw_drawSpherePatch(void *c,float* p0,float* p1,float* p2,float p3,float p4,float p5,float p6,float p7,float* p8,float p9); //method: drawSpherePatch void ( ::btIDebugDraw::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar,::btScalar,::btScalar,::btScalar,::btScalar,::btVector3 const &,::btScalar ) 
void btIDebugDraw_drawSphere(void *c,float p0,float* p1,float* p2); //method: drawSphere void ( ::btIDebugDraw::* )( ::btScalar,::btTransform const &,::btVector3 const & ) 
void btIDebugDraw_drawSphere0(void *c,float p0,float* p1,float* p2); //method: drawSphere void ( ::btIDebugDraw::* )( ::btScalar,::btTransform const &,::btVector3 const & ) 
void btIDebugDraw_drawSphere1(void *c,float* p0,float p1,float* p2); //method: drawSphere void ( ::btIDebugDraw::* )( ::btVector3 const &,::btScalar,::btVector3 const & ) 
void* btMatrix3x3DoubleData_new(); //constructor: btMatrix3x3DoubleData  ( ::btMatrix3x3DoubleData::* )(  ) 
void btMatrix3x3DoubleData_free(void *c); 
// attribute not supported: //attribute: ::btVector3DoubleData[3] btMatrix3x3DoubleData->m_el
void* btMatrix3x3FloatData_new(); //constructor: btMatrix3x3FloatData  ( ::btMatrix3x3FloatData::* )(  ) 
void btMatrix3x3FloatData_free(void *c); 
// attribute not supported: //attribute: ::btVector3FloatData[3] btMatrix3x3FloatData->m_el
void btMotionState_setWorldTransform(void *c,float* p0); //method: setWorldTransform void ( ::btMotionState::* )( ::btTransform const & ) 
void btMotionState_getWorldTransform(void *c,float* p0); //method: getWorldTransform void ( ::btMotionState::* )( ::btTransform & ) const
void* btPointerUid_new(); //constructor: btPointerUid  ( ::btPointerUid::* )(  ) 
void btPointerUid_free(void *c); 
// attribute not supported: //attribute: ::btPointerUid btPointerUid->
void* btQuadWord_new0(); //constructor: btQuadWord  ( ::btQuadWord::* )(  ) 
void* btQuadWord_new1(float p0,float p1,float p2); //constructor: btQuadWord  ( ::btQuadWord::* )( ::btScalar const &,::btScalar const &,::btScalar const & ) 
void* btQuadWord_new2(float p0,float p1,float p2,float p3); //constructor: btQuadWord  ( ::btQuadWord::* )( ::btScalar const &,::btScalar const &,::btScalar const &,::btScalar const & ) 
void btQuadWord_free(void *c); 
void btQuadWord_setMin(void *c,void* p0); //method: setMin void ( ::btQuadWord::* )( ::btQuadWord const & ) 
void btQuadWord_setValue(void *c,float p0,float p1,float p2); //method: setValue void ( ::btQuadWord::* )( ::btScalar const &,::btScalar const &,::btScalar const & ) 
void btQuadWord_setValue0(void *c,float p0,float p1,float p2); //method: setValue void ( ::btQuadWord::* )( ::btScalar const &,::btScalar const &,::btScalar const & ) 
void btQuadWord_setValue1(void *c,float p0,float p1,float p2,float p3); //method: setValue void ( ::btQuadWord::* )( ::btScalar const &,::btScalar const &,::btScalar const &,::btScalar const & ) 
void btQuadWord_setMax(void *c,void* p0); //method: setMax void ( ::btQuadWord::* )( ::btQuadWord const & ) 
float btQuadWord_getX(void *c); //method: getX ::btScalar const & ( ::btQuadWord::* )(  ) const
float btQuadWord_getY(void *c); //method: getY ::btScalar const & ( ::btQuadWord::* )(  ) const
float btQuadWord_getZ(void *c); //method: getZ ::btScalar const & ( ::btQuadWord::* )(  ) const
void btQuadWord_setW(void *c,float p0); //method: setW void ( ::btQuadWord::* )( ::btScalar ) 
float btQuadWord_w(void *c); //method: w ::btScalar const & ( ::btQuadWord::* )(  ) const
float btQuadWord_y(void *c); //method: y ::btScalar const & ( ::btQuadWord::* )(  ) const
float btQuadWord_x(void *c); //method: x ::btScalar const & ( ::btQuadWord::* )(  ) const
float btQuadWord_z(void *c); //method: z ::btScalar const & ( ::btQuadWord::* )(  ) const
void btQuadWord_setX(void *c,float p0); //method: setX void ( ::btQuadWord::* )( ::btScalar ) 
void btQuadWord_setY(void *c,float p0); //method: setY void ( ::btQuadWord::* )( ::btScalar ) 
void btQuadWord_setZ(void *c,float p0); //method: setZ void ( ::btQuadWord::* )( ::btScalar ) 
// attribute not supported: //attribute: ::btScalar[4] btQuadWord->m_floats
void btSerializer_setSerializationFlags(void *c,int p0); //method: setSerializationFlags void ( ::btSerializer::* )( int ) 
int btSerializer_getCurrentBufferSize(void *c); //method: getCurrentBufferSize int ( ::btSerializer::* )(  ) const
void btSerializer_startSerialization(void *c); //method: startSerialization void ( ::btSerializer::* )(  ) 
int btSerializer_getSerializationFlags(void *c); //method: getSerializationFlags int ( ::btSerializer::* )(  ) const
void btSerializer_finishSerialization(void *c); //method: finishSerialization void ( ::btSerializer::* )(  ) 
void* btSerializer_getUniquePointer(void *c,void* p0); //method: getUniquePointer void * ( ::btSerializer::* )( void * ) 
//not supported method: allocate ::btChunk * ( ::btSerializer::* )( ::size_t,int ) 
// error:  - unsupported, int - ok, ::btChunk * - ok

//not supported method: findNameForPointer char const * ( ::btSerializer::* )( void const * ) const
// error:  - unsupported, char const * - ok

void btSerializer_finalizeChunk(void *c,void* p0,char const * p1,int p2,void* p3); //method: finalizeChunk void ( ::btSerializer::* )( ::btChunk *,char const *,int,void * ) 
void btSerializer_serializeName(void *c,char const * p0); //method: serializeName void ( ::btSerializer::* )( char const * ) 
void* btSerializer_findPointer(void *c,void* p0); //method: findPointer void * ( ::btSerializer::* )( void * ) 
//not supported method: registerNameForPointer void ( ::btSerializer::* )( void const *,char const * ) 
// error:  - unsupported, char const * - ok, void - ok

//not supported method: getBufferPointer unsigned char const * ( ::btSerializer::* )(  ) const
// error:  - unsupported

void* btStackAlloc_new(unsigned int p0); //constructor: btStackAlloc  ( ::btStackAlloc::* )( unsigned int ) 
void btStackAlloc_free(void *c); 
void btStackAlloc_create(void *c,unsigned int p0); //method: create void ( ::btStackAlloc::* )( unsigned int ) 
void btStackAlloc_ctor(void *c); //method: ctor void ( ::btStackAlloc::* )(  ) 
//not supported method: allocate unsigned char * ( ::btStackAlloc::* )( unsigned int ) 
// error: unsigned int - ok,  - unsupported

void btStackAlloc_destroy(void *c); //method: destroy void ( ::btStackAlloc::* )(  ) 
void* btStackAlloc_beginBlock(void *c); //method: beginBlock ::btBlock * ( ::btStackAlloc::* )(  ) 
int btStackAlloc_getAvailableMemory(void *c); //method: getAvailableMemory int ( ::btStackAlloc::* )(  ) const
void btStackAlloc_endBlock(void *c,void* p0); //method: endBlock void ( ::btStackAlloc::* )( ::btBlock * ) 
// attribute not supported: //attribute: unsigned char * btStackAlloc->data
void btStackAlloc_totalsize_set(void *c,unsigned int a); //attribute: unsigned int btStackAlloc->totalsize
unsigned int btStackAlloc_totalsize_get(void *c); //attribute: unsigned int btStackAlloc->totalsize
void btStackAlloc_usedsize_set(void *c,unsigned int a); //attribute: unsigned int btStackAlloc->usedsize
unsigned int btStackAlloc_usedsize_get(void *c); //attribute: unsigned int btStackAlloc->usedsize
void btStackAlloc_current_set(void *c,void* a); //attribute: ::btBlock * btStackAlloc->current
void* btStackAlloc_current_get(void *c); //attribute: ::btBlock * btStackAlloc->current
void btStackAlloc_ischild_set(void *c,int a); //attribute: bool btStackAlloc->ischild
int btStackAlloc_ischild_get(void *c); //attribute: bool btStackAlloc->ischild
void* btTransformDoubleData_new(); //constructor: btTransformDoubleData  ( ::btTransformDoubleData::* )(  ) 
void btTransformDoubleData_free(void *c); 
void btTransformDoubleData_m_basis_set(void *c,void* a); //attribute: ::btMatrix3x3DoubleData btTransformDoubleData->m_basis
void* btTransformDoubleData_m_basis_get(void *c); //attribute: ::btMatrix3x3DoubleData btTransformDoubleData->m_basis
void btTransformDoubleData_m_origin_set(void *c,void* a); //attribute: ::btVector3DoubleData btTransformDoubleData->m_origin
void* btTransformDoubleData_m_origin_get(void *c); //attribute: ::btVector3DoubleData btTransformDoubleData->m_origin
void* btTransformFloatData_new(); //constructor: btTransformFloatData  ( ::btTransformFloatData::* )(  ) 
void btTransformFloatData_free(void *c); 
void btTransformFloatData_m_basis_set(void *c,void* a); //attribute: ::btMatrix3x3FloatData btTransformFloatData->m_basis
void* btTransformFloatData_m_basis_get(void *c); //attribute: ::btMatrix3x3FloatData btTransformFloatData->m_basis
void btTransformFloatData_m_origin_set(void *c,void* a); //attribute: ::btVector3FloatData btTransformFloatData->m_origin
void* btTransformFloatData_m_origin_get(void *c); //attribute: ::btVector3FloatData btTransformFloatData->m_origin
void* btTransformUtil_new(); //constructor: btTransformUtil  ( ::btTransformUtil::* )(  ) 
void btTransformUtil_free(void *c); 
//not supported method: calculateDiffAxisAngle void (*)( ::btTransform const &,::btTransform const &,::btVector3 &,::btScalar & )
// error: ::btTransform const & - ok, ::btTransform const & - ok, ::btVector3 & - ok,  - unsupported, void - ok

void btTransformUtil_calculateVelocity(float* p0,float* p1,float p2,float* p3,float* p4); //method: calculateVelocity void (*)( ::btTransform const &,::btTransform const &,::btScalar,::btVector3 &,::btVector3 & )
void btTransformUtil_integrateTransform(float* p0,float* p1,float* p2,float p3,float* p4); //method: integrateTransform void (*)( ::btTransform const &,::btVector3 const &,::btVector3 const &,::btScalar,::btTransform & )
void btTransformUtil_calculateVelocityQuaternion(float* p0,float* p1,float* p2,float* p3,float p4,float* p5,float* p6); //method: calculateVelocityQuaternion void (*)( ::btVector3 const &,::btVector3 const &,::btQuaternion const &,::btQuaternion const &,::btScalar,::btVector3 &,::btVector3 & )
//not supported method: calculateDiffAxisAngleQuaternion void (*)( ::btQuaternion const &,::btQuaternion const &,::btVector3 &,::btScalar & )
// error: ::btQuaternion const & - ok, ::btQuaternion const & - ok, ::btVector3 & - ok,  - unsupported, void - ok

void* btTypedObject_new(int p0); //constructor: btTypedObject  ( ::btTypedObject::* )( int ) 
void btTypedObject_free(void *c); 
int btTypedObject_getObjectType(void *c); //method: getObjectType int ( ::btTypedObject::* )(  ) const
void btTypedObject_m_objectType_set(void *c,int a); //attribute: int btTypedObject->m_objectType
int btTypedObject_m_objectType_get(void *c); //attribute: int btTypedObject->m_objectType
void* btVector3DoubleData_new(); //constructor: btVector3DoubleData  ( ::btVector3DoubleData::* )(  ) 
void btVector3DoubleData_free(void *c); 
// attribute not supported: //attribute: double[4] btVector3DoubleData->m_floats
void* btVector3FloatData_new(); //constructor: btVector3FloatData  ( ::btVector3FloatData::* )(  ) 
void btVector3FloatData_free(void *c); 
// attribute not supported: //attribute: float[4] btVector3FloatData->m_floats
void* btAngularLimit_new(); //constructor: btAngularLimit  ( ::btAngularLimit::* )(  ) 
void btAngularLimit_free(void *c); 
float btAngularLimit_getCorrection(void *c); //method: getCorrection ::btScalar ( ::btAngularLimit::* )(  ) const
void btAngularLimit_set(void *c,float p0,float p1,float p2,float p3,float p4); //method: set void ( ::btAngularLimit::* )( ::btScalar,::btScalar,::btScalar,::btScalar,::btScalar ) 
float btAngularLimit_getError(void *c); //method: getError ::btScalar ( ::btAngularLimit::* )(  ) const
//not supported method: fit void ( ::btAngularLimit::* )( ::btScalar & ) const
// error:  - unsupported, void - ok

int btAngularLimit_isLimit(void *c); //method: isLimit bool ( ::btAngularLimit::* )(  ) const
float btAngularLimit_getSign(void *c); //method: getSign ::btScalar ( ::btAngularLimit::* )(  ) const
float btAngularLimit_getBiasFactor(void *c); //method: getBiasFactor ::btScalar ( ::btAngularLimit::* )(  ) const
float btAngularLimit_getSoftness(void *c); //method: getSoftness ::btScalar ( ::btAngularLimit::* )(  ) const
float btAngularLimit_getHigh(void *c); //method: getHigh ::btScalar ( ::btAngularLimit::* )(  ) const
//not supported method: test void ( ::btAngularLimit::* )( ::btScalar const ) 
// error:  - unsupported, void - ok

float btAngularLimit_getHalfRange(void *c); //method: getHalfRange ::btScalar ( ::btAngularLimit::* )(  ) const
float btAngularLimit_getLow(void *c); //method: getLow ::btScalar ( ::btAngularLimit::* )(  ) const
float btAngularLimit_getRelaxationFactor(void *c); //method: getRelaxationFactor ::btScalar ( ::btAngularLimit::* )(  ) const
void btAngularLimit_m_center_set(void *c,float a); //attribute: ::btScalar btAngularLimit->m_center
float btAngularLimit_m_center_get(void *c); //attribute: ::btScalar btAngularLimit->m_center
void btAngularLimit_m_halfRange_set(void *c,float a); //attribute: ::btScalar btAngularLimit->m_halfRange
float btAngularLimit_m_halfRange_get(void *c); //attribute: ::btScalar btAngularLimit->m_halfRange
void btAngularLimit_m_softness_set(void *c,float a); //attribute: ::btScalar btAngularLimit->m_softness
float btAngularLimit_m_softness_get(void *c); //attribute: ::btScalar btAngularLimit->m_softness
void btAngularLimit_m_biasFactor_set(void *c,float a); //attribute: ::btScalar btAngularLimit->m_biasFactor
float btAngularLimit_m_biasFactor_get(void *c); //attribute: ::btScalar btAngularLimit->m_biasFactor
void btAngularLimit_m_relaxationFactor_set(void *c,float a); //attribute: ::btScalar btAngularLimit->m_relaxationFactor
float btAngularLimit_m_relaxationFactor_get(void *c); //attribute: ::btScalar btAngularLimit->m_relaxationFactor
void btAngularLimit_m_correction_set(void *c,float a); //attribute: ::btScalar btAngularLimit->m_correction
float btAngularLimit_m_correction_get(void *c); //attribute: ::btScalar btAngularLimit->m_correction
void btAngularLimit_m_sign_set(void *c,float a); //attribute: ::btScalar btAngularLimit->m_sign
float btAngularLimit_m_sign_get(void *c); //attribute: ::btScalar btAngularLimit->m_sign
void btAngularLimit_m_solveLimit_set(void *c,int a); //attribute: bool btAngularLimit->m_solveLimit
int btAngularLimit_m_solveLimit_get(void *c); //attribute: bool btAngularLimit->m_solveLimit
void* btConeTwistConstraint_new0(void* p0,void* p1,float* p2,float* p3); //constructor: btConeTwistConstraint  ( ::btConeTwistConstraint::* )( ::btRigidBody &,::btRigidBody &,::btTransform const &,::btTransform const & ) 
void* btConeTwistConstraint_new1(void* p0,float* p1); //constructor: btConeTwistConstraint  ( ::btConeTwistConstraint::* )( ::btRigidBody &,::btTransform const & ) 
void btConeTwistConstraint_free(void *c); 
void* btConeTwistConstraint_getRigidBodyB(void *c); //method: getRigidBodyB ::btRigidBody const & ( ::btConeTwistConstraint::* )(  ) const
void btConeTwistConstraint_buildJacobian(void *c); //method: buildJacobian void ( ::btConeTwistConstraint::* )(  ) 
void* btConeTwistConstraint_getRigidBodyA(void *c); //method: getRigidBodyA ::btRigidBody const & ( ::btConeTwistConstraint::* )(  ) const
void btConeTwistConstraint_adjustSwingAxisToUseEllipseNormal(void *c,float* p0); //method: adjustSwingAxisToUseEllipseNormal void ( ::btConeTwistConstraint::* )( ::btVector3 & ) const
int btConeTwistConstraint_isPastSwingLimit(void *c); //method: isPastSwingLimit bool ( ::btConeTwistConstraint::* )(  ) 
void btConeTwistConstraint_getFrameOffsetA(void *c,float* ret); //method: getFrameOffsetA ::btTransform const & ( ::btConeTwistConstraint::* )(  ) const
void btConeTwistConstraint_getFrameOffsetB(void *c,float* ret); //method: getFrameOffsetB ::btTransform const & ( ::btConeTwistConstraint::* )(  ) const
void btConeTwistConstraint_getInfo2NonVirtual(void *c,void* p0,float* p1,float* p2,float* p3,float* p4); //method: getInfo2NonVirtual void ( ::btConeTwistConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,::btTransform const &,::btTransform const &,::btMatrix3x3 const &,::btMatrix3x3 const & ) 
float btConeTwistConstraint_getSwingSpan1(void *c); //method: getSwingSpan1 ::btScalar ( ::btConeTwistConstraint::* )(  ) 
void btConeTwistConstraint_calcAngleInfo2(void *c,float* p0,float* p1,float* p2,float* p3); //method: calcAngleInfo2 void ( ::btConeTwistConstraint::* )( ::btTransform const &,::btTransform const &,::btMatrix3x3 const &,::btMatrix3x3 const & ) 
//not supported method: computeConeLimitInfo void ( ::btConeTwistConstraint::* )( ::btQuaternion const &,::btScalar &,::btVector3 &,::btScalar & ) 
// error: ::btQuaternion const & - ok,  - unsupported, ::btVector3 & - ok,  - unsupported, void - ok

float btConeTwistConstraint_getParam(void *c,int p0,int p1); //method: getParam ::btScalar ( ::btConeTwistConstraint::* )( int,int ) const
void btConeTwistConstraint_setDamping(void *c,float p0); //method: setDamping void ( ::btConeTwistConstraint::* )( ::btScalar ) 
void btConeTwistConstraint_getInfo1(void *c,void* p0); //method: getInfo1 void ( ::btConeTwistConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btConeTwistConstraint_getInfo2(void *c,void* p0); //method: getInfo2 void ( ::btConeTwistConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void btConeTwistConstraint_setParam(void *c,int p0,float p1,int p2); //method: setParam void ( ::btConeTwistConstraint::* )( int,::btScalar,int ) 
int btConeTwistConstraint_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btConeTwistConstraint::* )(  ) const
//not supported method: computeTwistLimitInfo void ( ::btConeTwistConstraint::* )( ::btQuaternion const &,::btScalar &,::btVector3 & ) 
// error: ::btQuaternion const & - ok,  - unsupported, ::btVector3 & - ok, void - ok

void btConeTwistConstraint_init(void *c); //method: init void ( ::btConeTwistConstraint::* )(  ) 
float btConeTwistConstraint_getTwistAngle(void *c); //method: getTwistAngle ::btScalar ( ::btConeTwistConstraint::* )(  ) 
void btConeTwistConstraint_setMaxMotorImpulseNormalized(void *c,float p0); //method: setMaxMotorImpulseNormalized void ( ::btConeTwistConstraint::* )( ::btScalar ) 
int btConeTwistConstraint_getSolveTwistLimit(void *c); //method: getSolveTwistLimit int ( ::btConeTwistConstraint::* )(  ) 
void btConeTwistConstraint_enableMotor(void *c,int p0); //method: enableMotor void ( ::btConeTwistConstraint::* )( bool ) 
void btConeTwistConstraint_getBFrame(void *c,float* ret); //method: getBFrame ::btTransform const & ( ::btConeTwistConstraint::* )(  ) 
void btConeTwistConstraint_getInfo1NonVirtual(void *c,void* p0); //method: getInfo1NonVirtual void ( ::btConeTwistConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
char const * btConeTwistConstraint_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btConeTwistConstraint::* )( void *,::btSerializer * ) const
float btConeTwistConstraint_getFixThresh(void *c); //method: getFixThresh ::btScalar ( ::btConeTwistConstraint::* )(  ) 
int btConeTwistConstraint_getSolveSwingLimit(void *c); //method: getSolveSwingLimit int ( ::btConeTwistConstraint::* )(  ) 
float btConeTwistConstraint_getSwingSpan2(void *c); //method: getSwingSpan2 ::btScalar ( ::btConeTwistConstraint::* )(  ) 
void btConeTwistConstraint_setAngularOnly(void *c,int p0); //method: setAngularOnly void ( ::btConeTwistConstraint::* )( bool ) 
void btConeTwistConstraint_setFrames(void *c,float* p0,float* p1); //method: setFrames void ( ::btConeTwistConstraint::* )( ::btTransform const &,::btTransform const & ) 
void btConeTwistConstraint_setLimit(void *c,int p0,float p1); //method: setLimit void ( ::btConeTwistConstraint::* )( int,::btScalar ) 
void btConeTwistConstraint_setLimit0(void *c,int p0,float p1); //method: setLimit void ( ::btConeTwistConstraint::* )( int,::btScalar ) 
void btConeTwistConstraint_setLimit1(void *c,float p0,float p1,float p2,float p3,float p4,float p5); //method: setLimit void ( ::btConeTwistConstraint::* )( ::btScalar,::btScalar,::btScalar,::btScalar,::btScalar,::btScalar ) 
float btConeTwistConstraint_getTwistLimitSign(void *c); //method: getTwistLimitSign ::btScalar ( ::btConeTwistConstraint::* )(  ) 
void btConeTwistConstraint_setMaxMotorImpulse(void *c,float p0); //method: setMaxMotorImpulse void ( ::btConeTwistConstraint::* )( ::btScalar ) 
void btConeTwistConstraint_calcAngleInfo(void *c); //method: calcAngleInfo void ( ::btConeTwistConstraint::* )(  ) 
void btConeTwistConstraint_setMotorTarget(void *c,float* p0); //method: setMotorTarget void ( ::btConeTwistConstraint::* )( ::btQuaternion const & ) 
void btConeTwistConstraint_setFixThresh(void *c,float p0); //method: setFixThresh void ( ::btConeTwistConstraint::* )( ::btScalar ) 
void btConeTwistConstraint_setMotorTargetInConstraintSpace(void *c,float* p0); //method: setMotorTargetInConstraintSpace void ( ::btConeTwistConstraint::* )( ::btQuaternion const & ) 
void btConeTwistConstraint_solveConstraintObsolete(void *c,void* p0,void* p1,float p2); //method: solveConstraintObsolete void ( ::btConeTwistConstraint::* )( ::btRigidBody &,::btRigidBody &,::btScalar ) 
void btConeTwistConstraint_GetPointForAngle(void *c,float p0,float p1,float* ret); //method: GetPointForAngle ::btVector3 ( ::btConeTwistConstraint::* )( ::btScalar,::btScalar ) const
void btConeTwistConstraint_updateRHS(void *c,float p0); //method: updateRHS void ( ::btConeTwistConstraint::* )( ::btScalar ) 
float btConeTwistConstraint_getTwistSpan(void *c); //method: getTwistSpan ::btScalar ( ::btConeTwistConstraint::* )(  ) 
void btConeTwistConstraint_getAFrame(void *c,float* ret); //method: getAFrame ::btTransform const & ( ::btConeTwistConstraint::* )(  ) 
// attribute not supported: //attribute: ::btJacobianEntry[3] btConeTwistConstraint->m_jac
void btConeTwistConstraint_m_rbAFrame_set(void *c,float* a); //attribute: ::btTransform btConeTwistConstraint->m_rbAFrame
void btConeTwistConstraint_m_rbAFrame_get(void *c,float* a);
void btConeTwistConstraint_m_rbBFrame_set(void *c,float* a); //attribute: ::btTransform btConeTwistConstraint->m_rbBFrame
void btConeTwistConstraint_m_rbBFrame_get(void *c,float* a);
void btConeTwistConstraint_m_limitSoftness_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_limitSoftness
float btConeTwistConstraint_m_limitSoftness_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_limitSoftness
void btConeTwistConstraint_m_biasFactor_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_biasFactor
float btConeTwistConstraint_m_biasFactor_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_biasFactor
void btConeTwistConstraint_m_relaxationFactor_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_relaxationFactor
float btConeTwistConstraint_m_relaxationFactor_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_relaxationFactor
void btConeTwistConstraint_m_damping_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_damping
float btConeTwistConstraint_m_damping_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_damping
void btConeTwistConstraint_m_swingSpan1_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_swingSpan1
float btConeTwistConstraint_m_swingSpan1_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_swingSpan1
void btConeTwistConstraint_m_swingSpan2_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_swingSpan2
float btConeTwistConstraint_m_swingSpan2_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_swingSpan2
void btConeTwistConstraint_m_twistSpan_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_twistSpan
float btConeTwistConstraint_m_twistSpan_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_twistSpan
void btConeTwistConstraint_m_fixThresh_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_fixThresh
float btConeTwistConstraint_m_fixThresh_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_fixThresh
void btConeTwistConstraint_m_swingAxis_set(void *c,float* a); //attribute: ::btVector3 btConeTwistConstraint->m_swingAxis
void btConeTwistConstraint_m_swingAxis_get(void *c,float* a);
void btConeTwistConstraint_m_twistAxis_set(void *c,float* a); //attribute: ::btVector3 btConeTwistConstraint->m_twistAxis
void btConeTwistConstraint_m_twistAxis_get(void *c,float* a);
void btConeTwistConstraint_m_kSwing_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_kSwing
float btConeTwistConstraint_m_kSwing_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_kSwing
void btConeTwistConstraint_m_kTwist_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_kTwist
float btConeTwistConstraint_m_kTwist_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_kTwist
void btConeTwistConstraint_m_twistLimitSign_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_twistLimitSign
float btConeTwistConstraint_m_twistLimitSign_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_twistLimitSign
void btConeTwistConstraint_m_swingCorrection_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_swingCorrection
float btConeTwistConstraint_m_swingCorrection_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_swingCorrection
void btConeTwistConstraint_m_twistCorrection_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_twistCorrection
float btConeTwistConstraint_m_twistCorrection_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_twistCorrection
void btConeTwistConstraint_m_twistAngle_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_twistAngle
float btConeTwistConstraint_m_twistAngle_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_twistAngle
void btConeTwistConstraint_m_accSwingLimitImpulse_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_accSwingLimitImpulse
float btConeTwistConstraint_m_accSwingLimitImpulse_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_accSwingLimitImpulse
void btConeTwistConstraint_m_accTwistLimitImpulse_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_accTwistLimitImpulse
float btConeTwistConstraint_m_accTwistLimitImpulse_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_accTwistLimitImpulse
void btConeTwistConstraint_m_angularOnly_set(void *c,int a); //attribute: bool btConeTwistConstraint->m_angularOnly
int btConeTwistConstraint_m_angularOnly_get(void *c); //attribute: bool btConeTwistConstraint->m_angularOnly
void btConeTwistConstraint_m_solveTwistLimit_set(void *c,int a); //attribute: bool btConeTwistConstraint->m_solveTwistLimit
int btConeTwistConstraint_m_solveTwistLimit_get(void *c); //attribute: bool btConeTwistConstraint->m_solveTwistLimit
void btConeTwistConstraint_m_solveSwingLimit_set(void *c,int a); //attribute: bool btConeTwistConstraint->m_solveSwingLimit
int btConeTwistConstraint_m_solveSwingLimit_get(void *c); //attribute: bool btConeTwistConstraint->m_solveSwingLimit
void btConeTwistConstraint_m_useSolveConstraintObsolete_set(void *c,int a); //attribute: bool btConeTwistConstraint->m_useSolveConstraintObsolete
int btConeTwistConstraint_m_useSolveConstraintObsolete_get(void *c); //attribute: bool btConeTwistConstraint->m_useSolveConstraintObsolete
void btConeTwistConstraint_m_swingLimitRatio_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_swingLimitRatio
float btConeTwistConstraint_m_swingLimitRatio_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_swingLimitRatio
void btConeTwistConstraint_m_twistLimitRatio_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_twistLimitRatio
float btConeTwistConstraint_m_twistLimitRatio_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_twistLimitRatio
void btConeTwistConstraint_m_twistAxisA_set(void *c,float* a); //attribute: ::btVector3 btConeTwistConstraint->m_twistAxisA
void btConeTwistConstraint_m_twistAxisA_get(void *c,float* a);
void btConeTwistConstraint_m_bMotorEnabled_set(void *c,int a); //attribute: bool btConeTwistConstraint->m_bMotorEnabled
int btConeTwistConstraint_m_bMotorEnabled_get(void *c); //attribute: bool btConeTwistConstraint->m_bMotorEnabled
void btConeTwistConstraint_m_bNormalizedMotorStrength_set(void *c,int a); //attribute: bool btConeTwistConstraint->m_bNormalizedMotorStrength
int btConeTwistConstraint_m_bNormalizedMotorStrength_get(void *c); //attribute: bool btConeTwistConstraint->m_bNormalizedMotorStrength
void btConeTwistConstraint_m_qTarget_set(void *c,float* a); //attribute: ::btQuaternion btConeTwistConstraint->m_qTarget
void btConeTwistConstraint_m_qTarget_get(void *c,float* a);
void btConeTwistConstraint_m_maxMotorImpulse_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_maxMotorImpulse
float btConeTwistConstraint_m_maxMotorImpulse_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_maxMotorImpulse
void btConeTwistConstraint_m_accMotorImpulse_set(void *c,float* a); //attribute: ::btVector3 btConeTwistConstraint->m_accMotorImpulse
void btConeTwistConstraint_m_accMotorImpulse_get(void *c,float* a);
void btConeTwistConstraint_m_flags_set(void *c,int a); //attribute: int btConeTwistConstraint->m_flags
int btConeTwistConstraint_m_flags_get(void *c); //attribute: int btConeTwistConstraint->m_flags
void btConeTwistConstraint_m_linCFM_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_linCFM
float btConeTwistConstraint_m_linCFM_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_linCFM
void btConeTwistConstraint_m_linERP_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_linERP
float btConeTwistConstraint_m_linERP_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_linERP
void btConeTwistConstraint_m_angCFM_set(void *c,float a); //attribute: ::btScalar btConeTwistConstraint->m_angCFM
float btConeTwistConstraint_m_angCFM_get(void *c); //attribute: ::btScalar btConeTwistConstraint->m_angCFM
void* btConeTwistConstraintData_new(); //constructor: btConeTwistConstraintData  ( ::btConeTwistConstraintData::* )(  ) 
void btConeTwistConstraintData_free(void *c); 
void btConeTwistConstraintData_m_typeConstraintData_set(void *c,void* a); //attribute: ::btTypedConstraintData btConeTwistConstraintData->m_typeConstraintData
void* btConeTwistConstraintData_m_typeConstraintData_get(void *c); //attribute: ::btTypedConstraintData btConeTwistConstraintData->m_typeConstraintData
void btConeTwistConstraintData_m_rbAFrame_set(void *c,void* a); //attribute: ::btTransformFloatData btConeTwistConstraintData->m_rbAFrame
void* btConeTwistConstraintData_m_rbAFrame_get(void *c); //attribute: ::btTransformFloatData btConeTwistConstraintData->m_rbAFrame
void btConeTwistConstraintData_m_rbBFrame_set(void *c,void* a); //attribute: ::btTransformFloatData btConeTwistConstraintData->m_rbBFrame
void* btConeTwistConstraintData_m_rbBFrame_get(void *c); //attribute: ::btTransformFloatData btConeTwistConstraintData->m_rbBFrame
void btConeTwistConstraintData_m_swingSpan1_set(void *c,float a); //attribute: float btConeTwistConstraintData->m_swingSpan1
float btConeTwistConstraintData_m_swingSpan1_get(void *c); //attribute: float btConeTwistConstraintData->m_swingSpan1
void btConeTwistConstraintData_m_swingSpan2_set(void *c,float a); //attribute: float btConeTwistConstraintData->m_swingSpan2
float btConeTwistConstraintData_m_swingSpan2_get(void *c); //attribute: float btConeTwistConstraintData->m_swingSpan2
void btConeTwistConstraintData_m_twistSpan_set(void *c,float a); //attribute: float btConeTwistConstraintData->m_twistSpan
float btConeTwistConstraintData_m_twistSpan_get(void *c); //attribute: float btConeTwistConstraintData->m_twistSpan
void btConeTwistConstraintData_m_limitSoftness_set(void *c,float a); //attribute: float btConeTwistConstraintData->m_limitSoftness
float btConeTwistConstraintData_m_limitSoftness_get(void *c); //attribute: float btConeTwistConstraintData->m_limitSoftness
void btConeTwistConstraintData_m_biasFactor_set(void *c,float a); //attribute: float btConeTwistConstraintData->m_biasFactor
float btConeTwistConstraintData_m_biasFactor_get(void *c); //attribute: float btConeTwistConstraintData->m_biasFactor
void btConeTwistConstraintData_m_relaxationFactor_set(void *c,float a); //attribute: float btConeTwistConstraintData->m_relaxationFactor
float btConeTwistConstraintData_m_relaxationFactor_get(void *c); //attribute: float btConeTwistConstraintData->m_relaxationFactor
void btConeTwistConstraintData_m_damping_set(void *c,float a); //attribute: float btConeTwistConstraintData->m_damping
float btConeTwistConstraintData_m_damping_get(void *c); //attribute: float btConeTwistConstraintData->m_damping
// attribute not supported: //attribute: char[4] btConeTwistConstraintData->m_pad
void* btTypedConstraint_btConstraintInfo1_new(); //constructor: btConstraintInfo1  ( ::btTypedConstraint::btConstraintInfo1::* )(  ) 
void btTypedConstraint_btConstraintInfo1_free(void *c); 
void btTypedConstraint_btConstraintInfo1_m_numConstraintRows_set(void *c,int a); //attribute: int btTypedConstraint_btConstraintInfo1->m_numConstraintRows
int btTypedConstraint_btConstraintInfo1_m_numConstraintRows_get(void *c); //attribute: int btTypedConstraint_btConstraintInfo1->m_numConstraintRows
void btTypedConstraint_btConstraintInfo1_nub_set(void *c,int a); //attribute: int btTypedConstraint_btConstraintInfo1->nub
int btTypedConstraint_btConstraintInfo1_nub_get(void *c); //attribute: int btTypedConstraint_btConstraintInfo1->nub
void* btTypedConstraint_btConstraintInfo2_new(); //constructor: btConstraintInfo2  ( ::btTypedConstraint::btConstraintInfo2::* )(  ) 
void btTypedConstraint_btConstraintInfo2_free(void *c); 
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->cfm
void btTypedConstraint_btConstraintInfo2_erp_set(void *c,float a); //attribute: ::btScalar btTypedConstraint_btConstraintInfo2->erp
float btTypedConstraint_btConstraintInfo2_erp_get(void *c); //attribute: ::btScalar btTypedConstraint_btConstraintInfo2->erp
// attribute not supported: //attribute: int * btTypedConstraint_btConstraintInfo2->findex
void btTypedConstraint_btConstraintInfo2_fps_set(void *c,float a); //attribute: ::btScalar btTypedConstraint_btConstraintInfo2->fps
float btTypedConstraint_btConstraintInfo2_fps_get(void *c); //attribute: ::btScalar btTypedConstraint_btConstraintInfo2->fps
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_J1angularAxis
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_J1linearAxis
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_J2angularAxis
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_J2linearAxis
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_constraintError
void btTypedConstraint_btConstraintInfo2_m_damping_set(void *c,float a); //attribute: ::btScalar btTypedConstraint_btConstraintInfo2->m_damping
float btTypedConstraint_btConstraintInfo2_m_damping_get(void *c); //attribute: ::btScalar btTypedConstraint_btConstraintInfo2->m_damping
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_lowerLimit
void btTypedConstraint_btConstraintInfo2_m_numIterations_set(void *c,int a); //attribute: int btTypedConstraint_btConstraintInfo2->m_numIterations
int btTypedConstraint_btConstraintInfo2_m_numIterations_get(void *c); //attribute: int btTypedConstraint_btConstraintInfo2->m_numIterations
// attribute not supported: //attribute: ::btScalar * btTypedConstraint_btConstraintInfo2->m_upperLimit
void btTypedConstraint_btConstraintInfo2_rowskip_set(void *c,int a); //attribute: int btTypedConstraint_btConstraintInfo2->rowskip
int btTypedConstraint_btConstraintInfo2_rowskip_get(void *c); //attribute: int btTypedConstraint_btConstraintInfo2->rowskip
void* btConstraintSetting_new(); //constructor: btConstraintSetting  ( ::btConstraintSetting::* )(  ) 
void btConstraintSetting_free(void *c); 
void btConstraintSetting_m_tau_set(void *c,float a); //attribute: ::btScalar btConstraintSetting->m_tau
float btConstraintSetting_m_tau_get(void *c); //attribute: ::btScalar btConstraintSetting->m_tau
void btConstraintSetting_m_damping_set(void *c,float a); //attribute: ::btScalar btConstraintSetting->m_damping
float btConstraintSetting_m_damping_get(void *c); //attribute: ::btScalar btConstraintSetting->m_damping
void btConstraintSetting_m_impulseClamp_set(void *c,float a); //attribute: ::btScalar btConstraintSetting->m_impulseClamp
float btConstraintSetting_m_impulseClamp_get(void *c); //attribute: ::btScalar btConstraintSetting->m_impulseClamp
void btConstraintSolver_reset(void *c); //method: reset void ( ::btConstraintSolver::* )(  ) 
void btConstraintSolver_allSolved(void *c,void* p0,void* p1,void* p2); //method: allSolved void ( ::btConstraintSolver::* )( ::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc * ) 
//not supported method: solveGroup ::btScalar ( ::btConstraintSolver::* )( ::btCollisionObject * *,int,::btPersistentManifold * *,int,::btTypedConstraint * *,int,::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc *,::btDispatcher * ) 
// error:  - unsupported, int - ok,  - unsupported, int - ok,  - unsupported, int - ok, ::btContactSolverInfo const & - ok, ::btIDebugDraw * - ok, ::btStackAlloc * - ok, ::btDispatcher * - ok, ::btScalar - ok

void btConstraintSolver_prepareSolve(void *c,int p0,int p1); //method: prepareSolve void ( ::btConstraintSolver::* )( int,int ) 
void btContactConstraint_getInfo1(void *c,void* p0); //method: getInfo1 void ( ::btContactConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btContactConstraint_setContactManifold(void *c,void* p0); //method: setContactManifold void ( ::btContactConstraint::* )( ::btPersistentManifold * ) 
void btContactConstraint_buildJacobian(void *c); //method: buildJacobian void ( ::btContactConstraint::* )(  ) 
void btContactConstraint_getInfo2(void *c,void* p0); //method: getInfo2 void ( ::btContactConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void* btContactConstraint_getContactManifold(void *c); //method: getContactManifold ::btPersistentManifold * ( ::btContactConstraint::* )(  ) 
void* btContactConstraint_getContactManifold0(void *c); //method: getContactManifold ::btPersistentManifold * ( ::btContactConstraint::* )(  ) 
void* btContactConstraint_getContactManifold1(void *c); //method: getContactManifold ::btPersistentManifold const * ( ::btContactConstraint::* )(  ) const
void btContactConstraint_m_contactManifold_set(void *c,void* a); //attribute: ::btPersistentManifold btContactConstraint->m_contactManifold
void* btContactConstraint_m_contactManifold_get(void *c); //attribute: ::btPersistentManifold btContactConstraint->m_contactManifold
void* btContactSolverInfo_new(); //constructor: btContactSolverInfo  ( ::btContactSolverInfo::* )(  ) 
void btContactSolverInfo_free(void *c); 
void* btContactSolverInfoData_new(); //constructor: btContactSolverInfoData  ( ::btContactSolverInfoData::* )(  ) 
void btContactSolverInfoData_free(void *c); 
void btContactSolverInfoData_m_tau_set(void *c,float a); //attribute: ::btScalar btContactSolverInfoData->m_tau
float btContactSolverInfoData_m_tau_get(void *c); //attribute: ::btScalar btContactSolverInfoData->m_tau
void btContactSolverInfoData_m_damping_set(void *c,float a); //attribute: ::btScalar btContactSolverInfoData->m_damping
float btContactSolverInfoData_m_damping_get(void *c); //attribute: ::btScalar btContactSolverInfoData->m_damping
void btContactSolverInfoData_m_friction_set(void *c,float a); //attribute: ::btScalar btContactSolverInfoData->m_friction
float btContactSolverInfoData_m_friction_get(void *c); //attribute: ::btScalar btContactSolverInfoData->m_friction
void btContactSolverInfoData_m_timeStep_set(void *c,float a); //attribute: ::btScalar btContactSolverInfoData->m_timeStep
float btContactSolverInfoData_m_timeStep_get(void *c); //attribute: ::btScalar btContactSolverInfoData->m_timeStep
void btContactSolverInfoData_m_restitution_set(void *c,float a); //attribute: ::btScalar btContactSolverInfoData->m_restitution
float btContactSolverInfoData_m_restitution_get(void *c); //attribute: ::btScalar btContactSolverInfoData->m_restitution
void btContactSolverInfoData_m_numIterations_set(void *c,int a); //attribute: int btContactSolverInfoData->m_numIterations
int btContactSolverInfoData_m_numIterations_get(void *c); //attribute: int btContactSolverInfoData->m_numIterations
void btContactSolverInfoData_m_maxErrorReduction_set(void *c,float a); //attribute: ::btScalar btContactSolverInfoData->m_maxErrorReduction
float btContactSolverInfoData_m_maxErrorReduction_get(void *c); //attribute: ::btScalar btContactSolverInfoData->m_maxErrorReduction
void btContactSolverInfoData_m_sor_set(void *c,float a); //attribute: ::btScalar btContactSolverInfoData->m_sor
float btContactSolverInfoData_m_sor_get(void *c); //attribute: ::btScalar btContactSolverInfoData->m_sor
void btContactSolverInfoData_m_erp_set(void *c,float a); //attribute: ::btScalar btContactSolverInfoData->m_erp
float btContactSolverInfoData_m_erp_get(void *c); //attribute: ::btScalar btContactSolverInfoData->m_erp
void btContactSolverInfoData_m_erp2_set(void *c,float a); //attribute: ::btScalar btContactSolverInfoData->m_erp2
float btContactSolverInfoData_m_erp2_get(void *c); //attribute: ::btScalar btContactSolverInfoData->m_erp2
void btContactSolverInfoData_m_globalCfm_set(void *c,float a); //attribute: ::btScalar btContactSolverInfoData->m_globalCfm
float btContactSolverInfoData_m_globalCfm_get(void *c); //attribute: ::btScalar btContactSolverInfoData->m_globalCfm
void btContactSolverInfoData_m_splitImpulse_set(void *c,int a); //attribute: int btContactSolverInfoData->m_splitImpulse
int btContactSolverInfoData_m_splitImpulse_get(void *c); //attribute: int btContactSolverInfoData->m_splitImpulse
void btContactSolverInfoData_m_splitImpulsePenetrationThreshold_set(void *c,float a); //attribute: ::btScalar btContactSolverInfoData->m_splitImpulsePenetrationThreshold
float btContactSolverInfoData_m_splitImpulsePenetrationThreshold_get(void *c); //attribute: ::btScalar btContactSolverInfoData->m_splitImpulsePenetrationThreshold
void btContactSolverInfoData_m_linearSlop_set(void *c,float a); //attribute: ::btScalar btContactSolverInfoData->m_linearSlop
float btContactSolverInfoData_m_linearSlop_get(void *c); //attribute: ::btScalar btContactSolverInfoData->m_linearSlop
void btContactSolverInfoData_m_warmstartingFactor_set(void *c,float a); //attribute: ::btScalar btContactSolverInfoData->m_warmstartingFactor
float btContactSolverInfoData_m_warmstartingFactor_get(void *c); //attribute: ::btScalar btContactSolverInfoData->m_warmstartingFactor
void btContactSolverInfoData_m_solverMode_set(void *c,int a); //attribute: int btContactSolverInfoData->m_solverMode
int btContactSolverInfoData_m_solverMode_get(void *c); //attribute: int btContactSolverInfoData->m_solverMode
void btContactSolverInfoData_m_restingContactRestitutionThreshold_set(void *c,int a); //attribute: int btContactSolverInfoData->m_restingContactRestitutionThreshold
int btContactSolverInfoData_m_restingContactRestitutionThreshold_get(void *c); //attribute: int btContactSolverInfoData->m_restingContactRestitutionThreshold
void btContactSolverInfoData_m_minimumSolverBatchSize_set(void *c,int a); //attribute: int btContactSolverInfoData->m_minimumSolverBatchSize
int btContactSolverInfoData_m_minimumSolverBatchSize_get(void *c); //attribute: int btContactSolverInfoData->m_minimumSolverBatchSize
void* btGeneric6DofConstraint_new0(void* p0,void* p1,float* p2,float* p3,int p4); //constructor: btGeneric6DofConstraint  ( ::btGeneric6DofConstraint::* )( ::btRigidBody &,::btRigidBody &,::btTransform const &,::btTransform const &,bool ) 
void* btGeneric6DofConstraint_new1(void* p0,float* p1,int p2); //constructor: btGeneric6DofConstraint  ( ::btGeneric6DofConstraint::* )( ::btRigidBody &,::btTransform const &,bool ) 
void btGeneric6DofConstraint_free(void *c); 
void btGeneric6DofConstraint_buildJacobian(void *c); //method: buildJacobian void ( ::btGeneric6DofConstraint::* )(  ) 
void btGeneric6DofConstraint_setParam(void *c,int p0,float p1,int p2); //method: setParam void ( ::btGeneric6DofConstraint::* )( int,::btScalar,int ) 
void btGeneric6DofConstraint_getInfo1NonVirtual(void *c,void* p0); //method: getInfo1NonVirtual void ( ::btGeneric6DofConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btGeneric6DofConstraint_getFrameOffsetA(void *c,float* ret); //method: getFrameOffsetA ::btTransform const & ( ::btGeneric6DofConstraint::* )(  ) const
void btGeneric6DofConstraint_getFrameOffsetA0(void *c,float* ret); //method: getFrameOffsetA ::btTransform const & ( ::btGeneric6DofConstraint::* )(  ) const
void btGeneric6DofConstraint_getFrameOffsetA1(void *c,float* ret); //method: getFrameOffsetA ::btTransform & ( ::btGeneric6DofConstraint::* )(  ) 
float btGeneric6DofConstraint_getRelativePivotPosition(void *c,int p0); //method: getRelativePivotPosition ::btScalar ( ::btGeneric6DofConstraint::* )( int ) const
void btGeneric6DofConstraint_calculateAngleInfo(void *c); //method: calculateAngleInfo void ( ::btGeneric6DofConstraint::* )(  ) 
void btGeneric6DofConstraint_getInfo2NonVirtual(void *c,void* p0,float* p1,float* p2,float* p3,float* p4,float* p5,float* p6); //method: getInfo2NonVirtual void ( ::btGeneric6DofConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
int btGeneric6DofConstraint_setAngularLimits(void *c,void* p0,int p1,float* p2,float* p3,float* p4,float* p5,float* p6,float* p7); //method: setAngularLimits int ( ::btGeneric6DofConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,int,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
float btGeneric6DofConstraint_getParam(void *c,int p0,int p1); //method: getParam ::btScalar ( ::btGeneric6DofConstraint::* )( int,int ) const
void btGeneric6DofConstraint_getInfo1(void *c,void* p0); //method: getInfo1 void ( ::btGeneric6DofConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btGeneric6DofConstraint_getInfo2(void *c,void* p0); //method: getInfo2 void ( ::btGeneric6DofConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void btGeneric6DofConstraint_calcAnchorPos(void *c); //method: calcAnchorPos void ( ::btGeneric6DofConstraint::* )(  ) 
void btGeneric6DofConstraint_getAngularLowerLimit(void *c,float* p0); //method: getAngularLowerLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 & ) 
int btGeneric6DofConstraint_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btGeneric6DofConstraint::* )(  ) const
void btGeneric6DofConstraint_getAxis(void *c,int p0,float* ret); //method: getAxis ::btVector3 ( ::btGeneric6DofConstraint::* )( int ) const
void btGeneric6DofConstraint_getLinearUpperLimit(void *c,float* p0); //method: getLinearUpperLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 & ) 
void btGeneric6DofConstraint_setUseFrameOffset(void *c,int p0); //method: setUseFrameOffset void ( ::btGeneric6DofConstraint::* )( bool ) 
int btGeneric6DofConstraint_isLimited(void *c,int p0); //method: isLimited bool ( ::btGeneric6DofConstraint::* )( int ) 
void* btGeneric6DofConstraint_getRotationalLimitMotor(void *c,int p0); //method: getRotationalLimitMotor ::btRotationalLimitMotor * ( ::btGeneric6DofConstraint::* )( int ) 
void btGeneric6DofConstraint_buildAngularJacobian(void *c,void* p0,float* p1); //method: buildAngularJacobian void ( ::btGeneric6DofConstraint::* )( ::btJacobianEntry &,::btVector3 const & ) 
void btGeneric6DofConstraint_getFrameOffsetB(void *c,float* ret); //method: getFrameOffsetB ::btTransform const & ( ::btGeneric6DofConstraint::* )(  ) const
void btGeneric6DofConstraint_getFrameOffsetB0(void *c,float* ret); //method: getFrameOffsetB ::btTransform const & ( ::btGeneric6DofConstraint::* )(  ) const
void btGeneric6DofConstraint_getFrameOffsetB1(void *c,float* ret); //method: getFrameOffsetB ::btTransform & ( ::btGeneric6DofConstraint::* )(  ) 
void btGeneric6DofConstraint_setLinearLowerLimit(void *c,float* p0); //method: setLinearLowerLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 const & ) 
void btGeneric6DofConstraint_getLinearLowerLimit(void *c,float* p0); //method: getLinearLowerLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 & ) 
void btGeneric6DofConstraint_buildLinearJacobian(void *c,void* p0,float* p1,float* p2,float* p3); //method: buildLinearJacobian void ( ::btGeneric6DofConstraint::* )( ::btJacobianEntry &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
int btGeneric6DofConstraint_getUseFrameOffset(void *c); //method: getUseFrameOffset bool ( ::btGeneric6DofConstraint::* )(  ) 
void btGeneric6DofConstraint_getCalculatedTransformB(void *c,float* ret); //method: getCalculatedTransformB ::btTransform const & ( ::btGeneric6DofConstraint::* )(  ) const
void btGeneric6DofConstraint_calculateTransforms(void *c,float* p0,float* p1); //method: calculateTransforms void ( ::btGeneric6DofConstraint::* )( ::btTransform const &,::btTransform const & ) 
void btGeneric6DofConstraint_calculateTransforms0(void *c,float* p0,float* p1); //method: calculateTransforms void ( ::btGeneric6DofConstraint::* )( ::btTransform const &,::btTransform const & ) 
void btGeneric6DofConstraint_calculateTransforms1(void *c); //method: calculateTransforms void ( ::btGeneric6DofConstraint::* )(  ) 
int btGeneric6DofConstraint_get_limit_motor_info2(void *c,void* p0,float* p1,float* p2,float* p3,float* p4,float* p5,float* p6,void* p7,int p8,float* p9,int p10,int p11); //method: get_limit_motor_info2 int ( ::btGeneric6DofConstraint::* )( ::btRotationalLimitMotor *,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btTypedConstraint::btConstraintInfo2 *,int,::btVector3 &,int,int ) 
void btGeneric6DofConstraint_getCalculatedTransformA(void *c,float* ret); //method: getCalculatedTransformA ::btTransform const & ( ::btGeneric6DofConstraint::* )(  ) const
char const * btGeneric6DofConstraint_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btGeneric6DofConstraint::* )( void *,::btSerializer * ) const
void btGeneric6DofConstraint_setLimit(void *c,int p0,float p1,float p2); //method: setLimit void ( ::btGeneric6DofConstraint::* )( int,::btScalar,::btScalar ) 
void* btGeneric6DofConstraint_getTranslationalLimitMotor(void *c); //method: getTranslationalLimitMotor ::btTranslationalLimitMotor * ( ::btGeneric6DofConstraint::* )(  ) 
int btGeneric6DofConstraint_setLinearLimits(void *c,void* p0,int p1,float* p2,float* p3,float* p4,float* p5,float* p6,float* p7); //method: setLinearLimits int ( ::btGeneric6DofConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,int,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
float btGeneric6DofConstraint_getAngle(void *c,int p0); //method: getAngle ::btScalar ( ::btGeneric6DofConstraint::* )( int ) const
void btGeneric6DofConstraint_updateRHS(void *c,float p0); //method: updateRHS void ( ::btGeneric6DofConstraint::* )( ::btScalar ) 
void btGeneric6DofConstraint_getAngularUpperLimit(void *c,float* p0); //method: getAngularUpperLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 & ) 
void btGeneric6DofConstraint_setAngularLowerLimit(void *c,float* p0); //method: setAngularLowerLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 const & ) 
void btGeneric6DofConstraint_calculateLinearInfo(void *c); //method: calculateLinearInfo void ( ::btGeneric6DofConstraint::* )(  ) 
void btGeneric6DofConstraint_setFrames(void *c,float* p0,float* p1); //method: setFrames void ( ::btGeneric6DofConstraint::* )( ::btTransform const &,::btTransform const & ) 
void btGeneric6DofConstraint_setLinearUpperLimit(void *c,float* p0); //method: setLinearUpperLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 const & ) 
void btGeneric6DofConstraint_setAngularUpperLimit(void *c,float* p0); //method: setAngularUpperLimit void ( ::btGeneric6DofConstraint::* )( ::btVector3 const & ) 
void btGeneric6DofConstraint_setAxis(void *c,float* p0,float* p1); //method: setAxis void ( ::btGeneric6DofConstraint::* )( ::btVector3 const &,::btVector3 const & ) 
int btGeneric6DofConstraint_testAngularLimitMotor(void *c,int p0); //method: testAngularLimitMotor bool ( ::btGeneric6DofConstraint::* )( int ) 
void btGeneric6DofConstraint_m_frameInA_set(void *c,float* a); //attribute: ::btTransform btGeneric6DofConstraint->m_frameInA
void btGeneric6DofConstraint_m_frameInA_get(void *c,float* a);
void btGeneric6DofConstraint_m_frameInB_set(void *c,float* a); //attribute: ::btTransform btGeneric6DofConstraint->m_frameInB
void btGeneric6DofConstraint_m_frameInB_get(void *c,float* a);
// attribute not supported: //attribute: ::btJacobianEntry[3] btGeneric6DofConstraint->m_jacLinear
// attribute not supported: //attribute: ::btJacobianEntry[3] btGeneric6DofConstraint->m_jacAng
void btGeneric6DofConstraint_m_linearLimits_set(void *c,void* a); //attribute: ::btTranslationalLimitMotor btGeneric6DofConstraint->m_linearLimits
void* btGeneric6DofConstraint_m_linearLimits_get(void *c); //attribute: ::btTranslationalLimitMotor btGeneric6DofConstraint->m_linearLimits
// attribute not supported: //attribute: ::btRotationalLimitMotor[3] btGeneric6DofConstraint->m_angularLimits
void btGeneric6DofConstraint_m_timeStep_set(void *c,float a); //attribute: ::btScalar btGeneric6DofConstraint->m_timeStep
float btGeneric6DofConstraint_m_timeStep_get(void *c); //attribute: ::btScalar btGeneric6DofConstraint->m_timeStep
void btGeneric6DofConstraint_m_calculatedTransformA_set(void *c,float* a); //attribute: ::btTransform btGeneric6DofConstraint->m_calculatedTransformA
void btGeneric6DofConstraint_m_calculatedTransformA_get(void *c,float* a);
void btGeneric6DofConstraint_m_calculatedTransformB_set(void *c,float* a); //attribute: ::btTransform btGeneric6DofConstraint->m_calculatedTransformB
void btGeneric6DofConstraint_m_calculatedTransformB_get(void *c,float* a);
void btGeneric6DofConstraint_m_calculatedAxisAngleDiff_set(void *c,float* a); //attribute: ::btVector3 btGeneric6DofConstraint->m_calculatedAxisAngleDiff
void btGeneric6DofConstraint_m_calculatedAxisAngleDiff_get(void *c,float* a);
// attribute not supported: //attribute: ::btVector3[3] btGeneric6DofConstraint->m_calculatedAxis
void btGeneric6DofConstraint_m_calculatedLinearDiff_set(void *c,float* a); //attribute: ::btVector3 btGeneric6DofConstraint->m_calculatedLinearDiff
void btGeneric6DofConstraint_m_calculatedLinearDiff_get(void *c,float* a);
void btGeneric6DofConstraint_m_factA_set(void *c,float a); //attribute: ::btScalar btGeneric6DofConstraint->m_factA
float btGeneric6DofConstraint_m_factA_get(void *c); //attribute: ::btScalar btGeneric6DofConstraint->m_factA
void btGeneric6DofConstraint_m_factB_set(void *c,float a); //attribute: ::btScalar btGeneric6DofConstraint->m_factB
float btGeneric6DofConstraint_m_factB_get(void *c); //attribute: ::btScalar btGeneric6DofConstraint->m_factB
void btGeneric6DofConstraint_m_hasStaticBody_set(void *c,int a); //attribute: bool btGeneric6DofConstraint->m_hasStaticBody
int btGeneric6DofConstraint_m_hasStaticBody_get(void *c); //attribute: bool btGeneric6DofConstraint->m_hasStaticBody
void btGeneric6DofConstraint_m_AnchorPos_set(void *c,float* a); //attribute: ::btVector3 btGeneric6DofConstraint->m_AnchorPos
void btGeneric6DofConstraint_m_AnchorPos_get(void *c,float* a);
void btGeneric6DofConstraint_m_useLinearReferenceFrameA_set(void *c,int a); //attribute: bool btGeneric6DofConstraint->m_useLinearReferenceFrameA
int btGeneric6DofConstraint_m_useLinearReferenceFrameA_get(void *c); //attribute: bool btGeneric6DofConstraint->m_useLinearReferenceFrameA
void btGeneric6DofConstraint_m_useOffsetForConstraintFrame_set(void *c,int a); //attribute: bool btGeneric6DofConstraint->m_useOffsetForConstraintFrame
int btGeneric6DofConstraint_m_useOffsetForConstraintFrame_get(void *c); //attribute: bool btGeneric6DofConstraint->m_useOffsetForConstraintFrame
void btGeneric6DofConstraint_m_flags_set(void *c,int a); //attribute: int btGeneric6DofConstraint->m_flags
int btGeneric6DofConstraint_m_flags_get(void *c); //attribute: int btGeneric6DofConstraint->m_flags
void btGeneric6DofConstraint_m_useSolveConstraintObsolete_set(void *c,int a); //attribute: bool btGeneric6DofConstraint->m_useSolveConstraintObsolete
int btGeneric6DofConstraint_m_useSolveConstraintObsolete_get(void *c); //attribute: bool btGeneric6DofConstraint->m_useSolveConstraintObsolete
void* btGeneric6DofConstraintData_new(); //constructor: btGeneric6DofConstraintData  ( ::btGeneric6DofConstraintData::* )(  ) 
void btGeneric6DofConstraintData_free(void *c); 
void btGeneric6DofConstraintData_m_typeConstraintData_set(void *c,void* a); //attribute: ::btTypedConstraintData btGeneric6DofConstraintData->m_typeConstraintData
void* btGeneric6DofConstraintData_m_typeConstraintData_get(void *c); //attribute: ::btTypedConstraintData btGeneric6DofConstraintData->m_typeConstraintData
void btGeneric6DofConstraintData_m_rbAFrame_set(void *c,void* a); //attribute: ::btTransformFloatData btGeneric6DofConstraintData->m_rbAFrame
void* btGeneric6DofConstraintData_m_rbAFrame_get(void *c); //attribute: ::btTransformFloatData btGeneric6DofConstraintData->m_rbAFrame
void btGeneric6DofConstraintData_m_rbBFrame_set(void *c,void* a); //attribute: ::btTransformFloatData btGeneric6DofConstraintData->m_rbBFrame
void* btGeneric6DofConstraintData_m_rbBFrame_get(void *c); //attribute: ::btTransformFloatData btGeneric6DofConstraintData->m_rbBFrame
void btGeneric6DofConstraintData_m_linearUpperLimit_set(void *c,void* a); //attribute: ::btVector3FloatData btGeneric6DofConstraintData->m_linearUpperLimit
void* btGeneric6DofConstraintData_m_linearUpperLimit_get(void *c); //attribute: ::btVector3FloatData btGeneric6DofConstraintData->m_linearUpperLimit
void btGeneric6DofConstraintData_m_linearLowerLimit_set(void *c,void* a); //attribute: ::btVector3FloatData btGeneric6DofConstraintData->m_linearLowerLimit
void* btGeneric6DofConstraintData_m_linearLowerLimit_get(void *c); //attribute: ::btVector3FloatData btGeneric6DofConstraintData->m_linearLowerLimit
void btGeneric6DofConstraintData_m_angularUpperLimit_set(void *c,void* a); //attribute: ::btVector3FloatData btGeneric6DofConstraintData->m_angularUpperLimit
void* btGeneric6DofConstraintData_m_angularUpperLimit_get(void *c); //attribute: ::btVector3FloatData btGeneric6DofConstraintData->m_angularUpperLimit
void btGeneric6DofConstraintData_m_angularLowerLimit_set(void *c,void* a); //attribute: ::btVector3FloatData btGeneric6DofConstraintData->m_angularLowerLimit
void* btGeneric6DofConstraintData_m_angularLowerLimit_get(void *c); //attribute: ::btVector3FloatData btGeneric6DofConstraintData->m_angularLowerLimit
void btGeneric6DofConstraintData_m_useLinearReferenceFrameA_set(void *c,int a); //attribute: int btGeneric6DofConstraintData->m_useLinearReferenceFrameA
int btGeneric6DofConstraintData_m_useLinearReferenceFrameA_get(void *c); //attribute: int btGeneric6DofConstraintData->m_useLinearReferenceFrameA
void btGeneric6DofConstraintData_m_useOffsetForConstraintFrame_set(void *c,int a); //attribute: int btGeneric6DofConstraintData->m_useOffsetForConstraintFrame
int btGeneric6DofConstraintData_m_useOffsetForConstraintFrame_get(void *c); //attribute: int btGeneric6DofConstraintData->m_useOffsetForConstraintFrame
void* btGeneric6DofSpringConstraint_new(void* p0,void* p1,float* p2,float* p3,int p4); //constructor: btGeneric6DofSpringConstraint  ( ::btGeneric6DofSpringConstraint::* )( ::btRigidBody &,::btRigidBody &,::btTransform const &,::btTransform const &,bool ) 
void btGeneric6DofSpringConstraint_free(void *c); 
int btGeneric6DofSpringConstraint_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btGeneric6DofSpringConstraint::* )(  ) const
void btGeneric6DofSpringConstraint_setEquilibriumPoint(void *c); //method: setEquilibriumPoint void ( ::btGeneric6DofSpringConstraint::* )(  ) 
void btGeneric6DofSpringConstraint_setEquilibriumPoint0(void *c); //method: setEquilibriumPoint void ( ::btGeneric6DofSpringConstraint::* )(  ) 
void btGeneric6DofSpringConstraint_setEquilibriumPoint1(void *c,int p0); //method: setEquilibriumPoint void ( ::btGeneric6DofSpringConstraint::* )( int ) 
void btGeneric6DofSpringConstraint_setEquilibriumPoint2(void *c,int p0,float p1); //method: setEquilibriumPoint void ( ::btGeneric6DofSpringConstraint::* )( int,::btScalar ) 
char const * btGeneric6DofSpringConstraint_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btGeneric6DofSpringConstraint::* )( void *,::btSerializer * ) const
void btGeneric6DofSpringConstraint_enableSpring(void *c,int p0,int p1); //method: enableSpring void ( ::btGeneric6DofSpringConstraint::* )( int,bool ) 
void btGeneric6DofSpringConstraint_setStiffness(void *c,int p0,float p1); //method: setStiffness void ( ::btGeneric6DofSpringConstraint::* )( int,::btScalar ) 
void btGeneric6DofSpringConstraint_setDamping(void *c,int p0,float p1); //method: setDamping void ( ::btGeneric6DofSpringConstraint::* )( int,::btScalar ) 
void btGeneric6DofSpringConstraint_getInfo2(void *c,void* p0); //method: getInfo2 void ( ::btGeneric6DofSpringConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void btGeneric6DofSpringConstraint_internalUpdateSprings(void *c,void* p0); //method: internalUpdateSprings void ( ::btGeneric6DofSpringConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void btGeneric6DofSpringConstraint_setAxis(void *c,float* p0,float* p1); //method: setAxis void ( ::btGeneric6DofSpringConstraint::* )( ::btVector3 const &,::btVector3 const & ) 
// attribute not supported: //attribute: bool[6] btGeneric6DofSpringConstraint->m_springEnabled
// attribute not supported: //attribute: ::btScalar[6] btGeneric6DofSpringConstraint->m_equilibriumPoint
// attribute not supported: //attribute: ::btScalar[6] btGeneric6DofSpringConstraint->m_springStiffness
// attribute not supported: //attribute: ::btScalar[6] btGeneric6DofSpringConstraint->m_springDamping
void* btGeneric6DofSpringConstraintData_new(); //constructor: btGeneric6DofSpringConstraintData  ( ::btGeneric6DofSpringConstraintData::* )(  ) 
void btGeneric6DofSpringConstraintData_free(void *c); 
void btGeneric6DofSpringConstraintData_m_6dofData_set(void *c,void* a); //attribute: ::btGeneric6DofConstraintData btGeneric6DofSpringConstraintData->m_6dofData
void* btGeneric6DofSpringConstraintData_m_6dofData_get(void *c); //attribute: ::btGeneric6DofConstraintData btGeneric6DofSpringConstraintData->m_6dofData
// attribute not supported: //attribute: int[6] btGeneric6DofSpringConstraintData->m_springEnabled
// attribute not supported: //attribute: float[6] btGeneric6DofSpringConstraintData->m_equilibriumPoint
// attribute not supported: //attribute: float[6] btGeneric6DofSpringConstraintData->m_springStiffness
// attribute not supported: //attribute: float[6] btGeneric6DofSpringConstraintData->m_springDamping
void* btHinge2Constraint_new(void* p0,void* p1,float* p2,float* p3,float* p4); //constructor: btHinge2Constraint  ( ::btHinge2Constraint::* )( ::btRigidBody &,::btRigidBody &,::btVector3 &,::btVector3 &,::btVector3 & ) 
void btHinge2Constraint_free(void *c); 
void btHinge2Constraint_setLowerLimit(void *c,float p0); //method: setLowerLimit void ( ::btHinge2Constraint::* )( ::btScalar ) 
void btHinge2Constraint_getAnchor2(void *c,float* ret); //method: getAnchor2 ::btVector3 const & ( ::btHinge2Constraint::* )(  ) 
void btHinge2Constraint_getAxis1(void *c,float* ret); //method: getAxis1 ::btVector3 const & ( ::btHinge2Constraint::* )(  ) 
void btHinge2Constraint_getAnchor(void *c,float* ret); //method: getAnchor ::btVector3 const & ( ::btHinge2Constraint::* )(  ) 
void btHinge2Constraint_getAxis2(void *c,float* ret); //method: getAxis2 ::btVector3 const & ( ::btHinge2Constraint::* )(  ) 
void btHinge2Constraint_setUpperLimit(void *c,float p0); //method: setUpperLimit void ( ::btHinge2Constraint::* )( ::btScalar ) 
float btHinge2Constraint_getAngle2(void *c); //method: getAngle2 ::btScalar ( ::btHinge2Constraint::* )(  ) 
float btHinge2Constraint_getAngle1(void *c); //method: getAngle1 ::btScalar ( ::btHinge2Constraint::* )(  ) 
void btHinge2Constraint_m_anchor_set(void *c,float* a); //attribute: ::btVector3 btHinge2Constraint->m_anchor
void btHinge2Constraint_m_anchor_get(void *c,float* a);
void btHinge2Constraint_m_axis1_set(void *c,float* a); //attribute: ::btVector3 btHinge2Constraint->m_axis1
void btHinge2Constraint_m_axis1_get(void *c,float* a);
void btHinge2Constraint_m_axis2_set(void *c,float* a); //attribute: ::btVector3 btHinge2Constraint->m_axis2
void btHinge2Constraint_m_axis2_get(void *c,float* a);
void* btHingeConstraint_new0(void* p0,void* p1,float* p2,float* p3,float* p4,float* p5,int p6); //constructor: btHingeConstraint  ( ::btHingeConstraint::* )( ::btRigidBody &,::btRigidBody &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,bool ) 
void* btHingeConstraint_new1(void* p0,float* p1,float* p2,int p3); //constructor: btHingeConstraint  ( ::btHingeConstraint::* )( ::btRigidBody &,::btVector3 const &,::btVector3 const &,bool ) 
void* btHingeConstraint_new2(void* p0,void* p1,float* p2,float* p3,int p4); //constructor: btHingeConstraint  ( ::btHingeConstraint::* )( ::btRigidBody &,::btRigidBody &,::btTransform const &,::btTransform const &,bool ) 
void* btHingeConstraint_new3(void* p0,float* p1,int p2); //constructor: btHingeConstraint  ( ::btHingeConstraint::* )( ::btRigidBody &,::btTransform const &,bool ) 
void btHingeConstraint_free(void *c); 
void* btHingeConstraint_getRigidBodyB(void *c); //method: getRigidBodyB ::btRigidBody const & ( ::btHingeConstraint::* )(  ) const
void* btHingeConstraint_getRigidBodyB0(void *c); //method: getRigidBodyB ::btRigidBody const & ( ::btHingeConstraint::* )(  ) const
void* btHingeConstraint_getRigidBodyB1(void *c); //method: getRigidBodyB ::btRigidBody & ( ::btHingeConstraint::* )(  ) 
void btHingeConstraint_getInfo2NonVirtual(void *c,void* p0,float* p1,float* p2,float* p3,float* p4); //method: getInfo2NonVirtual void ( ::btHingeConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const & ) 
void* btHingeConstraint_getRigidBodyA(void *c); //method: getRigidBodyA ::btRigidBody const & ( ::btHingeConstraint::* )(  ) const
void* btHingeConstraint_getRigidBodyA0(void *c); //method: getRigidBodyA ::btRigidBody const & ( ::btHingeConstraint::* )(  ) const
void* btHingeConstraint_getRigidBodyA1(void *c); //method: getRigidBodyA ::btRigidBody & ( ::btHingeConstraint::* )(  ) 
float btHingeConstraint_getMotorTargetVelosity(void *c); //method: getMotorTargetVelosity ::btScalar ( ::btHingeConstraint::* )(  ) 
void btHingeConstraint_getFrameOffsetA(void *c,float* ret); //method: getFrameOffsetA ::btTransform & ( ::btHingeConstraint::* )(  ) 
void btHingeConstraint_getFrameOffsetB(void *c,float* ret); //method: getFrameOffsetB ::btTransform & ( ::btHingeConstraint::* )(  ) 
void btHingeConstraint_buildJacobian(void *c); //method: buildJacobian void ( ::btHingeConstraint::* )(  ) 
void btHingeConstraint_setMaxMotorImpulse(void *c,float p0); //method: setMaxMotorImpulse void ( ::btHingeConstraint::* )( ::btScalar ) 
float btHingeConstraint_getHingeAngle(void *c); //method: getHingeAngle ::btScalar ( ::btHingeConstraint::* )(  ) 
float btHingeConstraint_getHingeAngle0(void *c); //method: getHingeAngle ::btScalar ( ::btHingeConstraint::* )(  ) 
float btHingeConstraint_getHingeAngle1(void *c,float* p0,float* p1); //method: getHingeAngle ::btScalar ( ::btHingeConstraint::* )( ::btTransform const &,::btTransform const & ) 
void btHingeConstraint_testLimit(void *c,float* p0,float* p1); //method: testLimit void ( ::btHingeConstraint::* )( ::btTransform const &,::btTransform const & ) 
void btHingeConstraint_getInfo1(void *c,void* p0); //method: getInfo1 void ( ::btHingeConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btHingeConstraint_getInfo2Internal(void *c,void* p0,float* p1,float* p2,float* p3,float* p4); //method: getInfo2Internal void ( ::btHingeConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const & ) 
void btHingeConstraint_getInfo2(void *c,void* p0); //method: getInfo2 void ( ::btHingeConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
float btHingeConstraint_getUpperLimit(void *c); //method: getUpperLimit ::btScalar ( ::btHingeConstraint::* )(  ) const
void btHingeConstraint_enableAngularMotor(void *c,int p0,float p1,float p2); //method: enableAngularMotor void ( ::btHingeConstraint::* )( bool,::btScalar,::btScalar ) 
float btHingeConstraint_getLimitSign(void *c); //method: getLimitSign ::btScalar ( ::btHingeConstraint::* )(  ) 
int btHingeConstraint_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btHingeConstraint::* )(  ) const
float btHingeConstraint_getMaxMotorImpulse(void *c); //method: getMaxMotorImpulse ::btScalar ( ::btHingeConstraint::* )(  ) 
float btHingeConstraint_getLowerLimit(void *c); //method: getLowerLimit ::btScalar ( ::btHingeConstraint::* )(  ) const
void btHingeConstraint_setParam(void *c,int p0,float p1,int p2); //method: setParam void ( ::btHingeConstraint::* )( int,::btScalar,int ) 
void btHingeConstraint_setUseFrameOffset(void *c,int p0); //method: setUseFrameOffset void ( ::btHingeConstraint::* )( bool ) 
int btHingeConstraint_getEnableAngularMotor(void *c); //method: getEnableAngularMotor bool ( ::btHingeConstraint::* )(  ) 
void btHingeConstraint_enableMotor(void *c,int p0); //method: enableMotor void ( ::btHingeConstraint::* )( bool ) 
void btHingeConstraint_getBFrame(void *c,float* ret); //method: getBFrame ::btTransform const & ( ::btHingeConstraint::* )(  ) const
void btHingeConstraint_getBFrame0(void *c,float* ret); //method: getBFrame ::btTransform const & ( ::btHingeConstraint::* )(  ) const
void btHingeConstraint_getBFrame1(void *c,float* ret); //method: getBFrame ::btTransform & ( ::btHingeConstraint::* )(  ) 
void btHingeConstraint_getInfo1NonVirtual(void *c,void* p0); //method: getInfo1NonVirtual void ( ::btHingeConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btHingeConstraint_getInfo2InternalUsingFrameOffset(void *c,void* p0,float* p1,float* p2,float* p3,float* p4); //method: getInfo2InternalUsingFrameOffset void ( ::btHingeConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const & ) 
char const * btHingeConstraint_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btHingeConstraint::* )( void *,::btSerializer * ) const
int btHingeConstraint_getUseFrameOffset(void *c); //method: getUseFrameOffset bool ( ::btHingeConstraint::* )(  ) 
void btHingeConstraint_setAngularOnly(void *c,int p0); //method: setAngularOnly void ( ::btHingeConstraint::* )( bool ) 
float btHingeConstraint_getParam(void *c,int p0,int p1); //method: getParam ::btScalar ( ::btHingeConstraint::* )( int,int ) const
void btHingeConstraint_setLimit(void *c,float p0,float p1,float p2,float p3,float p4); //method: setLimit void ( ::btHingeConstraint::* )( ::btScalar,::btScalar,::btScalar,::btScalar,::btScalar ) 
int btHingeConstraint_getSolveLimit(void *c); //method: getSolveLimit int ( ::btHingeConstraint::* )(  ) 
void btHingeConstraint_updateRHS(void *c,float p0); //method: updateRHS void ( ::btHingeConstraint::* )( ::btScalar ) 
void btHingeConstraint_setMotorTarget(void *c,float* p0,float p1); //method: setMotorTarget void ( ::btHingeConstraint::* )( ::btQuaternion const &,::btScalar ) 
void btHingeConstraint_setMotorTarget0(void *c,float* p0,float p1); //method: setMotorTarget void ( ::btHingeConstraint::* )( ::btQuaternion const &,::btScalar ) 
void btHingeConstraint_setMotorTarget1(void *c,float p0,float p1); //method: setMotorTarget void ( ::btHingeConstraint::* )( ::btScalar,::btScalar ) 
int btHingeConstraint_getAngularOnly(void *c); //method: getAngularOnly bool ( ::btHingeConstraint::* )(  ) 
void btHingeConstraint_setFrames(void *c,float* p0,float* p1); //method: setFrames void ( ::btHingeConstraint::* )( ::btTransform const &,::btTransform const & ) 
void btHingeConstraint_setAxis(void *c,float* p0); //method: setAxis void ( ::btHingeConstraint::* )( ::btVector3 & ) 
void btHingeConstraint_getAFrame(void *c,float* ret); //method: getAFrame ::btTransform const & ( ::btHingeConstraint::* )(  ) const
void btHingeConstraint_getAFrame0(void *c,float* ret); //method: getAFrame ::btTransform const & ( ::btHingeConstraint::* )(  ) const
void btHingeConstraint_getAFrame1(void *c,float* ret); //method: getAFrame ::btTransform & ( ::btHingeConstraint::* )(  ) 
// attribute not supported: //attribute: ::btJacobianEntry[3] btHingeConstraint->m_jac
// attribute not supported: //attribute: ::btJacobianEntry[3] btHingeConstraint->m_jacAng
void btHingeConstraint_m_rbAFrame_set(void *c,float* a); //attribute: ::btTransform btHingeConstraint->m_rbAFrame
void btHingeConstraint_m_rbAFrame_get(void *c,float* a);
void btHingeConstraint_m_rbBFrame_set(void *c,float* a); //attribute: ::btTransform btHingeConstraint->m_rbBFrame
void btHingeConstraint_m_rbBFrame_get(void *c,float* a);
void btHingeConstraint_m_motorTargetVelocity_set(void *c,float a); //attribute: ::btScalar btHingeConstraint->m_motorTargetVelocity
float btHingeConstraint_m_motorTargetVelocity_get(void *c); //attribute: ::btScalar btHingeConstraint->m_motorTargetVelocity
void btHingeConstraint_m_maxMotorImpulse_set(void *c,float a); //attribute: ::btScalar btHingeConstraint->m_maxMotorImpulse
float btHingeConstraint_m_maxMotorImpulse_get(void *c); //attribute: ::btScalar btHingeConstraint->m_maxMotorImpulse
void btHingeConstraint_m_limit_set(void *c,void* a); //attribute: ::btAngularLimit btHingeConstraint->m_limit
void* btHingeConstraint_m_limit_get(void *c); //attribute: ::btAngularLimit btHingeConstraint->m_limit
void btHingeConstraint_m_kHinge_set(void *c,float a); //attribute: ::btScalar btHingeConstraint->m_kHinge
float btHingeConstraint_m_kHinge_get(void *c); //attribute: ::btScalar btHingeConstraint->m_kHinge
void btHingeConstraint_m_accLimitImpulse_set(void *c,float a); //attribute: ::btScalar btHingeConstraint->m_accLimitImpulse
float btHingeConstraint_m_accLimitImpulse_get(void *c); //attribute: ::btScalar btHingeConstraint->m_accLimitImpulse
void btHingeConstraint_m_hingeAngle_set(void *c,float a); //attribute: ::btScalar btHingeConstraint->m_hingeAngle
float btHingeConstraint_m_hingeAngle_get(void *c); //attribute: ::btScalar btHingeConstraint->m_hingeAngle
void btHingeConstraint_m_referenceSign_set(void *c,float a); //attribute: ::btScalar btHingeConstraint->m_referenceSign
float btHingeConstraint_m_referenceSign_get(void *c); //attribute: ::btScalar btHingeConstraint->m_referenceSign
void btHingeConstraint_m_angularOnly_set(void *c,int a); //attribute: bool btHingeConstraint->m_angularOnly
int btHingeConstraint_m_angularOnly_get(void *c); //attribute: bool btHingeConstraint->m_angularOnly
void btHingeConstraint_m_enableAngularMotor_set(void *c,int a); //attribute: bool btHingeConstraint->m_enableAngularMotor
int btHingeConstraint_m_enableAngularMotor_get(void *c); //attribute: bool btHingeConstraint->m_enableAngularMotor
void btHingeConstraint_m_useSolveConstraintObsolete_set(void *c,int a); //attribute: bool btHingeConstraint->m_useSolveConstraintObsolete
int btHingeConstraint_m_useSolveConstraintObsolete_get(void *c); //attribute: bool btHingeConstraint->m_useSolveConstraintObsolete
void btHingeConstraint_m_useOffsetForConstraintFrame_set(void *c,int a); //attribute: bool btHingeConstraint->m_useOffsetForConstraintFrame
int btHingeConstraint_m_useOffsetForConstraintFrame_get(void *c); //attribute: bool btHingeConstraint->m_useOffsetForConstraintFrame
void btHingeConstraint_m_useReferenceFrameA_set(void *c,int a); //attribute: bool btHingeConstraint->m_useReferenceFrameA
int btHingeConstraint_m_useReferenceFrameA_get(void *c); //attribute: bool btHingeConstraint->m_useReferenceFrameA
void btHingeConstraint_m_accMotorImpulse_set(void *c,float a); //attribute: ::btScalar btHingeConstraint->m_accMotorImpulse
float btHingeConstraint_m_accMotorImpulse_get(void *c); //attribute: ::btScalar btHingeConstraint->m_accMotorImpulse
void btHingeConstraint_m_flags_set(void *c,int a); //attribute: int btHingeConstraint->m_flags
int btHingeConstraint_m_flags_get(void *c); //attribute: int btHingeConstraint->m_flags
void btHingeConstraint_m_normalCFM_set(void *c,float a); //attribute: ::btScalar btHingeConstraint->m_normalCFM
float btHingeConstraint_m_normalCFM_get(void *c); //attribute: ::btScalar btHingeConstraint->m_normalCFM
void btHingeConstraint_m_stopCFM_set(void *c,float a); //attribute: ::btScalar btHingeConstraint->m_stopCFM
float btHingeConstraint_m_stopCFM_get(void *c); //attribute: ::btScalar btHingeConstraint->m_stopCFM
void btHingeConstraint_m_stopERP_set(void *c,float a); //attribute: ::btScalar btHingeConstraint->m_stopERP
float btHingeConstraint_m_stopERP_get(void *c); //attribute: ::btScalar btHingeConstraint->m_stopERP
void* btHingeConstraintDoubleData_new(); //constructor: btHingeConstraintDoubleData  ( ::btHingeConstraintDoubleData::* )(  ) 
void btHingeConstraintDoubleData_free(void *c); 
void btHingeConstraintDoubleData_m_typeConstraintData_set(void *c,void* a); //attribute: ::btTypedConstraintData btHingeConstraintDoubleData->m_typeConstraintData
void* btHingeConstraintDoubleData_m_typeConstraintData_get(void *c); //attribute: ::btTypedConstraintData btHingeConstraintDoubleData->m_typeConstraintData
void btHingeConstraintDoubleData_m_rbAFrame_set(void *c,void* a); //attribute: ::btTransformDoubleData btHingeConstraintDoubleData->m_rbAFrame
void* btHingeConstraintDoubleData_m_rbAFrame_get(void *c); //attribute: ::btTransformDoubleData btHingeConstraintDoubleData->m_rbAFrame
void btHingeConstraintDoubleData_m_rbBFrame_set(void *c,void* a); //attribute: ::btTransformDoubleData btHingeConstraintDoubleData->m_rbBFrame
void* btHingeConstraintDoubleData_m_rbBFrame_get(void *c); //attribute: ::btTransformDoubleData btHingeConstraintDoubleData->m_rbBFrame
void btHingeConstraintDoubleData_m_useReferenceFrameA_set(void *c,int a); //attribute: int btHingeConstraintDoubleData->m_useReferenceFrameA
int btHingeConstraintDoubleData_m_useReferenceFrameA_get(void *c); //attribute: int btHingeConstraintDoubleData->m_useReferenceFrameA
void btHingeConstraintDoubleData_m_angularOnly_set(void *c,int a); //attribute: int btHingeConstraintDoubleData->m_angularOnly
int btHingeConstraintDoubleData_m_angularOnly_get(void *c); //attribute: int btHingeConstraintDoubleData->m_angularOnly
void btHingeConstraintDoubleData_m_enableAngularMotor_set(void *c,int a); //attribute: int btHingeConstraintDoubleData->m_enableAngularMotor
int btHingeConstraintDoubleData_m_enableAngularMotor_get(void *c); //attribute: int btHingeConstraintDoubleData->m_enableAngularMotor
void btHingeConstraintDoubleData_m_motorTargetVelocity_set(void *c,float a); //attribute: float btHingeConstraintDoubleData->m_motorTargetVelocity
float btHingeConstraintDoubleData_m_motorTargetVelocity_get(void *c); //attribute: float btHingeConstraintDoubleData->m_motorTargetVelocity
void btHingeConstraintDoubleData_m_maxMotorImpulse_set(void *c,float a); //attribute: float btHingeConstraintDoubleData->m_maxMotorImpulse
float btHingeConstraintDoubleData_m_maxMotorImpulse_get(void *c); //attribute: float btHingeConstraintDoubleData->m_maxMotorImpulse
void btHingeConstraintDoubleData_m_lowerLimit_set(void *c,float a); //attribute: float btHingeConstraintDoubleData->m_lowerLimit
float btHingeConstraintDoubleData_m_lowerLimit_get(void *c); //attribute: float btHingeConstraintDoubleData->m_lowerLimit
void btHingeConstraintDoubleData_m_upperLimit_set(void *c,float a); //attribute: float btHingeConstraintDoubleData->m_upperLimit
float btHingeConstraintDoubleData_m_upperLimit_get(void *c); //attribute: float btHingeConstraintDoubleData->m_upperLimit
void btHingeConstraintDoubleData_m_limitSoftness_set(void *c,float a); //attribute: float btHingeConstraintDoubleData->m_limitSoftness
float btHingeConstraintDoubleData_m_limitSoftness_get(void *c); //attribute: float btHingeConstraintDoubleData->m_limitSoftness
void btHingeConstraintDoubleData_m_biasFactor_set(void *c,float a); //attribute: float btHingeConstraintDoubleData->m_biasFactor
float btHingeConstraintDoubleData_m_biasFactor_get(void *c); //attribute: float btHingeConstraintDoubleData->m_biasFactor
void btHingeConstraintDoubleData_m_relaxationFactor_set(void *c,float a); //attribute: float btHingeConstraintDoubleData->m_relaxationFactor
float btHingeConstraintDoubleData_m_relaxationFactor_get(void *c); //attribute: float btHingeConstraintDoubleData->m_relaxationFactor
void* btHingeConstraintFloatData_new(); //constructor: btHingeConstraintFloatData  ( ::btHingeConstraintFloatData::* )(  ) 
void btHingeConstraintFloatData_free(void *c); 
void btHingeConstraintFloatData_m_typeConstraintData_set(void *c,void* a); //attribute: ::btTypedConstraintData btHingeConstraintFloatData->m_typeConstraintData
void* btHingeConstraintFloatData_m_typeConstraintData_get(void *c); //attribute: ::btTypedConstraintData btHingeConstraintFloatData->m_typeConstraintData
void btHingeConstraintFloatData_m_rbAFrame_set(void *c,void* a); //attribute: ::btTransformFloatData btHingeConstraintFloatData->m_rbAFrame
void* btHingeConstraintFloatData_m_rbAFrame_get(void *c); //attribute: ::btTransformFloatData btHingeConstraintFloatData->m_rbAFrame
void btHingeConstraintFloatData_m_rbBFrame_set(void *c,void* a); //attribute: ::btTransformFloatData btHingeConstraintFloatData->m_rbBFrame
void* btHingeConstraintFloatData_m_rbBFrame_get(void *c); //attribute: ::btTransformFloatData btHingeConstraintFloatData->m_rbBFrame
void btHingeConstraintFloatData_m_useReferenceFrameA_set(void *c,int a); //attribute: int btHingeConstraintFloatData->m_useReferenceFrameA
int btHingeConstraintFloatData_m_useReferenceFrameA_get(void *c); //attribute: int btHingeConstraintFloatData->m_useReferenceFrameA
void btHingeConstraintFloatData_m_angularOnly_set(void *c,int a); //attribute: int btHingeConstraintFloatData->m_angularOnly
int btHingeConstraintFloatData_m_angularOnly_get(void *c); //attribute: int btHingeConstraintFloatData->m_angularOnly
void btHingeConstraintFloatData_m_enableAngularMotor_set(void *c,int a); //attribute: int btHingeConstraintFloatData->m_enableAngularMotor
int btHingeConstraintFloatData_m_enableAngularMotor_get(void *c); //attribute: int btHingeConstraintFloatData->m_enableAngularMotor
void btHingeConstraintFloatData_m_motorTargetVelocity_set(void *c,float a); //attribute: float btHingeConstraintFloatData->m_motorTargetVelocity
float btHingeConstraintFloatData_m_motorTargetVelocity_get(void *c); //attribute: float btHingeConstraintFloatData->m_motorTargetVelocity
void btHingeConstraintFloatData_m_maxMotorImpulse_set(void *c,float a); //attribute: float btHingeConstraintFloatData->m_maxMotorImpulse
float btHingeConstraintFloatData_m_maxMotorImpulse_get(void *c); //attribute: float btHingeConstraintFloatData->m_maxMotorImpulse
void btHingeConstraintFloatData_m_lowerLimit_set(void *c,float a); //attribute: float btHingeConstraintFloatData->m_lowerLimit
float btHingeConstraintFloatData_m_lowerLimit_get(void *c); //attribute: float btHingeConstraintFloatData->m_lowerLimit
void btHingeConstraintFloatData_m_upperLimit_set(void *c,float a); //attribute: float btHingeConstraintFloatData->m_upperLimit
float btHingeConstraintFloatData_m_upperLimit_get(void *c); //attribute: float btHingeConstraintFloatData->m_upperLimit
void btHingeConstraintFloatData_m_limitSoftness_set(void *c,float a); //attribute: float btHingeConstraintFloatData->m_limitSoftness
float btHingeConstraintFloatData_m_limitSoftness_get(void *c); //attribute: float btHingeConstraintFloatData->m_limitSoftness
void btHingeConstraintFloatData_m_biasFactor_set(void *c,float a); //attribute: float btHingeConstraintFloatData->m_biasFactor
float btHingeConstraintFloatData_m_biasFactor_get(void *c); //attribute: float btHingeConstraintFloatData->m_biasFactor
void btHingeConstraintFloatData_m_relaxationFactor_set(void *c,float a); //attribute: float btHingeConstraintFloatData->m_relaxationFactor
float btHingeConstraintFloatData_m_relaxationFactor_get(void *c); //attribute: float btHingeConstraintFloatData->m_relaxationFactor
void* btJacobianEntry_new0(); //constructor: btJacobianEntry  ( ::btJacobianEntry::* )(  ) 
//not supported constructor: btJacobianEntry  ( ::btJacobianEntry::* )( ::btMatrix3x3 const &,::btMatrix3x3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar const,::btVector3 const &,::btScalar const ) 
// error: ::btMatrix3x3 const & - ok, ::btMatrix3x3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported, ::btVector3 const & - ok,  - unsupported

void* btJacobianEntry_new2(float* p0,float* p1,float* p2,float* p3,float* p4); //constructor: btJacobianEntry  ( ::btJacobianEntry::* )( ::btVector3 const &,::btMatrix3x3 const &,::btMatrix3x3 const &,::btVector3 const &,::btVector3 const & ) 
void* btJacobianEntry_new3(float* p0,float* p1,float* p2,float* p3); //constructor: btJacobianEntry  ( ::btJacobianEntry::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
//not supported constructor: btJacobianEntry  ( ::btJacobianEntry::* )( ::btMatrix3x3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar const ) 
// error: ::btMatrix3x3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported

void btJacobianEntry_free(void *c); 
float btJacobianEntry_getDiagonal(void *c); //method: getDiagonal ::btScalar ( ::btJacobianEntry::* )(  ) const
float btJacobianEntry_getRelativeVelocity(void *c,float* p0,float* p1,float* p2,float* p3); //method: getRelativeVelocity ::btScalar ( ::btJacobianEntry::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
//not supported method: getNonDiagonal ::btScalar ( ::btJacobianEntry::* )( ::btJacobianEntry const &,::btScalar const ) const
// error: ::btJacobianEntry const & - ok,  - unsupported, ::btScalar - ok

//not supported method: getNonDiagonal ::btScalar ( ::btJacobianEntry::* )( ::btJacobianEntry const &,::btScalar const ) const
// error: ::btJacobianEntry const & - ok,  - unsupported, ::btScalar - ok

//not supported method: getNonDiagonal ::btScalar ( ::btJacobianEntry::* )( ::btJacobianEntry const &,::btScalar const,::btScalar const ) const
// error: ::btJacobianEntry const & - ok,  - unsupported,  - unsupported, ::btScalar - ok

void btJacobianEntry_m_0MinvJt_set(void *c,float* a); //attribute: ::btVector3 btJacobianEntry->m_0MinvJt
void btJacobianEntry_m_0MinvJt_get(void *c,float* a);
void btJacobianEntry_m_1MinvJt_set(void *c,float* a); //attribute: ::btVector3 btJacobianEntry->m_1MinvJt
void btJacobianEntry_m_1MinvJt_get(void *c,float* a);
void btJacobianEntry_m_Adiag_set(void *c,float a); //attribute: ::btScalar btJacobianEntry->m_Adiag
float btJacobianEntry_m_Adiag_get(void *c); //attribute: ::btScalar btJacobianEntry->m_Adiag
void btJacobianEntry_m_aJ_set(void *c,float* a); //attribute: ::btVector3 btJacobianEntry->m_aJ
void btJacobianEntry_m_aJ_get(void *c,float* a);
void btJacobianEntry_m_bJ_set(void *c,float* a); //attribute: ::btVector3 btJacobianEntry->m_bJ
void btJacobianEntry_m_bJ_get(void *c,float* a);
void btJacobianEntry_m_linearJointAxis_set(void *c,float* a); //attribute: ::btVector3 btJacobianEntry->m_linearJointAxis
void btJacobianEntry_m_linearJointAxis_get(void *c,float* a);
void* btPoint2PointConstraint_new0(void* p0,void* p1,float* p2,float* p3); //constructor: btPoint2PointConstraint  ( ::btPoint2PointConstraint::* )( ::btRigidBody &,::btRigidBody &,::btVector3 const &,::btVector3 const & ) 
void* btPoint2PointConstraint_new1(void* p0,float* p1); //constructor: btPoint2PointConstraint  ( ::btPoint2PointConstraint::* )( ::btRigidBody &,::btVector3 const & ) 
void btPoint2PointConstraint_free(void *c); 
void btPoint2PointConstraint_getInfo1NonVirtual(void *c,void* p0); //method: getInfo1NonVirtual void ( ::btPoint2PointConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btPoint2PointConstraint_getInfo2NonVirtual(void *c,void* p0,float* p1,float* p2); //method: getInfo2NonVirtual void ( ::btPoint2PointConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,::btTransform const &,::btTransform const & ) 
void btPoint2PointConstraint_setParam(void *c,int p0,float p1,int p2); //method: setParam void ( ::btPoint2PointConstraint::* )( int,::btScalar,int ) 
void btPoint2PointConstraint_getPivotInA(void *c,float* ret); //method: getPivotInA ::btVector3 const & ( ::btPoint2PointConstraint::* )(  ) const
void btPoint2PointConstraint_getPivotInB(void *c,float* ret); //method: getPivotInB ::btVector3 const & ( ::btPoint2PointConstraint::* )(  ) const
void btPoint2PointConstraint_updateRHS(void *c,float p0); //method: updateRHS void ( ::btPoint2PointConstraint::* )( ::btScalar ) 
char const * btPoint2PointConstraint_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btPoint2PointConstraint::* )( void *,::btSerializer * ) const
void btPoint2PointConstraint_buildJacobian(void *c); //method: buildJacobian void ( ::btPoint2PointConstraint::* )(  ) 
int btPoint2PointConstraint_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btPoint2PointConstraint::* )(  ) const
float btPoint2PointConstraint_getParam(void *c,int p0,int p1); //method: getParam ::btScalar ( ::btPoint2PointConstraint::* )( int,int ) const
void btPoint2PointConstraint_getInfo1(void *c,void* p0); //method: getInfo1 void ( ::btPoint2PointConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btPoint2PointConstraint_getInfo2(void *c,void* p0); //method: getInfo2 void ( ::btPoint2PointConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void btPoint2PointConstraint_setPivotA(void *c,float* p0); //method: setPivotA void ( ::btPoint2PointConstraint::* )( ::btVector3 const & ) 
void btPoint2PointConstraint_setPivotB(void *c,float* p0); //method: setPivotB void ( ::btPoint2PointConstraint::* )( ::btVector3 const & ) 
// attribute not supported: //attribute: ::btJacobianEntry[3] btPoint2PointConstraint->m_jac
void btPoint2PointConstraint_m_pivotInA_set(void *c,float* a); //attribute: ::btVector3 btPoint2PointConstraint->m_pivotInA
void btPoint2PointConstraint_m_pivotInA_get(void *c,float* a);
void btPoint2PointConstraint_m_pivotInB_set(void *c,float* a); //attribute: ::btVector3 btPoint2PointConstraint->m_pivotInB
void btPoint2PointConstraint_m_pivotInB_get(void *c,float* a);
void btPoint2PointConstraint_m_flags_set(void *c,int a); //attribute: int btPoint2PointConstraint->m_flags
int btPoint2PointConstraint_m_flags_get(void *c); //attribute: int btPoint2PointConstraint->m_flags
void btPoint2PointConstraint_m_erp_set(void *c,float a); //attribute: ::btScalar btPoint2PointConstraint->m_erp
float btPoint2PointConstraint_m_erp_get(void *c); //attribute: ::btScalar btPoint2PointConstraint->m_erp
void btPoint2PointConstraint_m_cfm_set(void *c,float a); //attribute: ::btScalar btPoint2PointConstraint->m_cfm
float btPoint2PointConstraint_m_cfm_get(void *c); //attribute: ::btScalar btPoint2PointConstraint->m_cfm
void btPoint2PointConstraint_m_useSolveConstraintObsolete_set(void *c,int a); //attribute: bool btPoint2PointConstraint->m_useSolveConstraintObsolete
int btPoint2PointConstraint_m_useSolveConstraintObsolete_get(void *c); //attribute: bool btPoint2PointConstraint->m_useSolveConstraintObsolete
void btPoint2PointConstraint_m_setting_set(void *c,void* a); //attribute: ::btConstraintSetting btPoint2PointConstraint->m_setting
void* btPoint2PointConstraint_m_setting_get(void *c); //attribute: ::btConstraintSetting btPoint2PointConstraint->m_setting
void* btPoint2PointConstraintDoubleData_new(); //constructor: btPoint2PointConstraintDoubleData  ( ::btPoint2PointConstraintDoubleData::* )(  ) 
void btPoint2PointConstraintDoubleData_free(void *c); 
void btPoint2PointConstraintDoubleData_m_typeConstraintData_set(void *c,void* a); //attribute: ::btTypedConstraintData btPoint2PointConstraintDoubleData->m_typeConstraintData
void* btPoint2PointConstraintDoubleData_m_typeConstraintData_get(void *c); //attribute: ::btTypedConstraintData btPoint2PointConstraintDoubleData->m_typeConstraintData
void btPoint2PointConstraintDoubleData_m_pivotInA_set(void *c,void* a); //attribute: ::btVector3DoubleData btPoint2PointConstraintDoubleData->m_pivotInA
void* btPoint2PointConstraintDoubleData_m_pivotInA_get(void *c); //attribute: ::btVector3DoubleData btPoint2PointConstraintDoubleData->m_pivotInA
void btPoint2PointConstraintDoubleData_m_pivotInB_set(void *c,void* a); //attribute: ::btVector3DoubleData btPoint2PointConstraintDoubleData->m_pivotInB
void* btPoint2PointConstraintDoubleData_m_pivotInB_get(void *c); //attribute: ::btVector3DoubleData btPoint2PointConstraintDoubleData->m_pivotInB
void* btPoint2PointConstraintFloatData_new(); //constructor: btPoint2PointConstraintFloatData  ( ::btPoint2PointConstraintFloatData::* )(  ) 
void btPoint2PointConstraintFloatData_free(void *c); 
void btPoint2PointConstraintFloatData_m_typeConstraintData_set(void *c,void* a); //attribute: ::btTypedConstraintData btPoint2PointConstraintFloatData->m_typeConstraintData
void* btPoint2PointConstraintFloatData_m_typeConstraintData_get(void *c); //attribute: ::btTypedConstraintData btPoint2PointConstraintFloatData->m_typeConstraintData
void btPoint2PointConstraintFloatData_m_pivotInA_set(void *c,void* a); //attribute: ::btVector3FloatData btPoint2PointConstraintFloatData->m_pivotInA
void* btPoint2PointConstraintFloatData_m_pivotInA_get(void *c); //attribute: ::btVector3FloatData btPoint2PointConstraintFloatData->m_pivotInA
void btPoint2PointConstraintFloatData_m_pivotInB_set(void *c,void* a); //attribute: ::btVector3FloatData btPoint2PointConstraintFloatData->m_pivotInB
void* btPoint2PointConstraintFloatData_m_pivotInB_get(void *c); //attribute: ::btVector3FloatData btPoint2PointConstraintFloatData->m_pivotInB
void* btRotationalLimitMotor_new(); //constructor: btRotationalLimitMotor  ( ::btRotationalLimitMotor::* )(  ) 
void btRotationalLimitMotor_free(void *c); 
int btRotationalLimitMotor_testLimitValue(void *c,float p0); //method: testLimitValue int ( ::btRotationalLimitMotor::* )( ::btScalar ) 
float btRotationalLimitMotor_solveAngularLimits(void *c,float p0,float* p1,float p2,void* p3,void* p4); //method: solveAngularLimits ::btScalar ( ::btRotationalLimitMotor::* )( ::btScalar,::btVector3 &,::btScalar,::btRigidBody *,::btRigidBody * ) 
int btRotationalLimitMotor_needApplyTorques(void *c); //method: needApplyTorques bool ( ::btRotationalLimitMotor::* )(  ) 
int btRotationalLimitMotor_isLimited(void *c); //method: isLimited bool ( ::btRotationalLimitMotor::* )(  ) 
void btRotationalLimitMotor_m_accumulatedImpulse_set(void *c,float a); //attribute: ::btScalar btRotationalLimitMotor->m_accumulatedImpulse
float btRotationalLimitMotor_m_accumulatedImpulse_get(void *c); //attribute: ::btScalar btRotationalLimitMotor->m_accumulatedImpulse
void btRotationalLimitMotor_m_bounce_set(void *c,float a); //attribute: ::btScalar btRotationalLimitMotor->m_bounce
float btRotationalLimitMotor_m_bounce_get(void *c); //attribute: ::btScalar btRotationalLimitMotor->m_bounce
void btRotationalLimitMotor_m_currentLimit_set(void *c,int a); //attribute: int btRotationalLimitMotor->m_currentLimit
int btRotationalLimitMotor_m_currentLimit_get(void *c); //attribute: int btRotationalLimitMotor->m_currentLimit
void btRotationalLimitMotor_m_currentLimitError_set(void *c,float a); //attribute: ::btScalar btRotationalLimitMotor->m_currentLimitError
float btRotationalLimitMotor_m_currentLimitError_get(void *c); //attribute: ::btScalar btRotationalLimitMotor->m_currentLimitError
void btRotationalLimitMotor_m_currentPosition_set(void *c,float a); //attribute: ::btScalar btRotationalLimitMotor->m_currentPosition
float btRotationalLimitMotor_m_currentPosition_get(void *c); //attribute: ::btScalar btRotationalLimitMotor->m_currentPosition
void btRotationalLimitMotor_m_damping_set(void *c,float a); //attribute: ::btScalar btRotationalLimitMotor->m_damping
float btRotationalLimitMotor_m_damping_get(void *c); //attribute: ::btScalar btRotationalLimitMotor->m_damping
void btRotationalLimitMotor_m_enableMotor_set(void *c,int a); //attribute: bool btRotationalLimitMotor->m_enableMotor
int btRotationalLimitMotor_m_enableMotor_get(void *c); //attribute: bool btRotationalLimitMotor->m_enableMotor
void btRotationalLimitMotor_m_hiLimit_set(void *c,float a); //attribute: ::btScalar btRotationalLimitMotor->m_hiLimit
float btRotationalLimitMotor_m_hiLimit_get(void *c); //attribute: ::btScalar btRotationalLimitMotor->m_hiLimit
void btRotationalLimitMotor_m_limitSoftness_set(void *c,float a); //attribute: ::btScalar btRotationalLimitMotor->m_limitSoftness
float btRotationalLimitMotor_m_limitSoftness_get(void *c); //attribute: ::btScalar btRotationalLimitMotor->m_limitSoftness
void btRotationalLimitMotor_m_loLimit_set(void *c,float a); //attribute: ::btScalar btRotationalLimitMotor->m_loLimit
float btRotationalLimitMotor_m_loLimit_get(void *c); //attribute: ::btScalar btRotationalLimitMotor->m_loLimit
void btRotationalLimitMotor_m_maxLimitForce_set(void *c,float a); //attribute: ::btScalar btRotationalLimitMotor->m_maxLimitForce
float btRotationalLimitMotor_m_maxLimitForce_get(void *c); //attribute: ::btScalar btRotationalLimitMotor->m_maxLimitForce
void btRotationalLimitMotor_m_maxMotorForce_set(void *c,float a); //attribute: ::btScalar btRotationalLimitMotor->m_maxMotorForce
float btRotationalLimitMotor_m_maxMotorForce_get(void *c); //attribute: ::btScalar btRotationalLimitMotor->m_maxMotorForce
void btRotationalLimitMotor_m_normalCFM_set(void *c,float a); //attribute: ::btScalar btRotationalLimitMotor->m_normalCFM
float btRotationalLimitMotor_m_normalCFM_get(void *c); //attribute: ::btScalar btRotationalLimitMotor->m_normalCFM
void btRotationalLimitMotor_m_stopCFM_set(void *c,float a); //attribute: ::btScalar btRotationalLimitMotor->m_stopCFM
float btRotationalLimitMotor_m_stopCFM_get(void *c); //attribute: ::btScalar btRotationalLimitMotor->m_stopCFM
void btRotationalLimitMotor_m_stopERP_set(void *c,float a); //attribute: ::btScalar btRotationalLimitMotor->m_stopERP
float btRotationalLimitMotor_m_stopERP_get(void *c); //attribute: ::btScalar btRotationalLimitMotor->m_stopERP
void btRotationalLimitMotor_m_targetVelocity_set(void *c,float a); //attribute: ::btScalar btRotationalLimitMotor->m_targetVelocity
float btRotationalLimitMotor_m_targetVelocity_get(void *c); //attribute: ::btScalar btRotationalLimitMotor->m_targetVelocity
void* btSequentialImpulseConstraintSolver_new(); //constructor: btSequentialImpulseConstraintSolver  ( ::btSequentialImpulseConstraintSolver::* )(  ) 
void btSequentialImpulseConstraintSolver_free(void *c); 
void btSequentialImpulseConstraintSolver_convertContact(void *c,void* p0,void* p1); //method: convertContact void ( ::btSequentialImpulseConstraintSolver::* )( ::btPersistentManifold *,::btContactSolverInfo const & ) 
void btSequentialImpulseConstraintSolver_setRandSeed(void *c,long unsigned int p0); //method: setRandSeed void ( ::btSequentialImpulseConstraintSolver::* )( long unsigned int ) 
//not supported method: solveGroupCacheFriendlyIterations ::btScalar ( ::btSequentialImpulseConstraintSolver::* )( ::btCollisionObject * *,int,::btPersistentManifold * *,int,::btTypedConstraint * *,int,::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc * ) 
// error:  - unsupported, int - ok,  - unsupported, int - ok,  - unsupported, int - ok, ::btContactSolverInfo const & - ok, ::btIDebugDraw * - ok, ::btStackAlloc * - ok, ::btScalar - ok

//not supported method: solveSingleIteration ::btScalar ( ::btSequentialImpulseConstraintSolver::* )( int,::btCollisionObject * *,int,::btPersistentManifold * *,int,::btTypedConstraint * *,int,::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc * ) 
// error: int - ok,  - unsupported, int - ok,  - unsupported, int - ok,  - unsupported, int - ok, ::btContactSolverInfo const & - ok, ::btIDebugDraw * - ok, ::btStackAlloc * - ok, ::btScalar - ok

//not supported method: solveGroupCacheFriendlyFinish ::btScalar ( ::btSequentialImpulseConstraintSolver::* )( ::btCollisionObject * *,int,::btPersistentManifold * *,int,::btTypedConstraint * *,int,::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc * ) 
// error:  - unsupported, int - ok,  - unsupported, int - ok,  - unsupported, int - ok, ::btContactSolverInfo const & - ok, ::btIDebugDraw * - ok, ::btStackAlloc * - ok, ::btScalar - ok

void* btSequentialImpulseConstraintSolver_getFixedBody(); //method: getFixedBody ::btRigidBody & (*)(  )
void btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimitSIMD(void *c,void* p0,void* p1,void* p2); //method: resolveSingleConstraintRowLowerLimitSIMD void ( ::btSequentialImpulseConstraintSolver::* )( ::btRigidBody &,::btRigidBody &,::btSolverConstraint const & ) 
//not supported method: solveGroupCacheFriendlySplitImpulseIterations void ( ::btSequentialImpulseConstraintSolver::* )( ::btCollisionObject * *,int,::btPersistentManifold * *,int,::btTypedConstraint * *,int,::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc * ) 
// error:  - unsupported, int - ok,  - unsupported, int - ok,  - unsupported, int - ok, ::btContactSolverInfo const & - ok, ::btIDebugDraw * - ok, ::btStackAlloc * - ok, void - ok

//not supported method: solveGroupCacheFriendlySetup ::btScalar ( ::btSequentialImpulseConstraintSolver::* )( ::btCollisionObject * *,int,::btPersistentManifold * *,int,::btTypedConstraint * *,int,::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc * ) 
// error:  - unsupported, int - ok,  - unsupported, int - ok,  - unsupported, int - ok, ::btContactSolverInfo const & - ok, ::btIDebugDraw * - ok, ::btStackAlloc * - ok, ::btScalar - ok

//not supported method: setupContactConstraint void ( ::btSequentialImpulseConstraintSolver::* )( ::btSolverConstraint &,::btCollisionObject *,::btCollisionObject *,::btManifoldPoint &,::btContactSolverInfo const &,::btVector3 &,::btScalar &,::btScalar &,::btVector3 &,::btVector3 & ) 
// error: ::btSolverConstraint & - ok, ::btCollisionObject * - ok, ::btCollisionObject * - ok, ::btManifoldPoint & - ok, ::btContactSolverInfo const & - ok, ::btVector3 & - ok,  - unsupported,  - unsupported, ::btVector3 & - ok, ::btVector3 & - ok, void - ok

long unsigned int btSequentialImpulseConstraintSolver_btRand2(void *c); //method: btRand2 long unsigned int ( ::btSequentialImpulseConstraintSolver::* )(  ) 
void btSequentialImpulseConstraintSolver_setFrictionConstraintImpulse(void *c,void* p0,void* p1,void* p2,void* p3,void* p4); //method: setFrictionConstraintImpulse void ( ::btSequentialImpulseConstraintSolver::* )( ::btSolverConstraint &,::btRigidBody *,::btRigidBody *,::btManifoldPoint &,::btContactSolverInfo const & ) 
int btSequentialImpulseConstraintSolver_getOrInitSolverBody(void *c,void* p0); //method: getOrInitSolverBody int ( ::btSequentialImpulseConstraintSolver::* )( ::btCollisionObject & ) 
void btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGenericSIMD(void *c,void* p0,void* p1,void* p2); //method: resolveSingleConstraintRowGenericSIMD void ( ::btSequentialImpulseConstraintSolver::* )( ::btRigidBody &,::btRigidBody &,::btSolverConstraint const & ) 
int btSequentialImpulseConstraintSolver_btRandInt2(void *c,int p0); //method: btRandInt2 int ( ::btSequentialImpulseConstraintSolver::* )( int ) 
void btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimit(void *c,void* p0,void* p1,void* p2); //method: resolveSingleConstraintRowLowerLimit void ( ::btSequentialImpulseConstraintSolver::* )( ::btRigidBody &,::btRigidBody &,::btSolverConstraint const & ) 
void btSequentialImpulseConstraintSolver_reset(void *c); //method: reset void ( ::btSequentialImpulseConstraintSolver::* )(  ) 
void btSequentialImpulseConstraintSolver_resolveSplitPenetrationImpulseCacheFriendly(void *c,void* p0,void* p1,void* p2); //method: resolveSplitPenetrationImpulseCacheFriendly void ( ::btSequentialImpulseConstraintSolver::* )( ::btRigidBody &,::btRigidBody &,::btSolverConstraint const & ) 
void btSequentialImpulseConstraintSolver_setupFrictionConstraint(void *c,void* p0,float* p1,void* p2,void* p3,void* p4,float* p5,float* p6,void* p7,void* p8,float p9,float p10,float p11); //method: setupFrictionConstraint void ( ::btSequentialImpulseConstraintSolver::* )( ::btSolverConstraint &,::btVector3 const &,::btRigidBody *,::btRigidBody *,::btManifoldPoint &,::btVector3 const &,::btVector3 const &,::btCollisionObject *,::btCollisionObject *,::btScalar,::btScalar,::btScalar ) 
long unsigned int btSequentialImpulseConstraintSolver_getRandSeed(void *c); //method: getRandSeed long unsigned int ( ::btSequentialImpulseConstraintSolver::* )(  ) const
void* btSequentialImpulseConstraintSolver_addFrictionConstraint(void *c,float* p0,void* p1,void* p2,int p3,void* p4,float* p5,float* p6,void* p7,void* p8,float p9,float p10,float p11); //method: addFrictionConstraint ::btSolverConstraint & ( ::btSequentialImpulseConstraintSolver::* )( ::btVector3 const &,::btRigidBody *,::btRigidBody *,int,::btManifoldPoint &,::btVector3 const &,::btVector3 const &,::btCollisionObject *,::btCollisionObject *,::btScalar,::btScalar,::btScalar ) 
float btSequentialImpulseConstraintSolver_restitutionCurve(void *c,float p0,float p1); //method: restitutionCurve ::btScalar ( ::btSequentialImpulseConstraintSolver::* )( ::btScalar,::btScalar ) 
//not supported method: solveGroup ::btScalar ( ::btSequentialImpulseConstraintSolver::* )( ::btCollisionObject * *,int,::btPersistentManifold * *,int,::btTypedConstraint * *,int,::btContactSolverInfo const &,::btIDebugDraw *,::btStackAlloc *,::btDispatcher * ) 
// error:  - unsupported, int - ok,  - unsupported, int - ok,  - unsupported, int - ok, ::btContactSolverInfo const & - ok, ::btIDebugDraw * - ok, ::btStackAlloc * - ok, ::btDispatcher * - ok, ::btScalar - ok

void btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGeneric(void *c,void* p0,void* p1,void* p2); //method: resolveSingleConstraintRowGeneric void ( ::btSequentialImpulseConstraintSolver::* )( ::btRigidBody &,::btRigidBody &,::btSolverConstraint const & ) 
void btSequentialImpulseConstraintSolver_resolveSplitPenetrationSIMD(void *c,void* p0,void* p1,void* p2); //method: resolveSplitPenetrationSIMD void ( ::btSequentialImpulseConstraintSolver::* )( ::btRigidBody &,::btRigidBody &,::btSolverConstraint const & ) 
void btSequentialImpulseConstraintSolver_m_tmpSolverContactConstraintPool_set(void *c,void* a); //attribute: ::btConstraintArray btSequentialImpulseConstraintSolver->m_tmpSolverContactConstraintPool
void* btSequentialImpulseConstraintSolver_m_tmpSolverContactConstraintPool_get(void *c); //attribute: ::btConstraintArray btSequentialImpulseConstraintSolver->m_tmpSolverContactConstraintPool
void btSequentialImpulseConstraintSolver_m_tmpSolverNonContactConstraintPool_set(void *c,void* a); //attribute: ::btConstraintArray btSequentialImpulseConstraintSolver->m_tmpSolverNonContactConstraintPool
void* btSequentialImpulseConstraintSolver_m_tmpSolverNonContactConstraintPool_get(void *c); //attribute: ::btConstraintArray btSequentialImpulseConstraintSolver->m_tmpSolverNonContactConstraintPool
void btSequentialImpulseConstraintSolver_m_tmpSolverContactFrictionConstraintPool_set(void *c,void* a); //attribute: ::btConstraintArray btSequentialImpulseConstraintSolver->m_tmpSolverContactFrictionConstraintPool
void* btSequentialImpulseConstraintSolver_m_tmpSolverContactFrictionConstraintPool_get(void *c); //attribute: ::btConstraintArray btSequentialImpulseConstraintSolver->m_tmpSolverContactFrictionConstraintPool
void btSequentialImpulseConstraintSolver_m_orderTmpConstraintPool_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btSequentialImpulseConstraintSolver->m_orderTmpConstraintPool
void* btSequentialImpulseConstraintSolver_m_orderTmpConstraintPool_get(void *c); //attribute: ::btAlignedObjectArray<int> btSequentialImpulseConstraintSolver->m_orderTmpConstraintPool
void btSequentialImpulseConstraintSolver_m_orderFrictionConstraintPool_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btSequentialImpulseConstraintSolver->m_orderFrictionConstraintPool
void* btSequentialImpulseConstraintSolver_m_orderFrictionConstraintPool_get(void *c); //attribute: ::btAlignedObjectArray<int> btSequentialImpulseConstraintSolver->m_orderFrictionConstraintPool
void btSequentialImpulseConstraintSolver_m_tmpConstraintSizesPool_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1> btSequentialImpulseConstraintSolver->m_tmpConstraintSizesPool
void* btSequentialImpulseConstraintSolver_m_tmpConstraintSizesPool_get(void *c); //attribute: ::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1> btSequentialImpulseConstraintSolver->m_tmpConstraintSizesPool
void btSequentialImpulseConstraintSolver_m_btSeed2_set(void *c,long unsigned int a); //attribute: long unsigned int btSequentialImpulseConstraintSolver->m_btSeed2
long unsigned int btSequentialImpulseConstraintSolver_m_btSeed2_get(void *c); //attribute: long unsigned int btSequentialImpulseConstraintSolver->m_btSeed2
void* btSliderConstraint_new0(void* p0,void* p1,float* p2,float* p3,int p4); //constructor: btSliderConstraint  ( ::btSliderConstraint::* )( ::btRigidBody &,::btRigidBody &,::btTransform const &,::btTransform const &,bool ) 
void* btSliderConstraint_new1(void* p0,float* p1,int p2); //constructor: btSliderConstraint  ( ::btSliderConstraint::* )( ::btRigidBody &,::btTransform const &,bool ) 
void btSliderConstraint_free(void *c); 
void* btSliderConstraint_getRigidBodyB(void *c); //method: getRigidBodyB ::btRigidBody const & ( ::btSliderConstraint::* )(  ) const
void* btSliderConstraint_getRigidBodyA(void *c); //method: getRigidBodyA ::btRigidBody const & ( ::btSliderConstraint::* )(  ) const
float btSliderConstraint_getAngDepth(void *c); //method: getAngDepth ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getTargetAngMotorVelocity(void *c); //method: getTargetAngMotorVelocity ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getAngularPos(void *c); //method: getAngularPos ::btScalar ( ::btSliderConstraint::* )(  ) const
void btSliderConstraint_setRestitutionLimAng(void *c,float p0); //method: setRestitutionLimAng void ( ::btSliderConstraint::* )( ::btScalar ) 
float btSliderConstraint_getParam(void *c,int p0,int p1); //method: getParam ::btScalar ( ::btSliderConstraint::* )( int,int ) const
void btSliderConstraint_getInfo1(void *c,void* p0); //method: getInfo1 void ( ::btSliderConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btSliderConstraint_getInfo2(void *c,void* p0); //method: getInfo2 void ( ::btSliderConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
int btSliderConstraint_getPoweredLinMotor(void *c); //method: getPoweredLinMotor bool ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setUseFrameOffset(void *c,int p0); //method: setUseFrameOffset void ( ::btSliderConstraint::* )( bool ) 
void btSliderConstraint_setSoftnessLimLin(void *c,float p0); //method: setSoftnessLimLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_getAncorInA(void *c,float* ret); //method: getAncorInA ::btVector3 ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_getAncorInB(void *c,float* ret); //method: getAncorInB ::btVector3 ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setDampingDirAng(void *c,float p0); //method: setDampingDirAng void ( ::btSliderConstraint::* )( ::btScalar ) 
int btSliderConstraint_getSolveLinLimit(void *c); //method: getSolveLinLimit bool ( ::btSliderConstraint::* )(  ) 
int btSliderConstraint_getUseFrameOffset(void *c); //method: getUseFrameOffset bool ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getMaxAngMotorForce(void *c); //method: getMaxAngMotorForce ::btScalar ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setRestitutionDirAng(void *c,float p0); //method: setRestitutionDirAng void ( ::btSliderConstraint::* )( ::btScalar ) 
float btSliderConstraint_getMaxLinMotorForce(void *c); //method: getMaxLinMotorForce ::btScalar ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setDampingOrthoLin(void *c,float p0); //method: setDampingOrthoLin void ( ::btSliderConstraint::* )( ::btScalar ) 
int btSliderConstraint_getSolveAngLimit(void *c); //method: getSolveAngLimit bool ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setPoweredAngMotor(void *c,int p0); //method: setPoweredAngMotor void ( ::btSliderConstraint::* )( bool ) 
float btSliderConstraint_getLinearPos(void *c); //method: getLinearPos ::btScalar ( ::btSliderConstraint::* )(  ) const
void btSliderConstraint_getCalculatedTransformB(void *c,float* ret); //method: getCalculatedTransformB ::btTransform const & ( ::btSliderConstraint::* )(  ) const
void btSliderConstraint_getCalculatedTransformA(void *c,float* ret); //method: getCalculatedTransformA ::btTransform const & ( ::btSliderConstraint::* )(  ) const
void btSliderConstraint_testAngLimits(void *c); //method: testAngLimits void ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setDampingDirLin(void *c,float p0); //method: setDampingDirLin void ( ::btSliderConstraint::* )( ::btScalar ) 
float btSliderConstraint_getUpperAngLimit(void *c); //method: getUpperAngLimit ::btScalar ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setUpperAngLimit(void *c,float p0); //method: setUpperAngLimit void ( ::btSliderConstraint::* )( ::btScalar ) 
float btSliderConstraint_getRestitutionLimAng(void *c); //method: getRestitutionLimAng ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getSoftnessOrthoLin(void *c); //method: getSoftnessOrthoLin ::btScalar ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setLowerLinLimit(void *c,float p0); //method: setLowerLinLimit void ( ::btSliderConstraint::* )( ::btScalar ) 
float btSliderConstraint_getRestitutionDirLin(void *c); //method: getRestitutionDirLin ::btScalar ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_getInfo1NonVirtual(void *c,void* p0); //method: getInfo1NonVirtual void ( ::btSliderConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btSliderConstraint_setRestitutionLimLin(void *c,float p0); //method: setRestitutionLimLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setTargetLinMotorVelocity(void *c,float p0); //method: setTargetLinMotorVelocity void ( ::btSliderConstraint::* )( ::btScalar ) 
float btSliderConstraint_getUpperLinLimit(void *c); //method: getUpperLinLimit ::btScalar ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setMaxLinMotorForce(void *c,float p0); //method: setMaxLinMotorForce void ( ::btSliderConstraint::* )( ::btScalar ) 
float btSliderConstraint_getLowerAngLimit(void *c); //method: getLowerAngLimit ::btScalar ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setSoftnessDirLin(void *c,float p0); //method: setSoftnessDirLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_initParams(void *c); //method: initParams void ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_getInfo2NonVirtual(void *c,void* p0,float* p1,float* p2,float* p3,float* p4,float p5,float p6); //method: getInfo2NonVirtual void ( ::btSliderConstraint::* )( ::btTypedConstraint::btConstraintInfo2 *,::btTransform const &,::btTransform const &,::btVector3 const &,::btVector3 const &,::btScalar,::btScalar ) 
void btSliderConstraint_getFrameOffsetA(void *c,float* ret); //method: getFrameOffsetA ::btTransform const & ( ::btSliderConstraint::* )(  ) const
void btSliderConstraint_getFrameOffsetA0(void *c,float* ret); //method: getFrameOffsetA ::btTransform const & ( ::btSliderConstraint::* )(  ) const
void btSliderConstraint_getFrameOffsetA1(void *c,float* ret); //method: getFrameOffsetA ::btTransform & ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_getFrameOffsetB(void *c,float* ret); //method: getFrameOffsetB ::btTransform const & ( ::btSliderConstraint::* )(  ) const
void btSliderConstraint_getFrameOffsetB0(void *c,float* ret); //method: getFrameOffsetB ::btTransform const & ( ::btSliderConstraint::* )(  ) const
void btSliderConstraint_getFrameOffsetB1(void *c,float* ret); //method: getFrameOffsetB ::btTransform & ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getDampingDirAng(void *c); //method: getDampingDirAng ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getRestitutionLimLin(void *c); //method: getRestitutionLimLin ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getSoftnessOrthoAng(void *c); //method: getSoftnessOrthoAng ::btScalar ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setSoftnessOrthoLin(void *c,float p0); //method: setSoftnessOrthoLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setSoftnessLimAng(void *c,float p0); //method: setSoftnessLimAng void ( ::btSliderConstraint::* )( ::btScalar ) 
float btSliderConstraint_getDampingDirLin(void *c); //method: getDampingDirLin ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getSoftnessLimLin(void *c); //method: getSoftnessLimLin ::btScalar ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setPoweredLinMotor(void *c,int p0); //method: setPoweredLinMotor void ( ::btSliderConstraint::* )( bool ) 
void btSliderConstraint_calculateTransforms(void *c,float* p0,float* p1); //method: calculateTransforms void ( ::btSliderConstraint::* )( ::btTransform const &,::btTransform const & ) 
float btSliderConstraint_getLinDepth(void *c); //method: getLinDepth ::btScalar ( ::btSliderConstraint::* )(  ) 
char const * btSliderConstraint_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btSliderConstraint::* )( void *,::btSerializer * ) const
float btSliderConstraint_getDampingLimLin(void *c); //method: getDampingLimLin ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getRestitutionDirAng(void *c); //method: getRestitutionDirAng ::btScalar ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setParam(void *c,int p0,float p1,int p2); //method: setParam void ( ::btSliderConstraint::* )( int,::btScalar,int ) 
float btSliderConstraint_getDampingLimAng(void *c); //method: getDampingLimAng ::btScalar ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setRestitutionOrthoLin(void *c,float p0); //method: setRestitutionOrthoLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setRestitutionDirLin(void *c,float p0); //method: setRestitutionDirLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setDampingLimAng(void *c,float p0); //method: setDampingLimAng void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setSoftnessDirAng(void *c,float p0); //method: setSoftnessDirAng void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setUpperLinLimit(void *c,float p0); //method: setUpperLinLimit void ( ::btSliderConstraint::* )( ::btScalar ) 
int btSliderConstraint_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btSliderConstraint::* )(  ) const
void btSliderConstraint_setTargetAngMotorVelocity(void *c,float p0); //method: setTargetAngMotorVelocity void ( ::btSliderConstraint::* )( ::btScalar ) 
float btSliderConstraint_getSoftnessDirAng(void *c); //method: getSoftnessDirAng ::btScalar ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setMaxAngMotorForce(void *c,float p0); //method: setMaxAngMotorForce void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setLowerAngLimit(void *c,float p0); //method: setLowerAngLimit void ( ::btSliderConstraint::* )( ::btScalar ) 
int btSliderConstraint_getPoweredAngMotor(void *c); //method: getPoweredAngMotor bool ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getDampingOrthoAng(void *c); //method: getDampingOrthoAng ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getRestitutionOrthoLin(void *c); //method: getRestitutionOrthoLin ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getTargetLinMotorVelocity(void *c); //method: getTargetLinMotorVelocity ::btScalar ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_testLinLimits(void *c); //method: testLinLimits void ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getLowerLinLimit(void *c); //method: getLowerLinLimit ::btScalar ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setDampingOrthoAng(void *c,float p0); //method: setDampingOrthoAng void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setRestitutionOrthoAng(void *c,float p0); //method: setRestitutionOrthoAng void ( ::btSliderConstraint::* )( ::btScalar ) 
float btSliderConstraint_getRestitutionOrthoAng(void *c); //method: getRestitutionOrthoAng ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getDampingOrthoLin(void *c); //method: getDampingOrthoLin ::btScalar ( ::btSliderConstraint::* )(  ) 
float btSliderConstraint_getSoftnessLimAng(void *c); //method: getSoftnessLimAng ::btScalar ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_setSoftnessOrthoAng(void *c,float p0); //method: setSoftnessOrthoAng void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setDampingLimLin(void *c,float p0); //method: setDampingLimLin void ( ::btSliderConstraint::* )( ::btScalar ) 
void btSliderConstraint_setFrames(void *c,float* p0,float* p1); //method: setFrames void ( ::btSliderConstraint::* )( ::btTransform const &,::btTransform const & ) 
float btSliderConstraint_getSoftnessDirLin(void *c); //method: getSoftnessDirLin ::btScalar ( ::btSliderConstraint::* )(  ) 
int btSliderConstraint_getUseLinearReferenceFrameA(void *c); //method: getUseLinearReferenceFrameA bool ( ::btSliderConstraint::* )(  ) 
void btSliderConstraint_m_useSolveConstraintObsolete_set(void *c,int a); //attribute: bool btSliderConstraint->m_useSolveConstraintObsolete
int btSliderConstraint_m_useSolveConstraintObsolete_get(void *c); //attribute: bool btSliderConstraint->m_useSolveConstraintObsolete
void btSliderConstraint_m_useOffsetForConstraintFrame_set(void *c,int a); //attribute: bool btSliderConstraint->m_useOffsetForConstraintFrame
int btSliderConstraint_m_useOffsetForConstraintFrame_get(void *c); //attribute: bool btSliderConstraint->m_useOffsetForConstraintFrame
void btSliderConstraint_m_frameInA_set(void *c,float* a); //attribute: ::btTransform btSliderConstraint->m_frameInA
void btSliderConstraint_m_frameInA_get(void *c,float* a);
void btSliderConstraint_m_frameInB_set(void *c,float* a); //attribute: ::btTransform btSliderConstraint->m_frameInB
void btSliderConstraint_m_frameInB_get(void *c,float* a);
void btSliderConstraint_m_useLinearReferenceFrameA_set(void *c,int a); //attribute: bool btSliderConstraint->m_useLinearReferenceFrameA
int btSliderConstraint_m_useLinearReferenceFrameA_get(void *c); //attribute: bool btSliderConstraint->m_useLinearReferenceFrameA
void btSliderConstraint_m_lowerLinLimit_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_lowerLinLimit
float btSliderConstraint_m_lowerLinLimit_get(void *c); //attribute: ::btScalar btSliderConstraint->m_lowerLinLimit
void btSliderConstraint_m_upperLinLimit_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_upperLinLimit
float btSliderConstraint_m_upperLinLimit_get(void *c); //attribute: ::btScalar btSliderConstraint->m_upperLinLimit
void btSliderConstraint_m_lowerAngLimit_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_lowerAngLimit
float btSliderConstraint_m_lowerAngLimit_get(void *c); //attribute: ::btScalar btSliderConstraint->m_lowerAngLimit
void btSliderConstraint_m_upperAngLimit_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_upperAngLimit
float btSliderConstraint_m_upperAngLimit_get(void *c); //attribute: ::btScalar btSliderConstraint->m_upperAngLimit
void btSliderConstraint_m_softnessDirLin_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_softnessDirLin
float btSliderConstraint_m_softnessDirLin_get(void *c); //attribute: ::btScalar btSliderConstraint->m_softnessDirLin
void btSliderConstraint_m_restitutionDirLin_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_restitutionDirLin
float btSliderConstraint_m_restitutionDirLin_get(void *c); //attribute: ::btScalar btSliderConstraint->m_restitutionDirLin
void btSliderConstraint_m_dampingDirLin_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_dampingDirLin
float btSliderConstraint_m_dampingDirLin_get(void *c); //attribute: ::btScalar btSliderConstraint->m_dampingDirLin
void btSliderConstraint_m_cfmDirLin_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_cfmDirLin
float btSliderConstraint_m_cfmDirLin_get(void *c); //attribute: ::btScalar btSliderConstraint->m_cfmDirLin
void btSliderConstraint_m_softnessDirAng_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_softnessDirAng
float btSliderConstraint_m_softnessDirAng_get(void *c); //attribute: ::btScalar btSliderConstraint->m_softnessDirAng
void btSliderConstraint_m_restitutionDirAng_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_restitutionDirAng
float btSliderConstraint_m_restitutionDirAng_get(void *c); //attribute: ::btScalar btSliderConstraint->m_restitutionDirAng
void btSliderConstraint_m_dampingDirAng_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_dampingDirAng
float btSliderConstraint_m_dampingDirAng_get(void *c); //attribute: ::btScalar btSliderConstraint->m_dampingDirAng
void btSliderConstraint_m_cfmDirAng_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_cfmDirAng
float btSliderConstraint_m_cfmDirAng_get(void *c); //attribute: ::btScalar btSliderConstraint->m_cfmDirAng
void btSliderConstraint_m_softnessLimLin_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_softnessLimLin
float btSliderConstraint_m_softnessLimLin_get(void *c); //attribute: ::btScalar btSliderConstraint->m_softnessLimLin
void btSliderConstraint_m_restitutionLimLin_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_restitutionLimLin
float btSliderConstraint_m_restitutionLimLin_get(void *c); //attribute: ::btScalar btSliderConstraint->m_restitutionLimLin
void btSliderConstraint_m_dampingLimLin_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_dampingLimLin
float btSliderConstraint_m_dampingLimLin_get(void *c); //attribute: ::btScalar btSliderConstraint->m_dampingLimLin
void btSliderConstraint_m_cfmLimLin_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_cfmLimLin
float btSliderConstraint_m_cfmLimLin_get(void *c); //attribute: ::btScalar btSliderConstraint->m_cfmLimLin
void btSliderConstraint_m_softnessLimAng_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_softnessLimAng
float btSliderConstraint_m_softnessLimAng_get(void *c); //attribute: ::btScalar btSliderConstraint->m_softnessLimAng
void btSliderConstraint_m_restitutionLimAng_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_restitutionLimAng
float btSliderConstraint_m_restitutionLimAng_get(void *c); //attribute: ::btScalar btSliderConstraint->m_restitutionLimAng
void btSliderConstraint_m_dampingLimAng_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_dampingLimAng
float btSliderConstraint_m_dampingLimAng_get(void *c); //attribute: ::btScalar btSliderConstraint->m_dampingLimAng
void btSliderConstraint_m_cfmLimAng_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_cfmLimAng
float btSliderConstraint_m_cfmLimAng_get(void *c); //attribute: ::btScalar btSliderConstraint->m_cfmLimAng
void btSliderConstraint_m_softnessOrthoLin_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_softnessOrthoLin
float btSliderConstraint_m_softnessOrthoLin_get(void *c); //attribute: ::btScalar btSliderConstraint->m_softnessOrthoLin
void btSliderConstraint_m_restitutionOrthoLin_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_restitutionOrthoLin
float btSliderConstraint_m_restitutionOrthoLin_get(void *c); //attribute: ::btScalar btSliderConstraint->m_restitutionOrthoLin
void btSliderConstraint_m_dampingOrthoLin_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_dampingOrthoLin
float btSliderConstraint_m_dampingOrthoLin_get(void *c); //attribute: ::btScalar btSliderConstraint->m_dampingOrthoLin
void btSliderConstraint_m_cfmOrthoLin_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_cfmOrthoLin
float btSliderConstraint_m_cfmOrthoLin_get(void *c); //attribute: ::btScalar btSliderConstraint->m_cfmOrthoLin
void btSliderConstraint_m_softnessOrthoAng_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_softnessOrthoAng
float btSliderConstraint_m_softnessOrthoAng_get(void *c); //attribute: ::btScalar btSliderConstraint->m_softnessOrthoAng
void btSliderConstraint_m_restitutionOrthoAng_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_restitutionOrthoAng
float btSliderConstraint_m_restitutionOrthoAng_get(void *c); //attribute: ::btScalar btSliderConstraint->m_restitutionOrthoAng
void btSliderConstraint_m_dampingOrthoAng_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_dampingOrthoAng
float btSliderConstraint_m_dampingOrthoAng_get(void *c); //attribute: ::btScalar btSliderConstraint->m_dampingOrthoAng
void btSliderConstraint_m_cfmOrthoAng_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_cfmOrthoAng
float btSliderConstraint_m_cfmOrthoAng_get(void *c); //attribute: ::btScalar btSliderConstraint->m_cfmOrthoAng
void btSliderConstraint_m_solveLinLim_set(void *c,int a); //attribute: bool btSliderConstraint->m_solveLinLim
int btSliderConstraint_m_solveLinLim_get(void *c); //attribute: bool btSliderConstraint->m_solveLinLim
void btSliderConstraint_m_solveAngLim_set(void *c,int a); //attribute: bool btSliderConstraint->m_solveAngLim
int btSliderConstraint_m_solveAngLim_get(void *c); //attribute: bool btSliderConstraint->m_solveAngLim
void btSliderConstraint_m_flags_set(void *c,int a); //attribute: int btSliderConstraint->m_flags
int btSliderConstraint_m_flags_get(void *c); //attribute: int btSliderConstraint->m_flags
// attribute not supported: //attribute: ::btJacobianEntry[3] btSliderConstraint->m_jacLin
// attribute not supported: //attribute: ::btScalar[3] btSliderConstraint->m_jacLinDiagABInv
// attribute not supported: //attribute: ::btJacobianEntry[3] btSliderConstraint->m_jacAng
void btSliderConstraint_m_timeStep_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_timeStep
float btSliderConstraint_m_timeStep_get(void *c); //attribute: ::btScalar btSliderConstraint->m_timeStep
void btSliderConstraint_m_calculatedTransformA_set(void *c,float* a); //attribute: ::btTransform btSliderConstraint->m_calculatedTransformA
void btSliderConstraint_m_calculatedTransformA_get(void *c,float* a);
void btSliderConstraint_m_calculatedTransformB_set(void *c,float* a); //attribute: ::btTransform btSliderConstraint->m_calculatedTransformB
void btSliderConstraint_m_calculatedTransformB_get(void *c,float* a);
void btSliderConstraint_m_sliderAxis_set(void *c,float* a); //attribute: ::btVector3 btSliderConstraint->m_sliderAxis
void btSliderConstraint_m_sliderAxis_get(void *c,float* a);
void btSliderConstraint_m_realPivotAInW_set(void *c,float* a); //attribute: ::btVector3 btSliderConstraint->m_realPivotAInW
void btSliderConstraint_m_realPivotAInW_get(void *c,float* a);
void btSliderConstraint_m_realPivotBInW_set(void *c,float* a); //attribute: ::btVector3 btSliderConstraint->m_realPivotBInW
void btSliderConstraint_m_realPivotBInW_get(void *c,float* a);
void btSliderConstraint_m_projPivotInW_set(void *c,float* a); //attribute: ::btVector3 btSliderConstraint->m_projPivotInW
void btSliderConstraint_m_projPivotInW_get(void *c,float* a);
void btSliderConstraint_m_delta_set(void *c,float* a); //attribute: ::btVector3 btSliderConstraint->m_delta
void btSliderConstraint_m_delta_get(void *c,float* a);
void btSliderConstraint_m_depth_set(void *c,float* a); //attribute: ::btVector3 btSliderConstraint->m_depth
void btSliderConstraint_m_depth_get(void *c,float* a);
void btSliderConstraint_m_relPosA_set(void *c,float* a); //attribute: ::btVector3 btSliderConstraint->m_relPosA
void btSliderConstraint_m_relPosA_get(void *c,float* a);
void btSliderConstraint_m_relPosB_set(void *c,float* a); //attribute: ::btVector3 btSliderConstraint->m_relPosB
void btSliderConstraint_m_relPosB_get(void *c,float* a);
void btSliderConstraint_m_linPos_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_linPos
float btSliderConstraint_m_linPos_get(void *c); //attribute: ::btScalar btSliderConstraint->m_linPos
void btSliderConstraint_m_angPos_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_angPos
float btSliderConstraint_m_angPos_get(void *c); //attribute: ::btScalar btSliderConstraint->m_angPos
void btSliderConstraint_m_angDepth_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_angDepth
float btSliderConstraint_m_angDepth_get(void *c); //attribute: ::btScalar btSliderConstraint->m_angDepth
void btSliderConstraint_m_kAngle_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_kAngle
float btSliderConstraint_m_kAngle_get(void *c); //attribute: ::btScalar btSliderConstraint->m_kAngle
void btSliderConstraint_m_poweredLinMotor_set(void *c,int a); //attribute: bool btSliderConstraint->m_poweredLinMotor
int btSliderConstraint_m_poweredLinMotor_get(void *c); //attribute: bool btSliderConstraint->m_poweredLinMotor
void btSliderConstraint_m_targetLinMotorVelocity_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_targetLinMotorVelocity
float btSliderConstraint_m_targetLinMotorVelocity_get(void *c); //attribute: ::btScalar btSliderConstraint->m_targetLinMotorVelocity
void btSliderConstraint_m_maxLinMotorForce_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_maxLinMotorForce
float btSliderConstraint_m_maxLinMotorForce_get(void *c); //attribute: ::btScalar btSliderConstraint->m_maxLinMotorForce
void btSliderConstraint_m_accumulatedLinMotorImpulse_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_accumulatedLinMotorImpulse
float btSliderConstraint_m_accumulatedLinMotorImpulse_get(void *c); //attribute: ::btScalar btSliderConstraint->m_accumulatedLinMotorImpulse
void btSliderConstraint_m_poweredAngMotor_set(void *c,int a); //attribute: bool btSliderConstraint->m_poweredAngMotor
int btSliderConstraint_m_poweredAngMotor_get(void *c); //attribute: bool btSliderConstraint->m_poweredAngMotor
void btSliderConstraint_m_targetAngMotorVelocity_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_targetAngMotorVelocity
float btSliderConstraint_m_targetAngMotorVelocity_get(void *c); //attribute: ::btScalar btSliderConstraint->m_targetAngMotorVelocity
void btSliderConstraint_m_maxAngMotorForce_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_maxAngMotorForce
float btSliderConstraint_m_maxAngMotorForce_get(void *c); //attribute: ::btScalar btSliderConstraint->m_maxAngMotorForce
void btSliderConstraint_m_accumulatedAngMotorImpulse_set(void *c,float a); //attribute: ::btScalar btSliderConstraint->m_accumulatedAngMotorImpulse
float btSliderConstraint_m_accumulatedAngMotorImpulse_get(void *c); //attribute: ::btScalar btSliderConstraint->m_accumulatedAngMotorImpulse
void* btSliderConstraintData_new(); //constructor: btSliderConstraintData  ( ::btSliderConstraintData::* )(  ) 
void btSliderConstraintData_free(void *c); 
void btSliderConstraintData_m_typeConstraintData_set(void *c,void* a); //attribute: ::btTypedConstraintData btSliderConstraintData->m_typeConstraintData
void* btSliderConstraintData_m_typeConstraintData_get(void *c); //attribute: ::btTypedConstraintData btSliderConstraintData->m_typeConstraintData
void btSliderConstraintData_m_rbAFrame_set(void *c,void* a); //attribute: ::btTransformFloatData btSliderConstraintData->m_rbAFrame
void* btSliderConstraintData_m_rbAFrame_get(void *c); //attribute: ::btTransformFloatData btSliderConstraintData->m_rbAFrame
void btSliderConstraintData_m_rbBFrame_set(void *c,void* a); //attribute: ::btTransformFloatData btSliderConstraintData->m_rbBFrame
void* btSliderConstraintData_m_rbBFrame_get(void *c); //attribute: ::btTransformFloatData btSliderConstraintData->m_rbBFrame
void btSliderConstraintData_m_linearUpperLimit_set(void *c,float a); //attribute: float btSliderConstraintData->m_linearUpperLimit
float btSliderConstraintData_m_linearUpperLimit_get(void *c); //attribute: float btSliderConstraintData->m_linearUpperLimit
void btSliderConstraintData_m_linearLowerLimit_set(void *c,float a); //attribute: float btSliderConstraintData->m_linearLowerLimit
float btSliderConstraintData_m_linearLowerLimit_get(void *c); //attribute: float btSliderConstraintData->m_linearLowerLimit
void btSliderConstraintData_m_angularUpperLimit_set(void *c,float a); //attribute: float btSliderConstraintData->m_angularUpperLimit
float btSliderConstraintData_m_angularUpperLimit_get(void *c); //attribute: float btSliderConstraintData->m_angularUpperLimit
void btSliderConstraintData_m_angularLowerLimit_set(void *c,float a); //attribute: float btSliderConstraintData->m_angularLowerLimit
float btSliderConstraintData_m_angularLowerLimit_get(void *c); //attribute: float btSliderConstraintData->m_angularLowerLimit
void btSliderConstraintData_m_useLinearReferenceFrameA_set(void *c,int a); //attribute: int btSliderConstraintData->m_useLinearReferenceFrameA
int btSliderConstraintData_m_useLinearReferenceFrameA_get(void *c); //attribute: int btSliderConstraintData->m_useLinearReferenceFrameA
void btSliderConstraintData_m_useOffsetForConstraintFrame_set(void *c,int a); //attribute: int btSliderConstraintData->m_useOffsetForConstraintFrame
int btSliderConstraintData_m_useOffsetForConstraintFrame_get(void *c); //attribute: int btSliderConstraintData->m_useOffsetForConstraintFrame
void* btSolverBodyObsolete_new(); //constructor: btSolverBodyObsolete  ( ::btSolverBodyObsolete::* )(  ) 
void btSolverBodyObsolete_free(void *c); 
//not supported method: applyImpulse void ( ::btSolverBodyObsolete::* )( ::btVector3 const &,::btVector3 const &,::btScalar const ) 
// error: ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported, void - ok

void btSolverBodyObsolete_getAngularVelocity(void *c,float* p0); //method: getAngularVelocity void ( ::btSolverBodyObsolete::* )( ::btVector3 & ) const
void btSolverBodyObsolete_writebackVelocity(void *c); //method: writebackVelocity void ( ::btSolverBodyObsolete::* )(  ) 
void btSolverBodyObsolete_writebackVelocity0(void *c); //method: writebackVelocity void ( ::btSolverBodyObsolete::* )(  ) 
void btSolverBodyObsolete_writebackVelocity1(void *c,float p0); //method: writebackVelocity void ( ::btSolverBodyObsolete::* )( ::btScalar ) 
void btSolverBodyObsolete_internalApplyPushImpulse(void *c,float* p0,float* p1,float p2); //method: internalApplyPushImpulse void ( ::btSolverBodyObsolete::* )( ::btVector3 const &,::btVector3 const &,::btScalar ) 
void btSolverBodyObsolete_getVelocityInLocalPointObsolete(void *c,float* p0,float* p1); //method: getVelocityInLocalPointObsolete void ( ::btSolverBodyObsolete::* )( ::btVector3 const &,::btVector3 & ) const
void btSolverBodyObsolete_m_deltaLinearVelocity_set(void *c,float* a); //attribute: ::btVector3 btSolverBodyObsolete->m_deltaLinearVelocity
void btSolverBodyObsolete_m_deltaLinearVelocity_get(void *c,float* a);
void btSolverBodyObsolete_m_deltaAngularVelocity_set(void *c,float* a); //attribute: ::btVector3 btSolverBodyObsolete->m_deltaAngularVelocity
void btSolverBodyObsolete_m_deltaAngularVelocity_get(void *c,float* a);
void btSolverBodyObsolete_m_angularFactor_set(void *c,float* a); //attribute: ::btVector3 btSolverBodyObsolete->m_angularFactor
void btSolverBodyObsolete_m_angularFactor_get(void *c,float* a);
void btSolverBodyObsolete_m_invMass_set(void *c,float* a); //attribute: ::btVector3 btSolverBodyObsolete->m_invMass
void btSolverBodyObsolete_m_invMass_get(void *c,float* a);
void btSolverBodyObsolete_m_originalBody_set(void *c,void* a); //attribute: ::btRigidBody * btSolverBodyObsolete->m_originalBody
void* btSolverBodyObsolete_m_originalBody_get(void *c); //attribute: ::btRigidBody * btSolverBodyObsolete->m_originalBody
void btSolverBodyObsolete_m_pushVelocity_set(void *c,float* a); //attribute: ::btVector3 btSolverBodyObsolete->m_pushVelocity
void btSolverBodyObsolete_m_pushVelocity_get(void *c,float* a);
void btSolverBodyObsolete_m_turnVelocity_set(void *c,float* a); //attribute: ::btVector3 btSolverBodyObsolete->m_turnVelocity
void btSolverBodyObsolete_m_turnVelocity_get(void *c,float* a);
void* btSolverConstraint_new(); //constructor: btSolverConstraint  ( ::btSolverConstraint::* )(  ) 
void btSolverConstraint_free(void *c); 
// attribute not supported: //attribute: ::btSolverConstraint btSolverConstraint->
// attribute not supported: //attribute: ::btSolverConstraint btSolverConstraint->
// attribute not supported: //attribute: ::btSolverConstraint btSolverConstraint->
// attribute not supported: //attribute: ::btSolverConstraint btSolverConstraint->
// attribute not supported: //attribute: ::btSolverConstraint btSolverConstraint->
void btSolverConstraint_m_angularComponentA_set(void *c,float* a); //attribute: ::btVector3 btSolverConstraint->m_angularComponentA
void btSolverConstraint_m_angularComponentA_get(void *c,float* a);
void btSolverConstraint_m_angularComponentB_set(void *c,float* a); //attribute: ::btVector3 btSolverConstraint->m_angularComponentB
void btSolverConstraint_m_angularComponentB_get(void *c,float* a);
void btSolverConstraint_m_appliedImpulse_set(void *c,float a); //attribute: ::btScalar btSolverConstraint->m_appliedImpulse
float btSolverConstraint_m_appliedImpulse_get(void *c); //attribute: ::btScalar btSolverConstraint->m_appliedImpulse
void btSolverConstraint_m_appliedPushImpulse_set(void *c,float a); //attribute: ::btScalar btSolverConstraint->m_appliedPushImpulse
float btSolverConstraint_m_appliedPushImpulse_get(void *c); //attribute: ::btScalar btSolverConstraint->m_appliedPushImpulse
void btSolverConstraint_m_cfm_set(void *c,float a); //attribute: ::btScalar btSolverConstraint->m_cfm
float btSolverConstraint_m_cfm_get(void *c); //attribute: ::btScalar btSolverConstraint->m_cfm
void btSolverConstraint_m_contactNormal_set(void *c,float* a); //attribute: ::btVector3 btSolverConstraint->m_contactNormal
void btSolverConstraint_m_contactNormal_get(void *c,float* a);
void btSolverConstraint_m_friction_set(void *c,float a); //attribute: ::btScalar btSolverConstraint->m_friction
float btSolverConstraint_m_friction_get(void *c); //attribute: ::btScalar btSolverConstraint->m_friction
void btSolverConstraint_m_jacDiagABInv_set(void *c,float a); //attribute: ::btScalar btSolverConstraint->m_jacDiagABInv
float btSolverConstraint_m_jacDiagABInv_get(void *c); //attribute: ::btScalar btSolverConstraint->m_jacDiagABInv
void btSolverConstraint_m_lowerLimit_set(void *c,float a); //attribute: ::btScalar btSolverConstraint->m_lowerLimit
float btSolverConstraint_m_lowerLimit_get(void *c); //attribute: ::btScalar btSolverConstraint->m_lowerLimit
void btSolverConstraint_m_relpos1CrossNormal_set(void *c,float* a); //attribute: ::btVector3 btSolverConstraint->m_relpos1CrossNormal
void btSolverConstraint_m_relpos1CrossNormal_get(void *c,float* a);
void btSolverConstraint_m_relpos2CrossNormal_set(void *c,float* a); //attribute: ::btVector3 btSolverConstraint->m_relpos2CrossNormal
void btSolverConstraint_m_relpos2CrossNormal_get(void *c,float* a);
void btSolverConstraint_m_rhs_set(void *c,float a); //attribute: ::btScalar btSolverConstraint->m_rhs
float btSolverConstraint_m_rhs_get(void *c); //attribute: ::btScalar btSolverConstraint->m_rhs
void btSolverConstraint_m_rhsPenetration_set(void *c,float a); //attribute: ::btScalar btSolverConstraint->m_rhsPenetration
float btSolverConstraint_m_rhsPenetration_get(void *c); //attribute: ::btScalar btSolverConstraint->m_rhsPenetration
void btSolverConstraint_m_upperLimit_set(void *c,float a); //attribute: ::btScalar btSolverConstraint->m_upperLimit
float btSolverConstraint_m_upperLimit_get(void *c); //attribute: ::btScalar btSolverConstraint->m_upperLimit
void* btTranslationalLimitMotor_new(); //constructor: btTranslationalLimitMotor  ( ::btTranslationalLimitMotor::* )(  ) 
void btTranslationalLimitMotor_free(void *c); 
int btTranslationalLimitMotor_testLimitValue(void *c,int p0,float p1); //method: testLimitValue int ( ::btTranslationalLimitMotor::* )( int,::btScalar ) 
int btTranslationalLimitMotor_needApplyForce(void *c,int p0); //method: needApplyForce bool ( ::btTranslationalLimitMotor::* )( int ) 
float btTranslationalLimitMotor_solveLinearAxis(void *c,float p0,float p1,void* p2,float* p3,void* p4,float* p5,int p6,float* p7,float* p8); //method: solveLinearAxis ::btScalar ( ::btTranslationalLimitMotor::* )( ::btScalar,::btScalar,::btRigidBody &,::btVector3 const &,::btRigidBody &,::btVector3 const &,int,::btVector3 const &,::btVector3 const & ) 
int btTranslationalLimitMotor_isLimited(void *c,int p0); //method: isLimited bool ( ::btTranslationalLimitMotor::* )( int ) 
void btTranslationalLimitMotor_m_accumulatedImpulse_set(void *c,float* a); //attribute: ::btVector3 btTranslationalLimitMotor->m_accumulatedImpulse
void btTranslationalLimitMotor_m_accumulatedImpulse_get(void *c,float* a);
// attribute not supported: //attribute: int[3] btTranslationalLimitMotor->m_currentLimit
void btTranslationalLimitMotor_m_currentLimitError_set(void *c,float* a); //attribute: ::btVector3 btTranslationalLimitMotor->m_currentLimitError
void btTranslationalLimitMotor_m_currentLimitError_get(void *c,float* a);
void btTranslationalLimitMotor_m_currentLinearDiff_set(void *c,float* a); //attribute: ::btVector3 btTranslationalLimitMotor->m_currentLinearDiff
void btTranslationalLimitMotor_m_currentLinearDiff_get(void *c,float* a);
void btTranslationalLimitMotor_m_damping_set(void *c,float a); //attribute: ::btScalar btTranslationalLimitMotor->m_damping
float btTranslationalLimitMotor_m_damping_get(void *c); //attribute: ::btScalar btTranslationalLimitMotor->m_damping
// attribute not supported: //attribute: bool[3] btTranslationalLimitMotor->m_enableMotor
void btTranslationalLimitMotor_m_limitSoftness_set(void *c,float a); //attribute: ::btScalar btTranslationalLimitMotor->m_limitSoftness
float btTranslationalLimitMotor_m_limitSoftness_get(void *c); //attribute: ::btScalar btTranslationalLimitMotor->m_limitSoftness
void btTranslationalLimitMotor_m_lowerLimit_set(void *c,float* a); //attribute: ::btVector3 btTranslationalLimitMotor->m_lowerLimit
void btTranslationalLimitMotor_m_lowerLimit_get(void *c,float* a);
void btTranslationalLimitMotor_m_maxMotorForce_set(void *c,float* a); //attribute: ::btVector3 btTranslationalLimitMotor->m_maxMotorForce
void btTranslationalLimitMotor_m_maxMotorForce_get(void *c,float* a);
void btTranslationalLimitMotor_m_normalCFM_set(void *c,float* a); //attribute: ::btVector3 btTranslationalLimitMotor->m_normalCFM
void btTranslationalLimitMotor_m_normalCFM_get(void *c,float* a);
void btTranslationalLimitMotor_m_restitution_set(void *c,float a); //attribute: ::btScalar btTranslationalLimitMotor->m_restitution
float btTranslationalLimitMotor_m_restitution_get(void *c); //attribute: ::btScalar btTranslationalLimitMotor->m_restitution
void btTranslationalLimitMotor_m_stopCFM_set(void *c,float* a); //attribute: ::btVector3 btTranslationalLimitMotor->m_stopCFM
void btTranslationalLimitMotor_m_stopCFM_get(void *c,float* a);
void btTranslationalLimitMotor_m_stopERP_set(void *c,float* a); //attribute: ::btVector3 btTranslationalLimitMotor->m_stopERP
void btTranslationalLimitMotor_m_stopERP_get(void *c,float* a);
void btTranslationalLimitMotor_m_targetVelocity_set(void *c,float* a); //attribute: ::btVector3 btTranslationalLimitMotor->m_targetVelocity
void btTranslationalLimitMotor_m_targetVelocity_get(void *c,float* a);
void btTranslationalLimitMotor_m_upperLimit_set(void *c,float* a); //attribute: ::btVector3 btTranslationalLimitMotor->m_upperLimit
void btTranslationalLimitMotor_m_upperLimit_get(void *c,float* a);
void* btTypedConstraint_getRigidBodyB(void *c); //method: getRigidBodyB ::btRigidBody const & ( ::btTypedConstraint::* )(  ) const
void* btTypedConstraint_getRigidBodyB0(void *c); //method: getRigidBodyB ::btRigidBody const & ( ::btTypedConstraint::* )(  ) const
void* btTypedConstraint_getRigidBodyB1(void *c); //method: getRigidBodyB ::btRigidBody & ( ::btTypedConstraint::* )(  ) 
void btTypedConstraint_buildJacobian(void *c); //method: buildJacobian void ( ::btTypedConstraint::* )(  ) 
void* btTypedConstraint_getRigidBodyA(void *c); //method: getRigidBodyA ::btRigidBody const & ( ::btTypedConstraint::* )(  ) const
void* btTypedConstraint_getRigidBodyA0(void *c); //method: getRigidBodyA ::btRigidBody const & ( ::btTypedConstraint::* )(  ) const
void* btTypedConstraint_getRigidBodyA1(void *c); //method: getRigidBodyA ::btRigidBody & ( ::btTypedConstraint::* )(  ) 
char const * btTypedConstraint_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btTypedConstraint::* )( void *,::btSerializer * ) const
void btTypedConstraint_enableFeedback(void *c,int p0); //method: enableFeedback void ( ::btTypedConstraint::* )( bool ) 
int btTypedConstraint_getUserConstraintId(void *c); //method: getUserConstraintId int ( ::btTypedConstraint::* )(  ) const
void btTypedConstraint_setParam(void *c,int p0,float p1,int p2); //method: setParam void ( ::btTypedConstraint::* )( int,::btScalar,int ) 
float btTypedConstraint_getParam(void *c,int p0,int p1); //method: getParam ::btScalar ( ::btTypedConstraint::* )( int,int ) const
void btTypedConstraint_getInfo1(void *c,void* p0); //method: getInfo1 void ( ::btTypedConstraint::* )( ::btTypedConstraint::btConstraintInfo1 * ) 
void btTypedConstraint_getInfo2(void *c,void* p0); //method: getInfo2 void ( ::btTypedConstraint::* )( ::btTypedConstraint::btConstraintInfo2 * ) 
void btTypedConstraint_setBreakingImpulseThreshold(void *c,float p0); //method: setBreakingImpulseThreshold void ( ::btTypedConstraint::* )( ::btScalar ) 
void* btTypedConstraint_getFixedBody(); //method: getFixedBody ::btRigidBody & (*)(  )
int btTypedConstraint_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btTypedConstraint::* )(  ) const
int btTypedConstraint_isEnabled(void *c); //method: isEnabled bool ( ::btTypedConstraint::* )(  ) const
void btTypedConstraint_setUserConstraintId(void *c,int p0); //method: setUserConstraintId void ( ::btTypedConstraint::* )( int ) 
//not supported method: getConstraintType ::btTypedConstraintType ( ::btTypedConstraint::* )(  ) const
// error:  - unsupported

float btTypedConstraint_getMotorFactor(void *c,float p0,float p1,float p2,float p3,float p4); //method: getMotorFactor ::btScalar ( ::btTypedConstraint::* )( ::btScalar,::btScalar,::btScalar,::btScalar,::btScalar ) 
float btTypedConstraint_getDbgDrawSize(void *c); //method: getDbgDrawSize ::btScalar ( ::btTypedConstraint::* )(  ) 
void btTypedConstraint_internalSetAppliedImpulse(void *c,float p0); //method: internalSetAppliedImpulse void ( ::btTypedConstraint::* )( ::btScalar ) 
int btTypedConstraint_needsFeedback(void *c); //method: needsFeedback bool ( ::btTypedConstraint::* )(  ) const
void* btTypedConstraint_getUserConstraintPtr(void *c); //method: getUserConstraintPtr void * ( ::btTypedConstraint::* )(  ) 
void btTypedConstraint_setEnabled(void *c,int p0); //method: setEnabled void ( ::btTypedConstraint::* )( bool ) 
int btTypedConstraint_getUid(void *c); //method: getUid int ( ::btTypedConstraint::* )(  ) const
void btTypedConstraint_setDbgDrawSize(void *c,float p0); //method: setDbgDrawSize void ( ::btTypedConstraint::* )( ::btScalar ) 
void btTypedConstraint_setUserConstraintType(void *c,int p0); //method: setUserConstraintType void ( ::btTypedConstraint::* )( int ) 
float btTypedConstraint_internalGetAppliedImpulse(void *c); //method: internalGetAppliedImpulse ::btScalar ( ::btTypedConstraint::* )(  ) 
void btTypedConstraint_setupSolverConstraint(void *c,void* p0,int p1,int p2,float p3); //method: setupSolverConstraint void ( ::btTypedConstraint::* )( ::btConstraintArray &,int,int,::btScalar ) 
float btTypedConstraint_getBreakingImpulseThreshold(void *c); //method: getBreakingImpulseThreshold ::btScalar ( ::btTypedConstraint::* )(  ) const
int btTypedConstraint_getUserConstraintType(void *c); //method: getUserConstraintType int ( ::btTypedConstraint::* )(  ) const
void btTypedConstraint_solveConstraintObsolete(void *c,void* p0,void* p1,float p2); //method: solveConstraintObsolete void ( ::btTypedConstraint::* )( ::btRigidBody &,::btRigidBody &,::btScalar ) 
float btTypedConstraint_getAppliedImpulse(void *c); //method: getAppliedImpulse ::btScalar ( ::btTypedConstraint::* )(  ) const
void btTypedConstraint_setUserConstraintPtr(void *c,void* p0); //method: setUserConstraintPtr void ( ::btTypedConstraint::* )( void * ) 
// attribute not supported: //attribute: ::btTypedConstraint btTypedConstraint->
void btTypedConstraint_m_appliedImpulse_set(void *c,float a); //attribute: ::btScalar btTypedConstraint->m_appliedImpulse
float btTypedConstraint_m_appliedImpulse_get(void *c); //attribute: ::btScalar btTypedConstraint->m_appliedImpulse
void btTypedConstraint_m_breakingImpulseThreshold_set(void *c,float a); //attribute: ::btScalar btTypedConstraint->m_breakingImpulseThreshold
float btTypedConstraint_m_breakingImpulseThreshold_get(void *c); //attribute: ::btScalar btTypedConstraint->m_breakingImpulseThreshold
void btTypedConstraint_m_dbgDrawSize_set(void *c,float a); //attribute: ::btScalar btTypedConstraint->m_dbgDrawSize
float btTypedConstraint_m_dbgDrawSize_get(void *c); //attribute: ::btScalar btTypedConstraint->m_dbgDrawSize
void btTypedConstraint_m_isEnabled_set(void *c,int a); //attribute: bool btTypedConstraint->m_isEnabled
int btTypedConstraint_m_isEnabled_get(void *c); //attribute: bool btTypedConstraint->m_isEnabled
void btTypedConstraint_m_needsFeedback_set(void *c,int a); //attribute: bool btTypedConstraint->m_needsFeedback
int btTypedConstraint_m_needsFeedback_get(void *c); //attribute: bool btTypedConstraint->m_needsFeedback
void btTypedConstraint_m_rbA_set(void *c,void* a); //attribute: ::btRigidBody & btTypedConstraint->m_rbA
void* btTypedConstraint_m_rbA_get(void *c); //attribute: ::btRigidBody & btTypedConstraint->m_rbA
void btTypedConstraint_m_rbB_set(void *c,void* a); //attribute: ::btRigidBody & btTypedConstraint->m_rbB
void* btTypedConstraint_m_rbB_get(void *c); //attribute: ::btRigidBody & btTypedConstraint->m_rbB
void btTypedConstraint_m_userConstraintType_set(void *c,int a); //attribute: int btTypedConstraint->m_userConstraintType
int btTypedConstraint_m_userConstraintType_get(void *c); //attribute: int btTypedConstraint->m_userConstraintType
void* btTypedConstraintData_new(); //constructor: btTypedConstraintData  ( ::btTypedConstraintData::* )(  ) 
void btTypedConstraintData_free(void *c); 
void btTypedConstraintData_m_appliedImpulse_set(void *c,float a); //attribute: float btTypedConstraintData->m_appliedImpulse
float btTypedConstraintData_m_appliedImpulse_get(void *c); //attribute: float btTypedConstraintData->m_appliedImpulse
void btTypedConstraintData_m_dbgDrawSize_set(void *c,float a); //attribute: float btTypedConstraintData->m_dbgDrawSize
float btTypedConstraintData_m_dbgDrawSize_get(void *c); //attribute: float btTypedConstraintData->m_dbgDrawSize
void btTypedConstraintData_m_disableCollisionsBetweenLinkedBodies_set(void *c,int a); //attribute: int btTypedConstraintData->m_disableCollisionsBetweenLinkedBodies
int btTypedConstraintData_m_disableCollisionsBetweenLinkedBodies_get(void *c); //attribute: int btTypedConstraintData->m_disableCollisionsBetweenLinkedBodies
void btTypedConstraintData_m_name_set(void *c,char * a); //attribute: char * btTypedConstraintData->m_name
char * btTypedConstraintData_m_name_get(void *c); //attribute: char * btTypedConstraintData->m_name
void btTypedConstraintData_m_needsFeedback_set(void *c,int a); //attribute: int btTypedConstraintData->m_needsFeedback
int btTypedConstraintData_m_needsFeedback_get(void *c); //attribute: int btTypedConstraintData->m_needsFeedback
void btTypedConstraintData_m_objectType_set(void *c,int a); //attribute: int btTypedConstraintData->m_objectType
int btTypedConstraintData_m_objectType_get(void *c); //attribute: int btTypedConstraintData->m_objectType
// attribute not supported: //attribute: char[4] btTypedConstraintData->m_pad4
void btTypedConstraintData_m_rbA_set(void *c,void* a); //attribute: ::btRigidBodyFloatData * btTypedConstraintData->m_rbA
void* btTypedConstraintData_m_rbA_get(void *c); //attribute: ::btRigidBodyFloatData * btTypedConstraintData->m_rbA
void btTypedConstraintData_m_rbB_set(void *c,void* a); //attribute: ::btRigidBodyFloatData * btTypedConstraintData->m_rbB
void* btTypedConstraintData_m_rbB_get(void *c); //attribute: ::btRigidBodyFloatData * btTypedConstraintData->m_rbB
void btTypedConstraintData_m_userConstraintId_set(void *c,int a); //attribute: int btTypedConstraintData->m_userConstraintId
int btTypedConstraintData_m_userConstraintId_get(void *c); //attribute: int btTypedConstraintData->m_userConstraintId
void btTypedConstraintData_m_userConstraintType_set(void *c,int a); //attribute: int btTypedConstraintData->m_userConstraintType
int btTypedConstraintData_m_userConstraintType_get(void *c); //attribute: int btTypedConstraintData->m_userConstraintType
void* btUniversalConstraint_new(void* p0,void* p1,float* p2,float* p3,float* p4); //constructor: btUniversalConstraint  ( ::btUniversalConstraint::* )( ::btRigidBody &,::btRigidBody &,::btVector3 &,::btVector3 &,::btVector3 & ) 
void btUniversalConstraint_free(void *c); 
void btUniversalConstraint_setLowerLimit(void *c,float p0,float p1); //method: setLowerLimit void ( ::btUniversalConstraint::* )( ::btScalar,::btScalar ) 
void btUniversalConstraint_getAnchor2(void *c,float* ret); //method: getAnchor2 ::btVector3 const & ( ::btUniversalConstraint::* )(  ) 
void btUniversalConstraint_setAxis(void *c,float* p0,float* p1); //method: setAxis void ( ::btUniversalConstraint::* )( ::btVector3 const &,::btVector3 const & ) 
void btUniversalConstraint_getAxis1(void *c,float* ret); //method: getAxis1 ::btVector3 const & ( ::btUniversalConstraint::* )(  ) 
void btUniversalConstraint_getAnchor(void *c,float* ret); //method: getAnchor ::btVector3 const & ( ::btUniversalConstraint::* )(  ) 
void btUniversalConstraint_getAxis2(void *c,float* ret); //method: getAxis2 ::btVector3 const & ( ::btUniversalConstraint::* )(  ) 
void btUniversalConstraint_setUpperLimit(void *c,float p0,float p1); //method: setUpperLimit void ( ::btUniversalConstraint::* )( ::btScalar,::btScalar ) 
float btUniversalConstraint_getAngle2(void *c); //method: getAngle2 ::btScalar ( ::btUniversalConstraint::* )(  ) 
float btUniversalConstraint_getAngle1(void *c); //method: getAngle1 ::btScalar ( ::btUniversalConstraint::* )(  ) 
void btUniversalConstraint_m_anchor_set(void *c,float* a); //attribute: ::btVector3 btUniversalConstraint->m_anchor
void btUniversalConstraint_m_anchor_get(void *c,float* a);
void btUniversalConstraint_m_axis1_set(void *c,float* a); //attribute: ::btVector3 btUniversalConstraint->m_axis1
void btUniversalConstraint_m_axis1_get(void *c,float* a);
void btUniversalConstraint_m_axis2_set(void *c,float* a); //attribute: ::btVector3 btUniversalConstraint->m_axis2
void btUniversalConstraint_m_axis2_get(void *c,float* a);
void* btActionInterface_getFixedBody(); //method: getFixedBody ::btRigidBody & (*)(  )
void btActionInterface_updateAction(void *c,void* p0,float p1); //method: updateAction void ( ::btActionInterface::* )( ::btCollisionWorld *,::btScalar ) 
void btActionInterface_debugDraw(void *c,void* p0); //method: debugDraw void ( ::btActionInterface::* )( ::btIDebugDraw * ) 
void* btDiscreteDynamicsWorld_new(void* p0,void* p1,void* p2,void* p3); //constructor: btDiscreteDynamicsWorld  ( ::btDiscreteDynamicsWorld::* )( ::btDispatcher *,::btBroadphaseInterface *,::btConstraintSolver *,::btCollisionConfiguration * ) 
void btDiscreteDynamicsWorld_free(void *c); 
void btDiscreteDynamicsWorld_setGravity(void *c,float* p0); //method: setGravity void ( ::btDiscreteDynamicsWorld::* )( ::btVector3 const & ) 
void btDiscreteDynamicsWorld_addAction(void *c,void* p0); //method: addAction void ( ::btDiscreteDynamicsWorld::* )( ::btActionInterface * ) 
void btDiscreteDynamicsWorld_applyGravity(void *c); //method: applyGravity void ( ::btDiscreteDynamicsWorld::* )(  ) 
void btDiscreteDynamicsWorld_serialize(void *c,void* p0); //method: serialize void ( ::btDiscreteDynamicsWorld::* )( ::btSerializer * ) 
void* btDiscreteDynamicsWorld_getCollisionWorld(void *c); //method: getCollisionWorld ::btCollisionWorld * ( ::btDiscreteDynamicsWorld::* )(  ) 
void btDiscreteDynamicsWorld_addRigidBody(void *c,void* p0); //method: addRigidBody void ( ::btDiscreteDynamicsWorld::* )( ::btRigidBody * ) 
void btDiscreteDynamicsWorld_addRigidBody0(void *c,void* p0); //method: addRigidBody void ( ::btDiscreteDynamicsWorld::* )( ::btRigidBody * ) 
void btDiscreteDynamicsWorld_addRigidBody1(void *c,void* p0,short int p1,short int p2); //method: addRigidBody void ( ::btDiscreteDynamicsWorld::* )( ::btRigidBody *,short int,short int ) 
void btDiscreteDynamicsWorld_clearForces(void *c); //method: clearForces void ( ::btDiscreteDynamicsWorld::* )(  ) 
void btDiscreteDynamicsWorld_removeVehicle(void *c,void* p0); //method: removeVehicle void ( ::btDiscreteDynamicsWorld::* )( ::btActionInterface * ) 
void btDiscreteDynamicsWorld_serializeRigidBodies(void *c,void* p0); //method: serializeRigidBodies void ( ::btDiscreteDynamicsWorld::* )( ::btSerializer * ) 
void btDiscreteDynamicsWorld_internalSingleStepSimulation(void *c,float p0); //method: internalSingleStepSimulation void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
int btDiscreteDynamicsWorld_getSynchronizeAllMotionStates(void *c); //method: getSynchronizeAllMotionStates bool ( ::btDiscreteDynamicsWorld::* )(  ) const
void btDiscreteDynamicsWorld_setNumTasks(void *c,int p0); //method: setNumTasks void ( ::btDiscreteDynamicsWorld::* )( int ) 
void btDiscreteDynamicsWorld_setSynchronizeAllMotionStates(void *c,int p0); //method: setSynchronizeAllMotionStates void ( ::btDiscreteDynamicsWorld::* )( bool ) 
void btDiscreteDynamicsWorld_predictUnconstraintMotion(void *c,float p0); //method: predictUnconstraintMotion void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
void btDiscreteDynamicsWorld_removeConstraint(void *c,void* p0); //method: removeConstraint void ( ::btDiscreteDynamicsWorld::* )( ::btTypedConstraint * ) 
int btDiscreteDynamicsWorld_getNumConstraints(void *c); //method: getNumConstraints int ( ::btDiscreteDynamicsWorld::* )(  ) const
void btDiscreteDynamicsWorld_addCollisionObject(void *c,void* p0,short int p1,short int p2); //method: addCollisionObject void ( ::btDiscreteDynamicsWorld::* )( ::btCollisionObject *,short int,short int ) 
void btDiscreteDynamicsWorld_removeRigidBody(void *c,void* p0); //method: removeRigidBody void ( ::btDiscreteDynamicsWorld::* )( ::btRigidBody * ) 
void btDiscreteDynamicsWorld_integrateTransforms(void *c,float p0); //method: integrateTransforms void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
void btDiscreteDynamicsWorld_debugDrawConstraint(void *c,void* p0); //method: debugDrawConstraint void ( ::btDiscreteDynamicsWorld::* )( ::btTypedConstraint * ) 
void btDiscreteDynamicsWorld_debugDrawWorld(void *c); //method: debugDrawWorld void ( ::btDiscreteDynamicsWorld::* )(  ) 
void btDiscreteDynamicsWorld_calculateSimulationIslands(void *c); //method: calculateSimulationIslands void ( ::btDiscreteDynamicsWorld::* )(  ) 
void btDiscreteDynamicsWorld_addConstraint(void *c,void* p0,int p1); //method: addConstraint void ( ::btDiscreteDynamicsWorld::* )( ::btTypedConstraint *,bool ) 
void btDiscreteDynamicsWorld_startProfiling(void *c,float p0); //method: startProfiling void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
void btDiscreteDynamicsWorld_updateActivationState(void *c,float p0); //method: updateActivationState void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
void btDiscreteDynamicsWorld_getGravity(void *c,float* ret); //method: getGravity ::btVector3 ( ::btDiscreteDynamicsWorld::* )(  ) const
void btDiscreteDynamicsWorld_removeAction(void *c,void* p0); //method: removeAction void ( ::btDiscreteDynamicsWorld::* )( ::btActionInterface * ) 
void btDiscreteDynamicsWorld_removeCharacter(void *c,void* p0); //method: removeCharacter void ( ::btDiscreteDynamicsWorld::* )( ::btActionInterface * ) 
void btDiscreteDynamicsWorld_saveKinematicState(void *c,float p0); //method: saveKinematicState void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
void* btDiscreteDynamicsWorld_getConstraint(void *c,int p0); //method: getConstraint ::btTypedConstraint * ( ::btDiscreteDynamicsWorld::* )( int ) 
void* btDiscreteDynamicsWorld_getConstraint0(void *c,int p0); //method: getConstraint ::btTypedConstraint * ( ::btDiscreteDynamicsWorld::* )( int ) 
void* btDiscreteDynamicsWorld_getConstraint1(void *c,int p0); //method: getConstraint ::btTypedConstraint const * ( ::btDiscreteDynamicsWorld::* )( int ) const
void* btDiscreteDynamicsWorld_getConstraintSolver(void *c); //method: getConstraintSolver ::btConstraintSolver * ( ::btDiscreteDynamicsWorld::* )(  ) 
//not supported method: getSimulationIslandManager ::btSimulationIslandManager * ( ::btDiscreteDynamicsWorld::* )(  ) 
// error:  - unsupported

//not supported method: getSimulationIslandManager ::btSimulationIslandManager * ( ::btDiscreteDynamicsWorld::* )(  ) 
// error:  - unsupported

//not supported method: getSimulationIslandManager ::btSimulationIslandManager const * ( ::btDiscreteDynamicsWorld::* )(  ) const
// error:  - unsupported

void btDiscreteDynamicsWorld_addCharacter(void *c,void* p0); //method: addCharacter void ( ::btDiscreteDynamicsWorld::* )( ::btActionInterface * ) 
void btDiscreteDynamicsWorld_solveConstraints(void *c,void* p0); //method: solveConstraints void ( ::btDiscreteDynamicsWorld::* )( ::btContactSolverInfo & ) 
//not supported method: getWorldType ::btDynamicsWorldType ( ::btDiscreteDynamicsWorld::* )(  ) const
// error:  - unsupported

void btDiscreteDynamicsWorld_updateActions(void *c,float p0); //method: updateActions void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
void btDiscreteDynamicsWorld_updateVehicles(void *c,float p0); //method: updateVehicles void ( ::btDiscreteDynamicsWorld::* )( ::btScalar ) 
void btDiscreteDynamicsWorld_synchronizeSingleMotionState(void *c,void* p0); //method: synchronizeSingleMotionState void ( ::btDiscreteDynamicsWorld::* )( ::btRigidBody * ) 
void btDiscreteDynamicsWorld_addVehicle(void *c,void* p0); //method: addVehicle void ( ::btDiscreteDynamicsWorld::* )( ::btActionInterface * ) 
void btDiscreteDynamicsWorld_synchronizeMotionStates(void *c); //method: synchronizeMotionStates void ( ::btDiscreteDynamicsWorld::* )(  ) 
int btDiscreteDynamicsWorld_stepSimulation(void *c,float p0,int p1,float p2); //method: stepSimulation int ( ::btDiscreteDynamicsWorld::* )( ::btScalar,int,::btScalar ) 
void btDiscreteDynamicsWorld_removeCollisionObject(void *c,void* p0); //method: removeCollisionObject void ( ::btDiscreteDynamicsWorld::* )( ::btCollisionObject * ) 
void btDiscreteDynamicsWorld_setConstraintSolver(void *c,void* p0); //method: setConstraintSolver void ( ::btDiscreteDynamicsWorld::* )( ::btConstraintSolver * ) 
void btDiscreteDynamicsWorld_m_constraintSolver_set(void *c,void* a); //attribute: ::btConstraintSolver * btDiscreteDynamicsWorld->m_constraintSolver
void* btDiscreteDynamicsWorld_m_constraintSolver_get(void *c); //attribute: ::btConstraintSolver * btDiscreteDynamicsWorld->m_constraintSolver
// attribute not supported: //attribute: ::btSimulationIslandManager * btDiscreteDynamicsWorld->m_islandManager
void btDiscreteDynamicsWorld_m_constraints_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btTypedConstraint*> btDiscreteDynamicsWorld->m_constraints
void* btDiscreteDynamicsWorld_m_constraints_get(void *c); //attribute: ::btAlignedObjectArray<btTypedConstraint*> btDiscreteDynamicsWorld->m_constraints
void btDiscreteDynamicsWorld_m_nonStaticRigidBodies_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btRigidBody*> btDiscreteDynamicsWorld->m_nonStaticRigidBodies
void* btDiscreteDynamicsWorld_m_nonStaticRigidBodies_get(void *c); //attribute: ::btAlignedObjectArray<btRigidBody*> btDiscreteDynamicsWorld->m_nonStaticRigidBodies
void btDiscreteDynamicsWorld_m_gravity_set(void *c,float* a); //attribute: ::btVector3 btDiscreteDynamicsWorld->m_gravity
void btDiscreteDynamicsWorld_m_gravity_get(void *c,float* a);
void btDiscreteDynamicsWorld_m_localTime_set(void *c,float a); //attribute: ::btScalar btDiscreteDynamicsWorld->m_localTime
float btDiscreteDynamicsWorld_m_localTime_get(void *c); //attribute: ::btScalar btDiscreteDynamicsWorld->m_localTime
void btDiscreteDynamicsWorld_m_ownsIslandManager_set(void *c,int a); //attribute: bool btDiscreteDynamicsWorld->m_ownsIslandManager
int btDiscreteDynamicsWorld_m_ownsIslandManager_get(void *c); //attribute: bool btDiscreteDynamicsWorld->m_ownsIslandManager
void btDiscreteDynamicsWorld_m_ownsConstraintSolver_set(void *c,int a); //attribute: bool btDiscreteDynamicsWorld->m_ownsConstraintSolver
int btDiscreteDynamicsWorld_m_ownsConstraintSolver_get(void *c); //attribute: bool btDiscreteDynamicsWorld->m_ownsConstraintSolver
void btDiscreteDynamicsWorld_m_synchronizeAllMotionStates_set(void *c,int a); //attribute: bool btDiscreteDynamicsWorld->m_synchronizeAllMotionStates
int btDiscreteDynamicsWorld_m_synchronizeAllMotionStates_get(void *c); //attribute: bool btDiscreteDynamicsWorld->m_synchronizeAllMotionStates
void btDiscreteDynamicsWorld_m_actions_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btActionInterface*> btDiscreteDynamicsWorld->m_actions
void* btDiscreteDynamicsWorld_m_actions_get(void *c); //attribute: ::btAlignedObjectArray<btActionInterface*> btDiscreteDynamicsWorld->m_actions
void btDiscreteDynamicsWorld_m_profileTimings_set(void *c,int a); //attribute: int btDiscreteDynamicsWorld->m_profileTimings
int btDiscreteDynamicsWorld_m_profileTimings_get(void *c); //attribute: int btDiscreteDynamicsWorld->m_profileTimings
void btDynamicsWorld_setGravity(void *c,float* p0); //method: setGravity void ( ::btDynamicsWorld::* )( ::btVector3 const & ) 
void btDynamicsWorld_addAction(void *c,void* p0); //method: addAction void ( ::btDynamicsWorld::* )( ::btActionInterface * ) 
void* btDynamicsWorld_getSolverInfo(void *c); //method: getSolverInfo ::btContactSolverInfo & ( ::btDynamicsWorld::* )(  ) 
void btDynamicsWorld_addRigidBody(void *c,void* p0); //method: addRigidBody void ( ::btDynamicsWorld::* )( ::btRigidBody * ) 
void btDynamicsWorld_addRigidBody0(void *c,void* p0); //method: addRigidBody void ( ::btDynamicsWorld::* )( ::btRigidBody * ) 
void btDynamicsWorld_addRigidBody1(void *c,void* p0,short int p1,short int p2); //method: addRigidBody void ( ::btDynamicsWorld::* )( ::btRigidBody *,short int,short int ) 
void btDynamicsWorld_clearForces(void *c); //method: clearForces void ( ::btDynamicsWorld::* )(  ) 
void btDynamicsWorld_removeVehicle(void *c,void* p0); //method: removeVehicle void ( ::btDynamicsWorld::* )( ::btActionInterface * ) 
void btDynamicsWorld_removeConstraint(void *c,void* p0); //method: removeConstraint void ( ::btDynamicsWorld::* )( ::btTypedConstraint * ) 
int btDynamicsWorld_getNumConstraints(void *c); //method: getNumConstraints int ( ::btDynamicsWorld::* )(  ) const
void btDynamicsWorld_removeRigidBody(void *c,void* p0); //method: removeRigidBody void ( ::btDynamicsWorld::* )( ::btRigidBody * ) 
//not supported method: setInternalTickCallback void ( ::btDynamicsWorld::* )( ::btInternalTickCallback,void *,bool ) 
// error:  - unsupported, void * - ok, bool - ok, void - ok

void btDynamicsWorld_synchronizeMotionStates(void *c); //method: synchronizeMotionStates void ( ::btDynamicsWorld::* )(  ) 
void btDynamicsWorld_addConstraint(void *c,void* p0,int p1); //method: addConstraint void ( ::btDynamicsWorld::* )( ::btTypedConstraint *,bool ) 
void btDynamicsWorld_getGravity(void *c,float* ret); //method: getGravity ::btVector3 ( ::btDynamicsWorld::* )(  ) const
void btDynamicsWorld_debugDrawWorld(void *c); //method: debugDrawWorld void ( ::btDynamicsWorld::* )(  ) 
void btDynamicsWorld_removeAction(void *c,void* p0); //method: removeAction void ( ::btDynamicsWorld::* )( ::btActionInterface * ) 
void btDynamicsWorld_setWorldUserInfo(void *c,void* p0); //method: setWorldUserInfo void ( ::btDynamicsWorld::* )( void * ) 
void btDynamicsWorld_removeCharacter(void *c,void* p0); //method: removeCharacter void ( ::btDynamicsWorld::* )( ::btActionInterface * ) 
void* btDynamicsWorld_getConstraint(void *c,int p0); //method: getConstraint ::btTypedConstraint * ( ::btDynamicsWorld::* )( int ) 
void* btDynamicsWorld_getConstraint0(void *c,int p0); //method: getConstraint ::btTypedConstraint * ( ::btDynamicsWorld::* )( int ) 
void* btDynamicsWorld_getConstraint1(void *c,int p0); //method: getConstraint ::btTypedConstraint const * ( ::btDynamicsWorld::* )( int ) const
void* btDynamicsWorld_getConstraintSolver(void *c); //method: getConstraintSolver ::btConstraintSolver * ( ::btDynamicsWorld::* )(  ) 
int btDynamicsWorld_stepSimulation(void *c,float p0,int p1,float p2); //method: stepSimulation int ( ::btDynamicsWorld::* )( ::btScalar,int,::btScalar ) 
void btDynamicsWorld_addCharacter(void *c,void* p0); //method: addCharacter void ( ::btDynamicsWorld::* )( ::btActionInterface * ) 
//not supported method: getWorldType ::btDynamicsWorldType ( ::btDynamicsWorld::* )(  ) const
// error:  - unsupported

void btDynamicsWorld_addVehicle(void *c,void* p0); //method: addVehicle void ( ::btDynamicsWorld::* )( ::btActionInterface * ) 
void* btDynamicsWorld_getWorldUserInfo(void *c); //method: getWorldUserInfo void * ( ::btDynamicsWorld::* )(  ) const
void btDynamicsWorld_setConstraintSolver(void *c,void* p0); //method: setConstraintSolver void ( ::btDynamicsWorld::* )( ::btConstraintSolver * ) 
// attribute not supported: //attribute: ::btInternalTickCallback btDynamicsWorld->m_internalTickCallback
// attribute not supported: //attribute: ::btInternalTickCallback btDynamicsWorld->m_internalPreTickCallback
void btDynamicsWorld_m_worldUserInfo_set(void *c,void* a); //attribute: void * btDynamicsWorld->m_worldUserInfo
void* btDynamicsWorld_m_worldUserInfo_get(void *c); //attribute: void * btDynamicsWorld->m_worldUserInfo
void btDynamicsWorld_m_solverInfo_set(void *c,void* a); //attribute: ::btContactSolverInfo btDynamicsWorld->m_solverInfo
void* btDynamicsWorld_m_solverInfo_get(void *c); //attribute: ::btContactSolverInfo btDynamicsWorld->m_solverInfo
void* btRigidBody_new0(void* p0); //constructor: btRigidBody  ( ::btRigidBody::* )( ::btRigidBody::btRigidBodyConstructionInfo const & ) 
void* btRigidBody_new1(float p0,void* p1,void* p2,float* p3); //constructor: btRigidBody  ( ::btRigidBody::* )( ::btScalar,::btMotionState *,::btCollisionShape *,::btVector3 const & ) 
void btRigidBody_free(void *c); 
void btRigidBody_setGravity(void *c,float* p0); //method: setGravity void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_updateDeactivation(void *c,float p0); //method: updateDeactivation void ( ::btRigidBody::* )( ::btScalar ) 
void btRigidBody_setAngularFactor(void *c,float* p0); //method: setAngularFactor void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_setAngularFactor0(void *c,float* p0); //method: setAngularFactor void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_setAngularFactor1(void *c,float p0); //method: setAngularFactor void ( ::btRigidBody::* )( ::btScalar ) 
void btRigidBody_internalWritebackVelocity(void *c); //method: internalWritebackVelocity void ( ::btRigidBody::* )(  ) 
void btRigidBody_internalWritebackVelocity0(void *c); //method: internalWritebackVelocity void ( ::btRigidBody::* )(  ) 
void btRigidBody_internalWritebackVelocity1(void *c,float p0); //method: internalWritebackVelocity void ( ::btRigidBody::* )( ::btScalar ) 
void btRigidBody_getPushVelocity(void *c,float* ret); //method: getPushVelocity ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_internalGetDeltaAngularVelocity(void *c,float* ret); //method: internalGetDeltaAngularVelocity ::btVector3 & ( ::btRigidBody::* )(  ) 
void btRigidBody_applyGravity(void *c); //method: applyGravity void ( ::btRigidBody::* )(  ) 
char const * btRigidBody_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btRigidBody::* )( void *,::btSerializer * ) const
void btRigidBody_getOrientation(void *c,float* ret); //method: getOrientation ::btQuaternion ( ::btRigidBody::* )(  ) const
void btRigidBody_applyCentralForce(void *c,float* p0); //method: applyCentralForce void ( ::btRigidBody::* )( ::btVector3 const & ) 
//not supported method: internalApplyImpulse void ( ::btRigidBody::* )( ::btVector3 const &,::btVector3 const &,::btScalar const ) 
// error: ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported, void - ok

void btRigidBody_setMotionState(void *c,void* p0); //method: setMotionState void ( ::btRigidBody::* )( ::btMotionState * ) 
void btRigidBody_clearForces(void *c); //method: clearForces void ( ::btRigidBody::* )(  ) 
void* btRigidBody_getMotionState(void *c); //method: getMotionState ::btMotionState * ( ::btRigidBody::* )(  ) 
void* btRigidBody_getMotionState0(void *c); //method: getMotionState ::btMotionState * ( ::btRigidBody::* )(  ) 
void* btRigidBody_getMotionState1(void *c); //method: getMotionState ::btMotionState const * ( ::btRigidBody::* )(  ) const
void btRigidBody_setDamping(void *c,float p0,float p1); //method: setDamping void ( ::btRigidBody::* )( ::btScalar,::btScalar ) 
void btRigidBody_applyImpulse(void *c,float* p0,float* p1); //method: applyImpulse void ( ::btRigidBody::* )( ::btVector3 const &,::btVector3 const & ) 
void btRigidBody_applyTorque(void *c,float* p0); //method: applyTorque void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_internalApplyPushImpulse(void *c,float* p0,float* p1,float p2); //method: internalApplyPushImpulse void ( ::btRigidBody::* )( ::btVector3 const &,::btVector3 const &,::btScalar ) 
int btRigidBody_wantsSleeping(void *c); //method: wantsSleeping bool ( ::btRigidBody::* )(  ) 
void btRigidBody_setNewBroadphaseProxy(void *c,void* p0); //method: setNewBroadphaseProxy void ( ::btRigidBody::* )( ::btBroadphaseProxy * ) 
void btRigidBody_getVelocityInLocalPoint(void *c,float* p0,float* ret); //method: getVelocityInLocalPoint ::btVector3 ( ::btRigidBody::* )( ::btVector3 const & ) const
int btRigidBody_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btRigidBody::* )(  ) const
void btRigidBody_setAngularVelocity(void *c,float* p0); //method: setAngularVelocity void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_getLinearFactor(void *c,float* ret); //method: getLinearFactor ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_predictIntegratedTransform(void *c,float p0,float* p1); //method: predictIntegratedTransform void ( ::btRigidBody::* )( ::btScalar,::btTransform & ) 
void btRigidBody_internalGetAngularFactor(void *c,float* ret); //method: internalGetAngularFactor ::btVector3 const & ( ::btRigidBody::* )(  ) const
float btRigidBody_getAngularSleepingThreshold(void *c); //method: getAngularSleepingThreshold ::btScalar ( ::btRigidBody::* )(  ) const
void btRigidBody_applyDamping(void *c,float p0); //method: applyDamping void ( ::btRigidBody::* )( ::btScalar ) 
void btRigidBody_saveKinematicState(void *c,float p0); //method: saveKinematicState void ( ::btRigidBody::* )( ::btScalar ) 
void btRigidBody_setSleepingThresholds(void *c,float p0,float p1); //method: setSleepingThresholds void ( ::btRigidBody::* )( ::btScalar,::btScalar ) 
void btRigidBody_getAngularVelocity(void *c,float* ret); //method: getAngularVelocity ::btVector3 const & ( ::btRigidBody::* )(  ) const
float btRigidBody_getLinearSleepingThreshold(void *c); //method: getLinearSleepingThreshold ::btScalar ( ::btRigidBody::* )(  ) const
void btRigidBody_internalGetInvMass(void *c,float* ret); //method: internalGetInvMass ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_applyTorqueImpulse(void *c,float* p0); //method: applyTorqueImpulse void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_internalGetPushVelocity(void *c,float* ret); //method: internalGetPushVelocity ::btVector3 & ( ::btRigidBody::* )(  ) 
void btRigidBody_setLinearFactor(void *c,float* p0); //method: setLinearFactor void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_serializeSingleObject(void *c,void* p0); //method: serializeSingleObject void ( ::btRigidBody::* )( ::btSerializer * ) const
float btRigidBody_getInvMass(void *c); //method: getInvMass ::btScalar ( ::btRigidBody::* )(  ) const
void btRigidBody_getTotalForce(void *c,float* ret); //method: getTotalForce ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getCenterOfMassPosition(void *c,float* ret); //method: getCenterOfMassPosition ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getAabb(void *c,float* p0,float* p1); //method: getAabb void ( ::btRigidBody::* )( ::btVector3 &,::btVector3 & ) const
void* btRigidBody_getBroadphaseProxy(void *c); //method: getBroadphaseProxy ::btBroadphaseProxy const * ( ::btRigidBody::* )(  ) const
void* btRigidBody_getBroadphaseProxy0(void *c); //method: getBroadphaseProxy ::btBroadphaseProxy const * ( ::btRigidBody::* )(  ) const
void* btRigidBody_getBroadphaseProxy1(void *c); //method: getBroadphaseProxy ::btBroadphaseProxy * ( ::btRigidBody::* )(  ) 
void* btRigidBody_getCollisionShape(void *c); //method: getCollisionShape ::btCollisionShape const * ( ::btRigidBody::* )(  ) const
void* btRigidBody_getCollisionShape0(void *c); //method: getCollisionShape ::btCollisionShape const * ( ::btRigidBody::* )(  ) const
void* btRigidBody_getCollisionShape1(void *c); //method: getCollisionShape ::btCollisionShape * ( ::btRigidBody::* )(  ) 
void* btRigidBody_upcast(void* p0); //method: upcast ::btRigidBody const * (*)( ::btCollisionObject const * )
void* btRigidBody_upcast0(void* p0); //method: upcast ::btRigidBody const * (*)( ::btCollisionObject const * )
void* btRigidBody_upcast1(void* p0); //method: upcast ::btRigidBody * (*)( ::btCollisionObject * )
int btRigidBody_checkCollideWithOverride(void *c,void* p0); //method: checkCollideWithOverride bool ( ::btRigidBody::* )( ::btCollisionObject * ) 
void btRigidBody_translate(void *c,float* p0); //method: translate void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_updateInertiaTensor(void *c); //method: updateInertiaTensor void ( ::btRigidBody::* )(  ) 
void btRigidBody_applyForce(void *c,float* p0,float* p1); //method: applyForce void ( ::btRigidBody::* )( ::btVector3 const &,::btVector3 const & ) 
void btRigidBody_internalGetAngularVelocity(void *c,float* p0); //method: internalGetAngularVelocity void ( ::btRigidBody::* )( ::btVector3 & ) const
void btRigidBody_setupRigidBody(void *c,void* p0); //method: setupRigidBody void ( ::btRigidBody::* )( ::btRigidBody::btRigidBodyConstructionInfo const & ) 
void btRigidBody_applyCentralImpulse(void *c,float* p0); //method: applyCentralImpulse void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_getTurnVelocity(void *c,float* ret); //method: getTurnVelocity ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getDeltaLinearVelocity(void *c,float* ret); //method: getDeltaLinearVelocity ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_integrateVelocities(void *c,float p0); //method: integrateVelocities void ( ::btRigidBody::* )( ::btScalar ) 
void btRigidBody_getGravity(void *c,float* ret); //method: getGravity ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_setMassProps(void *c,float p0,float* p1); //method: setMassProps void ( ::btRigidBody::* )( ::btScalar,::btVector3 const & ) 
void btRigidBody_setCenterOfMassTransform(void *c,float* p0); //method: setCenterOfMassTransform void ( ::btRigidBody::* )( ::btTransform const & ) 
void btRigidBody_setFlags(void *c,int p0); //method: setFlags void ( ::btRigidBody::* )( int ) 
void btRigidBody_addConstraintRef(void *c,void* p0); //method: addConstraintRef void ( ::btRigidBody::* )( ::btTypedConstraint * ) 
void btRigidBody_setLinearVelocity(void *c,float* p0); //method: setLinearVelocity void ( ::btRigidBody::* )( ::btVector3 const & ) 
int btRigidBody_isInWorld(void *c); //method: isInWorld bool ( ::btRigidBody::* )(  ) const
void btRigidBody_getTotalTorque(void *c,float* ret); //method: getTotalTorque ::btVector3 const & ( ::btRigidBody::* )(  ) const
int btRigidBody_getNumConstraintRefs(void *c); //method: getNumConstraintRefs int ( ::btRigidBody::* )(  ) const
float btRigidBody_computeAngularImpulseDenominator(void *c,float* p0); //method: computeAngularImpulseDenominator ::btScalar ( ::btRigidBody::* )( ::btVector3 const & ) const
void btRigidBody_getInvInertiaTensorWorld(void *c,float* ret); //method: getInvInertiaTensorWorld ::btMatrix3x3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getDeltaAngularVelocity(void *c,float* ret); //method: getDeltaAngularVelocity ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_internalGetDeltaLinearVelocity(void *c,float* ret); //method: internalGetDeltaLinearVelocity ::btVector3 & ( ::btRigidBody::* )(  ) 
float btRigidBody_computeImpulseDenominator(void *c,float* p0,float* p1); //method: computeImpulseDenominator ::btScalar ( ::btRigidBody::* )( ::btVector3 const &,::btVector3 const & ) const
void* btRigidBody_getConstraintRef(void *c,int p0); //method: getConstraintRef ::btTypedConstraint * ( ::btRigidBody::* )( int ) 
float btRigidBody_getAngularDamping(void *c); //method: getAngularDamping ::btScalar ( ::btRigidBody::* )(  ) const
void btRigidBody_internalGetTurnVelocity(void *c,float* ret); //method: internalGetTurnVelocity ::btVector3 & ( ::btRigidBody::* )(  ) 
void btRigidBody_proceedToTransform(void *c,float* p0); //method: proceedToTransform void ( ::btRigidBody::* )( ::btTransform const & ) 
void btRigidBody_setInvInertiaDiagLocal(void *c,float* p0); //method: setInvInertiaDiagLocal void ( ::btRigidBody::* )( ::btVector3 const & ) 
void btRigidBody_getInvInertiaDiagLocal(void *c,float* ret); //method: getInvInertiaDiagLocal ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getCenterOfMassTransform(void *c,float* ret); //method: getCenterOfMassTransform ::btTransform const & ( ::btRigidBody::* )(  ) const
void btRigidBody_removeConstraintRef(void *c,void* p0); //method: removeConstraintRef void ( ::btRigidBody::* )( ::btTypedConstraint * ) 
void btRigidBody_getAngularFactor(void *c,float* ret); //method: getAngularFactor ::btVector3 const & ( ::btRigidBody::* )(  ) const
void btRigidBody_getLinearVelocity(void *c,float* ret); //method: getLinearVelocity ::btVector3 const & ( ::btRigidBody::* )(  ) const
int btRigidBody_getFlags(void *c); //method: getFlags int ( ::btRigidBody::* )(  ) const
void btRigidBody_internalGetVelocityInLocalPointObsolete(void *c,float* p0,float* p1); //method: internalGetVelocityInLocalPointObsolete void ( ::btRigidBody::* )( ::btVector3 const &,::btVector3 & ) const
float btRigidBody_getLinearDamping(void *c); //method: getLinearDamping ::btScalar ( ::btRigidBody::* )(  ) const
void btRigidBody_m_additionalAngularDampingFactor_set(void *c,float a); //attribute: ::btScalar btRigidBody->m_additionalAngularDampingFactor
float btRigidBody_m_additionalAngularDampingFactor_get(void *c); //attribute: ::btScalar btRigidBody->m_additionalAngularDampingFactor
void btRigidBody_m_additionalAngularDampingThresholdSqr_set(void *c,float a); //attribute: ::btScalar btRigidBody->m_additionalAngularDampingThresholdSqr
float btRigidBody_m_additionalAngularDampingThresholdSqr_get(void *c); //attribute: ::btScalar btRigidBody->m_additionalAngularDampingThresholdSqr
void btRigidBody_m_additionalDamping_set(void *c,int a); //attribute: bool btRigidBody->m_additionalDamping
int btRigidBody_m_additionalDamping_get(void *c); //attribute: bool btRigidBody->m_additionalDamping
void btRigidBody_m_additionalDampingFactor_set(void *c,float a); //attribute: ::btScalar btRigidBody->m_additionalDampingFactor
float btRigidBody_m_additionalDampingFactor_get(void *c); //attribute: ::btScalar btRigidBody->m_additionalDampingFactor
void btRigidBody_m_additionalLinearDampingThresholdSqr_set(void *c,float a); //attribute: ::btScalar btRigidBody->m_additionalLinearDampingThresholdSqr
float btRigidBody_m_additionalLinearDampingThresholdSqr_get(void *c); //attribute: ::btScalar btRigidBody->m_additionalLinearDampingThresholdSqr
void btRigidBody_m_angularDamping_set(void *c,float a); //attribute: ::btScalar btRigidBody->m_angularDamping
float btRigidBody_m_angularDamping_get(void *c); //attribute: ::btScalar btRigidBody->m_angularDamping
void btRigidBody_m_angularFactor_set(void *c,float* a); //attribute: ::btVector3 btRigidBody->m_angularFactor
void btRigidBody_m_angularFactor_get(void *c,float* a);
void btRigidBody_m_angularSleepingThreshold_set(void *c,float a); //attribute: ::btScalar btRigidBody->m_angularSleepingThreshold
float btRigidBody_m_angularSleepingThreshold_get(void *c); //attribute: ::btScalar btRigidBody->m_angularSleepingThreshold
void btRigidBody_m_angularVelocity_set(void *c,float* a); //attribute: ::btVector3 btRigidBody->m_angularVelocity
void btRigidBody_m_angularVelocity_get(void *c,float* a);
void btRigidBody_m_constraintRefs_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btTypedConstraint*> btRigidBody->m_constraintRefs
void* btRigidBody_m_constraintRefs_get(void *c); //attribute: ::btAlignedObjectArray<btTypedConstraint*> btRigidBody->m_constraintRefs
void btRigidBody_m_contactSolverType_set(void *c,int a); //attribute: int btRigidBody->m_contactSolverType
int btRigidBody_m_contactSolverType_get(void *c); //attribute: int btRigidBody->m_contactSolverType
void btRigidBody_m_debugBodyId_set(void *c,int a); //attribute: int btRigidBody->m_debugBodyId
int btRigidBody_m_debugBodyId_get(void *c); //attribute: int btRigidBody->m_debugBodyId
void btRigidBody_m_deltaAngularVelocity_set(void *c,float* a); //attribute: ::btVector3 btRigidBody->m_deltaAngularVelocity
void btRigidBody_m_deltaAngularVelocity_get(void *c,float* a);
void btRigidBody_m_deltaLinearVelocity_set(void *c,float* a); //attribute: ::btVector3 btRigidBody->m_deltaLinearVelocity
void btRigidBody_m_deltaLinearVelocity_get(void *c,float* a);
void btRigidBody_m_frictionSolverType_set(void *c,int a); //attribute: int btRigidBody->m_frictionSolverType
int btRigidBody_m_frictionSolverType_get(void *c); //attribute: int btRigidBody->m_frictionSolverType
void btRigidBody_m_gravity_set(void *c,float* a); //attribute: ::btVector3 btRigidBody->m_gravity
void btRigidBody_m_gravity_get(void *c,float* a);
void btRigidBody_m_gravity_acceleration_set(void *c,float* a); //attribute: ::btVector3 btRigidBody->m_gravity_acceleration
void btRigidBody_m_gravity_acceleration_get(void *c,float* a);
void btRigidBody_m_invInertiaLocal_set(void *c,float* a); //attribute: ::btVector3 btRigidBody->m_invInertiaLocal
void btRigidBody_m_invInertiaLocal_get(void *c,float* a);
void btRigidBody_m_invInertiaTensorWorld_set(void *c,float* a); //attribute: ::btMatrix3x3 btRigidBody->m_invInertiaTensorWorld
void btRigidBody_m_invInertiaTensorWorld_get(void *c,float* a);
void btRigidBody_m_invMass_set(void *c,float* a); //attribute: ::btVector3 btRigidBody->m_invMass
void btRigidBody_m_invMass_get(void *c,float* a);
void btRigidBody_m_inverseMass_set(void *c,float a); //attribute: ::btScalar btRigidBody->m_inverseMass
float btRigidBody_m_inverseMass_get(void *c); //attribute: ::btScalar btRigidBody->m_inverseMass
void btRigidBody_m_linearDamping_set(void *c,float a); //attribute: ::btScalar btRigidBody->m_linearDamping
float btRigidBody_m_linearDamping_get(void *c); //attribute: ::btScalar btRigidBody->m_linearDamping
void btRigidBody_m_linearFactor_set(void *c,float* a); //attribute: ::btVector3 btRigidBody->m_linearFactor
void btRigidBody_m_linearFactor_get(void *c,float* a);
void btRigidBody_m_linearSleepingThreshold_set(void *c,float a); //attribute: ::btScalar btRigidBody->m_linearSleepingThreshold
float btRigidBody_m_linearSleepingThreshold_get(void *c); //attribute: ::btScalar btRigidBody->m_linearSleepingThreshold
void btRigidBody_m_linearVelocity_set(void *c,float* a); //attribute: ::btVector3 btRigidBody->m_linearVelocity
void btRigidBody_m_linearVelocity_get(void *c,float* a);
void btRigidBody_m_optionalMotionState_set(void *c,void* a); //attribute: ::btMotionState * btRigidBody->m_optionalMotionState
void* btRigidBody_m_optionalMotionState_get(void *c); //attribute: ::btMotionState * btRigidBody->m_optionalMotionState
void btRigidBody_m_pushVelocity_set(void *c,float* a); //attribute: ::btVector3 btRigidBody->m_pushVelocity
void btRigidBody_m_pushVelocity_get(void *c,float* a);
void btRigidBody_m_rigidbodyFlags_set(void *c,int a); //attribute: int btRigidBody->m_rigidbodyFlags
int btRigidBody_m_rigidbodyFlags_get(void *c); //attribute: int btRigidBody->m_rigidbodyFlags
void btRigidBody_m_totalForce_set(void *c,float* a); //attribute: ::btVector3 btRigidBody->m_totalForce
void btRigidBody_m_totalForce_get(void *c,float* a);
void btRigidBody_m_totalTorque_set(void *c,float* a); //attribute: ::btVector3 btRigidBody->m_totalTorque
void btRigidBody_m_totalTorque_get(void *c,float* a);
void btRigidBody_m_turnVelocity_set(void *c,float* a); //attribute: ::btVector3 btRigidBody->m_turnVelocity
void btRigidBody_m_turnVelocity_get(void *c,float* a);
void* btRigidBody_btRigidBodyConstructionInfo_new(float p0,void* p1,void* p2,float* p3); //constructor: btRigidBodyConstructionInfo  ( ::btRigidBody::btRigidBodyConstructionInfo::* )( ::btScalar,::btMotionState *,::btCollisionShape *,::btVector3 const & ) 
void btRigidBody_btRigidBodyConstructionInfo_free(void *c); 
void btRigidBody_btRigidBodyConstructionInfo_m_additionalAngularDampingFactor_set(void *c,float a); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_additionalAngularDampingFactor
float btRigidBody_btRigidBodyConstructionInfo_m_additionalAngularDampingFactor_get(void *c); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_additionalAngularDampingFactor
void btRigidBody_btRigidBodyConstructionInfo_m_additionalAngularDampingThresholdSqr_set(void *c,float a); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_additionalAngularDampingThresholdSqr
float btRigidBody_btRigidBodyConstructionInfo_m_additionalAngularDampingThresholdSqr_get(void *c); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_additionalAngularDampingThresholdSqr
void btRigidBody_btRigidBodyConstructionInfo_m_additionalDamping_set(void *c,int a); //attribute: bool btRigidBody_btRigidBodyConstructionInfo->m_additionalDamping
int btRigidBody_btRigidBodyConstructionInfo_m_additionalDamping_get(void *c); //attribute: bool btRigidBody_btRigidBodyConstructionInfo->m_additionalDamping
void btRigidBody_btRigidBodyConstructionInfo_m_additionalDampingFactor_set(void *c,float a); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_additionalDampingFactor
float btRigidBody_btRigidBodyConstructionInfo_m_additionalDampingFactor_get(void *c); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_additionalDampingFactor
void btRigidBody_btRigidBodyConstructionInfo_m_additionalLinearDampingThresholdSqr_set(void *c,float a); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_additionalLinearDampingThresholdSqr
float btRigidBody_btRigidBodyConstructionInfo_m_additionalLinearDampingThresholdSqr_get(void *c); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_additionalLinearDampingThresholdSqr
void btRigidBody_btRigidBodyConstructionInfo_m_angularDamping_set(void *c,float a); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_angularDamping
float btRigidBody_btRigidBodyConstructionInfo_m_angularDamping_get(void *c); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_angularDamping
void btRigidBody_btRigidBodyConstructionInfo_m_angularSleepingThreshold_set(void *c,float a); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_angularSleepingThreshold
float btRigidBody_btRigidBodyConstructionInfo_m_angularSleepingThreshold_get(void *c); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_angularSleepingThreshold
void btRigidBody_btRigidBodyConstructionInfo_m_collisionShape_set(void *c,void* a); //attribute: ::btCollisionShape * btRigidBody_btRigidBodyConstructionInfo->m_collisionShape
void* btRigidBody_btRigidBodyConstructionInfo_m_collisionShape_get(void *c); //attribute: ::btCollisionShape * btRigidBody_btRigidBodyConstructionInfo->m_collisionShape
void btRigidBody_btRigidBodyConstructionInfo_m_friction_set(void *c,float a); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_friction
float btRigidBody_btRigidBodyConstructionInfo_m_friction_get(void *c); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_friction
void btRigidBody_btRigidBodyConstructionInfo_m_linearDamping_set(void *c,float a); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_linearDamping
float btRigidBody_btRigidBodyConstructionInfo_m_linearDamping_get(void *c); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_linearDamping
void btRigidBody_btRigidBodyConstructionInfo_m_linearSleepingThreshold_set(void *c,float a); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_linearSleepingThreshold
float btRigidBody_btRigidBodyConstructionInfo_m_linearSleepingThreshold_get(void *c); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_linearSleepingThreshold
void btRigidBody_btRigidBodyConstructionInfo_m_localInertia_set(void *c,float* a); //attribute: ::btVector3 btRigidBody_btRigidBodyConstructionInfo->m_localInertia
void btRigidBody_btRigidBodyConstructionInfo_m_localInertia_get(void *c,float* a);
void btRigidBody_btRigidBodyConstructionInfo_m_mass_set(void *c,float a); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_mass
float btRigidBody_btRigidBodyConstructionInfo_m_mass_get(void *c); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_mass
void btRigidBody_btRigidBodyConstructionInfo_m_motionState_set(void *c,void* a); //attribute: ::btMotionState * btRigidBody_btRigidBodyConstructionInfo->m_motionState
void* btRigidBody_btRigidBodyConstructionInfo_m_motionState_get(void *c); //attribute: ::btMotionState * btRigidBody_btRigidBodyConstructionInfo->m_motionState
void btRigidBody_btRigidBodyConstructionInfo_m_restitution_set(void *c,float a); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_restitution
float btRigidBody_btRigidBodyConstructionInfo_m_restitution_get(void *c); //attribute: ::btScalar btRigidBody_btRigidBodyConstructionInfo->m_restitution
void btRigidBody_btRigidBodyConstructionInfo_m_startWorldTransform_set(void *c,float* a); //attribute: ::btTransform btRigidBody_btRigidBodyConstructionInfo->m_startWorldTransform
void btRigidBody_btRigidBodyConstructionInfo_m_startWorldTransform_get(void *c,float* a);
void* btRigidBodyDoubleData_new(); //constructor: btRigidBodyDoubleData  ( ::btRigidBodyDoubleData::* )(  ) 
void btRigidBodyDoubleData_free(void *c); 
void btRigidBodyDoubleData_m_collisionObjectData_set(void *c,void* a); //attribute: ::btCollisionObjectDoubleData btRigidBodyDoubleData->m_collisionObjectData
void* btRigidBodyDoubleData_m_collisionObjectData_get(void *c); //attribute: ::btCollisionObjectDoubleData btRigidBodyDoubleData->m_collisionObjectData
void btRigidBodyDoubleData_m_invInertiaTensorWorld_set(void *c,void* a); //attribute: ::btMatrix3x3DoubleData btRigidBodyDoubleData->m_invInertiaTensorWorld
void* btRigidBodyDoubleData_m_invInertiaTensorWorld_get(void *c); //attribute: ::btMatrix3x3DoubleData btRigidBodyDoubleData->m_invInertiaTensorWorld
void btRigidBodyDoubleData_m_linearVelocity_set(void *c,void* a); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_linearVelocity
void* btRigidBodyDoubleData_m_linearVelocity_get(void *c); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_linearVelocity
void btRigidBodyDoubleData_m_angularVelocity_set(void *c,void* a); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_angularVelocity
void* btRigidBodyDoubleData_m_angularVelocity_get(void *c); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_angularVelocity
void btRigidBodyDoubleData_m_angularFactor_set(void *c,void* a); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_angularFactor
void* btRigidBodyDoubleData_m_angularFactor_get(void *c); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_angularFactor
void btRigidBodyDoubleData_m_linearFactor_set(void *c,void* a); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_linearFactor
void* btRigidBodyDoubleData_m_linearFactor_get(void *c); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_linearFactor
void btRigidBodyDoubleData_m_gravity_set(void *c,void* a); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_gravity
void* btRigidBodyDoubleData_m_gravity_get(void *c); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_gravity
void btRigidBodyDoubleData_m_gravity_acceleration_set(void *c,void* a); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_gravity_acceleration
void* btRigidBodyDoubleData_m_gravity_acceleration_get(void *c); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_gravity_acceleration
void btRigidBodyDoubleData_m_invInertiaLocal_set(void *c,void* a); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_invInertiaLocal
void* btRigidBodyDoubleData_m_invInertiaLocal_get(void *c); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_invInertiaLocal
void btRigidBodyDoubleData_m_totalForce_set(void *c,void* a); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_totalForce
void* btRigidBodyDoubleData_m_totalForce_get(void *c); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_totalForce
void btRigidBodyDoubleData_m_totalTorque_set(void *c,void* a); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_totalTorque
void* btRigidBodyDoubleData_m_totalTorque_get(void *c); //attribute: ::btVector3DoubleData btRigidBodyDoubleData->m_totalTorque
void btRigidBodyDoubleData_m_inverseMass_set(void *c,double a); //attribute: double btRigidBodyDoubleData->m_inverseMass
double btRigidBodyDoubleData_m_inverseMass_get(void *c); //attribute: double btRigidBodyDoubleData->m_inverseMass
void btRigidBodyDoubleData_m_linearDamping_set(void *c,double a); //attribute: double btRigidBodyDoubleData->m_linearDamping
double btRigidBodyDoubleData_m_linearDamping_get(void *c); //attribute: double btRigidBodyDoubleData->m_linearDamping
void btRigidBodyDoubleData_m_angularDamping_set(void *c,double a); //attribute: double btRigidBodyDoubleData->m_angularDamping
double btRigidBodyDoubleData_m_angularDamping_get(void *c); //attribute: double btRigidBodyDoubleData->m_angularDamping
void btRigidBodyDoubleData_m_additionalDampingFactor_set(void *c,double a); //attribute: double btRigidBodyDoubleData->m_additionalDampingFactor
double btRigidBodyDoubleData_m_additionalDampingFactor_get(void *c); //attribute: double btRigidBodyDoubleData->m_additionalDampingFactor
void btRigidBodyDoubleData_m_additionalLinearDampingThresholdSqr_set(void *c,double a); //attribute: double btRigidBodyDoubleData->m_additionalLinearDampingThresholdSqr
double btRigidBodyDoubleData_m_additionalLinearDampingThresholdSqr_get(void *c); //attribute: double btRigidBodyDoubleData->m_additionalLinearDampingThresholdSqr
void btRigidBodyDoubleData_m_additionalAngularDampingThresholdSqr_set(void *c,double a); //attribute: double btRigidBodyDoubleData->m_additionalAngularDampingThresholdSqr
double btRigidBodyDoubleData_m_additionalAngularDampingThresholdSqr_get(void *c); //attribute: double btRigidBodyDoubleData->m_additionalAngularDampingThresholdSqr
void btRigidBodyDoubleData_m_additionalAngularDampingFactor_set(void *c,double a); //attribute: double btRigidBodyDoubleData->m_additionalAngularDampingFactor
double btRigidBodyDoubleData_m_additionalAngularDampingFactor_get(void *c); //attribute: double btRigidBodyDoubleData->m_additionalAngularDampingFactor
void btRigidBodyDoubleData_m_linearSleepingThreshold_set(void *c,double a); //attribute: double btRigidBodyDoubleData->m_linearSleepingThreshold
double btRigidBodyDoubleData_m_linearSleepingThreshold_get(void *c); //attribute: double btRigidBodyDoubleData->m_linearSleepingThreshold
void btRigidBodyDoubleData_m_angularSleepingThreshold_set(void *c,double a); //attribute: double btRigidBodyDoubleData->m_angularSleepingThreshold
double btRigidBodyDoubleData_m_angularSleepingThreshold_get(void *c); //attribute: double btRigidBodyDoubleData->m_angularSleepingThreshold
void btRigidBodyDoubleData_m_additionalDamping_set(void *c,int a); //attribute: int btRigidBodyDoubleData->m_additionalDamping
int btRigidBodyDoubleData_m_additionalDamping_get(void *c); //attribute: int btRigidBodyDoubleData->m_additionalDamping
// attribute not supported: //attribute: char[4] btRigidBodyDoubleData->m_padding
void* btRigidBodyFloatData_new(); //constructor: btRigidBodyFloatData  ( ::btRigidBodyFloatData::* )(  ) 
void btRigidBodyFloatData_free(void *c); 
void btRigidBodyFloatData_m_additionalAngularDampingFactor_set(void *c,float a); //attribute: float btRigidBodyFloatData->m_additionalAngularDampingFactor
float btRigidBodyFloatData_m_additionalAngularDampingFactor_get(void *c); //attribute: float btRigidBodyFloatData->m_additionalAngularDampingFactor
void btRigidBodyFloatData_m_additionalAngularDampingThresholdSqr_set(void *c,float a); //attribute: float btRigidBodyFloatData->m_additionalAngularDampingThresholdSqr
float btRigidBodyFloatData_m_additionalAngularDampingThresholdSqr_get(void *c); //attribute: float btRigidBodyFloatData->m_additionalAngularDampingThresholdSqr
void btRigidBodyFloatData_m_additionalDamping_set(void *c,int a); //attribute: int btRigidBodyFloatData->m_additionalDamping
int btRigidBodyFloatData_m_additionalDamping_get(void *c); //attribute: int btRigidBodyFloatData->m_additionalDamping
void btRigidBodyFloatData_m_additionalDampingFactor_set(void *c,float a); //attribute: float btRigidBodyFloatData->m_additionalDampingFactor
float btRigidBodyFloatData_m_additionalDampingFactor_get(void *c); //attribute: float btRigidBodyFloatData->m_additionalDampingFactor
void btRigidBodyFloatData_m_additionalLinearDampingThresholdSqr_set(void *c,float a); //attribute: float btRigidBodyFloatData->m_additionalLinearDampingThresholdSqr
float btRigidBodyFloatData_m_additionalLinearDampingThresholdSqr_get(void *c); //attribute: float btRigidBodyFloatData->m_additionalLinearDampingThresholdSqr
void btRigidBodyFloatData_m_angularDamping_set(void *c,float a); //attribute: float btRigidBodyFloatData->m_angularDamping
float btRigidBodyFloatData_m_angularDamping_get(void *c); //attribute: float btRigidBodyFloatData->m_angularDamping
void btRigidBodyFloatData_m_angularFactor_set(void *c,void* a); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_angularFactor
void* btRigidBodyFloatData_m_angularFactor_get(void *c); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_angularFactor
void btRigidBodyFloatData_m_angularSleepingThreshold_set(void *c,float a); //attribute: float btRigidBodyFloatData->m_angularSleepingThreshold
float btRigidBodyFloatData_m_angularSleepingThreshold_get(void *c); //attribute: float btRigidBodyFloatData->m_angularSleepingThreshold
void btRigidBodyFloatData_m_angularVelocity_set(void *c,void* a); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_angularVelocity
void* btRigidBodyFloatData_m_angularVelocity_get(void *c); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_angularVelocity
void btRigidBodyFloatData_m_collisionObjectData_set(void *c,void* a); //attribute: ::btCollisionObjectFloatData btRigidBodyFloatData->m_collisionObjectData
void* btRigidBodyFloatData_m_collisionObjectData_get(void *c); //attribute: ::btCollisionObjectFloatData btRigidBodyFloatData->m_collisionObjectData
void btRigidBodyFloatData_m_gravity_set(void *c,void* a); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_gravity
void* btRigidBodyFloatData_m_gravity_get(void *c); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_gravity
void btRigidBodyFloatData_m_gravity_acceleration_set(void *c,void* a); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_gravity_acceleration
void* btRigidBodyFloatData_m_gravity_acceleration_get(void *c); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_gravity_acceleration
void btRigidBodyFloatData_m_invInertiaLocal_set(void *c,void* a); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_invInertiaLocal
void* btRigidBodyFloatData_m_invInertiaLocal_get(void *c); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_invInertiaLocal
void btRigidBodyFloatData_m_invInertiaTensorWorld_set(void *c,void* a); //attribute: ::btMatrix3x3FloatData btRigidBodyFloatData->m_invInertiaTensorWorld
void* btRigidBodyFloatData_m_invInertiaTensorWorld_get(void *c); //attribute: ::btMatrix3x3FloatData btRigidBodyFloatData->m_invInertiaTensorWorld
void btRigidBodyFloatData_m_inverseMass_set(void *c,float a); //attribute: float btRigidBodyFloatData->m_inverseMass
float btRigidBodyFloatData_m_inverseMass_get(void *c); //attribute: float btRigidBodyFloatData->m_inverseMass
void btRigidBodyFloatData_m_linearDamping_set(void *c,float a); //attribute: float btRigidBodyFloatData->m_linearDamping
float btRigidBodyFloatData_m_linearDamping_get(void *c); //attribute: float btRigidBodyFloatData->m_linearDamping
void btRigidBodyFloatData_m_linearFactor_set(void *c,void* a); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_linearFactor
void* btRigidBodyFloatData_m_linearFactor_get(void *c); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_linearFactor
void btRigidBodyFloatData_m_linearSleepingThreshold_set(void *c,float a); //attribute: float btRigidBodyFloatData->m_linearSleepingThreshold
float btRigidBodyFloatData_m_linearSleepingThreshold_get(void *c); //attribute: float btRigidBodyFloatData->m_linearSleepingThreshold
void btRigidBodyFloatData_m_linearVelocity_set(void *c,void* a); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_linearVelocity
void* btRigidBodyFloatData_m_linearVelocity_get(void *c); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_linearVelocity
void btRigidBodyFloatData_m_totalForce_set(void *c,void* a); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_totalForce
void* btRigidBodyFloatData_m_totalForce_get(void *c); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_totalForce
void btRigidBodyFloatData_m_totalTorque_set(void *c,void* a); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_totalTorque
void* btRigidBodyFloatData_m_totalTorque_get(void *c); //attribute: ::btVector3FloatData btRigidBodyFloatData->m_totalTorque
void* btSimpleDynamicsWorld_new(void* p0,void* p1,void* p2,void* p3); //constructor: btSimpleDynamicsWorld  ( ::btSimpleDynamicsWorld::* )( ::btDispatcher *,::btBroadphaseInterface *,::btConstraintSolver *,::btCollisionConfiguration * ) 
void btSimpleDynamicsWorld_free(void *c); 
void btSimpleDynamicsWorld_predictUnconstraintMotion(void *c,float p0); //method: predictUnconstraintMotion void ( ::btSimpleDynamicsWorld::* )( ::btScalar ) 
void btSimpleDynamicsWorld_setGravity(void *c,float* p0); //method: setGravity void ( ::btSimpleDynamicsWorld::* )( ::btVector3 const & ) 
void btSimpleDynamicsWorld_addAction(void *c,void* p0); //method: addAction void ( ::btSimpleDynamicsWorld::* )( ::btActionInterface * ) 
void btSimpleDynamicsWorld_synchronizeMotionStates(void *c); //method: synchronizeMotionStates void ( ::btSimpleDynamicsWorld::* )(  ) 
void btSimpleDynamicsWorld_setConstraintSolver(void *c,void* p0); //method: setConstraintSolver void ( ::btSimpleDynamicsWorld::* )( ::btConstraintSolver * ) 
int btSimpleDynamicsWorld_stepSimulation(void *c,float p0,int p1,float p2); //method: stepSimulation int ( ::btSimpleDynamicsWorld::* )( ::btScalar,int,::btScalar ) 
void* btSimpleDynamicsWorld_getConstraintSolver(void *c); //method: getConstraintSolver ::btConstraintSolver * ( ::btSimpleDynamicsWorld::* )(  ) 
//not supported method: getWorldType ::btDynamicsWorldType ( ::btSimpleDynamicsWorld::* )(  ) const
// error:  - unsupported

void btSimpleDynamicsWorld_removeRigidBody(void *c,void* p0); //method: removeRigidBody void ( ::btSimpleDynamicsWorld::* )( ::btRigidBody * ) 
void btSimpleDynamicsWorld_addRigidBody(void *c,void* p0); //method: addRigidBody void ( ::btSimpleDynamicsWorld::* )( ::btRigidBody * ) 
void btSimpleDynamicsWorld_addRigidBody0(void *c,void* p0); //method: addRigidBody void ( ::btSimpleDynamicsWorld::* )( ::btRigidBody * ) 
void btSimpleDynamicsWorld_addRigidBody1(void *c,void* p0,short int p1,short int p2); //method: addRigidBody void ( ::btSimpleDynamicsWorld::* )( ::btRigidBody *,short int,short int ) 
void btSimpleDynamicsWorld_getGravity(void *c,float* ret); //method: getGravity ::btVector3 ( ::btSimpleDynamicsWorld::* )(  ) const
void btSimpleDynamicsWorld_integrateTransforms(void *c,float p0); //method: integrateTransforms void ( ::btSimpleDynamicsWorld::* )( ::btScalar ) 
void btSimpleDynamicsWorld_removeCollisionObject(void *c,void* p0); //method: removeCollisionObject void ( ::btSimpleDynamicsWorld::* )( ::btCollisionObject * ) 
void btSimpleDynamicsWorld_clearForces(void *c); //method: clearForces void ( ::btSimpleDynamicsWorld::* )(  ) 
void btSimpleDynamicsWorld_removeAction(void *c,void* p0); //method: removeAction void ( ::btSimpleDynamicsWorld::* )( ::btActionInterface * ) 
void btSimpleDynamicsWorld_updateAabbs(void *c); //method: updateAabbs void ( ::btSimpleDynamicsWorld::* )(  ) 
void btSimpleDynamicsWorld_debugDrawWorld(void *c); //method: debugDrawWorld void ( ::btSimpleDynamicsWorld::* )(  ) 
void btSimpleDynamicsWorld_m_constraintSolver_set(void *c,void* a); //attribute: ::btConstraintSolver * btSimpleDynamicsWorld->m_constraintSolver
void* btSimpleDynamicsWorld_m_constraintSolver_get(void *c); //attribute: ::btConstraintSolver * btSimpleDynamicsWorld->m_constraintSolver
void btSimpleDynamicsWorld_m_ownsConstraintSolver_set(void *c,int a); //attribute: bool btSimpleDynamicsWorld->m_ownsConstraintSolver
int btSimpleDynamicsWorld_m_ownsConstraintSolver_get(void *c); //attribute: bool btSimpleDynamicsWorld->m_ownsConstraintSolver
void btSimpleDynamicsWorld_m_gravity_set(void *c,float* a); //attribute: ::btVector3 btSimpleDynamicsWorld->m_gravity
void btSimpleDynamicsWorld_m_gravity_get(void *c,float* a);
void* btWheelInfo_RaycastInfo_new(); //constructor: RaycastInfo  ( ::btWheelInfo::RaycastInfo::* )(  ) 
void btWheelInfo_RaycastInfo_free(void *c); 
void btWheelInfo_RaycastInfo_m_contactNormalWS_set(void *c,float* a); //attribute: ::btVector3 btWheelInfo_RaycastInfo->m_contactNormalWS
void btWheelInfo_RaycastInfo_m_contactNormalWS_get(void *c,float* a);
void btWheelInfo_RaycastInfo_m_contactPointWS_set(void *c,float* a); //attribute: ::btVector3 btWheelInfo_RaycastInfo->m_contactPointWS
void btWheelInfo_RaycastInfo_m_contactPointWS_get(void *c,float* a);
void btWheelInfo_RaycastInfo_m_suspensionLength_set(void *c,float a); //attribute: ::btScalar btWheelInfo_RaycastInfo->m_suspensionLength
float btWheelInfo_RaycastInfo_m_suspensionLength_get(void *c); //attribute: ::btScalar btWheelInfo_RaycastInfo->m_suspensionLength
void btWheelInfo_RaycastInfo_m_hardPointWS_set(void *c,float* a); //attribute: ::btVector3 btWheelInfo_RaycastInfo->m_hardPointWS
void btWheelInfo_RaycastInfo_m_hardPointWS_get(void *c,float* a);
void btWheelInfo_RaycastInfo_m_wheelDirectionWS_set(void *c,float* a); //attribute: ::btVector3 btWheelInfo_RaycastInfo->m_wheelDirectionWS
void btWheelInfo_RaycastInfo_m_wheelDirectionWS_get(void *c,float* a);
void btWheelInfo_RaycastInfo_m_wheelAxleWS_set(void *c,float* a); //attribute: ::btVector3 btWheelInfo_RaycastInfo->m_wheelAxleWS
void btWheelInfo_RaycastInfo_m_wheelAxleWS_get(void *c,float* a);
void btWheelInfo_RaycastInfo_m_isInContact_set(void *c,int a); //attribute: bool btWheelInfo_RaycastInfo->m_isInContact
int btWheelInfo_RaycastInfo_m_isInContact_get(void *c); //attribute: bool btWheelInfo_RaycastInfo->m_isInContact
void btWheelInfo_RaycastInfo_m_groundObject_set(void *c,void* a); //attribute: void * btWheelInfo_RaycastInfo->m_groundObject
void* btWheelInfo_RaycastInfo_m_groundObject_get(void *c); //attribute: void * btWheelInfo_RaycastInfo->m_groundObject
void* btDefaultVehicleRaycaster_new(void* p0); //constructor: btDefaultVehicleRaycaster  ( ::btDefaultVehicleRaycaster::* )( ::btDynamicsWorld * ) 
void btDefaultVehicleRaycaster_free(void *c); 
void* btDefaultVehicleRaycaster_castRay(void *c,float* p0,float* p1,void* p2); //method: castRay void * ( ::btDefaultVehicleRaycaster::* )( ::btVector3 const &,::btVector3 const &,::btVehicleRaycaster::btVehicleRaycasterResult & ) 
void btDefaultVehicleRaycaster_m_dynamicsWorld_set(void *c,void* a); //attribute: ::btDynamicsWorld * btDefaultVehicleRaycaster->m_dynamicsWorld
void* btDefaultVehicleRaycaster_m_dynamicsWorld_get(void *c); //attribute: ::btDynamicsWorld * btDefaultVehicleRaycaster->m_dynamicsWorld
void* btRaycastVehicle_new(void* p0,void* p1,void* p2); //constructor: btRaycastVehicle  ( ::btRaycastVehicle::* )( ::btRaycastVehicle::btVehicleTuning const &,::btRigidBody *,::btVehicleRaycaster * ) 
void btRaycastVehicle_free(void *c); 
void btRaycastVehicle_updateSuspension(void *c,float p0); //method: updateSuspension void ( ::btRaycastVehicle::* )( ::btScalar ) 
void* btRaycastVehicle_getRigidBody(void *c); //method: getRigidBody ::btRigidBody * ( ::btRaycastVehicle::* )(  ) 
void* btRaycastVehicle_getRigidBody0(void *c); //method: getRigidBody ::btRigidBody * ( ::btRaycastVehicle::* )(  ) 
void* btRaycastVehicle_getRigidBody1(void *c); //method: getRigidBody ::btRigidBody const * ( ::btRaycastVehicle::* )(  ) const
int btRaycastVehicle_getUserConstraintId(void *c); //method: getUserConstraintId int ( ::btRaycastVehicle::* )(  ) const
void btRaycastVehicle_defaultInit(void *c,void* p0); //method: defaultInit void ( ::btRaycastVehicle::* )( ::btRaycastVehicle::btVehicleTuning const & ) 
void btRaycastVehicle_getWheelTransformWS(void *c,int p0,float* ret); //method: getWheelTransformWS ::btTransform const & ( ::btRaycastVehicle::* )( int ) const
void* btRaycastVehicle_addWheel(void *c,float* p0,float* p1,float* p2,float p3,float p4,void* p5,int p6); //method: addWheel ::btWheelInfo & ( ::btRaycastVehicle::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar,::btScalar,::btRaycastVehicle::btVehicleTuning const &,bool ) 
void btRaycastVehicle_updateWheelTransform(void *c,int p0,int p1); //method: updateWheelTransform void ( ::btRaycastVehicle::* )( int,bool ) 
void btRaycastVehicle_setUserConstraintId(void *c,int p0); //method: setUserConstraintId void ( ::btRaycastVehicle::* )( int ) 
int btRaycastVehicle_getNumWheels(void *c); //method: getNumWheels int ( ::btRaycastVehicle::* )(  ) const
float btRaycastVehicle_rayCast(void *c,void* p0); //method: rayCast ::btScalar ( ::btRaycastVehicle::* )( ::btWheelInfo & ) 
int btRaycastVehicle_getRightAxis(void *c); //method: getRightAxis int ( ::btRaycastVehicle::* )(  ) const
void btRaycastVehicle_applyEngineForce(void *c,float p0,int p1); //method: applyEngineForce void ( ::btRaycastVehicle::* )( ::btScalar,int ) 
void btRaycastVehicle_getForwardVector(void *c,float* ret); //method: getForwardVector ::btVector3 ( ::btRaycastVehicle::* )(  ) const
void* btRaycastVehicle_getWheelInfo(void *c,int p0); //method: getWheelInfo ::btWheelInfo const & ( ::btRaycastVehicle::* )( int ) const
void* btRaycastVehicle_getWheelInfo0(void *c,int p0); //method: getWheelInfo ::btWheelInfo const & ( ::btRaycastVehicle::* )( int ) const
void* btRaycastVehicle_getWheelInfo1(void *c,int p0); //method: getWheelInfo ::btWheelInfo & ( ::btRaycastVehicle::* )( int ) 
void btRaycastVehicle_getChassisWorldTransform(void *c,float* ret); //method: getChassisWorldTransform ::btTransform const & ( ::btRaycastVehicle::* )(  ) const
void btRaycastVehicle_updateWheelTransformsWS(void *c,void* p0,int p1); //method: updateWheelTransformsWS void ( ::btRaycastVehicle::* )( ::btWheelInfo &,bool ) 
void btRaycastVehicle_resetSuspension(void *c); //method: resetSuspension void ( ::btRaycastVehicle::* )(  ) 
void btRaycastVehicle_setCoordinateSystem(void *c,int p0,int p1,int p2); //method: setCoordinateSystem void ( ::btRaycastVehicle::* )( int,int,int ) 
void btRaycastVehicle_setUserConstraintType(void *c,int p0); //method: setUserConstraintType void ( ::btRaycastVehicle::* )( int ) 
void btRaycastVehicle_debugDraw(void *c,void* p0); //method: debugDraw void ( ::btRaycastVehicle::* )( ::btIDebugDraw * ) 
void btRaycastVehicle_updateFriction(void *c,float p0); //method: updateFriction void ( ::btRaycastVehicle::* )( ::btScalar ) 
int btRaycastVehicle_getForwardAxis(void *c); //method: getForwardAxis int ( ::btRaycastVehicle::* )(  ) const
float btRaycastVehicle_getSteeringValue(void *c,int p0); //method: getSteeringValue ::btScalar ( ::btRaycastVehicle::* )( int ) const
int btRaycastVehicle_getUserConstraintType(void *c); //method: getUserConstraintType int ( ::btRaycastVehicle::* )(  ) const
int btRaycastVehicle_getUpAxis(void *c); //method: getUpAxis int ( ::btRaycastVehicle::* )(  ) const
void btRaycastVehicle_setPitchControl(void *c,float p0); //method: setPitchControl void ( ::btRaycastVehicle::* )( ::btScalar ) 
float btRaycastVehicle_getCurrentSpeedKmHour(void *c); //method: getCurrentSpeedKmHour ::btScalar ( ::btRaycastVehicle::* )(  ) const
void btRaycastVehicle_setBrake(void *c,float p0,int p1); //method: setBrake void ( ::btRaycastVehicle::* )( ::btScalar,int ) 
void btRaycastVehicle_setSteeringValue(void *c,float p0,int p1); //method: setSteeringValue void ( ::btRaycastVehicle::* )( ::btScalar,int ) 
void btRaycastVehicle_updateVehicle(void *c,float p0); //method: updateVehicle void ( ::btRaycastVehicle::* )( ::btScalar ) 
void btRaycastVehicle_updateAction(void *c,void* p0,float p1); //method: updateAction void ( ::btRaycastVehicle::* )( ::btCollisionWorld *,::btScalar ) 
void btRaycastVehicle_m_forwardWS_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btVector3> btRaycastVehicle->m_forwardWS
void* btRaycastVehicle_m_forwardWS_get(void *c); //attribute: ::btAlignedObjectArray<btVector3> btRaycastVehicle->m_forwardWS
void btRaycastVehicle_m_axle_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btVector3> btRaycastVehicle->m_axle
void* btRaycastVehicle_m_axle_get(void *c); //attribute: ::btAlignedObjectArray<btVector3> btRaycastVehicle->m_axle
void btRaycastVehicle_m_forwardImpulse_set(void *c,void* a); //attribute: ::btAlignedObjectArray<float> btRaycastVehicle->m_forwardImpulse
void* btRaycastVehicle_m_forwardImpulse_get(void *c); //attribute: ::btAlignedObjectArray<float> btRaycastVehicle->m_forwardImpulse
void btRaycastVehicle_m_sideImpulse_set(void *c,void* a); //attribute: ::btAlignedObjectArray<float> btRaycastVehicle->m_sideImpulse
void* btRaycastVehicle_m_sideImpulse_get(void *c); //attribute: ::btAlignedObjectArray<float> btRaycastVehicle->m_sideImpulse
void btRaycastVehicle_m_userConstraintType_set(void *c,int a); //attribute: int btRaycastVehicle->m_userConstraintType
int btRaycastVehicle_m_userConstraintType_get(void *c); //attribute: int btRaycastVehicle->m_userConstraintType
void btRaycastVehicle_m_userConstraintId_set(void *c,int a); //attribute: int btRaycastVehicle->m_userConstraintId
int btRaycastVehicle_m_userConstraintId_get(void *c); //attribute: int btRaycastVehicle->m_userConstraintId
void btRaycastVehicle_m_tau_set(void *c,float a); //attribute: ::btScalar btRaycastVehicle->m_tau
float btRaycastVehicle_m_tau_get(void *c); //attribute: ::btScalar btRaycastVehicle->m_tau
void btRaycastVehicle_m_damping_set(void *c,float a); //attribute: ::btScalar btRaycastVehicle->m_damping
float btRaycastVehicle_m_damping_get(void *c); //attribute: ::btScalar btRaycastVehicle->m_damping
void btRaycastVehicle_m_vehicleRaycaster_set(void *c,void* a); //attribute: ::btVehicleRaycaster * btRaycastVehicle->m_vehicleRaycaster
void* btRaycastVehicle_m_vehicleRaycaster_get(void *c); //attribute: ::btVehicleRaycaster * btRaycastVehicle->m_vehicleRaycaster
void btRaycastVehicle_m_pitchControl_set(void *c,float a); //attribute: ::btScalar btRaycastVehicle->m_pitchControl
float btRaycastVehicle_m_pitchControl_get(void *c); //attribute: ::btScalar btRaycastVehicle->m_pitchControl
void btRaycastVehicle_m_steeringValue_set(void *c,float a); //attribute: ::btScalar btRaycastVehicle->m_steeringValue
float btRaycastVehicle_m_steeringValue_get(void *c); //attribute: ::btScalar btRaycastVehicle->m_steeringValue
void btRaycastVehicle_m_currentVehicleSpeedKmHour_set(void *c,float a); //attribute: ::btScalar btRaycastVehicle->m_currentVehicleSpeedKmHour
float btRaycastVehicle_m_currentVehicleSpeedKmHour_get(void *c); //attribute: ::btScalar btRaycastVehicle->m_currentVehicleSpeedKmHour
void btRaycastVehicle_m_chassisBody_set(void *c,void* a); //attribute: ::btRigidBody * btRaycastVehicle->m_chassisBody
void* btRaycastVehicle_m_chassisBody_get(void *c); //attribute: ::btRigidBody * btRaycastVehicle->m_chassisBody
void btRaycastVehicle_m_indexRightAxis_set(void *c,int a); //attribute: int btRaycastVehicle->m_indexRightAxis
int btRaycastVehicle_m_indexRightAxis_get(void *c); //attribute: int btRaycastVehicle->m_indexRightAxis
void btRaycastVehicle_m_indexUpAxis_set(void *c,int a); //attribute: int btRaycastVehicle->m_indexUpAxis
int btRaycastVehicle_m_indexUpAxis_get(void *c); //attribute: int btRaycastVehicle->m_indexUpAxis
void btRaycastVehicle_m_indexForwardAxis_set(void *c,int a); //attribute: int btRaycastVehicle->m_indexForwardAxis
int btRaycastVehicle_m_indexForwardAxis_get(void *c); //attribute: int btRaycastVehicle->m_indexForwardAxis
void btRaycastVehicle_m_wheelInfo_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btWheelInfo> btRaycastVehicle->m_wheelInfo
void* btRaycastVehicle_m_wheelInfo_get(void *c); //attribute: ::btAlignedObjectArray<btWheelInfo> btRaycastVehicle->m_wheelInfo
void* btVehicleRaycaster_castRay(void *c,float* p0,float* p1,void* p2); //method: castRay void * ( ::btVehicleRaycaster::* )( ::btVector3 const &,::btVector3 const &,::btVehicleRaycaster::btVehicleRaycasterResult & ) 
void* btVehicleRaycaster_btVehicleRaycasterResult_new(); //constructor: btVehicleRaycasterResult  ( ::btVehicleRaycaster::btVehicleRaycasterResult::* )(  ) 
void btVehicleRaycaster_btVehicleRaycasterResult_free(void *c); 
void btVehicleRaycaster_btVehicleRaycasterResult_m_distFraction_set(void *c,float a); //attribute: ::btScalar btVehicleRaycaster_btVehicleRaycasterResult->m_distFraction
float btVehicleRaycaster_btVehicleRaycasterResult_m_distFraction_get(void *c); //attribute: ::btScalar btVehicleRaycaster_btVehicleRaycasterResult->m_distFraction
void btVehicleRaycaster_btVehicleRaycasterResult_m_hitNormalInWorld_set(void *c,float* a); //attribute: ::btVector3 btVehicleRaycaster_btVehicleRaycasterResult->m_hitNormalInWorld
void btVehicleRaycaster_btVehicleRaycasterResult_m_hitNormalInWorld_get(void *c,float* a);
void btVehicleRaycaster_btVehicleRaycasterResult_m_hitPointInWorld_set(void *c,float* a); //attribute: ::btVector3 btVehicleRaycaster_btVehicleRaycasterResult->m_hitPointInWorld
void btVehicleRaycaster_btVehicleRaycasterResult_m_hitPointInWorld_get(void *c,float* a);
void* btRaycastVehicle_btVehicleTuning_new(); //constructor: btVehicleTuning  ( ::btRaycastVehicle::btVehicleTuning::* )(  ) 
void btRaycastVehicle_btVehicleTuning_free(void *c); 
void btRaycastVehicle_btVehicleTuning_m_frictionSlip_set(void *c,float a); //attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_frictionSlip
float btRaycastVehicle_btVehicleTuning_m_frictionSlip_get(void *c); //attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_frictionSlip
void btRaycastVehicle_btVehicleTuning_m_maxSuspensionForce_set(void *c,float a); //attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_maxSuspensionForce
float btRaycastVehicle_btVehicleTuning_m_maxSuspensionForce_get(void *c); //attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_maxSuspensionForce
void btRaycastVehicle_btVehicleTuning_m_maxSuspensionTravelCm_set(void *c,float a); //attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_maxSuspensionTravelCm
float btRaycastVehicle_btVehicleTuning_m_maxSuspensionTravelCm_get(void *c); //attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_maxSuspensionTravelCm
void btRaycastVehicle_btVehicleTuning_m_suspensionCompression_set(void *c,float a); //attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_suspensionCompression
float btRaycastVehicle_btVehicleTuning_m_suspensionCompression_get(void *c); //attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_suspensionCompression
void btRaycastVehicle_btVehicleTuning_m_suspensionDamping_set(void *c,float a); //attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_suspensionDamping
float btRaycastVehicle_btVehicleTuning_m_suspensionDamping_get(void *c); //attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_suspensionDamping
void btRaycastVehicle_btVehicleTuning_m_suspensionStiffness_set(void *c,float a); //attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_suspensionStiffness
float btRaycastVehicle_btVehicleTuning_m_suspensionStiffness_get(void *c); //attribute: ::btScalar btRaycastVehicle_btVehicleTuning->m_suspensionStiffness
void* btWheelInfo_new(void* p0); //constructor: btWheelInfo  ( ::btWheelInfo::* )( ::btWheelInfoConstructionInfo & ) 
void btWheelInfo_free(void *c); 
float btWheelInfo_getSuspensionRestLength(void *c); //method: getSuspensionRestLength ::btScalar ( ::btWheelInfo::* )(  ) const
void btWheelInfo_updateWheel(void *c,void* p0,void* p1); //method: updateWheel void ( ::btWheelInfo::* )( ::btRigidBody const &,::btWheelInfo::RaycastInfo & ) 
void btWheelInfo_m_bIsFrontWheel_set(void *c,int a); //attribute: bool btWheelInfo->m_bIsFrontWheel
int btWheelInfo_m_bIsFrontWheel_get(void *c); //attribute: bool btWheelInfo->m_bIsFrontWheel
void btWheelInfo_m_brake_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_brake
float btWheelInfo_m_brake_get(void *c); //attribute: ::btScalar btWheelInfo->m_brake
void btWheelInfo_m_chassisConnectionPointCS_set(void *c,float* a); //attribute: ::btVector3 btWheelInfo->m_chassisConnectionPointCS
void btWheelInfo_m_chassisConnectionPointCS_get(void *c,float* a);
void btWheelInfo_m_clientInfo_set(void *c,void* a); //attribute: void * btWheelInfo->m_clientInfo
void* btWheelInfo_m_clientInfo_get(void *c); //attribute: void * btWheelInfo->m_clientInfo
void btWheelInfo_m_clippedInvContactDotSuspension_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_clippedInvContactDotSuspension
float btWheelInfo_m_clippedInvContactDotSuspension_get(void *c); //attribute: ::btScalar btWheelInfo->m_clippedInvContactDotSuspension
void btWheelInfo_m_deltaRotation_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_deltaRotation
float btWheelInfo_m_deltaRotation_get(void *c); //attribute: ::btScalar btWheelInfo->m_deltaRotation
void btWheelInfo_m_engineForce_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_engineForce
float btWheelInfo_m_engineForce_get(void *c); //attribute: ::btScalar btWheelInfo->m_engineForce
void btWheelInfo_m_frictionSlip_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_frictionSlip
float btWheelInfo_m_frictionSlip_get(void *c); //attribute: ::btScalar btWheelInfo->m_frictionSlip
void btWheelInfo_m_maxSuspensionForce_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_maxSuspensionForce
float btWheelInfo_m_maxSuspensionForce_get(void *c); //attribute: ::btScalar btWheelInfo->m_maxSuspensionForce
void btWheelInfo_m_maxSuspensionTravelCm_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_maxSuspensionTravelCm
float btWheelInfo_m_maxSuspensionTravelCm_get(void *c); //attribute: ::btScalar btWheelInfo->m_maxSuspensionTravelCm
void btWheelInfo_m_raycastInfo_set(void *c,void* a); //attribute: ::btWheelInfo::RaycastInfo btWheelInfo->m_raycastInfo
void* btWheelInfo_m_raycastInfo_get(void *c); //attribute: ::btWheelInfo::RaycastInfo btWheelInfo->m_raycastInfo
void btWheelInfo_m_rollInfluence_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_rollInfluence
float btWheelInfo_m_rollInfluence_get(void *c); //attribute: ::btScalar btWheelInfo->m_rollInfluence
void btWheelInfo_m_rotation_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_rotation
float btWheelInfo_m_rotation_get(void *c); //attribute: ::btScalar btWheelInfo->m_rotation
void btWheelInfo_m_skidInfo_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_skidInfo
float btWheelInfo_m_skidInfo_get(void *c); //attribute: ::btScalar btWheelInfo->m_skidInfo
void btWheelInfo_m_steering_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_steering
float btWheelInfo_m_steering_get(void *c); //attribute: ::btScalar btWheelInfo->m_steering
void btWheelInfo_m_suspensionRelativeVelocity_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_suspensionRelativeVelocity
float btWheelInfo_m_suspensionRelativeVelocity_get(void *c); //attribute: ::btScalar btWheelInfo->m_suspensionRelativeVelocity
void btWheelInfo_m_suspensionRestLength1_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_suspensionRestLength1
float btWheelInfo_m_suspensionRestLength1_get(void *c); //attribute: ::btScalar btWheelInfo->m_suspensionRestLength1
void btWheelInfo_m_suspensionStiffness_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_suspensionStiffness
float btWheelInfo_m_suspensionStiffness_get(void *c); //attribute: ::btScalar btWheelInfo->m_suspensionStiffness
void btWheelInfo_m_wheelAxleCS_set(void *c,float* a); //attribute: ::btVector3 btWheelInfo->m_wheelAxleCS
void btWheelInfo_m_wheelAxleCS_get(void *c,float* a);
void btWheelInfo_m_wheelDirectionCS_set(void *c,float* a); //attribute: ::btVector3 btWheelInfo->m_wheelDirectionCS
void btWheelInfo_m_wheelDirectionCS_get(void *c,float* a);
void btWheelInfo_m_wheelsDampingCompression_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_wheelsDampingCompression
float btWheelInfo_m_wheelsDampingCompression_get(void *c); //attribute: ::btScalar btWheelInfo->m_wheelsDampingCompression
void btWheelInfo_m_wheelsDampingRelaxation_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_wheelsDampingRelaxation
float btWheelInfo_m_wheelsDampingRelaxation_get(void *c); //attribute: ::btScalar btWheelInfo->m_wheelsDampingRelaxation
void btWheelInfo_m_wheelsRadius_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_wheelsRadius
float btWheelInfo_m_wheelsRadius_get(void *c); //attribute: ::btScalar btWheelInfo->m_wheelsRadius
void btWheelInfo_m_wheelsSuspensionForce_set(void *c,float a); //attribute: ::btScalar btWheelInfo->m_wheelsSuspensionForce
float btWheelInfo_m_wheelsSuspensionForce_get(void *c); //attribute: ::btScalar btWheelInfo->m_wheelsSuspensionForce
void btWheelInfo_m_worldTransform_set(void *c,float* a); //attribute: ::btTransform btWheelInfo->m_worldTransform
void btWheelInfo_m_worldTransform_get(void *c,float* a);
void* btWheelInfoConstructionInfo_new(); //constructor: btWheelInfoConstructionInfo  ( ::btWheelInfoConstructionInfo::* )(  ) 
void btWheelInfoConstructionInfo_free(void *c); 
void btWheelInfoConstructionInfo_m_bIsFrontWheel_set(void *c,int a); //attribute: bool btWheelInfoConstructionInfo->m_bIsFrontWheel
int btWheelInfoConstructionInfo_m_bIsFrontWheel_get(void *c); //attribute: bool btWheelInfoConstructionInfo->m_bIsFrontWheel
void btWheelInfoConstructionInfo_m_chassisConnectionCS_set(void *c,float* a); //attribute: ::btVector3 btWheelInfoConstructionInfo->m_chassisConnectionCS
void btWheelInfoConstructionInfo_m_chassisConnectionCS_get(void *c,float* a);
void btWheelInfoConstructionInfo_m_frictionSlip_set(void *c,float a); //attribute: ::btScalar btWheelInfoConstructionInfo->m_frictionSlip
float btWheelInfoConstructionInfo_m_frictionSlip_get(void *c); //attribute: ::btScalar btWheelInfoConstructionInfo->m_frictionSlip
void btWheelInfoConstructionInfo_m_maxSuspensionForce_set(void *c,float a); //attribute: ::btScalar btWheelInfoConstructionInfo->m_maxSuspensionForce
float btWheelInfoConstructionInfo_m_maxSuspensionForce_get(void *c); //attribute: ::btScalar btWheelInfoConstructionInfo->m_maxSuspensionForce
void btWheelInfoConstructionInfo_m_maxSuspensionTravelCm_set(void *c,float a); //attribute: ::btScalar btWheelInfoConstructionInfo->m_maxSuspensionTravelCm
float btWheelInfoConstructionInfo_m_maxSuspensionTravelCm_get(void *c); //attribute: ::btScalar btWheelInfoConstructionInfo->m_maxSuspensionTravelCm
void btWheelInfoConstructionInfo_m_suspensionRestLength_set(void *c,float a); //attribute: ::btScalar btWheelInfoConstructionInfo->m_suspensionRestLength
float btWheelInfoConstructionInfo_m_suspensionRestLength_get(void *c); //attribute: ::btScalar btWheelInfoConstructionInfo->m_suspensionRestLength
void btWheelInfoConstructionInfo_m_suspensionStiffness_set(void *c,float a); //attribute: ::btScalar btWheelInfoConstructionInfo->m_suspensionStiffness
float btWheelInfoConstructionInfo_m_suspensionStiffness_get(void *c); //attribute: ::btScalar btWheelInfoConstructionInfo->m_suspensionStiffness
void btWheelInfoConstructionInfo_m_wheelAxleCS_set(void *c,float* a); //attribute: ::btVector3 btWheelInfoConstructionInfo->m_wheelAxleCS
void btWheelInfoConstructionInfo_m_wheelAxleCS_get(void *c,float* a);
void btWheelInfoConstructionInfo_m_wheelDirectionCS_set(void *c,float* a); //attribute: ::btVector3 btWheelInfoConstructionInfo->m_wheelDirectionCS
void btWheelInfoConstructionInfo_m_wheelDirectionCS_get(void *c,float* a);
void btWheelInfoConstructionInfo_m_wheelRadius_set(void *c,float a); //attribute: ::btScalar btWheelInfoConstructionInfo->m_wheelRadius
float btWheelInfoConstructionInfo_m_wheelRadius_get(void *c); //attribute: ::btScalar btWheelInfoConstructionInfo->m_wheelRadius
void btWheelInfoConstructionInfo_m_wheelsDampingCompression_set(void *c,float a); //attribute: ::btScalar btWheelInfoConstructionInfo->m_wheelsDampingCompression
float btWheelInfoConstructionInfo_m_wheelsDampingCompression_get(void *c); //attribute: ::btScalar btWheelInfoConstructionInfo->m_wheelsDampingCompression
void btWheelInfoConstructionInfo_m_wheelsDampingRelaxation_set(void *c,float a); //attribute: ::btScalar btWheelInfoConstructionInfo->m_wheelsDampingRelaxation
float btWheelInfoConstructionInfo_m_wheelsDampingRelaxation_get(void *c); //attribute: ::btScalar btWheelInfoConstructionInfo->m_wheelsDampingRelaxation
void* btBU_Simplex1to4_new0(); //constructor: btBU_Simplex1to4  ( ::btBU_Simplex1to4::* )(  ) 
void* btBU_Simplex1to4_new1(float* p0); //constructor: btBU_Simplex1to4  ( ::btBU_Simplex1to4::* )( ::btVector3 const & ) 
void* btBU_Simplex1to4_new2(float* p0,float* p1); //constructor: btBU_Simplex1to4  ( ::btBU_Simplex1to4::* )( ::btVector3 const &,::btVector3 const & ) 
void* btBU_Simplex1to4_new3(float* p0,float* p1,float* p2); //constructor: btBU_Simplex1to4  ( ::btBU_Simplex1to4::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void* btBU_Simplex1to4_new4(float* p0,float* p1,float* p2,float* p3); //constructor: btBU_Simplex1to4  ( ::btBU_Simplex1to4::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btBU_Simplex1to4_free(void *c); 
void btBU_Simplex1to4_reset(void *c); //method: reset void ( ::btBU_Simplex1to4::* )(  ) 
int btBU_Simplex1to4_getNumPlanes(void *c); //method: getNumPlanes int ( ::btBU_Simplex1to4::* )(  ) const
int btBU_Simplex1to4_getIndex(void *c,int p0); //method: getIndex int ( ::btBU_Simplex1to4::* )( int ) const
int btBU_Simplex1to4_getNumEdges(void *c); //method: getNumEdges int ( ::btBU_Simplex1to4::* )(  ) const
char const * btBU_Simplex1to4_getName(void *c); //method: getName char const * ( ::btBU_Simplex1to4::* )(  ) const
void btBU_Simplex1to4_getVertex(void *c,int p0,float* p1); //method: getVertex void ( ::btBU_Simplex1to4::* )( int,::btVector3 & ) const
void btBU_Simplex1to4_getEdge(void *c,int p0,float* p1,float* p2); //method: getEdge void ( ::btBU_Simplex1to4::* )( int,::btVector3 &,::btVector3 & ) const
void btBU_Simplex1to4_addVertex(void *c,float* p0); //method: addVertex void ( ::btBU_Simplex1to4::* )( ::btVector3 const & ) 
int btBU_Simplex1to4_isInside(void *c,float* p0,float p1); //method: isInside bool ( ::btBU_Simplex1to4::* )( ::btVector3 const &,::btScalar ) const
void btBU_Simplex1to4_getPlane(void *c,float* p0,float* p1,int p2); //method: getPlane void ( ::btBU_Simplex1to4::* )( ::btVector3 &,::btVector3 &,int ) const
void btBU_Simplex1to4_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btBU_Simplex1to4::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
int btBU_Simplex1to4_getNumVertices(void *c); //method: getNumVertices int ( ::btBU_Simplex1to4::* )(  ) const
void btBU_Simplex1to4_m_numVertices_set(void *c,int a); //attribute: int btBU_Simplex1to4->m_numVertices
int btBU_Simplex1to4_m_numVertices_get(void *c); //attribute: int btBU_Simplex1to4->m_numVertices
// attribute not supported: //attribute: ::btVector3[4] btBU_Simplex1to4->m_vertices
void* btBoxShape_new(float* p0); //constructor: btBoxShape  ( ::btBoxShape::* )( ::btVector3 const & ) 
void btBoxShape_free(void *c); 
void btBoxShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btBoxShape::* )( ::btScalar,::btVector3 & ) const
int btBoxShape_getNumPlanes(void *c); //method: getNumPlanes int ( ::btBoxShape::* )(  ) const
void btBoxShape_localGetSupportingVertex(void *c,float* p0,float* ret); //method: localGetSupportingVertex ::btVector3 ( ::btBoxShape::* )( ::btVector3 const & ) const
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btBoxShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

void btBoxShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btBoxShape::* )( ::btVector3 const & ) 
void btBoxShape_getPlaneEquation(void *c,float* p0,int p1); //method: getPlaneEquation void ( ::btBoxShape::* )( ::btVector4 &,int ) const
void btBoxShape_getPreferredPenetrationDirection(void *c,int p0,float* p1); //method: getPreferredPenetrationDirection void ( ::btBoxShape::* )( int,::btVector3 & ) const
int btBoxShape_getNumEdges(void *c); //method: getNumEdges int ( ::btBoxShape::* )(  ) const
char const * btBoxShape_getName(void *c); //method: getName char const * ( ::btBoxShape::* )(  ) const
void btBoxShape_getVertex(void *c,int p0,float* p1); //method: getVertex void ( ::btBoxShape::* )( int,::btVector3 & ) const
void btBoxShape_getEdge(void *c,int p0,float* p1,float* p2); //method: getEdge void ( ::btBoxShape::* )( int,::btVector3 &,::btVector3 & ) const
int btBoxShape_isInside(void *c,float* p0,float p1); //method: isInside bool ( ::btBoxShape::* )( ::btVector3 const &,::btScalar ) const
void btBoxShape_getPlane(void *c,float* p0,float* p1,int p2); //method: getPlane void ( ::btBoxShape::* )( ::btVector3 &,::btVector3 &,int ) const
void btBoxShape_getHalfExtentsWithoutMargin(void *c,float* ret); //method: getHalfExtentsWithoutMargin ::btVector3 const & ( ::btBoxShape::* )(  ) const
int btBoxShape_getNumPreferredPenetrationDirections(void *c); //method: getNumPreferredPenetrationDirections int ( ::btBoxShape::* )(  ) const
void btBoxShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btBoxShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btBoxShape_setMargin(void *c,float p0); //method: setMargin void ( ::btBoxShape::* )( ::btScalar ) 
int btBoxShape_getNumVertices(void *c); //method: getNumVertices int ( ::btBoxShape::* )(  ) const
void btBoxShape_getHalfExtentsWithMargin(void *c,float* ret); //method: getHalfExtentsWithMargin ::btVector3 ( ::btBoxShape::* )(  ) const
void btBoxShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret); //method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btBoxShape::* )( ::btVector3 const & ) const
void* btBvhTriangleMeshShape_new0(void* p0,int p1,int p2); //constructor: btBvhTriangleMeshShape  ( ::btBvhTriangleMeshShape::* )( ::btStridingMeshInterface *,bool,bool ) 
void* btBvhTriangleMeshShape_new1(void* p0,int p1,float* p2,float* p3,int p4); //constructor: btBvhTriangleMeshShape  ( ::btBvhTriangleMeshShape::* )( ::btStridingMeshInterface *,bool,::btVector3 const &,::btVector3 const &,bool ) 
void btBvhTriangleMeshShape_free(void *c); 
int btBvhTriangleMeshShape_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btBvhTriangleMeshShape::* )(  ) const
void btBvhTriangleMeshShape_buildOptimizedBvh(void *c); //method: buildOptimizedBvh void ( ::btBvhTriangleMeshShape::* )(  ) 
void btBvhTriangleMeshShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btBvhTriangleMeshShape::* )( ::btVector3 const & ) 
void btBvhTriangleMeshShape_performRaycast(void *c,void* p0,float* p1,float* p2); //method: performRaycast void ( ::btBvhTriangleMeshShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) 
void btBvhTriangleMeshShape_setTriangleInfoMap(void *c,void* p0); //method: setTriangleInfoMap void ( ::btBvhTriangleMeshShape::* )( ::btTriangleInfoMap * ) 
int btBvhTriangleMeshShape_usesQuantizedAabbCompression(void *c); //method: usesQuantizedAabbCompression bool ( ::btBvhTriangleMeshShape::* )(  ) const
char const * btBvhTriangleMeshShape_getName(void *c); //method: getName char const * ( ::btBvhTriangleMeshShape::* )(  ) const
char const * btBvhTriangleMeshShape_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btBvhTriangleMeshShape::* )( void *,::btSerializer * ) const
void* btBvhTriangleMeshShape_getTriangleInfoMap(void *c); //method: getTriangleInfoMap ::btTriangleInfoMap const * ( ::btBvhTriangleMeshShape::* )(  ) const
void* btBvhTriangleMeshShape_getTriangleInfoMap0(void *c); //method: getTriangleInfoMap ::btTriangleInfoMap const * ( ::btBvhTriangleMeshShape::* )(  ) const
void* btBvhTriangleMeshShape_getTriangleInfoMap1(void *c); //method: getTriangleInfoMap ::btTriangleInfoMap * ( ::btBvhTriangleMeshShape::* )(  ) 
void btBvhTriangleMeshShape_serializeSingleTriangleInfoMap(void *c,void* p0); //method: serializeSingleTriangleInfoMap void ( ::btBvhTriangleMeshShape::* )( ::btSerializer * ) const
int btBvhTriangleMeshShape_getOwnsBvh(void *c); //method: getOwnsBvh bool ( ::btBvhTriangleMeshShape::* )(  ) const
void btBvhTriangleMeshShape_partialRefitTree(void *c,float* p0,float* p1); //method: partialRefitTree void ( ::btBvhTriangleMeshShape::* )( ::btVector3 const &,::btVector3 const & ) 
void* btBvhTriangleMeshShape_getOptimizedBvh(void *c); //method: getOptimizedBvh ::btOptimizedBvh * ( ::btBvhTriangleMeshShape::* )(  ) 
void btBvhTriangleMeshShape_processAllTriangles(void *c,void* p0,float* p1,float* p2); //method: processAllTriangles void ( ::btBvhTriangleMeshShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
void btBvhTriangleMeshShape_refitTree(void *c,float* p0,float* p1); //method: refitTree void ( ::btBvhTriangleMeshShape::* )( ::btVector3 const &,::btVector3 const & ) 
void btBvhTriangleMeshShape_performConvexcast(void *c,void* p0,float* p1,float* p2,float* p3,float* p4); //method: performConvexcast void ( ::btBvhTriangleMeshShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btBvhTriangleMeshShape_serializeSingleBvh(void *c,void* p0); //method: serializeSingleBvh void ( ::btBvhTriangleMeshShape::* )( ::btSerializer * ) const
void btBvhTriangleMeshShape_setOptimizedBvh(void *c,void* p0,float* p1); //method: setOptimizedBvh void ( ::btBvhTriangleMeshShape::* )( ::btOptimizedBvh *,::btVector3 const & ) 
void btBvhTriangleMeshShape_m_bvh_set(void *c,void* a); //attribute: ::btOptimizedBvh * btBvhTriangleMeshShape->m_bvh
void* btBvhTriangleMeshShape_m_bvh_get(void *c); //attribute: ::btOptimizedBvh * btBvhTriangleMeshShape->m_bvh
void btBvhTriangleMeshShape_m_triangleInfoMap_set(void *c,void* a); //attribute: ::btTriangleInfoMap * btBvhTriangleMeshShape->m_triangleInfoMap
void* btBvhTriangleMeshShape_m_triangleInfoMap_get(void *c); //attribute: ::btTriangleInfoMap * btBvhTriangleMeshShape->m_triangleInfoMap
void btBvhTriangleMeshShape_m_useQuantizedAabbCompression_set(void *c,int a); //attribute: bool btBvhTriangleMeshShape->m_useQuantizedAabbCompression
int btBvhTriangleMeshShape_m_useQuantizedAabbCompression_get(void *c); //attribute: bool btBvhTriangleMeshShape->m_useQuantizedAabbCompression
void btBvhTriangleMeshShape_m_ownsBvh_set(void *c,int a); //attribute: bool btBvhTriangleMeshShape->m_ownsBvh
int btBvhTriangleMeshShape_m_ownsBvh_get(void *c); //attribute: bool btBvhTriangleMeshShape->m_ownsBvh
// attribute not supported: //attribute: bool[11] btBvhTriangleMeshShape->m_pad
void* btCapsuleShape_new0(); //constructor: btCapsuleShape  ( ::btCapsuleShape::* )(  ) 
void* btCapsuleShape_new1(float p0,float p1); //constructor: btCapsuleShape  ( ::btCapsuleShape::* )( ::btScalar,::btScalar ) 
void btCapsuleShape_free(void *c); 
void btCapsuleShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btCapsuleShape::* )( ::btScalar,::btVector3 & ) const
int btCapsuleShape_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btCapsuleShape::* )(  ) const
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btCapsuleShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

void btCapsuleShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btCapsuleShape::* )( ::btVector3 const & ) 
int btCapsuleShape_getUpAxis(void *c); //method: getUpAxis int ( ::btCapsuleShape::* )(  ) const
char const * btCapsuleShape_getName(void *c); //method: getName char const * ( ::btCapsuleShape::* )(  ) const
float btCapsuleShape_getHalfHeight(void *c); //method: getHalfHeight ::btScalar ( ::btCapsuleShape::* )(  ) const
void btCapsuleShape_setMargin(void *c,float p0); //method: setMargin void ( ::btCapsuleShape::* )( ::btScalar ) 
void btCapsuleShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btCapsuleShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
char const * btCapsuleShape_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btCapsuleShape::* )( void *,::btSerializer * ) const
void btCapsuleShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret); //method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btCapsuleShape::* )( ::btVector3 const & ) const
float btCapsuleShape_getRadius(void *c); //method: getRadius ::btScalar ( ::btCapsuleShape::* )(  ) const
void btCapsuleShape_m_upAxis_set(void *c,int a); //attribute: int btCapsuleShape->m_upAxis
int btCapsuleShape_m_upAxis_get(void *c); //attribute: int btCapsuleShape->m_upAxis
void* btCapsuleShapeData_new(); //constructor: btCapsuleShapeData  ( ::btCapsuleShapeData::* )(  ) 
void btCapsuleShapeData_free(void *c); 
void btCapsuleShapeData_m_convexInternalShapeData_set(void *c,void* a); //attribute: ::btConvexInternalShapeData btCapsuleShapeData->m_convexInternalShapeData
void* btCapsuleShapeData_m_convexInternalShapeData_get(void *c); //attribute: ::btConvexInternalShapeData btCapsuleShapeData->m_convexInternalShapeData
void btCapsuleShapeData_m_upAxis_set(void *c,int a); //attribute: int btCapsuleShapeData->m_upAxis
int btCapsuleShapeData_m_upAxis_get(void *c); //attribute: int btCapsuleShapeData->m_upAxis
// attribute not supported: //attribute: char[4] btCapsuleShapeData->m_padding
void* btCapsuleShapeX_new(float p0,float p1); //constructor: btCapsuleShapeX  ( ::btCapsuleShapeX::* )( ::btScalar,::btScalar ) 
void btCapsuleShapeX_free(void *c); 
char const * btCapsuleShapeX_getName(void *c); //method: getName char const * ( ::btCapsuleShapeX::* )(  ) const
void* btCapsuleShapeZ_new(float p0,float p1); //constructor: btCapsuleShapeZ  ( ::btCapsuleShapeZ::* )( ::btScalar,::btScalar ) 
void btCapsuleShapeZ_free(void *c); 
char const * btCapsuleShapeZ_getName(void *c); //method: getName char const * ( ::btCapsuleShapeZ::* )(  ) const
void* btCharIndexTripletData_new(); //constructor: btCharIndexTripletData  ( ::btCharIndexTripletData::* )(  ) 
void btCharIndexTripletData_free(void *c); 
// attribute not supported: //attribute: unsigned char[3] btCharIndexTripletData->m_values
void btCharIndexTripletData_m_pad_set(void *c,char a); //attribute: char btCharIndexTripletData->m_pad
char btCharIndexTripletData_m_pad_get(void *c); //attribute: char btCharIndexTripletData->m_pad
void btCollisionShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btCollisionShape::* )( ::btScalar,::btVector3 & ) const
void btCollisionShape_setUserPointer(void *c,void* p0); //method: setUserPointer void ( ::btCollisionShape::* )( void * ) 
char const * btCollisionShape_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btCollisionShape::* )( void *,::btSerializer * ) const
void btCollisionShape_getLocalScaling(void *c,float* ret); //method: getLocalScaling ::btVector3 const & ( ::btCollisionShape::* )(  ) const
int btCollisionShape_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btCollisionShape::* )(  ) const
char const * btCollisionShape_getName(void *c); //method: getName char const * ( ::btCollisionShape::* )(  ) const
int btCollisionShape_isCompound(void *c); //method: isCompound bool ( ::btCollisionShape::* )(  ) const
int btCollisionShape_isPolyhedral(void *c); //method: isPolyhedral bool ( ::btCollisionShape::* )(  ) const
void btCollisionShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btCollisionShape::* )( ::btVector3 const & ) 
void btCollisionShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btCollisionShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
float btCollisionShape_getContactBreakingThreshold(void *c,float p0); //method: getContactBreakingThreshold ::btScalar ( ::btCollisionShape::* )( ::btScalar ) const
int btCollisionShape_isConvex(void *c); //method: isConvex bool ( ::btCollisionShape::* )(  ) const
int btCollisionShape_isInfinite(void *c); //method: isInfinite bool ( ::btCollisionShape::* )(  ) const
void* btCollisionShape_getUserPointer(void *c); //method: getUserPointer void * ( ::btCollisionShape::* )(  ) const
int btCollisionShape_isNonMoving(void *c); //method: isNonMoving bool ( ::btCollisionShape::* )(  ) const
float btCollisionShape_getMargin(void *c); //method: getMargin ::btScalar ( ::btCollisionShape::* )(  ) const
void btCollisionShape_setMargin(void *c,float p0); //method: setMargin void ( ::btCollisionShape::* )( ::btScalar ) 
int btCollisionShape_isConvex2d(void *c); //method: isConvex2d bool ( ::btCollisionShape::* )(  ) const
int btCollisionShape_isSoftBody(void *c); //method: isSoftBody bool ( ::btCollisionShape::* )(  ) const
void btCollisionShape_calculateTemporalAabb(void *c,float* p0,float* p1,float* p2,float p3,float* p4,float* p5); //method: calculateTemporalAabb void ( ::btCollisionShape::* )( ::btTransform const &,::btVector3 const &,::btVector3 const &,::btScalar,::btVector3 &,::btVector3 & ) const
int btCollisionShape_isConcave(void *c); //method: isConcave bool ( ::btCollisionShape::* )(  ) const
float btCollisionShape_getAngularMotionDisc(void *c); //method: getAngularMotionDisc ::btScalar ( ::btCollisionShape::* )(  ) const
void btCollisionShape_serializeSingleShape(void *c,void* p0); //method: serializeSingleShape void ( ::btCollisionShape::* )( ::btSerializer * ) const
//not supported method: getBoundingSphere void ( ::btCollisionShape::* )( ::btVector3 &,::btScalar & ) const
// error: ::btVector3 & - ok,  - unsupported, void - ok

int btCollisionShape_getShapeType(void *c); //method: getShapeType int ( ::btCollisionShape::* )(  ) const
void btCollisionShape_m_shapeType_set(void *c,int a); //attribute: int btCollisionShape->m_shapeType
int btCollisionShape_m_shapeType_get(void *c); //attribute: int btCollisionShape->m_shapeType
void btCollisionShape_m_userPointer_set(void *c,void* a); //attribute: void * btCollisionShape->m_userPointer
void* btCollisionShape_m_userPointer_get(void *c); //attribute: void * btCollisionShape->m_userPointer
void* btCollisionShapeData_new(); //constructor: btCollisionShapeData  ( ::btCollisionShapeData::* )(  ) 
void btCollisionShapeData_free(void *c); 
void btCollisionShapeData_m_name_set(void *c,char * a); //attribute: char * btCollisionShapeData->m_name
char * btCollisionShapeData_m_name_get(void *c); //attribute: char * btCollisionShapeData->m_name
void btCollisionShapeData_m_shapeType_set(void *c,int a); //attribute: int btCollisionShapeData->m_shapeType
int btCollisionShapeData_m_shapeType_get(void *c); //attribute: int btCollisionShapeData->m_shapeType
// attribute not supported: //attribute: char[4] btCollisionShapeData->m_padding
void* btCompoundShape_new(int p0); //constructor: btCompoundShape  ( ::btCompoundShape::* )( bool ) 
void btCompoundShape_free(void *c); 
void btCompoundShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btCompoundShape::* )( ::btScalar,::btVector3 & ) const
void* btCompoundShape_getDynamicAabbTree(void *c); //method: getDynamicAabbTree ::btDbvt const * ( ::btCompoundShape::* )(  ) const
void* btCompoundShape_getDynamicAabbTree0(void *c); //method: getDynamicAabbTree ::btDbvt const * ( ::btCompoundShape::* )(  ) const
void* btCompoundShape_getDynamicAabbTree1(void *c); //method: getDynamicAabbTree ::btDbvt * ( ::btCompoundShape::* )(  ) 
int btCompoundShape_getUpdateRevision(void *c); //method: getUpdateRevision int ( ::btCompoundShape::* )(  ) const
char const * btCompoundShape_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btCompoundShape::* )( void *,::btSerializer * ) const
void btCompoundShape_getLocalScaling(void *c,float* ret); //method: getLocalScaling ::btVector3 const & ( ::btCompoundShape::* )(  ) const
void btCompoundShape_createAabbTreeFromChildren(void *c); //method: createAabbTreeFromChildren void ( ::btCompoundShape::* )(  ) 
int btCompoundShape_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btCompoundShape::* )(  ) const
char const * btCompoundShape_getName(void *c); //method: getName char const * ( ::btCompoundShape::* )(  ) const
void btCompoundShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btCompoundShape::* )( ::btVector3 const & ) 
void btCompoundShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btCompoundShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void* btCompoundShape_getChildShape(void *c,int p0); //method: getChildShape ::btCollisionShape * ( ::btCompoundShape::* )( int ) 
void* btCompoundShape_getChildShape0(void *c,int p0); //method: getChildShape ::btCollisionShape * ( ::btCompoundShape::* )( int ) 
void* btCompoundShape_getChildShape1(void *c,int p0); //method: getChildShape ::btCollisionShape const * ( ::btCompoundShape::* )( int ) const
void btCompoundShape_addChildShape(void *c,float* p0,void* p1); //method: addChildShape void ( ::btCompoundShape::* )( ::btTransform const &,::btCollisionShape * ) 
void btCompoundShape_getChildTransform(void *c,int p0,float* ret); //method: getChildTransform ::btTransform & ( ::btCompoundShape::* )( int ) 
void btCompoundShape_getChildTransform0(void *c,int p0,float* ret); //method: getChildTransform ::btTransform & ( ::btCompoundShape::* )( int ) 
void btCompoundShape_getChildTransform1(void *c,int p0,float* ret); //method: getChildTransform ::btTransform const & ( ::btCompoundShape::* )( int ) const
void* btCompoundShape_getChildList(void *c); //method: getChildList ::btCompoundShapeChild * ( ::btCompoundShape::* )(  ) 
float btCompoundShape_getMargin(void *c); //method: getMargin ::btScalar ( ::btCompoundShape::* )(  ) const
void btCompoundShape_setMargin(void *c,float p0); //method: setMargin void ( ::btCompoundShape::* )( ::btScalar ) 
int btCompoundShape_getNumChildShapes(void *c); //method: getNumChildShapes int ( ::btCompoundShape::* )(  ) const
void btCompoundShape_removeChildShapeByIndex(void *c,int p0); //method: removeChildShapeByIndex void ( ::btCompoundShape::* )( int ) 
void btCompoundShape_recalculateLocalAabb(void *c); //method: recalculateLocalAabb void ( ::btCompoundShape::* )(  ) 
void btCompoundShape_updateChildTransform(void *c,int p0,float* p1,int p2); //method: updateChildTransform void ( ::btCompoundShape::* )( int,::btTransform const &,bool ) 
//not supported method: calculatePrincipalAxisTransform void ( ::btCompoundShape::* )( ::btScalar *,::btTransform &,::btVector3 & ) const
// error:  - unsupported, ::btTransform & - ok, ::btVector3 & - ok, void - ok

void btCompoundShape_removeChildShape(void *c,void* p0); //method: removeChildShape void ( ::btCompoundShape::* )( ::btCollisionShape * ) 
void btCompoundShape_m_children_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btCompoundShapeChild> btCompoundShape->m_children
void* btCompoundShape_m_children_get(void *c); //attribute: ::btAlignedObjectArray<btCompoundShapeChild> btCompoundShape->m_children
void btCompoundShape_m_localAabbMin_set(void *c,float* a); //attribute: ::btVector3 btCompoundShape->m_localAabbMin
void btCompoundShape_m_localAabbMin_get(void *c,float* a);
void btCompoundShape_m_localAabbMax_set(void *c,float* a); //attribute: ::btVector3 btCompoundShape->m_localAabbMax
void btCompoundShape_m_localAabbMax_get(void *c,float* a);
void btCompoundShape_m_dynamicAabbTree_set(void *c,void* a); //attribute: ::btDbvt * btCompoundShape->m_dynamicAabbTree
void* btCompoundShape_m_dynamicAabbTree_get(void *c); //attribute: ::btDbvt * btCompoundShape->m_dynamicAabbTree
void btCompoundShape_m_updateRevision_set(void *c,int a); //attribute: int btCompoundShape->m_updateRevision
int btCompoundShape_m_updateRevision_get(void *c); //attribute: int btCompoundShape->m_updateRevision
void btCompoundShape_m_collisionMargin_set(void *c,float a); //attribute: ::btScalar btCompoundShape->m_collisionMargin
float btCompoundShape_m_collisionMargin_get(void *c); //attribute: ::btScalar btCompoundShape->m_collisionMargin
void btCompoundShape_m_localScaling_set(void *c,float* a); //attribute: ::btVector3 btCompoundShape->m_localScaling
void btCompoundShape_m_localScaling_get(void *c,float* a);
void* btCompoundShapeChild_new(); //constructor: btCompoundShapeChild  ( ::btCompoundShapeChild::* )(  ) 
void btCompoundShapeChild_free(void *c); 
void btCompoundShapeChild_m_childMargin_set(void *c,float a); //attribute: ::btScalar btCompoundShapeChild->m_childMargin
float btCompoundShapeChild_m_childMargin_get(void *c); //attribute: ::btScalar btCompoundShapeChild->m_childMargin
void btCompoundShapeChild_m_childShape_set(void *c,void* a); //attribute: ::btCollisionShape * btCompoundShapeChild->m_childShape
void* btCompoundShapeChild_m_childShape_get(void *c); //attribute: ::btCollisionShape * btCompoundShapeChild->m_childShape
void btCompoundShapeChild_m_childShapeType_set(void *c,int a); //attribute: int btCompoundShapeChild->m_childShapeType
int btCompoundShapeChild_m_childShapeType_get(void *c); //attribute: int btCompoundShapeChild->m_childShapeType
void btCompoundShapeChild_m_node_set(void *c,void* a); //attribute: ::btDbvtNode * btCompoundShapeChild->m_node
void* btCompoundShapeChild_m_node_get(void *c); //attribute: ::btDbvtNode * btCompoundShapeChild->m_node
void btCompoundShapeChild_m_transform_set(void *c,float* a); //attribute: ::btTransform btCompoundShapeChild->m_transform
void btCompoundShapeChild_m_transform_get(void *c,float* a);
void* btCompoundShapeChildData_new(); //constructor: btCompoundShapeChildData  ( ::btCompoundShapeChildData::* )(  ) 
void btCompoundShapeChildData_free(void *c); 
void btCompoundShapeChildData_m_transform_set(void *c,void* a); //attribute: ::btTransformFloatData btCompoundShapeChildData->m_transform
void* btCompoundShapeChildData_m_transform_get(void *c); //attribute: ::btTransformFloatData btCompoundShapeChildData->m_transform
void btCompoundShapeChildData_m_childShape_set(void *c,void* a); //attribute: ::btCollisionShapeData * btCompoundShapeChildData->m_childShape
void* btCompoundShapeChildData_m_childShape_get(void *c); //attribute: ::btCollisionShapeData * btCompoundShapeChildData->m_childShape
void btCompoundShapeChildData_m_childShapeType_set(void *c,int a); //attribute: int btCompoundShapeChildData->m_childShapeType
int btCompoundShapeChildData_m_childShapeType_get(void *c); //attribute: int btCompoundShapeChildData->m_childShapeType
void btCompoundShapeChildData_m_childMargin_set(void *c,float a); //attribute: float btCompoundShapeChildData->m_childMargin
float btCompoundShapeChildData_m_childMargin_get(void *c); //attribute: float btCompoundShapeChildData->m_childMargin
void* btCompoundShapeData_new(); //constructor: btCompoundShapeData  ( ::btCompoundShapeData::* )(  ) 
void btCompoundShapeData_free(void *c); 
void btCompoundShapeData_m_collisionShapeData_set(void *c,void* a); //attribute: ::btCollisionShapeData btCompoundShapeData->m_collisionShapeData
void* btCompoundShapeData_m_collisionShapeData_get(void *c); //attribute: ::btCollisionShapeData btCompoundShapeData->m_collisionShapeData
void btCompoundShapeData_m_childShapePtr_set(void *c,void* a); //attribute: ::btCompoundShapeChildData * btCompoundShapeData->m_childShapePtr
void* btCompoundShapeData_m_childShapePtr_get(void *c); //attribute: ::btCompoundShapeChildData * btCompoundShapeData->m_childShapePtr
void btCompoundShapeData_m_numChildShapes_set(void *c,int a); //attribute: int btCompoundShapeData->m_numChildShapes
int btCompoundShapeData_m_numChildShapes_get(void *c); //attribute: int btCompoundShapeData->m_numChildShapes
void btCompoundShapeData_m_collisionMargin_set(void *c,float a); //attribute: float btCompoundShapeData->m_collisionMargin
float btCompoundShapeData_m_collisionMargin_get(void *c); //attribute: float btCompoundShapeData->m_collisionMargin
void btConcaveShape_processAllTriangles(void *c,void* p0,float* p1,float* p2); //method: processAllTriangles void ( ::btConcaveShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
void btConcaveShape_setMargin(void *c,float p0); //method: setMargin void ( ::btConcaveShape::* )( ::btScalar ) 
float btConcaveShape_getMargin(void *c); //method: getMargin ::btScalar ( ::btConcaveShape::* )(  ) const
void btConcaveShape_m_collisionMargin_set(void *c,float a); //attribute: ::btScalar btConcaveShape->m_collisionMargin
float btConcaveShape_m_collisionMargin_get(void *c); //attribute: ::btScalar btConcaveShape->m_collisionMargin
void* btConeShape_new(float p0,float p1); //constructor: btConeShape  ( ::btConeShape::* )( ::btScalar,::btScalar ) 
void btConeShape_free(void *c); 
void btConeShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btConeShape::* )( ::btScalar,::btVector3 & ) const
void btConeShape_localGetSupportingVertex(void *c,float* p0,float* ret); //method: localGetSupportingVertex ::btVector3 ( ::btConeShape::* )( ::btVector3 const & ) const
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btConeShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

int btConeShape_getConeUpIndex(void *c); //method: getConeUpIndex int ( ::btConeShape::* )(  ) const
char const * btConeShape_getName(void *c); //method: getName char const * ( ::btConeShape::* )(  ) const
float btConeShape_getHeight(void *c); //method: getHeight ::btScalar ( ::btConeShape::* )(  ) const
void btConeShape_setConeUpIndex(void *c,int p0); //method: setConeUpIndex void ( ::btConeShape::* )( int ) 
void btConeShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btConeShape::* )( ::btVector3 const & ) 
void btConeShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret); //method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btConeShape::* )( ::btVector3 const & ) const
float btConeShape_getRadius(void *c); //method: getRadius ::btScalar ( ::btConeShape::* )(  ) const
void* btConeShapeX_new(float p0,float p1); //constructor: btConeShapeX  ( ::btConeShapeX::* )( ::btScalar,::btScalar ) 
void btConeShapeX_free(void *c); 
void* btConeShapeZ_new(float p0,float p1); //constructor: btConeShapeZ  ( ::btConeShapeZ::* )( ::btScalar,::btScalar ) 
void btConeShapeZ_free(void *c); 
//not supported constructor: btConvexHullShape  ( ::btConvexHullShape::* )( ::btScalar const *,int,int ) 
// error:  - unsupported, int - ok, int - ok

void btConvexHullShape_free(void *c); 
void btConvexHullShape_addPoint(void *c,float* p0); //method: addPoint void ( ::btConvexHullShape::* )( ::btVector3 const & ) 
void btConvexHullShape_localGetSupportingVertex(void *c,float* p0,float* ret); //method: localGetSupportingVertex ::btVector3 ( ::btConvexHullShape::* )( ::btVector3 const & ) const
int btConvexHullShape_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btConvexHullShape::* )(  ) const
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btConvexHullShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

void btConvexHullShape_getScaledPoint(void *c,int p0,float* ret); //method: getScaledPoint ::btVector3 ( ::btConvexHullShape::* )( int ) const
int btConvexHullShape_getNumPlanes(void *c); //method: getNumPlanes int ( ::btConvexHullShape::* )(  ) const
//not supported method: getPoints ::btVector3 const * ( ::btConvexHullShape::* )(  ) const
// error:  - unsupported

int btConvexHullShape_getNumEdges(void *c); //method: getNumEdges int ( ::btConvexHullShape::* )(  ) const
char const * btConvexHullShape_getName(void *c); //method: getName char const * ( ::btConvexHullShape::* )(  ) const
void btConvexHullShape_getVertex(void *c,int p0,float* p1); //method: getVertex void ( ::btConvexHullShape::* )( int,::btVector3 & ) const
void btConvexHullShape_getEdge(void *c,int p0,float* p1,float* p2); //method: getEdge void ( ::btConvexHullShape::* )( int,::btVector3 &,::btVector3 & ) const
void btConvexHullShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret); //method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btConvexHullShape::* )( ::btVector3 const & ) const
//not supported method: project void ( ::btConvexHullShape::* )( ::btTransform const &,::btVector3 const &,float &,float & ) const
// error: ::btTransform const & - ok, ::btVector3 const & - ok,  - unsupported,  - unsupported, void - ok

int btConvexHullShape_isInside(void *c,float* p0,float p1); //method: isInside bool ( ::btConvexHullShape::* )( ::btVector3 const &,::btScalar ) const
void btConvexHullShape_getPlane(void *c,float* p0,float* p1,int p2); //method: getPlane void ( ::btConvexHullShape::* )( ::btVector3 &,::btVector3 &,int ) const
void btConvexHullShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btConvexHullShape::* )( ::btVector3 const & ) 
int btConvexHullShape_getNumVertices(void *c); //method: getNumVertices int ( ::btConvexHullShape::* )(  ) const
char const * btConvexHullShape_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btConvexHullShape::* )( void *,::btSerializer * ) const
int btConvexHullShape_getNumPoints(void *c); //method: getNumPoints int ( ::btConvexHullShape::* )(  ) const
//not supported method: getUnscaledPoints ::btVector3 * ( ::btConvexHullShape::* )(  ) 
// error:  - unsupported

//not supported method: getUnscaledPoints ::btVector3 * ( ::btConvexHullShape::* )(  ) 
// error:  - unsupported

//not supported method: getUnscaledPoints ::btVector3 const * ( ::btConvexHullShape::* )(  ) const
// error:  - unsupported

void btConvexHullShape_m_unscaledPoints_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btVector3> btConvexHullShape->m_unscaledPoints
void* btConvexHullShape_m_unscaledPoints_get(void *c); //attribute: ::btAlignedObjectArray<btVector3> btConvexHullShape->m_unscaledPoints
void* btConvexHullShapeData_new(); //constructor: btConvexHullShapeData  ( ::btConvexHullShapeData::* )(  ) 
void btConvexHullShapeData_free(void *c); 
void btConvexHullShapeData_m_convexInternalShapeData_set(void *c,void* a); //attribute: ::btConvexInternalShapeData btConvexHullShapeData->m_convexInternalShapeData
void* btConvexHullShapeData_m_convexInternalShapeData_get(void *c); //attribute: ::btConvexInternalShapeData btConvexHullShapeData->m_convexInternalShapeData
void btConvexHullShapeData_m_unscaledPointsFloatPtr_set(void *c,void* a); //attribute: ::btVector3FloatData * btConvexHullShapeData->m_unscaledPointsFloatPtr
void* btConvexHullShapeData_m_unscaledPointsFloatPtr_get(void *c); //attribute: ::btVector3FloatData * btConvexHullShapeData->m_unscaledPointsFloatPtr
void btConvexHullShapeData_m_unscaledPointsDoublePtr_set(void *c,void* a); //attribute: ::btVector3DoubleData * btConvexHullShapeData->m_unscaledPointsDoublePtr
void* btConvexHullShapeData_m_unscaledPointsDoublePtr_get(void *c); //attribute: ::btVector3DoubleData * btConvexHullShapeData->m_unscaledPointsDoublePtr
void btConvexHullShapeData_m_numUnscaledPoints_set(void *c,int a); //attribute: int btConvexHullShapeData->m_numUnscaledPoints
int btConvexHullShapeData_m_numUnscaledPoints_get(void *c); //attribute: int btConvexHullShapeData->m_numUnscaledPoints
// attribute not supported: //attribute: char[4] btConvexHullShapeData->m_padding3
void btConvexInternalAabbCachingShape_setCachedLocalAabb(void *c,float* p0,float* p1); //method: setCachedLocalAabb void ( ::btConvexInternalAabbCachingShape::* )( ::btVector3 const &,::btVector3 const & ) 
void btConvexInternalAabbCachingShape_recalcLocalAabb(void *c); //method: recalcLocalAabb void ( ::btConvexInternalAabbCachingShape::* )(  ) 
void btConvexInternalAabbCachingShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btConvexInternalAabbCachingShape::* )( ::btVector3 const & ) 
void btConvexInternalAabbCachingShape_getNonvirtualAabb(void *c,float* p0,float* p1,float* p2,float p3); //method: getNonvirtualAabb void ( ::btConvexInternalAabbCachingShape::* )( ::btTransform const &,::btVector3 &,::btVector3 &,::btScalar ) const
void btConvexInternalAabbCachingShape_getCachedLocalAabb(void *c,float* p0,float* p1); //method: getCachedLocalAabb void ( ::btConvexInternalAabbCachingShape::* )( ::btVector3 &,::btVector3 & ) const
void btConvexInternalAabbCachingShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btConvexInternalAabbCachingShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btConvexInternalAabbCachingShape_m_localAabbMin_set(void *c,float* a); //attribute: ::btVector3 btConvexInternalAabbCachingShape->m_localAabbMin
void btConvexInternalAabbCachingShape_m_localAabbMin_get(void *c,float* a);
void btConvexInternalAabbCachingShape_m_localAabbMax_set(void *c,float* a); //attribute: ::btVector3 btConvexInternalAabbCachingShape->m_localAabbMax
void btConvexInternalAabbCachingShape_m_localAabbMax_get(void *c,float* a);
void btConvexInternalAabbCachingShape_m_isLocalAabbValid_set(void *c,int a); //attribute: bool btConvexInternalAabbCachingShape->m_isLocalAabbValid
int btConvexInternalAabbCachingShape_m_isLocalAabbValid_get(void *c); //attribute: bool btConvexInternalAabbCachingShape->m_isLocalAabbValid
void btConvexInternalShape_localGetSupportingVertex(void *c,float* p0,float* ret); //method: localGetSupportingVertex ::btVector3 ( ::btConvexInternalShape::* )( ::btVector3 const & ) const
int btConvexInternalShape_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btConvexInternalShape::* )(  ) const
void btConvexInternalShape_getImplicitShapeDimensions(void *c,float* ret); //method: getImplicitShapeDimensions ::btVector3 const & ( ::btConvexInternalShape::* )(  ) const
char const * btConvexInternalShape_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btConvexInternalShape::* )( void *,::btSerializer * ) const
void btConvexInternalShape_getLocalScalingNV(void *c,float* ret); //method: getLocalScalingNV ::btVector3 const & ( ::btConvexInternalShape::* )(  ) const
void btConvexInternalShape_getAabbSlow(void *c,float* p0,float* p1,float* p2); //method: getAabbSlow void ( ::btConvexInternalShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btConvexInternalShape_getLocalScaling(void *c,float* ret); //method: getLocalScaling ::btVector3 const & ( ::btConvexInternalShape::* )(  ) const
void btConvexInternalShape_getPreferredPenetrationDirection(void *c,int p0,float* p1); //method: getPreferredPenetrationDirection void ( ::btConvexInternalShape::* )( int,::btVector3 & ) const
void btConvexInternalShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btConvexInternalShape::* )( ::btVector3 const & ) 
int btConvexInternalShape_getNumPreferredPenetrationDirections(void *c); //method: getNumPreferredPenetrationDirections int ( ::btConvexInternalShape::* )(  ) const
void btConvexInternalShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btConvexInternalShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btConvexInternalShape_setMargin(void *c,float p0); //method: setMargin void ( ::btConvexInternalShape::* )( ::btScalar ) 
float btConvexInternalShape_getMarginNV(void *c); //method: getMarginNV ::btScalar ( ::btConvexInternalShape::* )(  ) const
float btConvexInternalShape_getMargin(void *c); //method: getMargin ::btScalar ( ::btConvexInternalShape::* )(  ) const
void btConvexInternalShape_setSafeMargin(void *c,float p0,float p1); //method: setSafeMargin void ( ::btConvexInternalShape::* )( ::btScalar,::btScalar ) 
void btConvexInternalShape_setSafeMargin0(void *c,float p0,float p1); //method: setSafeMargin void ( ::btConvexInternalShape::* )( ::btScalar,::btScalar ) 
void btConvexInternalShape_setSafeMargin1(void *c,float* p0,float p1); //method: setSafeMargin void ( ::btConvexInternalShape::* )( ::btVector3 const &,::btScalar ) 
void btConvexInternalShape_setImplicitShapeDimensions(void *c,float* p0); //method: setImplicitShapeDimensions void ( ::btConvexInternalShape::* )( ::btVector3 const & ) 
void btConvexInternalShape_m_localScaling_set(void *c,float* a); //attribute: ::btVector3 btConvexInternalShape->m_localScaling
void btConvexInternalShape_m_localScaling_get(void *c,float* a);
void btConvexInternalShape_m_implicitShapeDimensions_set(void *c,float* a); //attribute: ::btVector3 btConvexInternalShape->m_implicitShapeDimensions
void btConvexInternalShape_m_implicitShapeDimensions_get(void *c,float* a);
void btConvexInternalShape_m_collisionMargin_set(void *c,float a); //attribute: ::btScalar btConvexInternalShape->m_collisionMargin
float btConvexInternalShape_m_collisionMargin_get(void *c); //attribute: ::btScalar btConvexInternalShape->m_collisionMargin
void btConvexInternalShape_m_padding_set(void *c,float a); //attribute: ::btScalar btConvexInternalShape->m_padding
float btConvexInternalShape_m_padding_get(void *c); //attribute: ::btScalar btConvexInternalShape->m_padding
void* btConvexInternalShapeData_new(); //constructor: btConvexInternalShapeData  ( ::btConvexInternalShapeData::* )(  ) 
void btConvexInternalShapeData_free(void *c); 
void btConvexInternalShapeData_m_collisionMargin_set(void *c,float a); //attribute: float btConvexInternalShapeData->m_collisionMargin
float btConvexInternalShapeData_m_collisionMargin_get(void *c); //attribute: float btConvexInternalShapeData->m_collisionMargin
void btConvexInternalShapeData_m_collisionShapeData_set(void *c,void* a); //attribute: ::btCollisionShapeData btConvexInternalShapeData->m_collisionShapeData
void* btConvexInternalShapeData_m_collisionShapeData_get(void *c); //attribute: ::btCollisionShapeData btConvexInternalShapeData->m_collisionShapeData
void btConvexInternalShapeData_m_implicitShapeDimensions_set(void *c,void* a); //attribute: ::btVector3FloatData btConvexInternalShapeData->m_implicitShapeDimensions
void* btConvexInternalShapeData_m_implicitShapeDimensions_get(void *c); //attribute: ::btVector3FloatData btConvexInternalShapeData->m_implicitShapeDimensions
void btConvexInternalShapeData_m_localScaling_set(void *c,void* a); //attribute: ::btVector3FloatData btConvexInternalShapeData->m_localScaling
void* btConvexInternalShapeData_m_localScaling_get(void *c); //attribute: ::btVector3FloatData btConvexInternalShapeData->m_localScaling
void btConvexInternalShapeData_m_padding_set(void *c,int a); //attribute: int btConvexInternalShapeData->m_padding
int btConvexInternalShapeData_m_padding_get(void *c); //attribute: int btConvexInternalShapeData->m_padding
void btConvexShape_getAabbNonVirtual(void *c,float* p0,float* p1,float* p2); //method: getAabbNonVirtual void ( ::btConvexShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btConvexShape_localGetSupportingVertex(void *c,float* p0,float* ret); //method: localGetSupportingVertex ::btVector3 ( ::btConvexShape::* )( ::btVector3 const & ) const
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btConvexShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

float btConvexShape_getMargin(void *c); //method: getMargin ::btScalar ( ::btConvexShape::* )(  ) const
void btConvexShape_localGetSupportVertexWithoutMarginNonVirtual(void *c,float* p0,float* ret); //method: localGetSupportVertexWithoutMarginNonVirtual ::btVector3 ( ::btConvexShape::* )( ::btVector3 const & ) const
void btConvexShape_getLocalScaling(void *c,float* ret); //method: getLocalScaling ::btVector3 const & ( ::btConvexShape::* )(  ) const
//not supported method: project void ( ::btConvexShape::* )( ::btTransform const &,::btVector3 const &,float &,float & ) const
// error: ::btTransform const & - ok, ::btVector3 const & - ok,  - unsupported,  - unsupported, void - ok

void btConvexShape_getPreferredPenetrationDirection(void *c,int p0,float* p1); //method: getPreferredPenetrationDirection void ( ::btConvexShape::* )( int,::btVector3 & ) const
void btConvexShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btConvexShape::* )( ::btVector3 const & ) 
void btConvexShape_getAabbSlow(void *c,float* p0,float* p1,float* p2); //method: getAabbSlow void ( ::btConvexShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btConvexShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btConvexShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btConvexShape_setMargin(void *c,float p0); //method: setMargin void ( ::btConvexShape::* )( ::btScalar ) 
int btConvexShape_getNumPreferredPenetrationDirections(void *c); //method: getNumPreferredPenetrationDirections int ( ::btConvexShape::* )(  ) const
void btConvexShape_localGetSupportVertexNonVirtual(void *c,float* p0,float* ret); //method: localGetSupportVertexNonVirtual ::btVector3 ( ::btConvexShape::* )( ::btVector3 const & ) const
void btConvexShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret); //method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btConvexShape::* )( ::btVector3 const & ) const
float btConvexShape_getMarginNonVirtual(void *c); //method: getMarginNonVirtual ::btScalar ( ::btConvexShape::* )(  ) const
void* btConvexTriangleMeshShape_new(void* p0,int p1); //constructor: btConvexTriangleMeshShape  ( ::btConvexTriangleMeshShape::* )( ::btStridingMeshInterface *,bool ) 
void btConvexTriangleMeshShape_free(void *c); 
int btConvexTriangleMeshShape_getNumPlanes(void *c); //method: getNumPlanes int ( ::btConvexTriangleMeshShape::* )(  ) const
void btConvexTriangleMeshShape_localGetSupportingVertex(void *c,float* p0,float* ret); //method: localGetSupportingVertex ::btVector3 ( ::btConvexTriangleMeshShape::* )( ::btVector3 const & ) const
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btConvexTriangleMeshShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

int btConvexTriangleMeshShape_getNumEdges(void *c); //method: getNumEdges int ( ::btConvexTriangleMeshShape::* )(  ) const
char const * btConvexTriangleMeshShape_getName(void *c); //method: getName char const * ( ::btConvexTriangleMeshShape::* )(  ) const
void btConvexTriangleMeshShape_getVertex(void *c,int p0,float* p1); //method: getVertex void ( ::btConvexTriangleMeshShape::* )( int,::btVector3 & ) const
void btConvexTriangleMeshShape_getEdge(void *c,int p0,float* p1,float* p2); //method: getEdge void ( ::btConvexTriangleMeshShape::* )( int,::btVector3 &,::btVector3 & ) const
void btConvexTriangleMeshShape_getLocalScaling(void *c,float* ret); //method: getLocalScaling ::btVector3 const & ( ::btConvexTriangleMeshShape::* )(  ) const
int btConvexTriangleMeshShape_isInside(void *c,float* p0,float p1); //method: isInside bool ( ::btConvexTriangleMeshShape::* )( ::btVector3 const &,::btScalar ) const
void btConvexTriangleMeshShape_getPlane(void *c,float* p0,float* p1,int p2); //method: getPlane void ( ::btConvexTriangleMeshShape::* )( ::btVector3 &,::btVector3 &,int ) const
void btConvexTriangleMeshShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btConvexTriangleMeshShape::* )( ::btVector3 const & ) 
void* btConvexTriangleMeshShape_getMeshInterface(void *c); //method: getMeshInterface ::btStridingMeshInterface * ( ::btConvexTriangleMeshShape::* )(  ) 
void* btConvexTriangleMeshShape_getMeshInterface0(void *c); //method: getMeshInterface ::btStridingMeshInterface * ( ::btConvexTriangleMeshShape::* )(  ) 
void* btConvexTriangleMeshShape_getMeshInterface1(void *c); //method: getMeshInterface ::btStridingMeshInterface const * ( ::btConvexTriangleMeshShape::* )(  ) const
int btConvexTriangleMeshShape_getNumVertices(void *c); //method: getNumVertices int ( ::btConvexTriangleMeshShape::* )(  ) const
//not supported method: calculatePrincipalAxisTransform void ( ::btConvexTriangleMeshShape::* )( ::btTransform &,::btVector3 &,::btScalar & ) const
// error: ::btTransform & - ok, ::btVector3 & - ok,  - unsupported, void - ok

void btConvexTriangleMeshShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret); //method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btConvexTriangleMeshShape::* )( ::btVector3 const & ) const
void btConvexTriangleMeshShape_m_stridingMesh_set(void *c,void* a); //attribute: ::btStridingMeshInterface * btConvexTriangleMeshShape->m_stridingMesh
void* btConvexTriangleMeshShape_m_stridingMesh_get(void *c); //attribute: ::btStridingMeshInterface * btConvexTriangleMeshShape->m_stridingMesh
void* btCylinderShape_new(float* p0); //constructor: btCylinderShape  ( ::btCylinderShape::* )( ::btVector3 const & ) 
void btCylinderShape_free(void *c); 
void btCylinderShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btCylinderShape::* )( ::btScalar,::btVector3 & ) const
void btCylinderShape_localGetSupportingVertex(void *c,float* p0,float* ret); //method: localGetSupportingVertex ::btVector3 ( ::btCylinderShape::* )( ::btVector3 const & ) const
int btCylinderShape_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btCylinderShape::* )(  ) const
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btCylinderShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

void btCylinderShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btCylinderShape::* )( ::btVector3 const & ) 
int btCylinderShape_getUpAxis(void *c); //method: getUpAxis int ( ::btCylinderShape::* )(  ) const
char const * btCylinderShape_getName(void *c); //method: getName char const * ( ::btCylinderShape::* )(  ) const
char const * btCylinderShape_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btCylinderShape::* )( void *,::btSerializer * ) const
void btCylinderShape_getHalfExtentsWithoutMargin(void *c,float* ret); //method: getHalfExtentsWithoutMargin ::btVector3 const & ( ::btCylinderShape::* )(  ) const
void btCylinderShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btCylinderShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btCylinderShape_setMargin(void *c,float p0); //method: setMargin void ( ::btCylinderShape::* )( ::btScalar ) 
void btCylinderShape_getHalfExtentsWithMargin(void *c,float* ret); //method: getHalfExtentsWithMargin ::btVector3 ( ::btCylinderShape::* )(  ) const
void btCylinderShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret); //method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btCylinderShape::* )( ::btVector3 const & ) const
float btCylinderShape_getRadius(void *c); //method: getRadius ::btScalar ( ::btCylinderShape::* )(  ) const
void btCylinderShape_m_upAxis_set(void *c,int a); //attribute: int btCylinderShape->m_upAxis
int btCylinderShape_m_upAxis_get(void *c); //attribute: int btCylinderShape->m_upAxis
void* btCylinderShapeData_new(); //constructor: btCylinderShapeData  ( ::btCylinderShapeData::* )(  ) 
void btCylinderShapeData_free(void *c); 
void btCylinderShapeData_m_convexInternalShapeData_set(void *c,void* a); //attribute: ::btConvexInternalShapeData btCylinderShapeData->m_convexInternalShapeData
void* btCylinderShapeData_m_convexInternalShapeData_get(void *c); //attribute: ::btConvexInternalShapeData btCylinderShapeData->m_convexInternalShapeData
void btCylinderShapeData_m_upAxis_set(void *c,int a); //attribute: int btCylinderShapeData->m_upAxis
int btCylinderShapeData_m_upAxis_get(void *c); //attribute: int btCylinderShapeData->m_upAxis
// attribute not supported: //attribute: char[4] btCylinderShapeData->m_padding
void* btCylinderShapeX_new(float* p0); //constructor: btCylinderShapeX  ( ::btCylinderShapeX::* )( ::btVector3 const & ) 
void btCylinderShapeX_free(void *c); 
char const * btCylinderShapeX_getName(void *c); //method: getName char const * ( ::btCylinderShapeX::* )(  ) const
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btCylinderShapeX::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

void btCylinderShapeX_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret); //method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btCylinderShapeX::* )( ::btVector3 const & ) const
float btCylinderShapeX_getRadius(void *c); //method: getRadius ::btScalar ( ::btCylinderShapeX::* )(  ) const
void* btCylinderShapeZ_new(float* p0); //constructor: btCylinderShapeZ  ( ::btCylinderShapeZ::* )( ::btVector3 const & ) 
void btCylinderShapeZ_free(void *c); 
char const * btCylinderShapeZ_getName(void *c); //method: getName char const * ( ::btCylinderShapeZ::* )(  ) const
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btCylinderShapeZ::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

void btCylinderShapeZ_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret); //method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btCylinderShapeZ::* )( ::btVector3 const & ) const
float btCylinderShapeZ_getRadius(void *c); //method: getRadius ::btScalar ( ::btCylinderShapeZ::* )(  ) const
void* btEmptyShape_new(); //constructor: btEmptyShape  ( ::btEmptyShape::* )(  ) 
void btEmptyShape_free(void *c); 
void btEmptyShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btEmptyShape::* )( ::btScalar,::btVector3 & ) const
char const * btEmptyShape_getName(void *c); //method: getName char const * ( ::btEmptyShape::* )(  ) const
void btEmptyShape_getLocalScaling(void *c,float* ret); //method: getLocalScaling ::btVector3 const & ( ::btEmptyShape::* )(  ) const
void btEmptyShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btEmptyShape::* )( ::btVector3 const & ) 
void btEmptyShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btEmptyShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btEmptyShape_processAllTriangles(void *c,void* p0,float* p1,float* p2); //method: processAllTriangles void ( ::btEmptyShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
void btEmptyShape_m_localScaling_set(void *c,float* a); //attribute: ::btVector3 btEmptyShape->m_localScaling
void btEmptyShape_m_localScaling_get(void *c,float* a);
void* btIndexedMesh_new(); //constructor: btIndexedMesh  ( ::btIndexedMesh::* )(  ) 
void btIndexedMesh_free(void *c); 
// attribute not supported: //attribute: ::PHY_ScalarType btIndexedMesh->m_indexType
void btIndexedMesh_m_numTriangles_set(void *c,int a); //attribute: int btIndexedMesh->m_numTriangles
int btIndexedMesh_m_numTriangles_get(void *c); //attribute: int btIndexedMesh->m_numTriangles
void btIndexedMesh_m_numVertices_set(void *c,int a); //attribute: int btIndexedMesh->m_numVertices
int btIndexedMesh_m_numVertices_get(void *c); //attribute: int btIndexedMesh->m_numVertices
// attribute not supported: //attribute: unsigned char const * btIndexedMesh->m_triangleIndexBase
void btIndexedMesh_m_triangleIndexStride_set(void *c,int a); //attribute: int btIndexedMesh->m_triangleIndexStride
int btIndexedMesh_m_triangleIndexStride_get(void *c); //attribute: int btIndexedMesh->m_triangleIndexStride
// attribute not supported: //attribute: unsigned char const * btIndexedMesh->m_vertexBase
void btIndexedMesh_m_vertexStride_set(void *c,int a); //attribute: int btIndexedMesh->m_vertexStride
int btIndexedMesh_m_vertexStride_get(void *c); //attribute: int btIndexedMesh->m_vertexStride
// attribute not supported: //attribute: ::PHY_ScalarType btIndexedMesh->m_vertexType
void* btIntIndexData_new(); //constructor: btIntIndexData  ( ::btIntIndexData::* )(  ) 
void btIntIndexData_free(void *c); 
void btIntIndexData_m_value_set(void *c,int a); //attribute: int btIntIndexData->m_value
int btIntIndexData_m_value_get(void *c); //attribute: int btIntIndexData->m_value
//not supported method: internalProcessTriangleIndex void ( ::btInternalTriangleIndexCallback::* )( ::btVector3 *,int,int ) 
// error:  - unsupported, int - ok, int - ok, void - ok

void* btMeshPartData_new(); //constructor: btMeshPartData  ( ::btMeshPartData::* )(  ) 
void btMeshPartData_free(void *c); 
void btMeshPartData_m_vertices3f_set(void *c,void* a); //attribute: ::btVector3FloatData * btMeshPartData->m_vertices3f
void* btMeshPartData_m_vertices3f_get(void *c); //attribute: ::btVector3FloatData * btMeshPartData->m_vertices3f
void btMeshPartData_m_vertices3d_set(void *c,void* a); //attribute: ::btVector3DoubleData * btMeshPartData->m_vertices3d
void* btMeshPartData_m_vertices3d_get(void *c); //attribute: ::btVector3DoubleData * btMeshPartData->m_vertices3d
void btMeshPartData_m_indices32_set(void *c,void* a); //attribute: ::btIntIndexData * btMeshPartData->m_indices32
void* btMeshPartData_m_indices32_get(void *c); //attribute: ::btIntIndexData * btMeshPartData->m_indices32
void btMeshPartData_m_3indices16_set(void *c,void* a); //attribute: ::btShortIntIndexTripletData * btMeshPartData->m_3indices16
void* btMeshPartData_m_3indices16_get(void *c); //attribute: ::btShortIntIndexTripletData * btMeshPartData->m_3indices16
void btMeshPartData_m_3indices8_set(void *c,void* a); //attribute: ::btCharIndexTripletData * btMeshPartData->m_3indices8
void* btMeshPartData_m_3indices8_get(void *c); //attribute: ::btCharIndexTripletData * btMeshPartData->m_3indices8
void btMeshPartData_m_indices16_set(void *c,void* a); //attribute: ::btShortIntIndexData * btMeshPartData->m_indices16
void* btMeshPartData_m_indices16_get(void *c); //attribute: ::btShortIntIndexData * btMeshPartData->m_indices16
void btMeshPartData_m_numTriangles_set(void *c,int a); //attribute: int btMeshPartData->m_numTriangles
int btMeshPartData_m_numTriangles_get(void *c); //attribute: int btMeshPartData->m_numTriangles
void btMeshPartData_m_numVertices_set(void *c,int a); //attribute: int btMeshPartData->m_numVertices
int btMeshPartData_m_numVertices_get(void *c); //attribute: int btMeshPartData->m_numVertices
//not supported constructor: btMultiSphereShape  ( ::btMultiSphereShape::* )( ::btVector3 const *,::btScalar const *,int ) 
// error:  - unsupported,  - unsupported, int - ok

void btMultiSphereShape_free(void *c); 
void btMultiSphereShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btMultiSphereShape::* )( ::btScalar,::btVector3 & ) const
int btMultiSphereShape_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btMultiSphereShape::* )(  ) const
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btMultiSphereShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

int btMultiSphereShape_getSphereCount(void *c); //method: getSphereCount int ( ::btMultiSphereShape::* )(  ) const
char const * btMultiSphereShape_getName(void *c); //method: getName char const * ( ::btMultiSphereShape::* )(  ) const
char const * btMultiSphereShape_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btMultiSphereShape::* )( void *,::btSerializer * ) const
void btMultiSphereShape_getSpherePosition(void *c,int p0,float* ret); //method: getSpherePosition ::btVector3 const & ( ::btMultiSphereShape::* )( int ) const
float btMultiSphereShape_getSphereRadius(void *c,int p0); //method: getSphereRadius ::btScalar ( ::btMultiSphereShape::* )( int ) const
void btMultiSphereShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret); //method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btMultiSphereShape::* )( ::btVector3 const & ) const
void btMultiSphereShape_m_localPositionArray_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btVector3> btMultiSphereShape->m_localPositionArray
void* btMultiSphereShape_m_localPositionArray_get(void *c); //attribute: ::btAlignedObjectArray<btVector3> btMultiSphereShape->m_localPositionArray
void btMultiSphereShape_m_radiArray_set(void *c,void* a); //attribute: ::btAlignedObjectArray<float> btMultiSphereShape->m_radiArray
void* btMultiSphereShape_m_radiArray_get(void *c); //attribute: ::btAlignedObjectArray<float> btMultiSphereShape->m_radiArray
void* btMultiSphereShapeData_new(); //constructor: btMultiSphereShapeData  ( ::btMultiSphereShapeData::* )(  ) 
void btMultiSphereShapeData_free(void *c); 
void btMultiSphereShapeData_m_convexInternalShapeData_set(void *c,void* a); //attribute: ::btConvexInternalShapeData btMultiSphereShapeData->m_convexInternalShapeData
void* btMultiSphereShapeData_m_convexInternalShapeData_get(void *c); //attribute: ::btConvexInternalShapeData btMultiSphereShapeData->m_convexInternalShapeData
void btMultiSphereShapeData_m_localPositionArrayPtr_set(void *c,void* a); //attribute: ::btPositionAndRadius * btMultiSphereShapeData->m_localPositionArrayPtr
void* btMultiSphereShapeData_m_localPositionArrayPtr_get(void *c); //attribute: ::btPositionAndRadius * btMultiSphereShapeData->m_localPositionArrayPtr
void btMultiSphereShapeData_m_localPositionArraySize_set(void *c,int a); //attribute: int btMultiSphereShapeData->m_localPositionArraySize
int btMultiSphereShapeData_m_localPositionArraySize_get(void *c); //attribute: int btMultiSphereShapeData->m_localPositionArraySize
// attribute not supported: //attribute: char[4] btMultiSphereShapeData->m_padding
void* btOptimizedBvh_new(); //constructor: btOptimizedBvh  ( ::btOptimizedBvh::* )(  ) 
void btOptimizedBvh_free(void *c); 
void btOptimizedBvh_updateBvhNodes(void *c,void* p0,int p1,int p2,int p3); //method: updateBvhNodes void ( ::btOptimizedBvh::* )( ::btStridingMeshInterface *,int,int,int ) 
int btOptimizedBvh_serializeInPlace(void *c,void* p0,unsigned int p1,int p2); //method: serializeInPlace bool ( ::btOptimizedBvh::* )( void *,unsigned int,bool ) const
void btOptimizedBvh_refit(void *c,void* p0,float* p1,float* p2); //method: refit void ( ::btOptimizedBvh::* )( ::btStridingMeshInterface *,::btVector3 const &,::btVector3 const & ) 
void btOptimizedBvh_build(void *c,void* p0,int p1,float* p2,float* p3); //method: build void ( ::btOptimizedBvh::* )( ::btStridingMeshInterface *,bool,::btVector3 const &,::btVector3 const & ) 
void btOptimizedBvh_refitPartial(void *c,void* p0,float* p1,float* p2); //method: refitPartial void ( ::btOptimizedBvh::* )( ::btStridingMeshInterface *,::btVector3 const &,::btVector3 const & ) 
void* btOptimizedBvh_deSerializeInPlace(void* p0,unsigned int p1,int p2); //method: deSerializeInPlace ::btOptimizedBvh * (*)( void *,unsigned int,bool )
void btPolyhedralConvexAabbCachingShape_setCachedLocalAabb(void *c,float* p0,float* p1); //method: setCachedLocalAabb void ( ::btPolyhedralConvexAabbCachingShape::* )( ::btVector3 const &,::btVector3 const & ) 
void btPolyhedralConvexAabbCachingShape_recalcLocalAabb(void *c); //method: recalcLocalAabb void ( ::btPolyhedralConvexAabbCachingShape::* )(  ) 
void btPolyhedralConvexAabbCachingShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btPolyhedralConvexAabbCachingShape::* )( ::btVector3 const & ) 
void btPolyhedralConvexAabbCachingShape_getNonvirtualAabb(void *c,float* p0,float* p1,float* p2,float p3); //method: getNonvirtualAabb void ( ::btPolyhedralConvexAabbCachingShape::* )( ::btTransform const &,::btVector3 &,::btVector3 &,::btScalar ) const
void btPolyhedralConvexAabbCachingShape_getCachedLocalAabb(void *c,float* p0,float* p1); //method: getCachedLocalAabb void ( ::btPolyhedralConvexAabbCachingShape::* )( ::btVector3 &,::btVector3 & ) const
void btPolyhedralConvexAabbCachingShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btPolyhedralConvexAabbCachingShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btPolyhedralConvexAabbCachingShape_m_localAabbMin_set(void *c,float* a); //attribute: ::btVector3 btPolyhedralConvexAabbCachingShape->m_localAabbMin
void btPolyhedralConvexAabbCachingShape_m_localAabbMin_get(void *c,float* a);
void btPolyhedralConvexAabbCachingShape_m_localAabbMax_set(void *c,float* a); //attribute: ::btVector3 btPolyhedralConvexAabbCachingShape->m_localAabbMax
void btPolyhedralConvexAabbCachingShape_m_localAabbMax_get(void *c,float* a);
void btPolyhedralConvexAabbCachingShape_m_isLocalAabbValid_set(void *c,int a); //attribute: bool btPolyhedralConvexAabbCachingShape->m_isLocalAabbValid
int btPolyhedralConvexAabbCachingShape_m_isLocalAabbValid_get(void *c); //attribute: bool btPolyhedralConvexAabbCachingShape->m_isLocalAabbValid
void btPolyhedralConvexShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btPolyhedralConvexShape::* )( ::btScalar,::btVector3 & ) const
int btPolyhedralConvexShape_getNumPlanes(void *c); //method: getNumPlanes int ( ::btPolyhedralConvexShape::* )(  ) const
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btPolyhedralConvexShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

int btPolyhedralConvexShape_getNumEdges(void *c); //method: getNumEdges int ( ::btPolyhedralConvexShape::* )(  ) const
void btPolyhedralConvexShape_getVertex(void *c,int p0,float* p1); //method: getVertex void ( ::btPolyhedralConvexShape::* )( int,::btVector3 & ) const
void btPolyhedralConvexShape_getEdge(void *c,int p0,float* p1,float* p2); //method: getEdge void ( ::btPolyhedralConvexShape::* )( int,::btVector3 &,::btVector3 & ) const
int btPolyhedralConvexShape_isInside(void *c,float* p0,float p1); //method: isInside bool ( ::btPolyhedralConvexShape::* )( ::btVector3 const &,::btScalar ) const
void btPolyhedralConvexShape_getPlane(void *c,float* p0,float* p1,int p2); //method: getPlane void ( ::btPolyhedralConvexShape::* )( ::btVector3 &,::btVector3 &,int ) const
//not supported method: getConvexPolyhedron ::btConvexPolyhedron const * ( ::btPolyhedralConvexShape::* )(  ) const
// error:  - unsupported

int btPolyhedralConvexShape_initializePolyhedralFeatures(void *c); //method: initializePolyhedralFeatures bool ( ::btPolyhedralConvexShape::* )(  ) 
int btPolyhedralConvexShape_getNumVertices(void *c); //method: getNumVertices int ( ::btPolyhedralConvexShape::* )(  ) const
void btPolyhedralConvexShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret); //method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btPolyhedralConvexShape::* )( ::btVector3 const & ) const
// attribute not supported: //attribute: ::btConvexPolyhedron * btPolyhedralConvexShape->m_polyhedron
void* btPositionAndRadius_new(); //constructor: btPositionAndRadius  ( ::btPositionAndRadius::* )(  ) 
void btPositionAndRadius_free(void *c); 
void btPositionAndRadius_m_pos_set(void *c,void* a); //attribute: ::btVector3FloatData btPositionAndRadius->m_pos
void* btPositionAndRadius_m_pos_get(void *c); //attribute: ::btVector3FloatData btPositionAndRadius->m_pos
void btPositionAndRadius_m_radius_set(void *c,float a); //attribute: float btPositionAndRadius->m_radius
float btPositionAndRadius_m_radius_get(void *c); //attribute: float btPositionAndRadius->m_radius
void* btScaledBvhTriangleMeshShape_new(void* p0,float* p1); //constructor: btScaledBvhTriangleMeshShape  ( ::btScaledBvhTriangleMeshShape::* )( ::btBvhTriangleMeshShape *,::btVector3 const & ) 
void btScaledBvhTriangleMeshShape_free(void *c); 
void btScaledBvhTriangleMeshShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btScaledBvhTriangleMeshShape::* )( ::btScalar,::btVector3 & ) const
void* btScaledBvhTriangleMeshShape_getChildShape(void *c); //method: getChildShape ::btBvhTriangleMeshShape * ( ::btScaledBvhTriangleMeshShape::* )(  ) 
void* btScaledBvhTriangleMeshShape_getChildShape0(void *c); //method: getChildShape ::btBvhTriangleMeshShape * ( ::btScaledBvhTriangleMeshShape::* )(  ) 
void* btScaledBvhTriangleMeshShape_getChildShape1(void *c); //method: getChildShape ::btBvhTriangleMeshShape const * ( ::btScaledBvhTriangleMeshShape::* )(  ) const
int btScaledBvhTriangleMeshShape_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btScaledBvhTriangleMeshShape::* )(  ) const
char const * btScaledBvhTriangleMeshShape_getName(void *c); //method: getName char const * ( ::btScaledBvhTriangleMeshShape::* )(  ) const
char const * btScaledBvhTriangleMeshShape_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btScaledBvhTriangleMeshShape::* )( void *,::btSerializer * ) const
void btScaledBvhTriangleMeshShape_getLocalScaling(void *c,float* ret); //method: getLocalScaling ::btVector3 const & ( ::btScaledBvhTriangleMeshShape::* )(  ) const
void btScaledBvhTriangleMeshShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btScaledBvhTriangleMeshShape::* )( ::btVector3 const & ) 
void btScaledBvhTriangleMeshShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btScaledBvhTriangleMeshShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btScaledBvhTriangleMeshShape_processAllTriangles(void *c,void* p0,float* p1,float* p2); //method: processAllTriangles void ( ::btScaledBvhTriangleMeshShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
void btScaledBvhTriangleMeshShape_m_localScaling_set(void *c,float* a); //attribute: ::btVector3 btScaledBvhTriangleMeshShape->m_localScaling
void btScaledBvhTriangleMeshShape_m_localScaling_get(void *c,float* a);
void btScaledBvhTriangleMeshShape_m_bvhTriMeshShape_set(void *c,void* a); //attribute: ::btBvhTriangleMeshShape * btScaledBvhTriangleMeshShape->m_bvhTriMeshShape
void* btScaledBvhTriangleMeshShape_m_bvhTriMeshShape_get(void *c); //attribute: ::btBvhTriangleMeshShape * btScaledBvhTriangleMeshShape->m_bvhTriMeshShape
void* btScaledTriangleMeshShapeData_new(); //constructor: btScaledTriangleMeshShapeData  ( ::btScaledTriangleMeshShapeData::* )(  ) 
void btScaledTriangleMeshShapeData_free(void *c); 
void btScaledTriangleMeshShapeData_m_trimeshShapeData_set(void *c,void* a); //attribute: ::btTriangleMeshShapeData btScaledTriangleMeshShapeData->m_trimeshShapeData
void* btScaledTriangleMeshShapeData_m_trimeshShapeData_get(void *c); //attribute: ::btTriangleMeshShapeData btScaledTriangleMeshShapeData->m_trimeshShapeData
void btScaledTriangleMeshShapeData_m_localScaling_set(void *c,void* a); //attribute: ::btVector3FloatData btScaledTriangleMeshShapeData->m_localScaling
void* btScaledTriangleMeshShapeData_m_localScaling_get(void *c); //attribute: ::btVector3FloatData btScaledTriangleMeshShapeData->m_localScaling
void* btShortIntIndexData_new(); //constructor: btShortIntIndexData  ( ::btShortIntIndexData::* )(  ) 
void btShortIntIndexData_free(void *c); 
// attribute not supported: //attribute: char[2] btShortIntIndexData->m_pad
void btShortIntIndexData_m_value_set(void *c,short int a); //attribute: short int btShortIntIndexData->m_value
short int btShortIntIndexData_m_value_get(void *c); //attribute: short int btShortIntIndexData->m_value
void* btShortIntIndexTripletData_new(); //constructor: btShortIntIndexTripletData  ( ::btShortIntIndexTripletData::* )(  ) 
void btShortIntIndexTripletData_free(void *c); 
// attribute not supported: //attribute: char[2] btShortIntIndexTripletData->m_pad
// attribute not supported: //attribute: short int[3] btShortIntIndexTripletData->m_values
void* btSphereShape_new(float p0); //constructor: btSphereShape  ( ::btSphereShape::* )( ::btScalar ) 
void btSphereShape_free(void *c); 
void btSphereShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btSphereShape::* )( ::btScalar,::btVector3 & ) const
void btSphereShape_localGetSupportingVertex(void *c,float* p0,float* ret); //method: localGetSupportingVertex ::btVector3 ( ::btSphereShape::* )( ::btVector3 const & ) const
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btSphereShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

char const * btSphereShape_getName(void *c); //method: getName char const * ( ::btSphereShape::* )(  ) const
float btSphereShape_getMargin(void *c); //method: getMargin ::btScalar ( ::btSphereShape::* )(  ) const
void btSphereShape_setMargin(void *c,float p0); //method: setMargin void ( ::btSphereShape::* )( ::btScalar ) 
void btSphereShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btSphereShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btSphereShape_setUnscaledRadius(void *c,float p0); //method: setUnscaledRadius void ( ::btSphereShape::* )( ::btScalar ) 
void btSphereShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret); //method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btSphereShape::* )( ::btVector3 const & ) const
float btSphereShape_getRadius(void *c); //method: getRadius ::btScalar ( ::btSphereShape::* )(  ) const
void* btStaticPlaneShape_new(float* p0,float p1); //constructor: btStaticPlaneShape  ( ::btStaticPlaneShape::* )( ::btVector3 const &,::btScalar ) 
void btStaticPlaneShape_free(void *c); 
void btStaticPlaneShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btStaticPlaneShape::* )( ::btScalar,::btVector3 & ) const
int btStaticPlaneShape_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btStaticPlaneShape::* )(  ) const
char const * btStaticPlaneShape_getName(void *c); //method: getName char const * ( ::btStaticPlaneShape::* )(  ) const
char const * btStaticPlaneShape_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btStaticPlaneShape::* )( void *,::btSerializer * ) const
void btStaticPlaneShape_getLocalScaling(void *c,float* ret); //method: getLocalScaling ::btVector3 const & ( ::btStaticPlaneShape::* )(  ) const
void btStaticPlaneShape_getPlaneNormal(void *c,float* ret); //method: getPlaneNormal ::btVector3 const & ( ::btStaticPlaneShape::* )(  ) const
float btStaticPlaneShape_getPlaneConstant(void *c); //method: getPlaneConstant ::btScalar const & ( ::btStaticPlaneShape::* )(  ) const
void btStaticPlaneShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btStaticPlaneShape::* )( ::btVector3 const & ) 
void btStaticPlaneShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btStaticPlaneShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btStaticPlaneShape_processAllTriangles(void *c,void* p0,float* p1,float* p2); //method: processAllTriangles void ( ::btStaticPlaneShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
void btStaticPlaneShape_m_localAabbMin_set(void *c,float* a); //attribute: ::btVector3 btStaticPlaneShape->m_localAabbMin
void btStaticPlaneShape_m_localAabbMin_get(void *c,float* a);
void btStaticPlaneShape_m_localAabbMax_set(void *c,float* a); //attribute: ::btVector3 btStaticPlaneShape->m_localAabbMax
void btStaticPlaneShape_m_localAabbMax_get(void *c,float* a);
void btStaticPlaneShape_m_planeNormal_set(void *c,float* a); //attribute: ::btVector3 btStaticPlaneShape->m_planeNormal
void btStaticPlaneShape_m_planeNormal_get(void *c,float* a);
void btStaticPlaneShape_m_planeConstant_set(void *c,float a); //attribute: ::btScalar btStaticPlaneShape->m_planeConstant
float btStaticPlaneShape_m_planeConstant_get(void *c); //attribute: ::btScalar btStaticPlaneShape->m_planeConstant
void btStaticPlaneShape_m_localScaling_set(void *c,float* a); //attribute: ::btVector3 btStaticPlaneShape->m_localScaling
void btStaticPlaneShape_m_localScaling_get(void *c,float* a);
void* btStaticPlaneShapeData_new(); //constructor: btStaticPlaneShapeData  ( ::btStaticPlaneShapeData::* )(  ) 
void btStaticPlaneShapeData_free(void *c); 
void btStaticPlaneShapeData_m_collisionShapeData_set(void *c,void* a); //attribute: ::btCollisionShapeData btStaticPlaneShapeData->m_collisionShapeData
void* btStaticPlaneShapeData_m_collisionShapeData_get(void *c); //attribute: ::btCollisionShapeData btStaticPlaneShapeData->m_collisionShapeData
void btStaticPlaneShapeData_m_localScaling_set(void *c,void* a); //attribute: ::btVector3FloatData btStaticPlaneShapeData->m_localScaling
void* btStaticPlaneShapeData_m_localScaling_get(void *c); //attribute: ::btVector3FloatData btStaticPlaneShapeData->m_localScaling
void btStaticPlaneShapeData_m_planeNormal_set(void *c,void* a); //attribute: ::btVector3FloatData btStaticPlaneShapeData->m_planeNormal
void* btStaticPlaneShapeData_m_planeNormal_get(void *c); //attribute: ::btVector3FloatData btStaticPlaneShapeData->m_planeNormal
void btStaticPlaneShapeData_m_planeConstant_set(void *c,float a); //attribute: float btStaticPlaneShapeData->m_planeConstant
float btStaticPlaneShapeData_m_planeConstant_get(void *c); //attribute: float btStaticPlaneShapeData->m_planeConstant
// attribute not supported: //attribute: char[4] btStaticPlaneShapeData->m_pad
//not supported method: getLockedReadOnlyVertexIndexBase void ( ::btStridingMeshInterface::* )( unsigned char const * *,int &,::PHY_ScalarType &,int &,unsigned char const * *,int &,int &,::PHY_ScalarType &,int ) const
// error:  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported, int - ok, void - ok

int btStridingMeshInterface_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btStridingMeshInterface::* )(  ) const
void btStridingMeshInterface_calculateAabbBruteForce(void *c,float* p0,float* p1); //method: calculateAabbBruteForce void ( ::btStridingMeshInterface::* )( ::btVector3 &,::btVector3 & ) 
char const * btStridingMeshInterface_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btStridingMeshInterface::* )( void *,::btSerializer * ) const
void btStridingMeshInterface_preallocateVertices(void *c,int p0); //method: preallocateVertices void ( ::btStridingMeshInterface::* )( int ) 
void btStridingMeshInterface_unLockVertexBase(void *c,int p0); //method: unLockVertexBase void ( ::btStridingMeshInterface::* )( int ) 
void btStridingMeshInterface_getScaling(void *c,float* ret); //method: getScaling ::btVector3 const & ( ::btStridingMeshInterface::* )(  ) const
void btStridingMeshInterface_preallocateIndices(void *c,int p0); //method: preallocateIndices void ( ::btStridingMeshInterface::* )( int ) 
void btStridingMeshInterface_setPremadeAabb(void *c,float* p0,float* p1); //method: setPremadeAabb void ( ::btStridingMeshInterface::* )( ::btVector3 const &,::btVector3 const & ) const
void btStridingMeshInterface_InternalProcessAllTriangles(void *c,void* p0,float* p1,float* p2); //method: InternalProcessAllTriangles void ( ::btStridingMeshInterface::* )( ::btInternalTriangleIndexCallback *,::btVector3 const &,::btVector3 const & ) const
//not supported method: getPremadeAabb void ( ::btStridingMeshInterface::* )( ::btVector3 *,::btVector3 * ) const
// error:  - unsupported,  - unsupported, void - ok

int btStridingMeshInterface_getNumSubParts(void *c); //method: getNumSubParts int ( ::btStridingMeshInterface::* )(  ) const
//not supported method: getLockedVertexIndexBase void ( ::btStridingMeshInterface::* )( unsigned char * *,int &,::PHY_ScalarType &,int &,unsigned char * *,int &,int &,::PHY_ScalarType &,int ) 
// error:  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported, int - ok, void - ok

int btStridingMeshInterface_hasPremadeAabb(void *c); //method: hasPremadeAabb bool ( ::btStridingMeshInterface::* )(  ) const
void btStridingMeshInterface_setScaling(void *c,float* p0); //method: setScaling void ( ::btStridingMeshInterface::* )( ::btVector3 const & ) 
void btStridingMeshInterface_unLockReadOnlyVertexBase(void *c,int p0); //method: unLockReadOnlyVertexBase void ( ::btStridingMeshInterface::* )( int ) const
void btStridingMeshInterface_m_scaling_set(void *c,float* a); //attribute: ::btVector3 btStridingMeshInterface->m_scaling
void btStridingMeshInterface_m_scaling_get(void *c,float* a);
void* btStridingMeshInterfaceData_new(); //constructor: btStridingMeshInterfaceData  ( ::btStridingMeshInterfaceData::* )(  ) 
void btStridingMeshInterfaceData_free(void *c); 
void btStridingMeshInterfaceData_m_meshPartsPtr_set(void *c,void* a); //attribute: ::btMeshPartData * btStridingMeshInterfaceData->m_meshPartsPtr
void* btStridingMeshInterfaceData_m_meshPartsPtr_get(void *c); //attribute: ::btMeshPartData * btStridingMeshInterfaceData->m_meshPartsPtr
void btStridingMeshInterfaceData_m_scaling_set(void *c,void* a); //attribute: ::btVector3FloatData btStridingMeshInterfaceData->m_scaling
void* btStridingMeshInterfaceData_m_scaling_get(void *c); //attribute: ::btVector3FloatData btStridingMeshInterfaceData->m_scaling
void btStridingMeshInterfaceData_m_numMeshParts_set(void *c,int a); //attribute: int btStridingMeshInterfaceData->m_numMeshParts
int btStridingMeshInterfaceData_m_numMeshParts_get(void *c); //attribute: int btStridingMeshInterfaceData->m_numMeshParts
// attribute not supported: //attribute: char[4] btStridingMeshInterfaceData->m_padding
//not supported method: processTriangle void ( ::btTriangleCallback::* )( ::btVector3 *,int,int ) 
// error:  - unsupported, int - ok, int - ok, void - ok

void* btTriangleIndexVertexArray_new0(); //constructor: btTriangleIndexVertexArray  ( ::btTriangleIndexVertexArray::* )(  ) 
//not supported constructor: btTriangleIndexVertexArray  ( ::btTriangleIndexVertexArray::* )( int,int *,int,int,::btScalar *,int ) 
// error: int - ok,  - unsupported, int - ok, int - ok,  - unsupported, int - ok

void btTriangleIndexVertexArray_free(void *c); 
//not supported method: getLockedReadOnlyVertexIndexBase void ( ::btTriangleIndexVertexArray::* )( unsigned char const * *,int &,::PHY_ScalarType &,int &,unsigned char const * *,int &,int &,::PHY_ScalarType &,int ) const
// error:  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported, int - ok, void - ok

void btTriangleIndexVertexArray_preallocateIndices(void *c,int p0); //method: preallocateIndices void ( ::btTriangleIndexVertexArray::* )( int ) 
void btTriangleIndexVertexArray_preallocateVertices(void *c,int p0); //method: preallocateVertices void ( ::btTriangleIndexVertexArray::* )( int ) 
void* btTriangleIndexVertexArray_getIndexedMeshArray(void *c); //method: getIndexedMeshArray ::IndexedMeshArray & ( ::btTriangleIndexVertexArray::* )(  ) 
void* btTriangleIndexVertexArray_getIndexedMeshArray0(void *c); //method: getIndexedMeshArray ::IndexedMeshArray & ( ::btTriangleIndexVertexArray::* )(  ) 
void* btTriangleIndexVertexArray_getIndexedMeshArray1(void *c); //method: getIndexedMeshArray ::IndexedMeshArray const & ( ::btTriangleIndexVertexArray::* )(  ) const
void btTriangleIndexVertexArray_setPremadeAabb(void *c,float* p0,float* p1); //method: setPremadeAabb void ( ::btTriangleIndexVertexArray::* )( ::btVector3 const &,::btVector3 const & ) const
//not supported method: getPremadeAabb void ( ::btTriangleIndexVertexArray::* )( ::btVector3 *,::btVector3 * ) const
// error:  - unsupported,  - unsupported, void - ok

//not supported method: addIndexedMesh void ( ::btTriangleIndexVertexArray::* )( ::btIndexedMesh const &,::PHY_ScalarType ) 
// error: ::btIndexedMesh const & - ok,  - unsupported, void - ok

int btTriangleIndexVertexArray_getNumSubParts(void *c); //method: getNumSubParts int ( ::btTriangleIndexVertexArray::* )(  ) const
//not supported method: getLockedVertexIndexBase void ( ::btTriangleIndexVertexArray::* )( unsigned char * *,int &,::PHY_ScalarType &,int &,unsigned char * *,int &,int &,::PHY_ScalarType &,int ) 
// error:  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported,  - unsupported, int - ok, void - ok

int btTriangleIndexVertexArray_hasPremadeAabb(void *c); //method: hasPremadeAabb bool ( ::btTriangleIndexVertexArray::* )(  ) const
void btTriangleIndexVertexArray_unLockVertexBase(void *c,int p0); //method: unLockVertexBase void ( ::btTriangleIndexVertexArray::* )( int ) 
void btTriangleIndexVertexArray_unLockReadOnlyVertexBase(void *c,int p0); //method: unLockReadOnlyVertexBase void ( ::btTriangleIndexVertexArray::* )( int ) const
void btTriangleIndexVertexArray_m_indexedMeshes_set(void *c,void* a); //attribute: ::IndexedMeshArray btTriangleIndexVertexArray->m_indexedMeshes
void* btTriangleIndexVertexArray_m_indexedMeshes_get(void *c); //attribute: ::IndexedMeshArray btTriangleIndexVertexArray->m_indexedMeshes
// attribute not supported: //attribute: int[2] btTriangleIndexVertexArray->m_pad
void btTriangleIndexVertexArray_m_hasAabb_set(void *c,int a); //attribute: int btTriangleIndexVertexArray->m_hasAabb
int btTriangleIndexVertexArray_m_hasAabb_get(void *c); //attribute: int btTriangleIndexVertexArray->m_hasAabb
void btTriangleIndexVertexArray_m_aabbMin_set(void *c,float* a); //attribute: ::btVector3 btTriangleIndexVertexArray->m_aabbMin
void btTriangleIndexVertexArray_m_aabbMin_get(void *c,float* a);
void btTriangleIndexVertexArray_m_aabbMax_set(void *c,float* a); //attribute: ::btVector3 btTriangleIndexVertexArray->m_aabbMax
void btTriangleIndexVertexArray_m_aabbMax_get(void *c,float* a);
void* btTriangleInfo_new(); //constructor: btTriangleInfo  ( ::btTriangleInfo::* )(  ) 
void btTriangleInfo_free(void *c); 
void btTriangleInfo_m_edgeV0V1Angle_set(void *c,float a); //attribute: ::btScalar btTriangleInfo->m_edgeV0V1Angle
float btTriangleInfo_m_edgeV0V1Angle_get(void *c); //attribute: ::btScalar btTriangleInfo->m_edgeV0V1Angle
void btTriangleInfo_m_edgeV1V2Angle_set(void *c,float a); //attribute: ::btScalar btTriangleInfo->m_edgeV1V2Angle
float btTriangleInfo_m_edgeV1V2Angle_get(void *c); //attribute: ::btScalar btTriangleInfo->m_edgeV1V2Angle
void btTriangleInfo_m_edgeV2V0Angle_set(void *c,float a); //attribute: ::btScalar btTriangleInfo->m_edgeV2V0Angle
float btTriangleInfo_m_edgeV2V0Angle_get(void *c); //attribute: ::btScalar btTriangleInfo->m_edgeV2V0Angle
void btTriangleInfo_m_flags_set(void *c,int a); //attribute: int btTriangleInfo->m_flags
int btTriangleInfo_m_flags_get(void *c); //attribute: int btTriangleInfo->m_flags
void* btTriangleInfoData_new(); //constructor: btTriangleInfoData  ( ::btTriangleInfoData::* )(  ) 
void btTriangleInfoData_free(void *c); 
void btTriangleInfoData_m_flags_set(void *c,int a); //attribute: int btTriangleInfoData->m_flags
int btTriangleInfoData_m_flags_get(void *c); //attribute: int btTriangleInfoData->m_flags
void btTriangleInfoData_m_edgeV0V1Angle_set(void *c,float a); //attribute: float btTriangleInfoData->m_edgeV0V1Angle
float btTriangleInfoData_m_edgeV0V1Angle_get(void *c); //attribute: float btTriangleInfoData->m_edgeV0V1Angle
void btTriangleInfoData_m_edgeV1V2Angle_set(void *c,float a); //attribute: float btTriangleInfoData->m_edgeV1V2Angle
float btTriangleInfoData_m_edgeV1V2Angle_get(void *c); //attribute: float btTriangleInfoData->m_edgeV1V2Angle
void btTriangleInfoData_m_edgeV2V0Angle_set(void *c,float a); //attribute: float btTriangleInfoData->m_edgeV2V0Angle
float btTriangleInfoData_m_edgeV2V0Angle_get(void *c); //attribute: float btTriangleInfoData->m_edgeV2V0Angle
void* btTriangleInfoMap_new(); //constructor: btTriangleInfoMap  ( ::btTriangleInfoMap::* )(  ) 
void btTriangleInfoMap_free(void *c); 
char const * btTriangleInfoMap_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btTriangleInfoMap::* )( void *,::btSerializer * ) const
int btTriangleInfoMap_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btTriangleInfoMap::* )(  ) const
void btTriangleInfoMap_deSerialize(void *c,void* p0); //method: deSerialize void ( ::btTriangleInfoMap::* )( ::btTriangleInfoMapData & ) 
void btTriangleInfoMap_m_convexEpsilon_set(void *c,float a); //attribute: ::btScalar btTriangleInfoMap->m_convexEpsilon
float btTriangleInfoMap_m_convexEpsilon_get(void *c); //attribute: ::btScalar btTriangleInfoMap->m_convexEpsilon
void btTriangleInfoMap_m_edgeDistanceThreshold_set(void *c,float a); //attribute: ::btScalar btTriangleInfoMap->m_edgeDistanceThreshold
float btTriangleInfoMap_m_edgeDistanceThreshold_get(void *c); //attribute: ::btScalar btTriangleInfoMap->m_edgeDistanceThreshold
void btTriangleInfoMap_m_equalVertexThreshold_set(void *c,float a); //attribute: ::btScalar btTriangleInfoMap->m_equalVertexThreshold
float btTriangleInfoMap_m_equalVertexThreshold_get(void *c); //attribute: ::btScalar btTriangleInfoMap->m_equalVertexThreshold
void btTriangleInfoMap_m_maxEdgeAngleThreshold_set(void *c,float a); //attribute: ::btScalar btTriangleInfoMap->m_maxEdgeAngleThreshold
float btTriangleInfoMap_m_maxEdgeAngleThreshold_get(void *c); //attribute: ::btScalar btTriangleInfoMap->m_maxEdgeAngleThreshold
void btTriangleInfoMap_m_planarEpsilon_set(void *c,float a); //attribute: ::btScalar btTriangleInfoMap->m_planarEpsilon
float btTriangleInfoMap_m_planarEpsilon_get(void *c); //attribute: ::btScalar btTriangleInfoMap->m_planarEpsilon
void btTriangleInfoMap_m_zeroAreaThreshold_set(void *c,float a); //attribute: ::btScalar btTriangleInfoMap->m_zeroAreaThreshold
float btTriangleInfoMap_m_zeroAreaThreshold_get(void *c); //attribute: ::btScalar btTriangleInfoMap->m_zeroAreaThreshold
void* btTriangleInfoMapData_new(); //constructor: btTriangleInfoMapData  ( ::btTriangleInfoMapData::* )(  ) 
void btTriangleInfoMapData_free(void *c); 
void btTriangleInfoMapData_m_convexEpsilon_set(void *c,float a); //attribute: float btTriangleInfoMapData->m_convexEpsilon
float btTriangleInfoMapData_m_convexEpsilon_get(void *c); //attribute: float btTriangleInfoMapData->m_convexEpsilon
void btTriangleInfoMapData_m_edgeDistanceThreshold_set(void *c,float a); //attribute: float btTriangleInfoMapData->m_edgeDistanceThreshold
float btTriangleInfoMapData_m_edgeDistanceThreshold_get(void *c); //attribute: float btTriangleInfoMapData->m_edgeDistanceThreshold
void btTriangleInfoMapData_m_equalVertexThreshold_set(void *c,float a); //attribute: float btTriangleInfoMapData->m_equalVertexThreshold
float btTriangleInfoMapData_m_equalVertexThreshold_get(void *c); //attribute: float btTriangleInfoMapData->m_equalVertexThreshold
// attribute not supported: //attribute: int * btTriangleInfoMapData->m_hashTablePtr
void btTriangleInfoMapData_m_hashTableSize_set(void *c,int a); //attribute: int btTriangleInfoMapData->m_hashTableSize
int btTriangleInfoMapData_m_hashTableSize_get(void *c); //attribute: int btTriangleInfoMapData->m_hashTableSize
// attribute not supported: //attribute: int * btTriangleInfoMapData->m_keyArrayPtr
// attribute not supported: //attribute: int * btTriangleInfoMapData->m_nextPtr
void btTriangleInfoMapData_m_nextSize_set(void *c,int a); //attribute: int btTriangleInfoMapData->m_nextSize
int btTriangleInfoMapData_m_nextSize_get(void *c); //attribute: int btTriangleInfoMapData->m_nextSize
void btTriangleInfoMapData_m_numKeys_set(void *c,int a); //attribute: int btTriangleInfoMapData->m_numKeys
int btTriangleInfoMapData_m_numKeys_get(void *c); //attribute: int btTriangleInfoMapData->m_numKeys
void btTriangleInfoMapData_m_numValues_set(void *c,int a); //attribute: int btTriangleInfoMapData->m_numValues
int btTriangleInfoMapData_m_numValues_get(void *c); //attribute: int btTriangleInfoMapData->m_numValues
// attribute not supported: //attribute: char[4] btTriangleInfoMapData->m_padding
void btTriangleInfoMapData_m_planarEpsilon_set(void *c,float a); //attribute: float btTriangleInfoMapData->m_planarEpsilon
float btTriangleInfoMapData_m_planarEpsilon_get(void *c); //attribute: float btTriangleInfoMapData->m_planarEpsilon
void btTriangleInfoMapData_m_valueArrayPtr_set(void *c,void* a); //attribute: ::btTriangleInfoData * btTriangleInfoMapData->m_valueArrayPtr
void* btTriangleInfoMapData_m_valueArrayPtr_get(void *c); //attribute: ::btTriangleInfoData * btTriangleInfoMapData->m_valueArrayPtr
void btTriangleInfoMapData_m_zeroAreaThreshold_set(void *c,float a); //attribute: float btTriangleInfoMapData->m_zeroAreaThreshold
float btTriangleInfoMapData_m_zeroAreaThreshold_get(void *c); //attribute: float btTriangleInfoMapData->m_zeroAreaThreshold
void* btTriangleMesh_new(int p0,int p1); //constructor: btTriangleMesh  ( ::btTriangleMesh::* )( bool,bool ) 
void btTriangleMesh_free(void *c); 
void btTriangleMesh_preallocateIndices(void *c,int p0); //method: preallocateIndices void ( ::btTriangleMesh::* )( int ) 
int btTriangleMesh_getNumTriangles(void *c); //method: getNumTriangles int ( ::btTriangleMesh::* )(  ) const
int btTriangleMesh_getUse32bitIndices(void *c); //method: getUse32bitIndices bool ( ::btTriangleMesh::* )(  ) const
void btTriangleMesh_addIndex(void *c,int p0); //method: addIndex void ( ::btTriangleMesh::* )( int ) 
void btTriangleMesh_preallocateVertices(void *c,int p0); //method: preallocateVertices void ( ::btTriangleMesh::* )( int ) 
int btTriangleMesh_findOrAddVertex(void *c,float* p0,int p1); //method: findOrAddVertex int ( ::btTriangleMesh::* )( ::btVector3 const &,bool ) 
int btTriangleMesh_getUse4componentVertices(void *c); //method: getUse4componentVertices bool ( ::btTriangleMesh::* )(  ) const
void btTriangleMesh_addTriangle(void *c,float* p0,float* p1,float* p2,int p3); //method: addTriangle void ( ::btTriangleMesh::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,bool ) 
void btTriangleMesh_m_4componentVertices_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btVector3> btTriangleMesh->m_4componentVertices
void* btTriangleMesh_m_4componentVertices_get(void *c); //attribute: ::btAlignedObjectArray<btVector3> btTriangleMesh->m_4componentVertices
void btTriangleMesh_m_3componentVertices_set(void *c,void* a); //attribute: ::btAlignedObjectArray<float> btTriangleMesh->m_3componentVertices
void* btTriangleMesh_m_3componentVertices_get(void *c); //attribute: ::btAlignedObjectArray<float> btTriangleMesh->m_3componentVertices
void btTriangleMesh_m_32bitIndices_set(void *c,void* a); //attribute: ::btAlignedObjectArray<unsigned int> btTriangleMesh->m_32bitIndices
void* btTriangleMesh_m_32bitIndices_get(void *c); //attribute: ::btAlignedObjectArray<unsigned int> btTriangleMesh->m_32bitIndices
void btTriangleMesh_m_16bitIndices_set(void *c,void* a); //attribute: ::btAlignedObjectArray<unsigned short> btTriangleMesh->m_16bitIndices
void* btTriangleMesh_m_16bitIndices_get(void *c); //attribute: ::btAlignedObjectArray<unsigned short> btTriangleMesh->m_16bitIndices
void btTriangleMesh_m_use32bitIndices_set(void *c,int a); //attribute: bool btTriangleMesh->m_use32bitIndices
int btTriangleMesh_m_use32bitIndices_get(void *c); //attribute: bool btTriangleMesh->m_use32bitIndices
void btTriangleMesh_m_use4componentVertices_set(void *c,int a); //attribute: bool btTriangleMesh->m_use4componentVertices
int btTriangleMesh_m_use4componentVertices_get(void *c); //attribute: bool btTriangleMesh->m_use4componentVertices
void btTriangleMesh_m_weldingThreshold_set(void *c,float a); //attribute: ::btScalar btTriangleMesh->m_weldingThreshold
float btTriangleMesh_m_weldingThreshold_get(void *c); //attribute: ::btScalar btTriangleMesh->m_weldingThreshold
void* btTriangleMeshShape_new(void* p0); //constructor: btTriangleMeshShape  ( ::btTriangleMeshShape::* )( ::btStridingMeshInterface * ) 
void btTriangleMeshShape_free(void *c); 
void btTriangleMeshShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btTriangleMeshShape::* )( ::btScalar,::btVector3 & ) const
void btTriangleMeshShape_getLocalAabbMax(void *c,float* ret); //method: getLocalAabbMax ::btVector3 const & ( ::btTriangleMeshShape::* )(  ) const
void btTriangleMeshShape_localGetSupportingVertex(void *c,float* p0,float* ret); //method: localGetSupportingVertex ::btVector3 ( ::btTriangleMeshShape::* )( ::btVector3 const & ) const
char const * btTriangleMeshShape_getName(void *c); //method: getName char const * ( ::btTriangleMeshShape::* )(  ) const
void btTriangleMeshShape_getLocalScaling(void *c,float* ret); //method: getLocalScaling ::btVector3 const & ( ::btTriangleMeshShape::* )(  ) const
void btTriangleMeshShape_recalcLocalAabb(void *c); //method: recalcLocalAabb void ( ::btTriangleMeshShape::* )(  ) 
void btTriangleMeshShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btTriangleMeshShape::* )( ::btVector3 const & ) 
void* btTriangleMeshShape_getMeshInterface(void *c); //method: getMeshInterface ::btStridingMeshInterface * ( ::btTriangleMeshShape::* )(  ) 
void* btTriangleMeshShape_getMeshInterface0(void *c); //method: getMeshInterface ::btStridingMeshInterface * ( ::btTriangleMeshShape::* )(  ) 
void* btTriangleMeshShape_getMeshInterface1(void *c); //method: getMeshInterface ::btStridingMeshInterface const * ( ::btTriangleMeshShape::* )(  ) const
void btTriangleMeshShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btTriangleMeshShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btTriangleMeshShape_processAllTriangles(void *c,void* p0,float* p1,float* p2); //method: processAllTriangles void ( ::btTriangleMeshShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
void btTriangleMeshShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret); //method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btTriangleMeshShape::* )( ::btVector3 const & ) const
void btTriangleMeshShape_getLocalAabbMin(void *c,float* ret); //method: getLocalAabbMin ::btVector3 const & ( ::btTriangleMeshShape::* )(  ) const
void btTriangleMeshShape_m_localAabbMin_set(void *c,float* a); //attribute: ::btVector3 btTriangleMeshShape->m_localAabbMin
void btTriangleMeshShape_m_localAabbMin_get(void *c,float* a);
void btTriangleMeshShape_m_localAabbMax_set(void *c,float* a); //attribute: ::btVector3 btTriangleMeshShape->m_localAabbMax
void btTriangleMeshShape_m_localAabbMax_get(void *c,float* a);
void btTriangleMeshShape_m_meshInterface_set(void *c,void* a); //attribute: ::btStridingMeshInterface * btTriangleMeshShape->m_meshInterface
void* btTriangleMeshShape_m_meshInterface_get(void *c); //attribute: ::btStridingMeshInterface * btTriangleMeshShape->m_meshInterface
void* btTriangleMeshShapeData_new(); //constructor: btTriangleMeshShapeData  ( ::btTriangleMeshShapeData::* )(  ) 
void btTriangleMeshShapeData_free(void *c); 
void btTriangleMeshShapeData_m_collisionMargin_set(void *c,float a); //attribute: float btTriangleMeshShapeData->m_collisionMargin
float btTriangleMeshShapeData_m_collisionMargin_get(void *c); //attribute: float btTriangleMeshShapeData->m_collisionMargin
void btTriangleMeshShapeData_m_collisionShapeData_set(void *c,void* a); //attribute: ::btCollisionShapeData btTriangleMeshShapeData->m_collisionShapeData
void* btTriangleMeshShapeData_m_collisionShapeData_get(void *c); //attribute: ::btCollisionShapeData btTriangleMeshShapeData->m_collisionShapeData
void btTriangleMeshShapeData_m_meshInterface_set(void *c,void* a); //attribute: ::btStridingMeshInterfaceData btTriangleMeshShapeData->m_meshInterface
void* btTriangleMeshShapeData_m_meshInterface_get(void *c); //attribute: ::btStridingMeshInterfaceData btTriangleMeshShapeData->m_meshInterface
// attribute not supported: //attribute: char[4] btTriangleMeshShapeData->m_pad3
void btTriangleMeshShapeData_m_quantizedDoubleBvh_set(void *c,void* a); //attribute: ::btQuantizedBvhDoubleData * btTriangleMeshShapeData->m_quantizedDoubleBvh
void* btTriangleMeshShapeData_m_quantizedDoubleBvh_get(void *c); //attribute: ::btQuantizedBvhDoubleData * btTriangleMeshShapeData->m_quantizedDoubleBvh
void btTriangleMeshShapeData_m_quantizedFloatBvh_set(void *c,void* a); //attribute: ::btQuantizedBvhFloatData * btTriangleMeshShapeData->m_quantizedFloatBvh
void* btTriangleMeshShapeData_m_quantizedFloatBvh_get(void *c); //attribute: ::btQuantizedBvhFloatData * btTriangleMeshShapeData->m_quantizedFloatBvh
void btTriangleMeshShapeData_m_triangleInfoMap_set(void *c,void* a); //attribute: ::btTriangleInfoMapData * btTriangleMeshShapeData->m_triangleInfoMap
void* btTriangleMeshShapeData_m_triangleInfoMap_get(void *c); //attribute: ::btTriangleInfoMapData * btTriangleMeshShapeData->m_triangleInfoMap
void* btTriangleShape_new0(); //constructor: btTriangleShape  ( ::btTriangleShape::* )(  ) 
void* btTriangleShape_new1(float* p0,float* p1,float* p2); //constructor: btTriangleShape  ( ::btTriangleShape::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btTriangleShape_free(void *c); 
void btTriangleShape_getVertexPtr(void *c,int p0,float* ret); //method: getVertexPtr ::btVector3 & ( ::btTriangleShape::* )( int ) 
void btTriangleShape_getVertexPtr0(void *c,int p0,float* ret); //method: getVertexPtr ::btVector3 & ( ::btTriangleShape::* )( int ) 
void btTriangleShape_getVertexPtr1(void *c,int p0,float* ret); //method: getVertexPtr ::btVector3 const & ( ::btTriangleShape::* )( int ) const
int btTriangleShape_getNumPlanes(void *c); //method: getNumPlanes int ( ::btTriangleShape::* )(  ) const
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btTriangleShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

void btTriangleShape_getPreferredPenetrationDirection(void *c,int p0,float* p1); //method: getPreferredPenetrationDirection void ( ::btTriangleShape::* )( int,::btVector3 & ) const
int btTriangleShape_getNumEdges(void *c); //method: getNumEdges int ( ::btTriangleShape::* )(  ) const
char const * btTriangleShape_getName(void *c); //method: getName char const * ( ::btTriangleShape::* )(  ) const
int btTriangleShape_getNumVertices(void *c); //method: getNumVertices int ( ::btTriangleShape::* )(  ) const
void btTriangleShape_getEdge(void *c,int p0,float* p1,float* p2); //method: getEdge void ( ::btTriangleShape::* )( int,::btVector3 &,::btVector3 & ) const
int btTriangleShape_isInside(void *c,float* p0,float p1); //method: isInside bool ( ::btTriangleShape::* )( ::btVector3 const &,::btScalar ) const
void btTriangleShape_getPlane(void *c,float* p0,float* p1,int p2); //method: getPlane void ( ::btTriangleShape::* )( ::btVector3 &,::btVector3 &,int ) const
int btTriangleShape_getNumPreferredPenetrationDirections(void *c); //method: getNumPreferredPenetrationDirections int ( ::btTriangleShape::* )(  ) const
void btTriangleShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btTriangleShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btTriangleShape_getVertex(void *c,int p0,float* p1); //method: getVertex void ( ::btTriangleShape::* )( int,::btVector3 & ) const
void btTriangleShape_calcNormal(void *c,float* p0); //method: calcNormal void ( ::btTriangleShape::* )( ::btVector3 & ) const
void btTriangleShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btTriangleShape::* )( ::btScalar,::btVector3 & ) const
void btTriangleShape_getPlaneEquation(void *c,int p0,float* p1,float* p2); //method: getPlaneEquation void ( ::btTriangleShape::* )( int,::btVector3 &,::btVector3 & ) const
void btTriangleShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret); //method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btTriangleShape::* )( ::btVector3 const & ) const
// attribute not supported: //attribute: ::btVector3[3] btTriangleShape->m_vertices1
void* btUniformScalingShape_new(void* p0,float p1); //constructor: btUniformScalingShape  ( ::btUniformScalingShape::* )( ::btConvexShape *,::btScalar ) 
void btUniformScalingShape_free(void *c); 
void btUniformScalingShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btUniformScalingShape::* )( ::btScalar,::btVector3 & ) const
float btUniformScalingShape_getUniformScalingFactor(void *c); //method: getUniformScalingFactor ::btScalar ( ::btUniformScalingShape::* )(  ) const
void btUniformScalingShape_localGetSupportingVertex(void *c,float* p0,float* ret); //method: localGetSupportingVertex ::btVector3 ( ::btUniformScalingShape::* )( ::btVector3 const & ) const
//not supported method: batchedUnitVectorGetSupportingVertexWithoutMargin void ( ::btUniformScalingShape::* )( ::btVector3 const *,::btVector3 *,int ) const
// error:  - unsupported,  - unsupported, int - ok, void - ok

char const * btUniformScalingShape_getName(void *c); //method: getName char const * ( ::btUniformScalingShape::* )(  ) const
void btUniformScalingShape_getAabbSlow(void *c,float* p0,float* p1,float* p2); //method: getAabbSlow void ( ::btUniformScalingShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btUniformScalingShape_getLocalScaling(void *c,float* ret); //method: getLocalScaling ::btVector3 const & ( ::btUniformScalingShape::* )(  ) const
void* btUniformScalingShape_getChildShape(void *c); //method: getChildShape ::btConvexShape * ( ::btUniformScalingShape::* )(  ) 
void* btUniformScalingShape_getChildShape0(void *c); //method: getChildShape ::btConvexShape * ( ::btUniformScalingShape::* )(  ) 
void* btUniformScalingShape_getChildShape1(void *c); //method: getChildShape ::btConvexShape const * ( ::btUniformScalingShape::* )(  ) const
void btUniformScalingShape_getPreferredPenetrationDirection(void *c,int p0,float* p1); //method: getPreferredPenetrationDirection void ( ::btUniformScalingShape::* )( int,::btVector3 & ) const
void btUniformScalingShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btUniformScalingShape::* )( ::btVector3 const & ) 
int btUniformScalingShape_getNumPreferredPenetrationDirections(void *c); //method: getNumPreferredPenetrationDirections int ( ::btUniformScalingShape::* )(  ) const
void btUniformScalingShape_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btUniformScalingShape::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void btUniformScalingShape_setMargin(void *c,float p0); //method: setMargin void ( ::btUniformScalingShape::* )( ::btScalar ) 
float btUniformScalingShape_getMargin(void *c); //method: getMargin ::btScalar ( ::btUniformScalingShape::* )(  ) const
void btUniformScalingShape_localGetSupportingVertexWithoutMargin(void *c,float* p0,float* ret); //method: localGetSupportingVertexWithoutMargin ::btVector3 ( ::btUniformScalingShape::* )( ::btVector3 const & ) const
void btUniformScalingShape_m_childConvexShape_set(void *c,void* a); //attribute: ::btConvexShape * btUniformScalingShape->m_childConvexShape
void* btUniformScalingShape_m_childConvexShape_get(void *c); //attribute: ::btConvexShape * btUniformScalingShape->m_childConvexShape
void btUniformScalingShape_m_uniformScalingFactor_set(void *c,float a); //attribute: ::btScalar btUniformScalingShape->m_uniformScalingFactor
float btUniformScalingShape_m_uniformScalingFactor_get(void *c); //attribute: ::btScalar btUniformScalingShape->m_uniformScalingFactor
void* bT_BOX_BOX_TRANSFORM_CACHE_new(); //constructor: BT_BOX_BOX_TRANSFORM_CACHE  ( ::BT_BOX_BOX_TRANSFORM_CACHE::* )(  ) 
void bT_BOX_BOX_TRANSFORM_CACHE_free(void *c); 
void bT_BOX_BOX_TRANSFORM_CACHE_calc_from_full_invert(void *c,float* p0,float* p1); //method: calc_from_full_invert void ( ::BT_BOX_BOX_TRANSFORM_CACHE::* )( ::btTransform const &,::btTransform const & ) 
void bT_BOX_BOX_TRANSFORM_CACHE_calc_from_homogenic(void *c,float* p0,float* p1); //method: calc_from_homogenic void ( ::BT_BOX_BOX_TRANSFORM_CACHE::* )( ::btTransform const &,::btTransform const & ) 
void bT_BOX_BOX_TRANSFORM_CACHE_transform(void *c,float* p0,float* ret); //method: transform ::btVector3 ( ::BT_BOX_BOX_TRANSFORM_CACHE::* )( ::btVector3 const & ) const
void bT_BOX_BOX_TRANSFORM_CACHE_calc_absolute_matrix(void *c); //method: calc_absolute_matrix void ( ::BT_BOX_BOX_TRANSFORM_CACHE::* )(  ) 
void bT_BOX_BOX_TRANSFORM_CACHE_m_T1to0_set(void *c,float* a); //attribute: ::btVector3 bT_BOX_BOX_TRANSFORM_CACHE->m_T1to0
void bT_BOX_BOX_TRANSFORM_CACHE_m_T1to0_get(void *c,float* a);
void bT_BOX_BOX_TRANSFORM_CACHE_m_R1to0_set(void *c,float* a); //attribute: ::btMatrix3x3 bT_BOX_BOX_TRANSFORM_CACHE->m_R1to0
void bT_BOX_BOX_TRANSFORM_CACHE_m_R1to0_get(void *c,float* a);
void bT_BOX_BOX_TRANSFORM_CACHE_m_AR_set(void *c,float* a); //attribute: ::btMatrix3x3 bT_BOX_BOX_TRANSFORM_CACHE->m_AR
void bT_BOX_BOX_TRANSFORM_CACHE_m_AR_get(void *c,float* a);
void* bT_QUANTIZED_BVH_NODE_new(); //constructor: BT_QUANTIZED_BVH_NODE  ( ::BT_QUANTIZED_BVH_NODE::* )(  ) 
void bT_QUANTIZED_BVH_NODE_free(void *c); 
int bT_QUANTIZED_BVH_NODE_getEscapeIndex(void *c); //method: getEscapeIndex int ( ::BT_QUANTIZED_BVH_NODE::* )(  ) const
int bT_QUANTIZED_BVH_NODE_getDataIndex(void *c); //method: getDataIndex int ( ::BT_QUANTIZED_BVH_NODE::* )(  ) const
void bT_QUANTIZED_BVH_NODE_setEscapeIndex(void *c,int p0); //method: setEscapeIndex void ( ::BT_QUANTIZED_BVH_NODE::* )( int ) 
void bT_QUANTIZED_BVH_NODE_setDataIndex(void *c,int p0); //method: setDataIndex void ( ::BT_QUANTIZED_BVH_NODE::* )( int ) 
int bT_QUANTIZED_BVH_NODE_isLeafNode(void *c); //method: isLeafNode bool ( ::BT_QUANTIZED_BVH_NODE::* )(  ) const
//not supported method: testQuantizedBoxOverlapp bool ( ::BT_QUANTIZED_BVH_NODE::* )( short unsigned int *,short unsigned int * ) const
// error:  - unsupported,  - unsupported, bool - ok

void bT_QUANTIZED_BVH_NODE_m_escapeIndexOrDataIndex_set(void *c,int a); //attribute: int bT_QUANTIZED_BVH_NODE->m_escapeIndexOrDataIndex
int bT_QUANTIZED_BVH_NODE_m_escapeIndexOrDataIndex_get(void *c); //attribute: int bT_QUANTIZED_BVH_NODE->m_escapeIndexOrDataIndex
// attribute not supported: //attribute: short unsigned int[3] bT_QUANTIZED_BVH_NODE->m_quantizedAabbMax
// attribute not supported: //attribute: short unsigned int[3] bT_QUANTIZED_BVH_NODE->m_quantizedAabbMin
void* btGImpactCompoundShape_CompoundPrimitiveManager_new0(void* p0); //constructor: CompoundPrimitiveManager  ( ::btGImpactCompoundShape::CompoundPrimitiveManager::* )( ::btGImpactCompoundShape * ) 
void* btGImpactCompoundShape_CompoundPrimitiveManager_new1(); //constructor: CompoundPrimitiveManager  ( ::btGImpactCompoundShape::CompoundPrimitiveManager::* )(  ) 
void btGImpactCompoundShape_CompoundPrimitiveManager_free(void *c); 
int btGImpactCompoundShape_CompoundPrimitiveManager_get_primitive_count(void *c); //method: get_primitive_count int ( ::btGImpactCompoundShape::CompoundPrimitiveManager::* )(  ) const
void btGImpactCompoundShape_CompoundPrimitiveManager_get_primitive_triangle(void *c,int p0,void* p1); //method: get_primitive_triangle void ( ::btGImpactCompoundShape::CompoundPrimitiveManager::* )( int,::btPrimitiveTriangle & ) const
void btGImpactCompoundShape_CompoundPrimitiveManager_get_primitive_box(void *c,int p0,void* p1); //method: get_primitive_box void ( ::btGImpactCompoundShape::CompoundPrimitiveManager::* )( int,::btAABB & ) const
int btGImpactCompoundShape_CompoundPrimitiveManager_is_trimesh(void *c); //method: is_trimesh bool ( ::btGImpactCompoundShape::CompoundPrimitiveManager::* )(  ) const
void btGImpactCompoundShape_CompoundPrimitiveManager_m_compoundShape_set(void *c,void* a); //attribute: ::btGImpactCompoundShape * btGImpactCompoundShape_CompoundPrimitiveManager->m_compoundShape
void* btGImpactCompoundShape_CompoundPrimitiveManager_m_compoundShape_get(void *c); //attribute: ::btGImpactCompoundShape * btGImpactCompoundShape_CompoundPrimitiveManager->m_compoundShape
void* btGImpactCollisionAlgorithm_CreateFunc_new(); //constructor: CreateFunc  ( ::btGImpactCollisionAlgorithm::CreateFunc::* )(  ) 
void btGImpactCollisionAlgorithm_CreateFunc_free(void *c); 
void* btGImpactCollisionAlgorithm_CreateFunc_CreateCollisionAlgorithm(void *c,void* p0,void* p1,void* p2); //method: CreateCollisionAlgorithm ::btCollisionAlgorithm * ( ::btGImpactCollisionAlgorithm::CreateFunc::* )( ::btCollisionAlgorithmConstructionInfo &,::btCollisionObject *,::btCollisionObject * ) 
void* gIM_BVH_DATA_new(); //constructor: GIM_BVH_DATA  ( ::GIM_BVH_DATA::* )(  ) 
void gIM_BVH_DATA_free(void *c); 
void gIM_BVH_DATA_m_bound_set(void *c,void* a); //attribute: ::btAABB gIM_BVH_DATA->m_bound
void* gIM_BVH_DATA_m_bound_get(void *c); //attribute: ::btAABB gIM_BVH_DATA->m_bound
void gIM_BVH_DATA_m_data_set(void *c,int a); //attribute: int gIM_BVH_DATA->m_data
int gIM_BVH_DATA_m_data_get(void *c); //attribute: int gIM_BVH_DATA->m_data
void* gIM_BVH_DATA_ARRAY_new(); //constructor: GIM_BVH_DATA_ARRAY  ( ::GIM_BVH_DATA_ARRAY::* )(  ) 
void gIM_BVH_DATA_ARRAY_free(void *c); 
void* gIM_BVH_TREE_NODE_new(); //constructor: GIM_BVH_TREE_NODE  ( ::GIM_BVH_TREE_NODE::* )(  ) 
void gIM_BVH_TREE_NODE_free(void *c); 
void gIM_BVH_TREE_NODE_setDataIndex(void *c,int p0); //method: setDataIndex void ( ::GIM_BVH_TREE_NODE::* )( int ) 
int gIM_BVH_TREE_NODE_getEscapeIndex(void *c); //method: getEscapeIndex int ( ::GIM_BVH_TREE_NODE::* )(  ) const
int gIM_BVH_TREE_NODE_getDataIndex(void *c); //method: getDataIndex int ( ::GIM_BVH_TREE_NODE::* )(  ) const
void gIM_BVH_TREE_NODE_setEscapeIndex(void *c,int p0); //method: setEscapeIndex void ( ::GIM_BVH_TREE_NODE::* )( int ) 
int gIM_BVH_TREE_NODE_isLeafNode(void *c); //method: isLeafNode bool ( ::GIM_BVH_TREE_NODE::* )(  ) const
void gIM_BVH_TREE_NODE_m_bound_set(void *c,void* a); //attribute: ::btAABB gIM_BVH_TREE_NODE->m_bound
void* gIM_BVH_TREE_NODE_m_bound_get(void *c); //attribute: ::btAABB gIM_BVH_TREE_NODE->m_bound
void gIM_BVH_TREE_NODE_m_escapeIndexOrDataIndex_set(void *c,int a); //attribute: int gIM_BVH_TREE_NODE->m_escapeIndexOrDataIndex
int gIM_BVH_TREE_NODE_m_escapeIndexOrDataIndex_get(void *c); //attribute: int gIM_BVH_TREE_NODE->m_escapeIndexOrDataIndex
void* gIM_BVH_TREE_NODE_ARRAY_new(); //constructor: GIM_BVH_TREE_NODE_ARRAY  ( ::GIM_BVH_TREE_NODE_ARRAY::* )(  ) 
void gIM_BVH_TREE_NODE_ARRAY_free(void *c); 
void* gIM_PAIR_new0(); //constructor: GIM_PAIR  ( ::GIM_PAIR::* )(  ) 
void* gIM_PAIR_new1(int p0,int p1); //constructor: GIM_PAIR  ( ::GIM_PAIR::* )( int,int ) 
void gIM_PAIR_free(void *c); 
void gIM_PAIR_m_index1_set(void *c,int a); //attribute: int gIM_PAIR->m_index1
int gIM_PAIR_m_index1_get(void *c); //attribute: int gIM_PAIR->m_index1
void gIM_PAIR_m_index2_set(void *c,int a); //attribute: int gIM_PAIR->m_index2
int gIM_PAIR_m_index2_get(void *c); //attribute: int gIM_PAIR->m_index2
void* gIM_QUANTIZED_BVH_NODE_ARRAY_new(); //constructor: GIM_QUANTIZED_BVH_NODE_ARRAY  ( ::GIM_QUANTIZED_BVH_NODE_ARRAY::* )(  ) 
void gIM_QUANTIZED_BVH_NODE_ARRAY_free(void *c); 
void* gIM_TRIANGLE_CONTACT_new(); //constructor: GIM_TRIANGLE_CONTACT  ( ::GIM_TRIANGLE_CONTACT::* )(  ) 
void gIM_TRIANGLE_CONTACT_free(void *c); 
//not supported method: merge_points void ( ::GIM_TRIANGLE_CONTACT::* )( ::btVector4 const &,::btScalar,::btVector3 const *,int ) 
// error: ::btVector4 const & - ok, ::btScalar - ok,  - unsupported, int - ok, void - ok

void gIM_TRIANGLE_CONTACT_copy_from(void *c,void* p0); //method: copy_from void ( ::GIM_TRIANGLE_CONTACT::* )( ::GIM_TRIANGLE_CONTACT const & ) 
void gIM_TRIANGLE_CONTACT_m_penetration_depth_set(void *c,float a); //attribute: ::btScalar gIM_TRIANGLE_CONTACT->m_penetration_depth
float gIM_TRIANGLE_CONTACT_m_penetration_depth_get(void *c); //attribute: ::btScalar gIM_TRIANGLE_CONTACT->m_penetration_depth
void gIM_TRIANGLE_CONTACT_m_point_count_set(void *c,int a); //attribute: int gIM_TRIANGLE_CONTACT->m_point_count
int gIM_TRIANGLE_CONTACT_m_point_count_get(void *c); //attribute: int gIM_TRIANGLE_CONTACT->m_point_count
// attribute not supported: //attribute: ::btVector3[16] gIM_TRIANGLE_CONTACT->m_points
void gIM_TRIANGLE_CONTACT_m_separating_normal_set(void *c,float* a); //attribute: ::btVector4 gIM_TRIANGLE_CONTACT->m_separating_normal
void gIM_TRIANGLE_CONTACT_m_separating_normal_get(void *c,float* a);
void* btGImpactMeshShapePart_TrimeshPrimitiveManager_new0(); //constructor: TrimeshPrimitiveManager  ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )(  ) 
void* btGImpactMeshShapePart_TrimeshPrimitiveManager_new1(void* p0,int p1); //constructor: TrimeshPrimitiveManager  ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )( ::btStridingMeshInterface *,int ) 
void btGImpactMeshShapePart_TrimeshPrimitiveManager_free(void *c); 
int btGImpactMeshShapePart_TrimeshPrimitiveManager_get_vertex_count(void *c); //method: get_vertex_count int ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )(  ) const
void btGImpactMeshShapePart_TrimeshPrimitiveManager_get_vertex(void *c,int p0,float* p1); //method: get_vertex void ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )( int,::btVector3 & ) const
int btGImpactMeshShapePart_TrimeshPrimitiveManager_is_trimesh(void *c); //method: is_trimesh bool ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )(  ) const
void btGImpactMeshShapePart_TrimeshPrimitiveManager_lock(void *c); //method: lock void ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )(  ) 
void btGImpactMeshShapePart_TrimeshPrimitiveManager_get_primitive_box(void *c,int p0,void* p1); //method: get_primitive_box void ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )( int,::btAABB & ) const
void btGImpactMeshShapePart_TrimeshPrimitiveManager_get_primitive_triangle(void *c,int p0,void* p1); //method: get_primitive_triangle void ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )( int,::btPrimitiveTriangle & ) const
void btGImpactMeshShapePart_TrimeshPrimitiveManager_unlock(void *c); //method: unlock void ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )(  ) 
void btGImpactMeshShapePart_TrimeshPrimitiveManager_get_bullet_triangle(void *c,int p0,void* p1); //method: get_bullet_triangle void ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )( int,::btTriangleShapeEx & ) const
int btGImpactMeshShapePart_TrimeshPrimitiveManager_get_primitive_count(void *c); //method: get_primitive_count int ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )(  ) const
//not supported method: get_indices void ( ::btGImpactMeshShapePart::TrimeshPrimitiveManager::* )( int,int &,int &,int & ) const
// error: int - ok,  - unsupported,  - unsupported,  - unsupported, void - ok

void btGImpactMeshShapePart_TrimeshPrimitiveManager_m_margin_set(void *c,float a); //attribute: ::btScalar btGImpactMeshShapePart_TrimeshPrimitiveManager->m_margin
float btGImpactMeshShapePart_TrimeshPrimitiveManager_m_margin_get(void *c); //attribute: ::btScalar btGImpactMeshShapePart_TrimeshPrimitiveManager->m_margin
void btGImpactMeshShapePart_TrimeshPrimitiveManager_m_meshInterface_set(void *c,void* a); //attribute: ::btStridingMeshInterface * btGImpactMeshShapePart_TrimeshPrimitiveManager->m_meshInterface
void* btGImpactMeshShapePart_TrimeshPrimitiveManager_m_meshInterface_get(void *c); //attribute: ::btStridingMeshInterface * btGImpactMeshShapePart_TrimeshPrimitiveManager->m_meshInterface
void btGImpactMeshShapePart_TrimeshPrimitiveManager_m_scale_set(void *c,float* a); //attribute: ::btVector3 btGImpactMeshShapePart_TrimeshPrimitiveManager->m_scale
void btGImpactMeshShapePart_TrimeshPrimitiveManager_m_scale_get(void *c,float* a);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_m_part_set(void *c,int a); //attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->m_part
int btGImpactMeshShapePart_TrimeshPrimitiveManager_m_part_get(void *c); //attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->m_part
void btGImpactMeshShapePart_TrimeshPrimitiveManager_m_lock_count_set(void *c,int a); //attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->m_lock_count
int btGImpactMeshShapePart_TrimeshPrimitiveManager_m_lock_count_get(void *c); //attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->m_lock_count
// attribute not supported: //attribute: unsigned char const * btGImpactMeshShapePart_TrimeshPrimitiveManager->vertexbase
void btGImpactMeshShapePart_TrimeshPrimitiveManager_numverts_set(void *c,int a); //attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->numverts
int btGImpactMeshShapePart_TrimeshPrimitiveManager_numverts_get(void *c); //attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->numverts
// attribute not supported: //attribute: ::PHY_ScalarType btGImpactMeshShapePart_TrimeshPrimitiveManager->type
void btGImpactMeshShapePart_TrimeshPrimitiveManager_stride_set(void *c,int a); //attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->stride
int btGImpactMeshShapePart_TrimeshPrimitiveManager_stride_get(void *c); //attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->stride
// attribute not supported: //attribute: unsigned char const * btGImpactMeshShapePart_TrimeshPrimitiveManager->indexbase
void btGImpactMeshShapePart_TrimeshPrimitiveManager_indexstride_set(void *c,int a); //attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->indexstride
int btGImpactMeshShapePart_TrimeshPrimitiveManager_indexstride_get(void *c); //attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->indexstride
void btGImpactMeshShapePart_TrimeshPrimitiveManager_numfaces_set(void *c,int a); //attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->numfaces
int btGImpactMeshShapePart_TrimeshPrimitiveManager_numfaces_get(void *c); //attribute: int btGImpactMeshShapePart_TrimeshPrimitiveManager->numfaces
// attribute not supported: //attribute: ::PHY_ScalarType btGImpactMeshShapePart_TrimeshPrimitiveManager->indicestype
void* btAABB_new0(); //constructor: btAABB  ( ::btAABB::* )(  ) 
void* btAABB_new1(float* p0,float* p1,float* p2); //constructor: btAABB  ( ::btAABB::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void* btAABB_new2(float* p0,float* p1,float* p2,float p3); //constructor: btAABB  ( ::btAABB::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
void* btAABB_new3(void* p0,float p1); //constructor: btAABB  ( ::btAABB::* )( ::btAABB const &,::btScalar ) 
void btAABB_free(void *c); 
int btAABB_overlapping_trans_conservative(void *c,void* p0,float* p1); //method: overlapping_trans_conservative bool ( ::btAABB::* )( ::btAABB const &,::btTransform & ) const
void btAABB_appy_transform(void *c,float* p0); //method: appy_transform void ( ::btAABB::* )( ::btTransform const & ) 
void btAABB_find_intersection(void *c,void* p0,void* p1); //method: find_intersection void ( ::btAABB::* )( ::btAABB const &,::btAABB & ) const
int btAABB_collide_ray(void *c,float* p0,float* p1); //method: collide_ray bool ( ::btAABB::* )( ::btVector3 const &,::btVector3 const & ) const
int btAABB_overlapping_trans_cache(void *c,void* p0,void* p1,int p2); //method: overlapping_trans_cache bool ( ::btAABB::* )( ::btAABB const &,::BT_BOX_BOX_TRANSFORM_CACHE const &,bool ) const
void btAABB_get_center_extend(void *c,float* p0,float* p1); //method: get_center_extend void ( ::btAABB::* )( ::btVector3 &,::btVector3 & ) const
void btAABB_invalidate(void *c); //method: invalidate void ( ::btAABB::* )(  ) 
int btAABB_has_collision(void *c,void* p0); //method: has_collision bool ( ::btAABB::* )( ::btAABB const & ) const
//not supported method: projection_interval void ( ::btAABB::* )( ::btVector3 const &,::btScalar &,::btScalar & ) const
// error: ::btVector3 const & - ok,  - unsupported,  - unsupported, void - ok

void btAABB_appy_transform_trans_cache(void *c,void* p0); //method: appy_transform_trans_cache void ( ::btAABB::* )( ::BT_BOX_BOX_TRANSFORM_CACHE const & ) 
void btAABB_calc_from_triangle_margin(void *c,float* p0,float* p1,float* p2,float p3); //method: calc_from_triangle_margin void ( ::btAABB::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
void btAABB_increment_margin(void *c,float p0); //method: increment_margin void ( ::btAABB::* )( ::btScalar ) 
void btAABB_merge(void *c,void* p0); //method: merge void ( ::btAABB::* )( ::btAABB const & ) 
int btAABB_collide_plane(void *c,float* p0); //method: collide_plane bool ( ::btAABB::* )( ::btVector4 const & ) const
//not supported method: plane_classify ::eBT_PLANE_INTERSECTION_TYPE ( ::btAABB::* )( ::btVector4 const & ) const
// error: ::btVector4 const & - ok,  - unsupported

int btAABB_overlapping_trans_conservative2(void *c,void* p0,void* p1); //method: overlapping_trans_conservative2 bool ( ::btAABB::* )( ::btAABB const &,::BT_BOX_BOX_TRANSFORM_CACHE const & ) const
void btAABB_copy_with_margin(void *c,void* p0,float p1); //method: copy_with_margin void ( ::btAABB::* )( ::btAABB const &,::btScalar ) 
int btAABB_collide_triangle_exact(void *c,float* p0,float* p1,float* p2,float* p3); //method: collide_triangle_exact bool ( ::btAABB::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector4 const & ) const
void btAABB_m_max_set(void *c,float* a); //attribute: ::btVector3 btAABB->m_max
void btAABB_m_max_get(void *c,float* a);
void btAABB_m_min_set(void *c,float* a); //attribute: ::btVector3 btAABB->m_min
void btAABB_m_min_get(void *c,float* a);
void* btBvhTree_new(); //constructor: btBvhTree  ( ::btBvhTree::* )(  ) 
void btBvhTree_free(void *c); 
int btBvhTree_getNodeCount(void *c); //method: getNodeCount int ( ::btBvhTree::* )(  ) const
void btBvhTree_build_tree(void *c,void* p0); //method: build_tree void ( ::btBvhTree::* )( ::GIM_BVH_DATA_ARRAY & ) 
void btBvhTree_setNodeBound(void *c,int p0,void* p1); //method: setNodeBound void ( ::btBvhTree::* )( int,::btAABB const & ) 
int btBvhTree_getLeftNode(void *c,int p0); //method: getLeftNode int ( ::btBvhTree::* )( int ) const
void btBvhTree__build_sub_tree(void *c,void* p0,int p1,int p2); //method: _build_sub_tree void ( ::btBvhTree::* )( ::GIM_BVH_DATA_ARRAY &,int,int ) 
void btBvhTree_clearNodes(void *c); //method: clearNodes void ( ::btBvhTree::* )(  ) 
int btBvhTree__sort_and_calc_splitting_index(void *c,void* p0,int p1,int p2,int p3); //method: _sort_and_calc_splitting_index int ( ::btBvhTree::* )( ::GIM_BVH_DATA_ARRAY &,int,int,int ) 
int btBvhTree_getEscapeNodeIndex(void *c,int p0); //method: getEscapeNodeIndex int ( ::btBvhTree::* )( int ) const
int btBvhTree_isLeafNode(void *c,int p0); //method: isLeafNode bool ( ::btBvhTree::* )( int ) const
void* btBvhTree_get_node_pointer(void *c,int p0); //method: get_node_pointer ::GIM_BVH_TREE_NODE const * ( ::btBvhTree::* )( int ) const
int btBvhTree_getNodeData(void *c,int p0); //method: getNodeData int ( ::btBvhTree::* )( int ) const
void btBvhTree_getNodeBound(void *c,int p0,void* p1); //method: getNodeBound void ( ::btBvhTree::* )( int,::btAABB & ) const
int btBvhTree_getRightNode(void *c,int p0); //method: getRightNode int ( ::btBvhTree::* )( int ) const
int btBvhTree__calc_splitting_axis(void *c,void* p0,int p1,int p2); //method: _calc_splitting_axis int ( ::btBvhTree::* )( ::GIM_BVH_DATA_ARRAY &,int,int ) 
void btBvhTree_m_num_nodes_set(void *c,int a); //attribute: int btBvhTree->m_num_nodes
int btBvhTree_m_num_nodes_get(void *c); //attribute: int btBvhTree->m_num_nodes
void btBvhTree_m_node_array_set(void *c,void* a); //attribute: ::GIM_BVH_TREE_NODE_ARRAY btBvhTree->m_node_array
void* btBvhTree_m_node_array_get(void *c); //attribute: ::GIM_BVH_TREE_NODE_ARRAY btBvhTree->m_node_array
void* btGImpactBvh_new0(); //constructor: btGImpactBvh  ( ::btGImpactBvh::* )(  ) 
void* btGImpactBvh_new1(void* p0); //constructor: btGImpactBvh  ( ::btGImpactBvh::* )( ::btPrimitiveManagerBase * ) 
void btGImpactBvh_free(void *c); 
void btGImpactBvh_setNodeBound(void *c,int p0,void* p1); //method: setNodeBound void ( ::btGImpactBvh::* )( int,::btAABB const & ) 
int btGImpactBvh_getEscapeNodeIndex(void *c,int p0); //method: getEscapeNodeIndex int ( ::btGImpactBvh::* )( int ) const
int btGImpactBvh_isLeafNode(void *c,int p0); //method: isLeafNode bool ( ::btGImpactBvh::* )( int ) const
void* btGImpactBvh_getPrimitiveManager(void *c); //method: getPrimitiveManager ::btPrimitiveManagerBase * ( ::btGImpactBvh::* )(  ) const
void btGImpactBvh_getNodeBound(void *c,int p0,void* p1); //method: getNodeBound void ( ::btGImpactBvh::* )( int,::btAABB & ) const
int btGImpactBvh_getRightNode(void *c,int p0); //method: getRightNode int ( ::btGImpactBvh::* )( int ) const
int btGImpactBvh_getLeftNode(void *c,int p0); //method: getLeftNode int ( ::btGImpactBvh::* )( int ) const
void btGImpactBvh_setPrimitiveManager(void *c,void* p0); //method: setPrimitiveManager void ( ::btGImpactBvh::* )( ::btPrimitiveManagerBase * ) 
void btGImpactBvh_buildSet(void *c); //method: buildSet void ( ::btGImpactBvh::* )(  ) 
void btGImpactBvh_getNodeTriangle(void *c,int p0,void* p1); //method: getNodeTriangle void ( ::btGImpactBvh::* )( int,::btPrimitiveTriangle & ) const
int btGImpactBvh_getNodeCount(void *c); //method: getNodeCount int ( ::btGImpactBvh::* )(  ) const
int btGImpactBvh_hasHierarchy(void *c); //method: hasHierarchy bool ( ::btGImpactBvh::* )(  ) const
int btGImpactBvh_rayQuery(void *c,float* p0,float* p1,void* p2); //method: rayQuery bool ( ::btGImpactBvh::* )( ::btVector3 const &,::btVector3 const &,::btAlignedObjectArray<int> & ) const
void btGImpactBvh_update(void *c); //method: update void ( ::btGImpactBvh::* )(  ) 
void btGImpactBvh_refit(void *c); //method: refit void ( ::btGImpactBvh::* )(  ) 
int btGImpactBvh_isTrimesh(void *c); //method: isTrimesh bool ( ::btGImpactBvh::* )(  ) const
int btGImpactBvh_boxQuery(void *c,void* p0,void* p1); //method: boxQuery bool ( ::btGImpactBvh::* )( ::btAABB const &,::btAlignedObjectArray<int> & ) const
void btGImpactBvh_find_collision(void* p0,float* p1,void* p2,float* p3,void* p4); //method: find_collision void (*)( ::btGImpactBvh *,::btTransform const &,::btGImpactBvh *,::btTransform const &,::btPairSet & )
void* btGImpactBvh_get_node_pointer(void *c,int p0); //method: get_node_pointer ::GIM_BVH_TREE_NODE const * ( ::btGImpactBvh::* )( int ) const
int btGImpactBvh_boxQueryTrans(void *c,void* p0,float* p1,void* p2); //method: boxQueryTrans bool ( ::btGImpactBvh::* )( ::btAABB const &,::btTransform const &,::btAlignedObjectArray<int> & ) const
//not supported method: getGlobalBox ::btAABB ( ::btGImpactBvh::* )(  ) const
// error:  - unsupported

int btGImpactBvh_getNodeData(void *c,int p0); //method: getNodeData int ( ::btGImpactBvh::* )( int ) const
void btGImpactBvh_m_box_tree_set(void *c,void* a); //attribute: ::btBvhTree btGImpactBvh->m_box_tree
void* btGImpactBvh_m_box_tree_get(void *c); //attribute: ::btBvhTree btGImpactBvh->m_box_tree
void btGImpactBvh_m_primitive_manager_set(void *c,void* a); //attribute: ::btPrimitiveManagerBase * btGImpactBvh->m_primitive_manager
void* btGImpactBvh_m_primitive_manager_get(void *c); //attribute: ::btPrimitiveManagerBase * btGImpactBvh->m_primitive_manager
void* btGImpactCollisionAlgorithm_new(void* p0,void* p1,void* p2); //constructor: btGImpactCollisionAlgorithm  ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionAlgorithmConstructionInfo const &,::btCollisionObject *,::btCollisionObject * ) 
void btGImpactCollisionAlgorithm_free(void *c); 
int btGImpactCollisionAlgorithm_getFace1(void *c); //method: getFace1 int ( ::btGImpactCollisionAlgorithm::* )(  ) 
int btGImpactCollisionAlgorithm_getFace0(void *c); //method: getFace0 int ( ::btGImpactCollisionAlgorithm::* )(  ) 
void btGImpactCollisionAlgorithm_gimpact_vs_compoundshape(void *c,void* p0,void* p1,void* p2,void* p3,int p4); //method: gimpact_vs_compoundshape void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btGImpactShapeInterface *,::btCompoundShape *,bool ) 
void btGImpactCollisionAlgorithm_gimpact_vs_shape(void *c,void* p0,void* p1,void* p2,void* p3,int p4); //method: gimpact_vs_shape void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btGImpactShapeInterface *,::btCollisionShape *,bool ) 
void btGImpactCollisionAlgorithm_convex_vs_convex_collision(void *c,void* p0,void* p1,void* p2,void* p3); //method: convex_vs_convex_collision void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btCollisionShape *,::btCollisionShape * ) 
void btGImpactCollisionAlgorithm_setFace0(void *c,int p0); //method: setFace0 void ( ::btGImpactCollisionAlgorithm::* )( int ) 
void btGImpactCollisionAlgorithm_setFace1(void *c,int p0); //method: setFace1 void ( ::btGImpactCollisionAlgorithm::* )( int ) 
void btGImpactCollisionAlgorithm_checkManifold(void *c,void* p0,void* p1); //method: checkManifold void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject * ) 
//not supported method: collide_gjk_triangles void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btGImpactMeshShapePart *,::btGImpactMeshShapePart *,int const *,int ) 
// error: ::btCollisionObject * - ok, ::btCollisionObject * - ok, ::btGImpactMeshShapePart * - ok, ::btGImpactMeshShapePart * - ok,  - unsupported, int - ok, void - ok

void* btGImpactCollisionAlgorithm_newContactManifold(void *c,void* p0,void* p1); //method: newContactManifold ::btPersistentManifold * ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject * ) 
void btGImpactCollisionAlgorithm_addContactPoint(void *c,void* p0,void* p1,float* p2,float* p3,float p4); //method: addContactPoint void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btVector3 const &,::btVector3 const &,::btScalar ) 
void btGImpactCollisionAlgorithm_gimpacttrimeshpart_vs_plane_collision(void *c,void* p0,void* p1,void* p2,void* p3,int p4); //method: gimpacttrimeshpart_vs_plane_collision void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btGImpactMeshShapePart *,::btStaticPlaneShape *,bool ) 
void btGImpactCollisionAlgorithm_registerAlgorithm(void* p0); //method: registerAlgorithm void (*)( ::btCollisionDispatcher * )
void btGImpactCollisionAlgorithm_processCollision(void *c,void* p0,void* p1,void* p2,void* p3); //method: processCollision void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
void btGImpactCollisionAlgorithm_destroyContactManifolds(void *c); //method: destroyContactManifolds void ( ::btGImpactCollisionAlgorithm::* )(  ) 
//not supported method: collide_sat_triangles void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btGImpactMeshShapePart *,::btGImpactMeshShapePart *,int const *,int ) 
// error: ::btCollisionObject * - ok, ::btCollisionObject * - ok, ::btGImpactMeshShapePart * - ok, ::btGImpactMeshShapePart * - ok,  - unsupported, int - ok, void - ok

void btGImpactCollisionAlgorithm_gimpact_vs_gimpact_find_pairs(void *c,float* p0,float* p1,void* p2,void* p3,void* p4); //method: gimpact_vs_gimpact_find_pairs void ( ::btGImpactCollisionAlgorithm::* )( ::btTransform const &,::btTransform const &,::btGImpactShapeInterface *,::btGImpactShapeInterface *,::btPairSet & ) 
void* btGImpactCollisionAlgorithm_getLastManifold(void *c); //method: getLastManifold ::btPersistentManifold * ( ::btGImpactCollisionAlgorithm::* )(  ) 
void btGImpactCollisionAlgorithm_gimpact_vs_shape_find_pairs(void *c,float* p0,float* p1,void* p2,void* p3,void* p4); //method: gimpact_vs_shape_find_pairs void ( ::btGImpactCollisionAlgorithm::* )( ::btTransform const &,::btTransform const &,::btGImpactShapeInterface *,::btCollisionShape *,::btAlignedObjectArray<int> & ) 
void btGImpactCollisionAlgorithm_destroyConvexAlgorithm(void *c); //method: destroyConvexAlgorithm void ( ::btGImpactCollisionAlgorithm::* )(  ) 
void btGImpactCollisionAlgorithm_checkConvexAlgorithm(void *c,void* p0,void* p1); //method: checkConvexAlgorithm void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject * ) 
void* btGImpactCollisionAlgorithm_newAlgorithm(void *c,void* p0,void* p1); //method: newAlgorithm ::btCollisionAlgorithm * ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject * ) 
void btGImpactCollisionAlgorithm_shape_vs_shape_collision(void *c,void* p0,void* p1,void* p2,void* p3); //method: shape_vs_shape_collision void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btCollisionShape *,::btCollisionShape * ) 
void btGImpactCollisionAlgorithm_setPart1(void *c,int p0); //method: setPart1 void ( ::btGImpactCollisionAlgorithm::* )( int ) 
void btGImpactCollisionAlgorithm_setPart0(void *c,int p0); //method: setPart0 void ( ::btGImpactCollisionAlgorithm::* )( int ) 
void btGImpactCollisionAlgorithm_clearCache(void *c); //method: clearCache void ( ::btGImpactCollisionAlgorithm::* )(  ) 
int btGImpactCollisionAlgorithm_getPart1(void *c); //method: getPart1 int ( ::btGImpactCollisionAlgorithm::* )(  ) 
int btGImpactCollisionAlgorithm_getPart0(void *c); //method: getPart0 int ( ::btGImpactCollisionAlgorithm::* )(  ) 
void btGImpactCollisionAlgorithm_gimpact_vs_concave(void *c,void* p0,void* p1,void* p2,void* p3,int p4); //method: gimpact_vs_concave void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btGImpactShapeInterface *,::btConcaveShape *,bool ) 
float btGImpactCollisionAlgorithm_calculateTimeOfImpact(void *c,void* p0,void* p1,void* p2,void* p3); //method: calculateTimeOfImpact ::btScalar ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
void btGImpactCollisionAlgorithm_gimpact_vs_gimpact(void *c,void* p0,void* p1,void* p2,void* p3); //method: gimpact_vs_gimpact void ( ::btGImpactCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btGImpactShapeInterface *,::btGImpactShapeInterface * ) 
void btGImpactCollisionAlgorithm_getAllContactManifolds(void *c,void* p0); //method: getAllContactManifolds void ( ::btGImpactCollisionAlgorithm::* )( ::btManifoldArray & ) 
void btGImpactCollisionAlgorithm_m_convex_algorithm_set(void *c,void* a); //attribute: ::btCollisionAlgorithm * btGImpactCollisionAlgorithm->m_convex_algorithm
void* btGImpactCollisionAlgorithm_m_convex_algorithm_get(void *c); //attribute: ::btCollisionAlgorithm * btGImpactCollisionAlgorithm->m_convex_algorithm
void btGImpactCollisionAlgorithm_m_manifoldPtr_set(void *c,void* a); //attribute: ::btPersistentManifold * btGImpactCollisionAlgorithm->m_manifoldPtr
void* btGImpactCollisionAlgorithm_m_manifoldPtr_get(void *c); //attribute: ::btPersistentManifold * btGImpactCollisionAlgorithm->m_manifoldPtr
void btGImpactCollisionAlgorithm_m_resultOut_set(void *c,void* a); //attribute: ::btManifoldResult * btGImpactCollisionAlgorithm->m_resultOut
void* btGImpactCollisionAlgorithm_m_resultOut_get(void *c); //attribute: ::btManifoldResult * btGImpactCollisionAlgorithm->m_resultOut
void btGImpactCollisionAlgorithm_m_dispatchInfo_set(void *c,void* a); //attribute: ::btDispatcherInfo const * btGImpactCollisionAlgorithm->m_dispatchInfo
void* btGImpactCollisionAlgorithm_m_dispatchInfo_get(void *c); //attribute: ::btDispatcherInfo const * btGImpactCollisionAlgorithm->m_dispatchInfo
void btGImpactCollisionAlgorithm_m_triface0_set(void *c,int a); //attribute: int btGImpactCollisionAlgorithm->m_triface0
int btGImpactCollisionAlgorithm_m_triface0_get(void *c); //attribute: int btGImpactCollisionAlgorithm->m_triface0
void btGImpactCollisionAlgorithm_m_part0_set(void *c,int a); //attribute: int btGImpactCollisionAlgorithm->m_part0
int btGImpactCollisionAlgorithm_m_part0_get(void *c); //attribute: int btGImpactCollisionAlgorithm->m_part0
void btGImpactCollisionAlgorithm_m_triface1_set(void *c,int a); //attribute: int btGImpactCollisionAlgorithm->m_triface1
int btGImpactCollisionAlgorithm_m_triface1_get(void *c); //attribute: int btGImpactCollisionAlgorithm->m_triface1
void btGImpactCollisionAlgorithm_m_part1_set(void *c,int a); //attribute: int btGImpactCollisionAlgorithm->m_part1
int btGImpactCollisionAlgorithm_m_part1_get(void *c); //attribute: int btGImpactCollisionAlgorithm->m_part1
void* btGImpactCompoundShape_new(int p0); //constructor: btGImpactCompoundShape  ( ::btGImpactCompoundShape::* )( bool ) 
void btGImpactCompoundShape_free(void *c); 
void btGImpactCompoundShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btGImpactCompoundShape::* )( ::btScalar,::btVector3 & ) const
void btGImpactCompoundShape_addChildShape(void *c,float* p0,void* p1); //method: addChildShape void ( ::btGImpactCompoundShape::* )( ::btTransform const &,::btCollisionShape * ) 
void btGImpactCompoundShape_addChildShape0(void *c,float* p0,void* p1); //method: addChildShape void ( ::btGImpactCompoundShape::* )( ::btTransform const &,::btCollisionShape * ) 
void btGImpactCompoundShape_addChildShape1(void *c,void* p0); //method: addChildShape void ( ::btGImpactCompoundShape::* )( ::btCollisionShape * ) 
void* btGImpactCompoundShape_getCompoundPrimitiveManager(void *c); //method: getCompoundPrimitiveManager ::btGImpactCompoundShape::CompoundPrimitiveManager * ( ::btGImpactCompoundShape::* )(  ) 
void btGImpactCompoundShape_setChildTransform(void *c,int p0,float* p1); //method: setChildTransform void ( ::btGImpactCompoundShape::* )( int,::btTransform const & ) 
void btGImpactCompoundShape_getChildTransform(void *c,int p0,float* ret); //method: getChildTransform ::btTransform ( ::btGImpactCompoundShape::* )( int ) const
void btGImpactCompoundShape_getBulletTetrahedron(void *c,int p0,void* p1); //method: getBulletTetrahedron void ( ::btGImpactCompoundShape::* )( int,::btTetrahedronShapeEx & ) const
char const * btGImpactCompoundShape_getName(void *c); //method: getName char const * ( ::btGImpactCompoundShape::* )(  ) const
int btGImpactCompoundShape_needsRetrieveTetrahedrons(void *c); //method: needsRetrieveTetrahedrons bool ( ::btGImpactCompoundShape::* )(  ) const
void* btGImpactCompoundShape_getChildShape(void *c,int p0); //method: getChildShape ::btCollisionShape * ( ::btGImpactCompoundShape::* )( int ) 
void* btGImpactCompoundShape_getChildShape0(void *c,int p0); //method: getChildShape ::btCollisionShape * ( ::btGImpactCompoundShape::* )( int ) 
void* btGImpactCompoundShape_getChildShape1(void *c,int p0); //method: getChildShape ::btCollisionShape const * ( ::btGImpactCompoundShape::* )( int ) const
void btGImpactCompoundShape_getBulletTriangle(void *c,int p0,void* p1); //method: getBulletTriangle void ( ::btGImpactCompoundShape::* )( int,::btTriangleShapeEx & ) const
int btGImpactCompoundShape_needsRetrieveTriangles(void *c); //method: needsRetrieveTriangles bool ( ::btGImpactCompoundShape::* )(  ) const
int btGImpactCompoundShape_childrenHasTransform(void *c); //method: childrenHasTransform bool ( ::btGImpactCompoundShape::* )(  ) const
int btGImpactCompoundShape_getNumChildShapes(void *c); //method: getNumChildShapes int ( ::btGImpactCompoundShape::* )(  ) const
void* btGImpactCompoundShape_getPrimitiveManager(void *c); //method: getPrimitiveManager ::btPrimitiveManagerBase const * ( ::btGImpactCompoundShape::* )(  ) const
void btGImpactCompoundShape_getChildAabb(void *c,int p0,float* p1,float* p2,float* p3); //method: getChildAabb void ( ::btGImpactCompoundShape::* )( int,::btTransform const &,::btVector3 &,::btVector3 & ) const
//not supported method: getGImpactShapeType ::eGIMPACT_SHAPE_TYPE ( ::btGImpactCompoundShape::* )(  ) const
// error:  - unsupported

void btGImpactCompoundShape_m_childShapes_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btCollisionShape*> btGImpactCompoundShape->m_childShapes
void* btGImpactCompoundShape_m_childShapes_get(void *c); //attribute: ::btAlignedObjectArray<btCollisionShape*> btGImpactCompoundShape->m_childShapes
void btGImpactCompoundShape_m_childTransforms_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btTransform> btGImpactCompoundShape->m_childTransforms
void* btGImpactCompoundShape_m_childTransforms_get(void *c); //attribute: ::btAlignedObjectArray<btTransform> btGImpactCompoundShape->m_childTransforms
void btGImpactCompoundShape_m_primitive_manager_set(void *c,void* a); //attribute: ::btGImpactCompoundShape::CompoundPrimitiveManager btGImpactCompoundShape->m_primitive_manager
void* btGImpactCompoundShape_m_primitive_manager_get(void *c); //attribute: ::btGImpactCompoundShape::CompoundPrimitiveManager btGImpactCompoundShape->m_primitive_manager
void* btGImpactMeshShape_new(void* p0); //constructor: btGImpactMeshShape  ( ::btGImpactMeshShape::* )( ::btStridingMeshInterface * ) 
void btGImpactMeshShape_free(void *c); 
void btGImpactMeshShape_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btGImpactMeshShape::* )( ::btScalar,::btVector3 & ) const
void btGImpactMeshShape_setChildTransform(void *c,int p0,float* p1); //method: setChildTransform void ( ::btGImpactMeshShape::* )( int,::btTransform const & ) 
void* btGImpactMeshShape_getMeshInterface(void *c); //method: getMeshInterface ::btStridingMeshInterface * ( ::btGImpactMeshShape::* )(  ) 
void* btGImpactMeshShape_getMeshInterface0(void *c); //method: getMeshInterface ::btStridingMeshInterface * ( ::btGImpactMeshShape::* )(  ) 
void* btGImpactMeshShape_getMeshInterface1(void *c); //method: getMeshInterface ::btStridingMeshInterface const * ( ::btGImpactMeshShape::* )(  ) const
void* btGImpactMeshShape_getPrimitiveManager(void *c); //method: getPrimitiveManager ::btPrimitiveManagerBase const * ( ::btGImpactMeshShape::* )(  ) const
void btGImpactMeshShape_processAllTriangles(void *c,void* p0,float* p1,float* p2); //method: processAllTriangles void ( ::btGImpactMeshShape::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
int btGImpactMeshShape_getMeshPartCount(void *c); //method: getMeshPartCount int ( ::btGImpactMeshShape::* )(  ) const
int btGImpactMeshShape_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btGImpactMeshShape::* )(  ) const
void btGImpactMeshShape_rayTest(void *c,float* p0,float* p1,void* p2); //method: rayTest void ( ::btGImpactMeshShape::* )( ::btVector3 const &,::btVector3 const &,::btCollisionWorld::RayResultCallback & ) const
void btGImpactMeshShape_buildMeshParts(void *c,void* p0); //method: buildMeshParts void ( ::btGImpactMeshShape::* )( ::btStridingMeshInterface * ) 
char const * btGImpactMeshShape_getName(void *c); //method: getName char const * ( ::btGImpactMeshShape::* )(  ) const
void btGImpactMeshShape_getBulletTriangle(void *c,int p0,void* p1); //method: getBulletTriangle void ( ::btGImpactMeshShape::* )( int,::btTriangleShapeEx & ) const
void btGImpactMeshShape_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btGImpactMeshShape::* )( ::btVector3 const & ) 
int btGImpactMeshShape_needsRetrieveTriangles(void *c); //method: needsRetrieveTriangles bool ( ::btGImpactMeshShape::* )(  ) const
int btGImpactMeshShape_childrenHasTransform(void *c); //method: childrenHasTransform bool ( ::btGImpactMeshShape::* )(  ) const
void* btGImpactMeshShape_getChildShape(void *c,int p0); //method: getChildShape ::btCollisionShape * ( ::btGImpactMeshShape::* )( int ) 
void* btGImpactMeshShape_getChildShape0(void *c,int p0); //method: getChildShape ::btCollisionShape * ( ::btGImpactMeshShape::* )( int ) 
void* btGImpactMeshShape_getChildShape1(void *c,int p0); //method: getChildShape ::btCollisionShape const * ( ::btGImpactMeshShape::* )( int ) const
void btGImpactMeshShape_calcLocalAABB(void *c); //method: calcLocalAABB void ( ::btGImpactMeshShape::* )(  ) 
void btGImpactMeshShape_getChildTransform(void *c,int p0,float* ret); //method: getChildTransform ::btTransform ( ::btGImpactMeshShape::* )( int ) const
char const * btGImpactMeshShape_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btGImpactMeshShape::* )( void *,::btSerializer * ) const
void btGImpactMeshShape_lockChildShapes(void *c); //method: lockChildShapes void ( ::btGImpactMeshShape::* )(  ) const
void btGImpactMeshShape_setMargin(void *c,float p0); //method: setMargin void ( ::btGImpactMeshShape::* )( ::btScalar ) 
int btGImpactMeshShape_getNumChildShapes(void *c); //method: getNumChildShapes int ( ::btGImpactMeshShape::* )(  ) const
void btGImpactMeshShape_getChildAabb(void *c,int p0,float* p1,float* p2,float* p3); //method: getChildAabb void ( ::btGImpactMeshShape::* )( int,::btTransform const &,::btVector3 &,::btVector3 & ) const
void btGImpactMeshShape_getBulletTetrahedron(void *c,int p0,void* p1); //method: getBulletTetrahedron void ( ::btGImpactMeshShape::* )( int,::btTetrahedronShapeEx & ) const
int btGImpactMeshShape_needsRetrieveTetrahedrons(void *c); //method: needsRetrieveTetrahedrons bool ( ::btGImpactMeshShape::* )(  ) const
void btGImpactMeshShape_unlockChildShapes(void *c); //method: unlockChildShapes void ( ::btGImpactMeshShape::* )(  ) const
void* btGImpactMeshShape_getMeshPart(void *c,int p0); //method: getMeshPart ::btGImpactMeshShapePart * ( ::btGImpactMeshShape::* )( int ) 
void* btGImpactMeshShape_getMeshPart0(void *c,int p0); //method: getMeshPart ::btGImpactMeshShapePart * ( ::btGImpactMeshShape::* )( int ) 
void* btGImpactMeshShape_getMeshPart1(void *c,int p0); //method: getMeshPart ::btGImpactMeshShapePart const * ( ::btGImpactMeshShape::* )( int ) const
void btGImpactMeshShape_postUpdate(void *c); //method: postUpdate void ( ::btGImpactMeshShape::* )(  ) 
//not supported method: getGImpactShapeType ::eGIMPACT_SHAPE_TYPE ( ::btGImpactMeshShape::* )(  ) const
// error:  - unsupported

void btGImpactMeshShape_m_meshInterface_set(void *c,void* a); //attribute: ::btStridingMeshInterface * btGImpactMeshShape->m_meshInterface
void* btGImpactMeshShape_m_meshInterface_get(void *c); //attribute: ::btStridingMeshInterface * btGImpactMeshShape->m_meshInterface
void btGImpactMeshShape_m_mesh_parts_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btGImpactMeshShapePart*> btGImpactMeshShape->m_mesh_parts
void* btGImpactMeshShape_m_mesh_parts_get(void *c); //attribute: ::btAlignedObjectArray<btGImpactMeshShapePart*> btGImpactMeshShape->m_mesh_parts
void* btGImpactMeshShapeData_new(); //constructor: btGImpactMeshShapeData  ( ::btGImpactMeshShapeData::* )(  ) 
void btGImpactMeshShapeData_free(void *c); 
void btGImpactMeshShapeData_m_collisionShapeData_set(void *c,void* a); //attribute: ::btCollisionShapeData btGImpactMeshShapeData->m_collisionShapeData
void* btGImpactMeshShapeData_m_collisionShapeData_get(void *c); //attribute: ::btCollisionShapeData btGImpactMeshShapeData->m_collisionShapeData
void btGImpactMeshShapeData_m_meshInterface_set(void *c,void* a); //attribute: ::btStridingMeshInterfaceData btGImpactMeshShapeData->m_meshInterface
void* btGImpactMeshShapeData_m_meshInterface_get(void *c); //attribute: ::btStridingMeshInterfaceData btGImpactMeshShapeData->m_meshInterface
void btGImpactMeshShapeData_m_localScaling_set(void *c,void* a); //attribute: ::btVector3FloatData btGImpactMeshShapeData->m_localScaling
void* btGImpactMeshShapeData_m_localScaling_get(void *c); //attribute: ::btVector3FloatData btGImpactMeshShapeData->m_localScaling
void btGImpactMeshShapeData_m_collisionMargin_set(void *c,float a); //attribute: float btGImpactMeshShapeData->m_collisionMargin
float btGImpactMeshShapeData_m_collisionMargin_get(void *c); //attribute: float btGImpactMeshShapeData->m_collisionMargin
void btGImpactMeshShapeData_m_gimpactSubType_set(void *c,int a); //attribute: int btGImpactMeshShapeData->m_gimpactSubType
int btGImpactMeshShapeData_m_gimpactSubType_get(void *c); //attribute: int btGImpactMeshShapeData->m_gimpactSubType
void* btGImpactMeshShapePart_new0(); //constructor: btGImpactMeshShapePart  ( ::btGImpactMeshShapePart::* )(  ) 
void* btGImpactMeshShapePart_new1(void* p0,int p1); //constructor: btGImpactMeshShapePart  ( ::btGImpactMeshShapePart::* )( ::btStridingMeshInterface *,int ) 
void btGImpactMeshShapePart_free(void *c); 
void btGImpactMeshShapePart_calculateLocalInertia(void *c,float p0,float* p1); //method: calculateLocalInertia void ( ::btGImpactMeshShapePart::* )( ::btScalar,::btVector3 & ) const
void btGImpactMeshShapePart_setChildTransform(void *c,int p0,float* p1); //method: setChildTransform void ( ::btGImpactMeshShapePart::* )( int,::btTransform const & ) 
void btGImpactMeshShapePart_getLocalScaling(void *c,float* ret); //method: getLocalScaling ::btVector3 const & ( ::btGImpactMeshShapePart::* )(  ) const
void btGImpactMeshShapePart_getVertex(void *c,int p0,float* p1); //method: getVertex void ( ::btGImpactMeshShapePart::* )( int,::btVector3 & ) const
void btGImpactMeshShapePart_processAllTriangles(void *c,void* p0,float* p1,float* p2); //method: processAllTriangles void ( ::btGImpactMeshShapePart::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
char const * btGImpactMeshShapePart_getName(void *c); //method: getName char const * ( ::btGImpactMeshShapePart::* )(  ) const
void btGImpactMeshShapePart_getBulletTriangle(void *c,int p0,void* p1); //method: getBulletTriangle void ( ::btGImpactMeshShapePart::* )( int,::btTriangleShapeEx & ) const
void btGImpactMeshShapePart_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btGImpactMeshShapePart::* )( ::btVector3 const & ) 
int btGImpactMeshShapePart_getPart(void *c); //method: getPart int ( ::btGImpactMeshShapePart::* )(  ) const
int btGImpactMeshShapePart_childrenHasTransform(void *c); //method: childrenHasTransform bool ( ::btGImpactMeshShapePart::* )(  ) const
int btGImpactMeshShapePart_needsRetrieveTriangles(void *c); //method: needsRetrieveTriangles bool ( ::btGImpactMeshShapePart::* )(  ) const
void* btGImpactMeshShapePart_getChildShape(void *c,int p0); //method: getChildShape ::btCollisionShape * ( ::btGImpactMeshShapePart::* )( int ) 
void* btGImpactMeshShapePart_getChildShape0(void *c,int p0); //method: getChildShape ::btCollisionShape * ( ::btGImpactMeshShapePart::* )( int ) 
void* btGImpactMeshShapePart_getChildShape1(void *c,int p0); //method: getChildShape ::btCollisionShape const * ( ::btGImpactMeshShapePart::* )( int ) const
void btGImpactMeshShapePart_getChildTransform(void *c,int p0,float* ret); //method: getChildTransform ::btTransform ( ::btGImpactMeshShapePart::* )( int ) const
void btGImpactMeshShapePart_lockChildShapes(void *c); //method: lockChildShapes void ( ::btGImpactMeshShapePart::* )(  ) const
float btGImpactMeshShapePart_getMargin(void *c); //method: getMargin ::btScalar ( ::btGImpactMeshShapePart::* )(  ) const
void btGImpactMeshShapePart_setMargin(void *c,float p0); //method: setMargin void ( ::btGImpactMeshShapePart::* )( ::btScalar ) 
void* btGImpactMeshShapePart_getPrimitiveManager(void *c); //method: getPrimitiveManager ::btPrimitiveManagerBase const * ( ::btGImpactMeshShapePart::* )(  ) const
int btGImpactMeshShapePart_getNumChildShapes(void *c); //method: getNumChildShapes int ( ::btGImpactMeshShapePart::* )(  ) const
void btGImpactMeshShapePart_getBulletTetrahedron(void *c,int p0,void* p1); //method: getBulletTetrahedron void ( ::btGImpactMeshShapePart::* )( int,::btTetrahedronShapeEx & ) const
void* btGImpactMeshShapePart_getTrimeshPrimitiveManager(void *c); //method: getTrimeshPrimitiveManager ::btGImpactMeshShapePart::TrimeshPrimitiveManager * ( ::btGImpactMeshShapePart::* )(  ) 
int btGImpactMeshShapePart_needsRetrieveTetrahedrons(void *c); //method: needsRetrieveTetrahedrons bool ( ::btGImpactMeshShapePart::* )(  ) const
void btGImpactMeshShapePart_unlockChildShapes(void *c); //method: unlockChildShapes void ( ::btGImpactMeshShapePart::* )(  ) const
//not supported method: getGImpactShapeType ::eGIMPACT_SHAPE_TYPE ( ::btGImpactMeshShapePart::* )(  ) const
// error:  - unsupported

int btGImpactMeshShapePart_getVertexCount(void *c); //method: getVertexCount int ( ::btGImpactMeshShapePart::* )(  ) const
void btGImpactMeshShapePart_m_primitive_manager_set(void *c,void* a); //attribute: ::btGImpactMeshShapePart::TrimeshPrimitiveManager btGImpactMeshShapePart->m_primitive_manager
void* btGImpactMeshShapePart_m_primitive_manager_get(void *c); //attribute: ::btGImpactMeshShapePart::TrimeshPrimitiveManager btGImpactMeshShapePart->m_primitive_manager
void* btGImpactQuantizedBvh_new0(); //constructor: btGImpactQuantizedBvh  ( ::btGImpactQuantizedBvh::* )(  ) 
void* btGImpactQuantizedBvh_new1(void* p0); //constructor: btGImpactQuantizedBvh  ( ::btGImpactQuantizedBvh::* )( ::btPrimitiveManagerBase * ) 
void btGImpactQuantizedBvh_free(void *c); 
void btGImpactQuantizedBvh_setNodeBound(void *c,int p0,void* p1); //method: setNodeBound void ( ::btGImpactQuantizedBvh::* )( int,::btAABB const & ) 
int btGImpactQuantizedBvh_getEscapeNodeIndex(void *c,int p0); //method: getEscapeNodeIndex int ( ::btGImpactQuantizedBvh::* )( int ) const
int btGImpactQuantizedBvh_isLeafNode(void *c,int p0); //method: isLeafNode bool ( ::btGImpactQuantizedBvh::* )( int ) const
void* btGImpactQuantizedBvh_getPrimitiveManager(void *c); //method: getPrimitiveManager ::btPrimitiveManagerBase * ( ::btGImpactQuantizedBvh::* )(  ) const
void btGImpactQuantizedBvh_getNodeBound(void *c,int p0,void* p1); //method: getNodeBound void ( ::btGImpactQuantizedBvh::* )( int,::btAABB & ) const
int btGImpactQuantizedBvh_getRightNode(void *c,int p0); //method: getRightNode int ( ::btGImpactQuantizedBvh::* )( int ) const
int btGImpactQuantizedBvh_getLeftNode(void *c,int p0); //method: getLeftNode int ( ::btGImpactQuantizedBvh::* )( int ) const
void btGImpactQuantizedBvh_setPrimitiveManager(void *c,void* p0); //method: setPrimitiveManager void ( ::btGImpactQuantizedBvh::* )( ::btPrimitiveManagerBase * ) 
void btGImpactQuantizedBvh_buildSet(void *c); //method: buildSet void ( ::btGImpactQuantizedBvh::* )(  ) 
void btGImpactQuantizedBvh_getNodeTriangle(void *c,int p0,void* p1); //method: getNodeTriangle void ( ::btGImpactQuantizedBvh::* )( int,::btPrimitiveTriangle & ) const
int btGImpactQuantizedBvh_getNodeCount(void *c); //method: getNodeCount int ( ::btGImpactQuantizedBvh::* )(  ) const
int btGImpactQuantizedBvh_hasHierarchy(void *c); //method: hasHierarchy bool ( ::btGImpactQuantizedBvh::* )(  ) const
int btGImpactQuantizedBvh_rayQuery(void *c,float* p0,float* p1,void* p2); //method: rayQuery bool ( ::btGImpactQuantizedBvh::* )( ::btVector3 const &,::btVector3 const &,::btAlignedObjectArray<int> & ) const
void btGImpactQuantizedBvh_update(void *c); //method: update void ( ::btGImpactQuantizedBvh::* )(  ) 
void btGImpactQuantizedBvh_refit(void *c); //method: refit void ( ::btGImpactQuantizedBvh::* )(  ) 
int btGImpactQuantizedBvh_isTrimesh(void *c); //method: isTrimesh bool ( ::btGImpactQuantizedBvh::* )(  ) const
int btGImpactQuantizedBvh_boxQuery(void *c,void* p0,void* p1); //method: boxQuery bool ( ::btGImpactQuantizedBvh::* )( ::btAABB const &,::btAlignedObjectArray<int> & ) const
void btGImpactQuantizedBvh_find_collision(void* p0,float* p1,void* p2,float* p3,void* p4); //method: find_collision void (*)( ::btGImpactQuantizedBvh *,::btTransform const &,::btGImpactQuantizedBvh *,::btTransform const &,::btPairSet & )
void* btGImpactQuantizedBvh_get_node_pointer(void *c,int p0); //method: get_node_pointer ::BT_QUANTIZED_BVH_NODE const * ( ::btGImpactQuantizedBvh::* )( int ) const
int btGImpactQuantizedBvh_boxQueryTrans(void *c,void* p0,float* p1,void* p2); //method: boxQueryTrans bool ( ::btGImpactQuantizedBvh::* )( ::btAABB const &,::btTransform const &,::btAlignedObjectArray<int> & ) const
//not supported method: getGlobalBox ::btAABB ( ::btGImpactQuantizedBvh::* )(  ) const
// error:  - unsupported

int btGImpactQuantizedBvh_getNodeData(void *c,int p0); //method: getNodeData int ( ::btGImpactQuantizedBvh::* )( int ) const
void btGImpactQuantizedBvh_m_box_tree_set(void *c,void* a); //attribute: ::btQuantizedBvhTree btGImpactQuantizedBvh->m_box_tree
void* btGImpactQuantizedBvh_m_box_tree_get(void *c); //attribute: ::btQuantizedBvhTree btGImpactQuantizedBvh->m_box_tree
void btGImpactQuantizedBvh_m_primitive_manager_set(void *c,void* a); //attribute: ::btPrimitiveManagerBase * btGImpactQuantizedBvh->m_primitive_manager
void* btGImpactQuantizedBvh_m_primitive_manager_get(void *c); //attribute: ::btPrimitiveManagerBase * btGImpactQuantizedBvh->m_primitive_manager
void btGImpactShapeInterface_getPrimitiveTriangle(void *c,int p0,void* p1); //method: getPrimitiveTriangle void ( ::btGImpactShapeInterface::* )( int,::btPrimitiveTriangle & ) const
void btGImpactShapeInterface_setChildTransform(void *c,int p0,float* p1); //method: setChildTransform void ( ::btGImpactShapeInterface::* )( int,::btTransform const & ) 
void btGImpactShapeInterface_getLocalScaling(void *c,float* ret); //method: getLocalScaling ::btVector3 const & ( ::btGImpactShapeInterface::* )(  ) const
void* btGImpactShapeInterface_getLocalBox(void *c); //method: getLocalBox ::btAABB const & ( ::btGImpactShapeInterface::* )(  ) 
void* btGImpactShapeInterface_getPrimitiveManager(void *c); //method: getPrimitiveManager ::btPrimitiveManagerBase const * ( ::btGImpactShapeInterface::* )(  ) const
void btGImpactShapeInterface_processAllTriangles(void *c,void* p0,float* p1,float* p2); //method: processAllTriangles void ( ::btGImpactShapeInterface::* )( ::btTriangleCallback *,::btVector3 const &,::btVector3 const & ) const
int btGImpactShapeInterface_hasBoxSet(void *c); //method: hasBoxSet bool ( ::btGImpactShapeInterface::* )(  ) const
void btGImpactShapeInterface_rayTest(void *c,float* p0,float* p1,void* p2); //method: rayTest void ( ::btGImpactShapeInterface::* )( ::btVector3 const &,::btVector3 const &,::btCollisionWorld::RayResultCallback & ) const
void* btGImpactShapeInterface_getBoxSet(void *c); //method: getBoxSet ::btGImpactBoxSet * ( ::btGImpactShapeInterface::* )(  ) 
void btGImpactShapeInterface_getBulletTriangle(void *c,int p0,void* p1); //method: getBulletTriangle void ( ::btGImpactShapeInterface::* )( int,::btTriangleShapeEx & ) const
void btGImpactShapeInterface_setLocalScaling(void *c,float* p0); //method: setLocalScaling void ( ::btGImpactShapeInterface::* )( ::btVector3 const & ) 
int btGImpactShapeInterface_needsRetrieveTriangles(void *c); //method: needsRetrieveTriangles bool ( ::btGImpactShapeInterface::* )(  ) const
int btGImpactShapeInterface_childrenHasTransform(void *c); //method: childrenHasTransform bool ( ::btGImpactShapeInterface::* )(  ) const
void btGImpactShapeInterface_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btGImpactShapeInterface::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void* btGImpactShapeInterface_getChildShape(void *c,int p0); //method: getChildShape ::btCollisionShape * ( ::btGImpactShapeInterface::* )( int ) 
void* btGImpactShapeInterface_getChildShape0(void *c,int p0); //method: getChildShape ::btCollisionShape * ( ::btGImpactShapeInterface::* )( int ) 
void* btGImpactShapeInterface_getChildShape1(void *c,int p0); //method: getChildShape ::btCollisionShape const * ( ::btGImpactShapeInterface::* )( int ) const
void btGImpactShapeInterface_calcLocalAABB(void *c); //method: calcLocalAABB void ( ::btGImpactShapeInterface::* )(  ) 
void btGImpactShapeInterface_getChildTransform(void *c,int p0,float* ret); //method: getChildTransform ::btTransform ( ::btGImpactShapeInterface::* )( int ) const
void btGImpactShapeInterface_lockChildShapes(void *c); //method: lockChildShapes void ( ::btGImpactShapeInterface::* )(  ) const
void btGImpactShapeInterface_setMargin(void *c,float p0); //method: setMargin void ( ::btGImpactShapeInterface::* )( ::btScalar ) 
int btGImpactShapeInterface_getNumChildShapes(void *c); //method: getNumChildShapes int ( ::btGImpactShapeInterface::* )(  ) const
void btGImpactShapeInterface_getChildAabb(void *c,int p0,float* p1,float* p2,float* p3); //method: getChildAabb void ( ::btGImpactShapeInterface::* )( int,::btTransform const &,::btVector3 &,::btVector3 & ) const
int btGImpactShapeInterface_getShapeType(void *c); //method: getShapeType int ( ::btGImpactShapeInterface::* )(  ) const
void btGImpactShapeInterface_getBulletTetrahedron(void *c,int p0,void* p1); //method: getBulletTetrahedron void ( ::btGImpactShapeInterface::* )( int,::btTetrahedronShapeEx & ) const
int btGImpactShapeInterface_needsRetrieveTetrahedrons(void *c); //method: needsRetrieveTetrahedrons bool ( ::btGImpactShapeInterface::* )(  ) const
void btGImpactShapeInterface_unlockChildShapes(void *c); //method: unlockChildShapes void ( ::btGImpactShapeInterface::* )(  ) const
void btGImpactShapeInterface_postUpdate(void *c); //method: postUpdate void ( ::btGImpactShapeInterface::* )(  ) 
void btGImpactShapeInterface_updateBound(void *c); //method: updateBound void ( ::btGImpactShapeInterface::* )(  ) 
//not supported method: getGImpactShapeType ::eGIMPACT_SHAPE_TYPE ( ::btGImpactShapeInterface::* )(  ) const
// error:  - unsupported

void btGImpactShapeInterface_localScaling_set(void *c,float* a); //attribute: ::btVector3 btGImpactShapeInterface->localScaling
void btGImpactShapeInterface_localScaling_get(void *c,float* a);
void btGImpactShapeInterface_m_box_set_set(void *c,void* a); //attribute: ::btGImpactBoxSet btGImpactShapeInterface->m_box_set
void* btGImpactShapeInterface_m_box_set_get(void *c); //attribute: ::btGImpactBoxSet btGImpactShapeInterface->m_box_set
void btGImpactShapeInterface_m_localAABB_set(void *c,void* a); //attribute: ::btAABB btGImpactShapeInterface->m_localAABB
void* btGImpactShapeInterface_m_localAABB_get(void *c); //attribute: ::btAABB btGImpactShapeInterface->m_localAABB
void btGImpactShapeInterface_m_needs_update_set(void *c,int a); //attribute: bool btGImpactShapeInterface->m_needs_update
int btGImpactShapeInterface_m_needs_update_get(void *c); //attribute: bool btGImpactShapeInterface->m_needs_update
void* btPairSet_new(); //constructor: btPairSet  ( ::btPairSet::* )(  ) 
void btPairSet_free(void *c); 
void btPairSet_push_pair_inv(void *c,int p0,int p1); //method: push_pair_inv void ( ::btPairSet::* )( int,int ) 
void btPairSet_push_pair(void *c,int p0,int p1); //method: push_pair void ( ::btPairSet::* )( int,int ) 
void btPrimitiveManagerBase_get_primitive_box(void *c,int p0,void* p1); //method: get_primitive_box void ( ::btPrimitiveManagerBase::* )( int,::btAABB & ) const
void btPrimitiveManagerBase_get_primitive_triangle(void *c,int p0,void* p1); //method: get_primitive_triangle void ( ::btPrimitiveManagerBase::* )( int,::btPrimitiveTriangle & ) const
int btPrimitiveManagerBase_is_trimesh(void *c); //method: is_trimesh bool ( ::btPrimitiveManagerBase::* )(  ) const
int btPrimitiveManagerBase_get_primitive_count(void *c); //method: get_primitive_count int ( ::btPrimitiveManagerBase::* )(  ) const
void* btPrimitiveTriangle_new(); //constructor: btPrimitiveTriangle  ( ::btPrimitiveTriangle::* )(  ) 
void btPrimitiveTriangle_free(void *c); 
//not supported method: clip_triangle int ( ::btPrimitiveTriangle::* )( ::btPrimitiveTriangle &,::btVector3 * ) 
// error: ::btPrimitiveTriangle & - ok,  - unsupported, int - ok

void btPrimitiveTriangle_get_edge_plane(void *c,int p0,float* p1); //method: get_edge_plane void ( ::btPrimitiveTriangle::* )( int,::btVector4 & ) const
int btPrimitiveTriangle_overlap_test_conservative(void *c,void* p0); //method: overlap_test_conservative bool ( ::btPrimitiveTriangle::* )( ::btPrimitiveTriangle const & ) 
void btPrimitiveTriangle_buildTriPlane(void *c); //method: buildTriPlane void ( ::btPrimitiveTriangle::* )(  ) 
void btPrimitiveTriangle_applyTransform(void *c,float* p0); //method: applyTransform void ( ::btPrimitiveTriangle::* )( ::btTransform const & ) 
int btPrimitiveTriangle_find_triangle_collision_clip_method(void *c,void* p0,void* p1); //method: find_triangle_collision_clip_method bool ( ::btPrimitiveTriangle::* )( ::btPrimitiveTriangle &,::GIM_TRIANGLE_CONTACT & ) 
void btPrimitiveTriangle_m_dummy_set(void *c,float a); //attribute: ::btScalar btPrimitiveTriangle->m_dummy
float btPrimitiveTriangle_m_dummy_get(void *c); //attribute: ::btScalar btPrimitiveTriangle->m_dummy
void btPrimitiveTriangle_m_margin_set(void *c,float a); //attribute: ::btScalar btPrimitiveTriangle->m_margin
float btPrimitiveTriangle_m_margin_get(void *c); //attribute: ::btScalar btPrimitiveTriangle->m_margin
void btPrimitiveTriangle_m_plane_set(void *c,float* a); //attribute: ::btVector4 btPrimitiveTriangle->m_plane
void btPrimitiveTriangle_m_plane_get(void *c,float* a);
// attribute not supported: //attribute: ::btVector3[3] btPrimitiveTriangle->m_vertices
void* btQuantizedBvhTree_new(); //constructor: btQuantizedBvhTree  ( ::btQuantizedBvhTree::* )(  ) 
void btQuantizedBvhTree_free(void *c); 
int btQuantizedBvhTree_getNodeCount(void *c); //method: getNodeCount int ( ::btQuantizedBvhTree::* )(  ) const
void btQuantizedBvhTree_calc_quantization(void *c,void* p0,float p1); //method: calc_quantization void ( ::btQuantizedBvhTree::* )( ::GIM_BVH_DATA_ARRAY &,::btScalar ) 
void btQuantizedBvhTree_build_tree(void *c,void* p0); //method: build_tree void ( ::btQuantizedBvhTree::* )( ::GIM_BVH_DATA_ARRAY & ) 
void btQuantizedBvhTree_setNodeBound(void *c,int p0,void* p1); //method: setNodeBound void ( ::btQuantizedBvhTree::* )( int,::btAABB const & ) 
int btQuantizedBvhTree_getLeftNode(void *c,int p0); //method: getLeftNode int ( ::btQuantizedBvhTree::* )( int ) const
void btQuantizedBvhTree__build_sub_tree(void *c,void* p0,int p1,int p2); //method: _build_sub_tree void ( ::btQuantizedBvhTree::* )( ::GIM_BVH_DATA_ARRAY &,int,int ) 
void btQuantizedBvhTree_clearNodes(void *c); //method: clearNodes void ( ::btQuantizedBvhTree::* )(  ) 
int btQuantizedBvhTree__sort_and_calc_splitting_index(void *c,void* p0,int p1,int p2,int p3); //method: _sort_and_calc_splitting_index int ( ::btQuantizedBvhTree::* )( ::GIM_BVH_DATA_ARRAY &,int,int,int ) 
//not supported method: quantizePoint void ( ::btQuantizedBvhTree::* )( short unsigned int *,::btVector3 const & ) const
// error:  - unsupported, ::btVector3 const & - ok, void - ok

int btQuantizedBvhTree_getEscapeNodeIndex(void *c,int p0); //method: getEscapeNodeIndex int ( ::btQuantizedBvhTree::* )( int ) const
int btQuantizedBvhTree_isLeafNode(void *c,int p0); //method: isLeafNode bool ( ::btQuantizedBvhTree::* )( int ) const
void* btQuantizedBvhTree_get_node_pointer(void *c,int p0); //method: get_node_pointer ::BT_QUANTIZED_BVH_NODE const * ( ::btQuantizedBvhTree::* )( int ) const
//not supported method: testQuantizedBoxOverlapp bool ( ::btQuantizedBvhTree::* )( int,short unsigned int *,short unsigned int * ) const
// error: int - ok,  - unsupported,  - unsupported, bool - ok

int btQuantizedBvhTree_getNodeData(void *c,int p0); //method: getNodeData int ( ::btQuantizedBvhTree::* )( int ) const
void btQuantizedBvhTree_getNodeBound(void *c,int p0,void* p1); //method: getNodeBound void ( ::btQuantizedBvhTree::* )( int,::btAABB & ) const
int btQuantizedBvhTree_getRightNode(void *c,int p0); //method: getRightNode int ( ::btQuantizedBvhTree::* )( int ) const
int btQuantizedBvhTree__calc_splitting_axis(void *c,void* p0,int p1,int p2); //method: _calc_splitting_axis int ( ::btQuantizedBvhTree::* )( ::GIM_BVH_DATA_ARRAY &,int,int ) 
void btQuantizedBvhTree_m_bvhQuantization_set(void *c,float* a); //attribute: ::btVector3 btQuantizedBvhTree->m_bvhQuantization
void btQuantizedBvhTree_m_bvhQuantization_get(void *c,float* a);
void btQuantizedBvhTree_m_global_bound_set(void *c,void* a); //attribute: ::btAABB btQuantizedBvhTree->m_global_bound
void* btQuantizedBvhTree_m_global_bound_get(void *c); //attribute: ::btAABB btQuantizedBvhTree->m_global_bound
void btQuantizedBvhTree_m_node_array_set(void *c,void* a); //attribute: ::GIM_QUANTIZED_BVH_NODE_ARRAY btQuantizedBvhTree->m_node_array
void* btQuantizedBvhTree_m_node_array_get(void *c); //attribute: ::GIM_QUANTIZED_BVH_NODE_ARRAY btQuantizedBvhTree->m_node_array
void btQuantizedBvhTree_m_num_nodes_set(void *c,int a); //attribute: int btQuantizedBvhTree->m_num_nodes
int btQuantizedBvhTree_m_num_nodes_get(void *c); //attribute: int btQuantizedBvhTree->m_num_nodes
void* btTetrahedronShapeEx_new(); //constructor: btTetrahedronShapeEx  ( ::btTetrahedronShapeEx::* )(  ) 
void btTetrahedronShapeEx_free(void *c); 
void btTetrahedronShapeEx_setVertices(void *c,float* p0,float* p1,float* p2,float* p3); //method: setVertices void ( ::btTetrahedronShapeEx::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void* btTriangleShapeEx_new0(); //constructor: btTriangleShapeEx  ( ::btTriangleShapeEx::* )(  ) 
void* btTriangleShapeEx_new1(float* p0,float* p1,float* p2); //constructor: btTriangleShapeEx  ( ::btTriangleShapeEx::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btTriangleShapeEx_free(void *c); 
int btTriangleShapeEx_overlap_test_conservative(void *c,void* p0); //method: overlap_test_conservative bool ( ::btTriangleShapeEx::* )( ::btTriangleShapeEx const & ) 
void btTriangleShapeEx_buildTriPlane(void *c,float* p0); //method: buildTriPlane void ( ::btTriangleShapeEx::* )( ::btVector4 & ) const
void btTriangleShapeEx_applyTransform(void *c,float* p0); //method: applyTransform void ( ::btTriangleShapeEx::* )( ::btTransform const & ) 
void btTriangleShapeEx_getAabb(void *c,float* p0,float* p1,float* p2); //method: getAabb void ( ::btTriangleShapeEx::* )( ::btTransform const &,::btVector3 &,::btVector3 & ) const
void* btDbvt_IClone_new(); //constructor: IClone  ( ::btDbvt::IClone::* )(  ) 
void btDbvt_IClone_free(void *c); 
void btDbvt_IClone_CloneLeaf(void *c,void* p0); //method: CloneLeaf void ( ::btDbvt::IClone::* )( ::btDbvtNode * ) 
void* btDbvt_ICollide_new(); //constructor: ICollide  ( ::btDbvt::ICollide::* )(  ) 
void btDbvt_ICollide_free(void *c); 
void btDbvt_ICollide_Process(void *c,void* p0,void* p1); //method: Process void ( ::btDbvt::ICollide::* )( ::btDbvtNode const *,::btDbvtNode const * ) 
void btDbvt_ICollide_Process0(void *c,void* p0,void* p1); //method: Process void ( ::btDbvt::ICollide::* )( ::btDbvtNode const *,::btDbvtNode const * ) 
void btDbvt_ICollide_Process1(void *c,void* p0); //method: Process void ( ::btDbvt::ICollide::* )( ::btDbvtNode const * ) 
void btDbvt_ICollide_Process2(void *c,void* p0,float p1); //method: Process void ( ::btDbvt::ICollide::* )( ::btDbvtNode const *,::btScalar ) 
int btDbvt_ICollide_AllLeaves(void *c,void* p0); //method: AllLeaves bool ( ::btDbvt::ICollide::* )( ::btDbvtNode const * ) 
int btDbvt_ICollide_Descent(void *c,void* p0); //method: Descent bool ( ::btDbvt::ICollide::* )( ::btDbvtNode const * ) 
void btDbvt_IWriter_WriteLeaf(void *c,void* p0,int p1,int p2); //method: WriteLeaf void ( ::btDbvt::IWriter::* )( ::btDbvtNode const *,int,int ) 
void btDbvt_IWriter_WriteNode(void *c,void* p0,int p1,int p2,int p3,int p4); //method: WriteNode void ( ::btDbvt::IWriter::* )( ::btDbvtNode const *,int,int,int,int ) 
void btDbvt_IWriter_Prepare(void *c,void* p0,int p1); //method: Prepare void ( ::btDbvt::IWriter::* )( ::btDbvtNode const *,int ) 
void* bt32BitAxisSweep3_new(float* p0,float* p1,unsigned int p2,void* p3,int p4); //constructor: bt32BitAxisSweep3  ( ::bt32BitAxisSweep3::* )( ::btVector3 const &,::btVector3 const &,unsigned int,::btOverlappingPairCache *,bool ) 
void bt32BitAxisSweep3_free(void *c); 
void* btAxisSweep3_new(float* p0,float* p1,short unsigned int p2,void* p3,int p4); //constructor: btAxisSweep3  ( ::btAxisSweep3::* )( ::btVector3 const &,::btVector3 const &,short unsigned int,::btOverlappingPairCache *,bool ) 
void btAxisSweep3_free(void *c); 
void* btAxisSweep3Internal_unsignedint__new(float* p0,float* p1,unsigned int p2,unsigned int p3,unsigned int p4,void* p5,int p6); //constructor: btAxisSweep3Internal  ( ::btAxisSweep3Internal<unsigned int>::* )( ::btVector3 const &,::btVector3 const &,unsigned int,unsigned int,unsigned int,::btOverlappingPairCache *,bool ) 
void btAxisSweep3Internal_unsignedint__free(void *c); 
void btAxisSweep3Internal_unsignedint__sortMinUp(void *c,int p0,unsigned int p1,void* p2,int p3); //method: sortMinUp void ( ::btAxisSweep3Internal<unsigned int>::* )( int,unsigned int,::btDispatcher *,bool ) 
unsigned int btAxisSweep3Internal_unsignedint__allocHandle(void *c); //method: allocHandle unsigned int ( ::btAxisSweep3Internal<unsigned int>::* )(  ) 
unsigned int btAxisSweep3Internal_unsignedint__getNumHandles(void *c); //method: getNumHandles unsigned int ( ::btAxisSweep3Internal<unsigned int>::* )(  ) const
unsigned int btAxisSweep3Internal_unsignedint__addHandle(void *c,float* p0,float* p1,void* p2,short int p3,short int p4,void* p5,void* p6); //method: addHandle unsigned int ( ::btAxisSweep3Internal<unsigned int>::* )( ::btVector3 const &,::btVector3 const &,void *,short int,short int,::btDispatcher *,void * ) 
//not supported method: quantize void ( ::btAxisSweep3Internal<unsigned int>::* )( unsigned int *,::btVector3 const &,int ) const
// error:  - unsupported, ::btVector3 const & - ok, int - ok, void - ok

void btAxisSweep3Internal_unsignedint__sortMaxUp(void *c,int p0,unsigned int p1,void* p2,int p3); //method: sortMaxUp void ( ::btAxisSweep3Internal<unsigned int>::* )( int,unsigned int,::btDispatcher *,bool ) 
void btAxisSweep3Internal_unsignedint__removeHandle(void *c,unsigned int p0,void* p1); //method: removeHandle void ( ::btAxisSweep3Internal<unsigned int>::* )( unsigned int,::btDispatcher * ) 
void* btAxisSweep3Internal_unsignedint__getOverlappingPairUserCallback(void *c); //method: getOverlappingPairUserCallback ::btOverlappingPairCallback const * ( ::btAxisSweep3Internal<unsigned int>::* )(  ) const
void btAxisSweep3Internal_unsignedint__sortMaxDown(void *c,int p0,unsigned int p1,void* p2,int p3); //method: sortMaxDown void ( ::btAxisSweep3Internal<unsigned int>::* )( int,unsigned int,::btDispatcher *,bool ) 
void btAxisSweep3Internal_unsignedint__rayTest(void *c,float* p0,float* p1,void* p2,float* p3,float* p4); //method: rayTest void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseRayCallback &,::btVector3 const &,::btVector3 const & ) 
void btAxisSweep3Internal_unsignedint__setAabb(void *c,void* p0,float* p1,float* p2,void* p3); //method: setAabb void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btBroadphaseProxy *,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btAxisSweep3Internal_unsignedint__resetPool(void *c,void* p0); //method: resetPool void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btDispatcher * ) 
int btAxisSweep3Internal_unsignedint__testAabbOverlap(void *c,void* p0,void* p1); //method: testAabbOverlap bool ( ::btAxisSweep3Internal<unsigned int>::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void btAxisSweep3Internal_unsignedint__getAabb(void *c,void* p0,float* p1,float* p2); //method: getAabb void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
//not supported method: testOverlap2D bool ( ::btAxisSweep3Internal<unsigned int>::* )( ::btAxisSweep3Internal<unsigned int>::Handle const *,::btAxisSweep3Internal<unsigned int>::Handle const *,int,int ) 
// error:  - unsupported,  - unsupported, int - ok, int - ok, bool - ok

void btAxisSweep3Internal_unsignedint__updateHandle(void *c,unsigned int p0,float* p1,float* p2,void* p3); //method: updateHandle void ( ::btAxisSweep3Internal<unsigned int>::* )( unsigned int,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btAxisSweep3Internal_unsignedint__freeHandle(void *c,unsigned int p0); //method: freeHandle void ( ::btAxisSweep3Internal<unsigned int>::* )( unsigned int ) 
void btAxisSweep3Internal_unsignedint__printStats(void *c); //method: printStats void ( ::btAxisSweep3Internal<unsigned int>::* )(  ) 
void* btAxisSweep3Internal_unsignedint__createProxy(void *c,float* p0,float* p1,int p2,void* p3,short int p4,short int p5,void* p6,void* p7); //method: createProxy ::btBroadphaseProxy * ( ::btAxisSweep3Internal<unsigned int>::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int,::btDispatcher *,void * ) 
void btAxisSweep3Internal_unsignedint__setOverlappingPairUserCallback(void *c,void* p0); //method: setOverlappingPairUserCallback void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btOverlappingPairCallback * ) 
void btAxisSweep3Internal_unsignedint__calculateOverlappingPairs(void *c,void* p0); //method: calculateOverlappingPairs void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btDispatcher * ) 
void* btAxisSweep3Internal_unsignedint__getOverlappingPairCache(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btAxisSweep3Internal<unsigned int>::* )(  ) 
void* btAxisSweep3Internal_unsignedint__getOverlappingPairCache0(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btAxisSweep3Internal<unsigned int>::* )(  ) 
void* btAxisSweep3Internal_unsignedint__getOverlappingPairCache1(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache const * ( ::btAxisSweep3Internal<unsigned int>::* )(  ) const
void btAxisSweep3Internal_unsignedint__unQuantize(void *c,void* p0,float* p1,float* p2); //method: unQuantize void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
void btAxisSweep3Internal_unsignedint__sortMinDown(void *c,int p0,unsigned int p1,void* p2,int p3); //method: sortMinDown void ( ::btAxisSweep3Internal<unsigned int>::* )( int,unsigned int,::btDispatcher *,bool ) 
void btAxisSweep3Internal_unsignedint__aabbTest(void *c,float* p0,float* p1,void* p2); //method: aabbTest void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseAabbCallback & ) 
void btAxisSweep3Internal_unsignedint__getBroadphaseAabb(void *c,float* p0,float* p1); //method: getBroadphaseAabb void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btVector3 &,::btVector3 & ) const
void btAxisSweep3Internal_unsignedint__destroyProxy(void *c,void* p0,void* p1); //method: destroyProxy void ( ::btAxisSweep3Internal<unsigned int>::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
//not supported method: getHandle ::btAxisSweep3Internal<unsigned int>::Handle * ( ::btAxisSweep3Internal<unsigned int>::* )( unsigned int ) const
// error: unsigned int - ok,  - unsupported

void btAxisSweep3Internal_unsignedint__m_bpHandleMask_set(void *c,unsigned int a); //attribute: unsigned int btAxisSweep3Internal_unsignedint_->m_bpHandleMask
unsigned int btAxisSweep3Internal_unsignedint__m_bpHandleMask_get(void *c); //attribute: unsigned int btAxisSweep3Internal_unsignedint_->m_bpHandleMask
void btAxisSweep3Internal_unsignedint__m_handleSentinel_set(void *c,unsigned int a); //attribute: unsigned int btAxisSweep3Internal_unsignedint_->m_handleSentinel
unsigned int btAxisSweep3Internal_unsignedint__m_handleSentinel_get(void *c); //attribute: unsigned int btAxisSweep3Internal_unsignedint_->m_handleSentinel
void btAxisSweep3Internal_unsignedint__m_worldAabbMin_set(void *c,float* a); //attribute: ::btVector3 btAxisSweep3Internal_unsignedint_->m_worldAabbMin
void btAxisSweep3Internal_unsignedint__m_worldAabbMin_get(void *c,float* a);
void btAxisSweep3Internal_unsignedint__m_worldAabbMax_set(void *c,float* a); //attribute: ::btVector3 btAxisSweep3Internal_unsignedint_->m_worldAabbMax
void btAxisSweep3Internal_unsignedint__m_worldAabbMax_get(void *c,float* a);
void btAxisSweep3Internal_unsignedint__m_quantize_set(void *c,float* a); //attribute: ::btVector3 btAxisSweep3Internal_unsignedint_->m_quantize
void btAxisSweep3Internal_unsignedint__m_quantize_get(void *c,float* a);
void btAxisSweep3Internal_unsignedint__m_numHandles_set(void *c,unsigned int a); //attribute: unsigned int btAxisSweep3Internal_unsignedint_->m_numHandles
unsigned int btAxisSweep3Internal_unsignedint__m_numHandles_get(void *c); //attribute: unsigned int btAxisSweep3Internal_unsignedint_->m_numHandles
void btAxisSweep3Internal_unsignedint__m_maxHandles_set(void *c,unsigned int a); //attribute: unsigned int btAxisSweep3Internal_unsignedint_->m_maxHandles
unsigned int btAxisSweep3Internal_unsignedint__m_maxHandles_get(void *c); //attribute: unsigned int btAxisSweep3Internal_unsignedint_->m_maxHandles
// attribute not supported: //attribute: ::btAxisSweep3Internal<unsigned int>::Handle * btAxisSweep3Internal_unsignedint_->m_pHandles
void btAxisSweep3Internal_unsignedint__m_firstFreeHandle_set(void *c,unsigned int a); //attribute: unsigned int btAxisSweep3Internal_unsignedint_->m_firstFreeHandle
unsigned int btAxisSweep3Internal_unsignedint__m_firstFreeHandle_get(void *c); //attribute: unsigned int btAxisSweep3Internal_unsignedint_->m_firstFreeHandle
// attribute not supported: //attribute: ::btAxisSweep3Internal<unsigned int>::Edge *[3] btAxisSweep3Internal_unsignedint_->m_pEdges
// attribute not supported: //attribute: void *[3] btAxisSweep3Internal_unsignedint_->m_pEdgesRawPtr
void btAxisSweep3Internal_unsignedint__m_pairCache_set(void *c,void* a); //attribute: ::btOverlappingPairCache * btAxisSweep3Internal_unsignedint_->m_pairCache
void* btAxisSweep3Internal_unsignedint__m_pairCache_get(void *c); //attribute: ::btOverlappingPairCache * btAxisSweep3Internal_unsignedint_->m_pairCache
void btAxisSweep3Internal_unsignedint__m_userPairCallback_set(void *c,void* a); //attribute: ::btOverlappingPairCallback * btAxisSweep3Internal_unsignedint_->m_userPairCallback
void* btAxisSweep3Internal_unsignedint__m_userPairCallback_get(void *c); //attribute: ::btOverlappingPairCallback * btAxisSweep3Internal_unsignedint_->m_userPairCallback
void btAxisSweep3Internal_unsignedint__m_ownsPairCache_set(void *c,int a); //attribute: bool btAxisSweep3Internal_unsignedint_->m_ownsPairCache
int btAxisSweep3Internal_unsignedint__m_ownsPairCache_get(void *c); //attribute: bool btAxisSweep3Internal_unsignedint_->m_ownsPairCache
void btAxisSweep3Internal_unsignedint__m_invalidPair_set(void *c,int a); //attribute: int btAxisSweep3Internal_unsignedint_->m_invalidPair
int btAxisSweep3Internal_unsignedint__m_invalidPair_get(void *c); //attribute: int btAxisSweep3Internal_unsignedint_->m_invalidPair
void btAxisSweep3Internal_unsignedint__m_raycastAccelerator_set(void *c,void* a); //attribute: ::btDbvtBroadphase * btAxisSweep3Internal_unsignedint_->m_raycastAccelerator
void* btAxisSweep3Internal_unsignedint__m_raycastAccelerator_get(void *c); //attribute: ::btDbvtBroadphase * btAxisSweep3Internal_unsignedint_->m_raycastAccelerator
void btAxisSweep3Internal_unsignedint__m_nullPairCache_set(void *c,void* a); //attribute: ::btOverlappingPairCache * btAxisSweep3Internal_unsignedint_->m_nullPairCache
void* btAxisSweep3Internal_unsignedint__m_nullPairCache_get(void *c); //attribute: ::btOverlappingPairCache * btAxisSweep3Internal_unsignedint_->m_nullPairCache
void* btAxisSweep3Internal_unsignedshort__new(float* p0,float* p1,short unsigned int p2,short unsigned int p3,short unsigned int p4,void* p5,int p6); //constructor: btAxisSweep3Internal  ( ::btAxisSweep3Internal<unsigned short>::* )( ::btVector3 const &,::btVector3 const &,short unsigned int,short unsigned int,short unsigned int,::btOverlappingPairCache *,bool ) 
void btAxisSweep3Internal_unsignedshort__free(void *c); 
void btAxisSweep3Internal_unsignedshort__sortMinUp(void *c,int p0,short unsigned int p1,void* p2,int p3); //method: sortMinUp void ( ::btAxisSweep3Internal<unsigned short>::* )( int,short unsigned int,::btDispatcher *,bool ) 
short unsigned int btAxisSweep3Internal_unsignedshort__allocHandle(void *c); //method: allocHandle short unsigned int ( ::btAxisSweep3Internal<unsigned short>::* )(  ) 
short unsigned int btAxisSweep3Internal_unsignedshort__getNumHandles(void *c); //method: getNumHandles short unsigned int ( ::btAxisSweep3Internal<unsigned short>::* )(  ) const
short unsigned int btAxisSweep3Internal_unsignedshort__addHandle(void *c,float* p0,float* p1,void* p2,short int p3,short int p4,void* p5,void* p6); //method: addHandle short unsigned int ( ::btAxisSweep3Internal<unsigned short>::* )( ::btVector3 const &,::btVector3 const &,void *,short int,short int,::btDispatcher *,void * ) 
//not supported method: quantize void ( ::btAxisSweep3Internal<unsigned short>::* )( short unsigned int *,::btVector3 const &,int ) const
// error:  - unsupported, ::btVector3 const & - ok, int - ok, void - ok

void btAxisSweep3Internal_unsignedshort__sortMaxUp(void *c,int p0,short unsigned int p1,void* p2,int p3); //method: sortMaxUp void ( ::btAxisSweep3Internal<unsigned short>::* )( int,short unsigned int,::btDispatcher *,bool ) 
void btAxisSweep3Internal_unsignedshort__removeHandle(void *c,short unsigned int p0,void* p1); //method: removeHandle void ( ::btAxisSweep3Internal<unsigned short>::* )( short unsigned int,::btDispatcher * ) 
void* btAxisSweep3Internal_unsignedshort__getOverlappingPairUserCallback(void *c); //method: getOverlappingPairUserCallback ::btOverlappingPairCallback const * ( ::btAxisSweep3Internal<unsigned short>::* )(  ) const
void btAxisSweep3Internal_unsignedshort__sortMaxDown(void *c,int p0,short unsigned int p1,void* p2,int p3); //method: sortMaxDown void ( ::btAxisSweep3Internal<unsigned short>::* )( int,short unsigned int,::btDispatcher *,bool ) 
void btAxisSweep3Internal_unsignedshort__rayTest(void *c,float* p0,float* p1,void* p2,float* p3,float* p4); //method: rayTest void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseRayCallback &,::btVector3 const &,::btVector3 const & ) 
void btAxisSweep3Internal_unsignedshort__setAabb(void *c,void* p0,float* p1,float* p2,void* p3); //method: setAabb void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btBroadphaseProxy *,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btAxisSweep3Internal_unsignedshort__resetPool(void *c,void* p0); //method: resetPool void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btDispatcher * ) 
int btAxisSweep3Internal_unsignedshort__testAabbOverlap(void *c,void* p0,void* p1); //method: testAabbOverlap bool ( ::btAxisSweep3Internal<unsigned short>::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void btAxisSweep3Internal_unsignedshort__getAabb(void *c,void* p0,float* p1,float* p2); //method: getAabb void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
//not supported method: testOverlap2D bool ( ::btAxisSweep3Internal<unsigned short>::* )( ::btAxisSweep3Internal<unsigned short>::Handle const *,::btAxisSweep3Internal<unsigned short>::Handle const *,int,int ) 
// error:  - unsupported,  - unsupported, int - ok, int - ok, bool - ok

void btAxisSweep3Internal_unsignedshort__updateHandle(void *c,short unsigned int p0,float* p1,float* p2,void* p3); //method: updateHandle void ( ::btAxisSweep3Internal<unsigned short>::* )( short unsigned int,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btAxisSweep3Internal_unsignedshort__freeHandle(void *c,short unsigned int p0); //method: freeHandle void ( ::btAxisSweep3Internal<unsigned short>::* )( short unsigned int ) 
void btAxisSweep3Internal_unsignedshort__printStats(void *c); //method: printStats void ( ::btAxisSweep3Internal<unsigned short>::* )(  ) 
void* btAxisSweep3Internal_unsignedshort__createProxy(void *c,float* p0,float* p1,int p2,void* p3,short int p4,short int p5,void* p6,void* p7); //method: createProxy ::btBroadphaseProxy * ( ::btAxisSweep3Internal<unsigned short>::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int,::btDispatcher *,void * ) 
void btAxisSweep3Internal_unsignedshort__setOverlappingPairUserCallback(void *c,void* p0); //method: setOverlappingPairUserCallback void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btOverlappingPairCallback * ) 
void btAxisSweep3Internal_unsignedshort__calculateOverlappingPairs(void *c,void* p0); //method: calculateOverlappingPairs void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btDispatcher * ) 
void* btAxisSweep3Internal_unsignedshort__getOverlappingPairCache(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btAxisSweep3Internal<unsigned short>::* )(  ) 
void* btAxisSweep3Internal_unsignedshort__getOverlappingPairCache0(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btAxisSweep3Internal<unsigned short>::* )(  ) 
void* btAxisSweep3Internal_unsignedshort__getOverlappingPairCache1(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache const * ( ::btAxisSweep3Internal<unsigned short>::* )(  ) const
void btAxisSweep3Internal_unsignedshort__unQuantize(void *c,void* p0,float* p1,float* p2); //method: unQuantize void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
void btAxisSweep3Internal_unsignedshort__sortMinDown(void *c,int p0,short unsigned int p1,void* p2,int p3); //method: sortMinDown void ( ::btAxisSweep3Internal<unsigned short>::* )( int,short unsigned int,::btDispatcher *,bool ) 
void btAxisSweep3Internal_unsignedshort__aabbTest(void *c,float* p0,float* p1,void* p2); //method: aabbTest void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseAabbCallback & ) 
void btAxisSweep3Internal_unsignedshort__getBroadphaseAabb(void *c,float* p0,float* p1); //method: getBroadphaseAabb void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btVector3 &,::btVector3 & ) const
void btAxisSweep3Internal_unsignedshort__destroyProxy(void *c,void* p0,void* p1); //method: destroyProxy void ( ::btAxisSweep3Internal<unsigned short>::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
//not supported method: getHandle ::btAxisSweep3Internal<unsigned short>::Handle * ( ::btAxisSweep3Internal<unsigned short>::* )( short unsigned int ) const
// error: short unsigned int - ok,  - unsupported

void btAxisSweep3Internal_unsignedshort__m_bpHandleMask_set(void *c,short unsigned int a); //attribute: short unsigned int btAxisSweep3Internal_unsignedshort_->m_bpHandleMask
short unsigned int btAxisSweep3Internal_unsignedshort__m_bpHandleMask_get(void *c); //attribute: short unsigned int btAxisSweep3Internal_unsignedshort_->m_bpHandleMask
void btAxisSweep3Internal_unsignedshort__m_handleSentinel_set(void *c,short unsigned int a); //attribute: short unsigned int btAxisSweep3Internal_unsignedshort_->m_handleSentinel
short unsigned int btAxisSweep3Internal_unsignedshort__m_handleSentinel_get(void *c); //attribute: short unsigned int btAxisSweep3Internal_unsignedshort_->m_handleSentinel
void btAxisSweep3Internal_unsignedshort__m_worldAabbMin_set(void *c,float* a); //attribute: ::btVector3 btAxisSweep3Internal_unsignedshort_->m_worldAabbMin
void btAxisSweep3Internal_unsignedshort__m_worldAabbMin_get(void *c,float* a);
void btAxisSweep3Internal_unsignedshort__m_worldAabbMax_set(void *c,float* a); //attribute: ::btVector3 btAxisSweep3Internal_unsignedshort_->m_worldAabbMax
void btAxisSweep3Internal_unsignedshort__m_worldAabbMax_get(void *c,float* a);
void btAxisSweep3Internal_unsignedshort__m_quantize_set(void *c,float* a); //attribute: ::btVector3 btAxisSweep3Internal_unsignedshort_->m_quantize
void btAxisSweep3Internal_unsignedshort__m_quantize_get(void *c,float* a);
void btAxisSweep3Internal_unsignedshort__m_numHandles_set(void *c,short unsigned int a); //attribute: short unsigned int btAxisSweep3Internal_unsignedshort_->m_numHandles
short unsigned int btAxisSweep3Internal_unsignedshort__m_numHandles_get(void *c); //attribute: short unsigned int btAxisSweep3Internal_unsignedshort_->m_numHandles
void btAxisSweep3Internal_unsignedshort__m_maxHandles_set(void *c,short unsigned int a); //attribute: short unsigned int btAxisSweep3Internal_unsignedshort_->m_maxHandles
short unsigned int btAxisSweep3Internal_unsignedshort__m_maxHandles_get(void *c); //attribute: short unsigned int btAxisSweep3Internal_unsignedshort_->m_maxHandles
// attribute not supported: //attribute: ::btAxisSweep3Internal<unsigned short>::Handle * btAxisSweep3Internal_unsignedshort_->m_pHandles
void btAxisSweep3Internal_unsignedshort__m_firstFreeHandle_set(void *c,short unsigned int a); //attribute: short unsigned int btAxisSweep3Internal_unsignedshort_->m_firstFreeHandle
short unsigned int btAxisSweep3Internal_unsignedshort__m_firstFreeHandle_get(void *c); //attribute: short unsigned int btAxisSweep3Internal_unsignedshort_->m_firstFreeHandle
// attribute not supported: //attribute: ::btAxisSweep3Internal<unsigned short>::Edge *[3] btAxisSweep3Internal_unsignedshort_->m_pEdges
// attribute not supported: //attribute: void *[3] btAxisSweep3Internal_unsignedshort_->m_pEdgesRawPtr
void btAxisSweep3Internal_unsignedshort__m_pairCache_set(void *c,void* a); //attribute: ::btOverlappingPairCache * btAxisSweep3Internal_unsignedshort_->m_pairCache
void* btAxisSweep3Internal_unsignedshort__m_pairCache_get(void *c); //attribute: ::btOverlappingPairCache * btAxisSweep3Internal_unsignedshort_->m_pairCache
void btAxisSweep3Internal_unsignedshort__m_userPairCallback_set(void *c,void* a); //attribute: ::btOverlappingPairCallback * btAxisSweep3Internal_unsignedshort_->m_userPairCallback
void* btAxisSweep3Internal_unsignedshort__m_userPairCallback_get(void *c); //attribute: ::btOverlappingPairCallback * btAxisSweep3Internal_unsignedshort_->m_userPairCallback
void btAxisSweep3Internal_unsignedshort__m_ownsPairCache_set(void *c,int a); //attribute: bool btAxisSweep3Internal_unsignedshort_->m_ownsPairCache
int btAxisSweep3Internal_unsignedshort__m_ownsPairCache_get(void *c); //attribute: bool btAxisSweep3Internal_unsignedshort_->m_ownsPairCache
void btAxisSweep3Internal_unsignedshort__m_invalidPair_set(void *c,int a); //attribute: int btAxisSweep3Internal_unsignedshort_->m_invalidPair
int btAxisSweep3Internal_unsignedshort__m_invalidPair_get(void *c); //attribute: int btAxisSweep3Internal_unsignedshort_->m_invalidPair
void btAxisSweep3Internal_unsignedshort__m_raycastAccelerator_set(void *c,void* a); //attribute: ::btDbvtBroadphase * btAxisSweep3Internal_unsignedshort_->m_raycastAccelerator
void* btAxisSweep3Internal_unsignedshort__m_raycastAccelerator_get(void *c); //attribute: ::btDbvtBroadphase * btAxisSweep3Internal_unsignedshort_->m_raycastAccelerator
void btAxisSweep3Internal_unsignedshort__m_nullPairCache_set(void *c,void* a); //attribute: ::btOverlappingPairCache * btAxisSweep3Internal_unsignedshort_->m_nullPairCache
void* btAxisSweep3Internal_unsignedshort__m_nullPairCache_get(void *c); //attribute: ::btOverlappingPairCache * btAxisSweep3Internal_unsignedshort_->m_nullPairCache
void* btMultiSapBroadphase_btBridgeProxy_new(); //constructor: btBridgeProxy  ( ::btMultiSapBroadphase::btBridgeProxy::* )(  ) 
void btMultiSapBroadphase_btBridgeProxy_free(void *c); 
void btMultiSapBroadphase_btBridgeProxy_m_childBroadphase_set(void *c,void* a); //attribute: ::btBroadphaseInterface * btMultiSapBroadphase_btBridgeProxy->m_childBroadphase
void* btMultiSapBroadphase_btBridgeProxy_m_childBroadphase_get(void *c); //attribute: ::btBroadphaseInterface * btMultiSapBroadphase_btBridgeProxy->m_childBroadphase
void btMultiSapBroadphase_btBridgeProxy_m_childProxy_set(void *c,void* a); //attribute: ::btBroadphaseProxy * btMultiSapBroadphase_btBridgeProxy->m_childProxy
void* btMultiSapBroadphase_btBridgeProxy_m_childProxy_get(void *c); //attribute: ::btBroadphaseProxy * btMultiSapBroadphase_btBridgeProxy->m_childProxy
int btBroadphaseAabbCallback_process(void *c,void* p0); //method: process bool ( ::btBroadphaseAabbCallback::* )( ::btBroadphaseProxy const * ) 
void btBroadphaseInterface_rayTest(void *c,float* p0,float* p1,void* p2,float* p3,float* p4); //method: rayTest void ( ::btBroadphaseInterface::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseRayCallback &,::btVector3 const &,::btVector3 const & ) 
void btBroadphaseInterface_setAabb(void *c,void* p0,float* p1,float* p2,void* p3); //method: setAabb void ( ::btBroadphaseInterface::* )( ::btBroadphaseProxy *,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btBroadphaseInterface_getBroadphaseAabb(void *c,float* p0,float* p1); //method: getBroadphaseAabb void ( ::btBroadphaseInterface::* )( ::btVector3 &,::btVector3 & ) const
void btBroadphaseInterface_resetPool(void *c,void* p0); //method: resetPool void ( ::btBroadphaseInterface::* )( ::btDispatcher * ) 
void btBroadphaseInterface_calculateOverlappingPairs(void *c,void* p0); //method: calculateOverlappingPairs void ( ::btBroadphaseInterface::* )( ::btDispatcher * ) 
void btBroadphaseInterface_printStats(void *c); //method: printStats void ( ::btBroadphaseInterface::* )(  ) 
void btBroadphaseInterface_getAabb(void *c,void* p0,float* p1,float* p2); //method: getAabb void ( ::btBroadphaseInterface::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
void btBroadphaseInterface_aabbTest(void *c,float* p0,float* p1,void* p2); //method: aabbTest void ( ::btBroadphaseInterface::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseAabbCallback & ) 
void* btBroadphaseInterface_createProxy(void *c,float* p0,float* p1,int p2,void* p3,short int p4,short int p5,void* p6,void* p7); //method: createProxy ::btBroadphaseProxy * ( ::btBroadphaseInterface::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int,::btDispatcher *,void * ) 
void* btBroadphaseInterface_getOverlappingPairCache(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btBroadphaseInterface::* )(  ) 
void* btBroadphaseInterface_getOverlappingPairCache0(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btBroadphaseInterface::* )(  ) 
void* btBroadphaseInterface_getOverlappingPairCache1(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache const * ( ::btBroadphaseInterface::* )(  ) const
void btBroadphaseInterface_destroyProxy(void *c,void* p0,void* p1); //method: destroyProxy void ( ::btBroadphaseInterface::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void* btBroadphasePair_new0(); //constructor: btBroadphasePair  ( ::btBroadphasePair::* )(  ) 
void* btBroadphasePair_new1(void* p0,void* p1); //constructor: btBroadphasePair  ( ::btBroadphasePair::* )( ::btBroadphaseProxy &,::btBroadphaseProxy & ) 
void btBroadphasePair_free(void *c); 
// attribute not supported: //attribute: ::btBroadphasePair btBroadphasePair->
void btBroadphasePair_m_algorithm_set(void *c,void* a); //attribute: ::btCollisionAlgorithm * btBroadphasePair->m_algorithm
void* btBroadphasePair_m_algorithm_get(void *c); //attribute: ::btCollisionAlgorithm * btBroadphasePair->m_algorithm
void btBroadphasePair_m_pProxy0_set(void *c,void* a); //attribute: ::btBroadphaseProxy * btBroadphasePair->m_pProxy0
void* btBroadphasePair_m_pProxy0_get(void *c); //attribute: ::btBroadphaseProxy * btBroadphasePair->m_pProxy0
void btBroadphasePair_m_pProxy1_set(void *c,void* a); //attribute: ::btBroadphaseProxy * btBroadphasePair->m_pProxy1
void* btBroadphasePair_m_pProxy1_get(void *c); //attribute: ::btBroadphaseProxy * btBroadphasePair->m_pProxy1
void* btBroadphasePairSortPredicate_new(); //constructor: btBroadphasePairSortPredicate  ( ::btBroadphasePairSortPredicate::* )(  ) 
void btBroadphasePairSortPredicate_free(void *c); 
void* btBroadphaseProxy_new0(); //constructor: btBroadphaseProxy  ( ::btBroadphaseProxy::* )(  ) 
void* btBroadphaseProxy_new1(float* p0,float* p1,void* p2,short int p3,short int p4,void* p5); //constructor: btBroadphaseProxy  ( ::btBroadphaseProxy::* )( ::btVector3 const &,::btVector3 const &,void *,short int,short int,void * ) 
void btBroadphaseProxy_free(void *c); 
int btBroadphaseProxy_isConvex(int p0); //method: isConvex bool (*)( int )
int btBroadphaseProxy_isInfinite(int p0); //method: isInfinite bool (*)( int )
int btBroadphaseProxy_getUid(void *c); //method: getUid int ( ::btBroadphaseProxy::* )(  ) const
int btBroadphaseProxy_isConcave(int p0); //method: isConcave bool (*)( int )
int btBroadphaseProxy_isNonMoving(int p0); //method: isNonMoving bool (*)( int )
int btBroadphaseProxy_isCompound(int p0); //method: isCompound bool (*)( int )
int btBroadphaseProxy_isPolyhedral(int p0); //method: isPolyhedral bool (*)( int )
int btBroadphaseProxy_isConvex2d(int p0); //method: isConvex2d bool (*)( int )
int btBroadphaseProxy_isSoftBody(int p0); //method: isSoftBody bool (*)( int )
void btBroadphaseProxy_m_aabbMax_set(void *c,float* a); //attribute: ::btVector3 btBroadphaseProxy->m_aabbMax
void btBroadphaseProxy_m_aabbMax_get(void *c,float* a);
void btBroadphaseProxy_m_aabbMin_set(void *c,float* a); //attribute: ::btVector3 btBroadphaseProxy->m_aabbMin
void btBroadphaseProxy_m_aabbMin_get(void *c,float* a);
void btBroadphaseProxy_m_clientObject_set(void *c,void* a); //attribute: void * btBroadphaseProxy->m_clientObject
void* btBroadphaseProxy_m_clientObject_get(void *c); //attribute: void * btBroadphaseProxy->m_clientObject
void btBroadphaseProxy_m_collisionFilterGroup_set(void *c,short int a); //attribute: short int btBroadphaseProxy->m_collisionFilterGroup
short int btBroadphaseProxy_m_collisionFilterGroup_get(void *c); //attribute: short int btBroadphaseProxy->m_collisionFilterGroup
void btBroadphaseProxy_m_collisionFilterMask_set(void *c,short int a); //attribute: short int btBroadphaseProxy->m_collisionFilterMask
short int btBroadphaseProxy_m_collisionFilterMask_get(void *c); //attribute: short int btBroadphaseProxy->m_collisionFilterMask
void btBroadphaseProxy_m_multiSapParentProxy_set(void *c,void* a); //attribute: void * btBroadphaseProxy->m_multiSapParentProxy
void* btBroadphaseProxy_m_multiSapParentProxy_get(void *c); //attribute: void * btBroadphaseProxy->m_multiSapParentProxy
void btBroadphaseProxy_m_uniqueId_set(void *c,int a); //attribute: int btBroadphaseProxy->m_uniqueId
int btBroadphaseProxy_m_uniqueId_get(void *c); //attribute: int btBroadphaseProxy->m_uniqueId
void btBroadphaseRayCallback_m_lambda_max_set(void *c,float a); //attribute: ::btScalar btBroadphaseRayCallback->m_lambda_max
float btBroadphaseRayCallback_m_lambda_max_get(void *c); //attribute: ::btScalar btBroadphaseRayCallback->m_lambda_max
void btBroadphaseRayCallback_m_rayDirectionInverse_set(void *c,float* a); //attribute: ::btVector3 btBroadphaseRayCallback->m_rayDirectionInverse
void btBroadphaseRayCallback_m_rayDirectionInverse_get(void *c,float* a);
// attribute not supported: //attribute: unsigned int[3] btBroadphaseRayCallback->m_signs
void* btBvhSubtreeInfo_new(); //constructor: btBvhSubtreeInfo  ( ::btBvhSubtreeInfo::* )(  ) 
void btBvhSubtreeInfo_free(void *c); 
void btBvhSubtreeInfo_setAabbFromQuantizeNode(void *c,void* p0); //method: setAabbFromQuantizeNode void ( ::btBvhSubtreeInfo::* )( ::btQuantizedBvhNode const & ) 
// attribute not supported: //attribute: int[3] btBvhSubtreeInfo->m_padding
// attribute not supported: //attribute: short unsigned int[3] btBvhSubtreeInfo->m_quantizedAabbMax
// attribute not supported: //attribute: short unsigned int[3] btBvhSubtreeInfo->m_quantizedAabbMin
void btBvhSubtreeInfo_m_rootNodeIndex_set(void *c,int a); //attribute: int btBvhSubtreeInfo->m_rootNodeIndex
int btBvhSubtreeInfo_m_rootNodeIndex_get(void *c); //attribute: int btBvhSubtreeInfo->m_rootNodeIndex
void btBvhSubtreeInfo_m_subtreeSize_set(void *c,int a); //attribute: int btBvhSubtreeInfo->m_subtreeSize
int btBvhSubtreeInfo_m_subtreeSize_get(void *c); //attribute: int btBvhSubtreeInfo->m_subtreeSize
void* btBvhSubtreeInfoData_new(); //constructor: btBvhSubtreeInfoData  ( ::btBvhSubtreeInfoData::* )(  ) 
void btBvhSubtreeInfoData_free(void *c); 
void btBvhSubtreeInfoData_m_rootNodeIndex_set(void *c,int a); //attribute: int btBvhSubtreeInfoData->m_rootNodeIndex
int btBvhSubtreeInfoData_m_rootNodeIndex_get(void *c); //attribute: int btBvhSubtreeInfoData->m_rootNodeIndex
void btBvhSubtreeInfoData_m_subtreeSize_set(void *c,int a); //attribute: int btBvhSubtreeInfoData->m_subtreeSize
int btBvhSubtreeInfoData_m_subtreeSize_get(void *c); //attribute: int btBvhSubtreeInfoData->m_subtreeSize
// attribute not supported: //attribute: short unsigned int[3] btBvhSubtreeInfoData->m_quantizedAabbMin
// attribute not supported: //attribute: short unsigned int[3] btBvhSubtreeInfoData->m_quantizedAabbMax
void btCollisionAlgorithm_getAllContactManifolds(void *c,void* p0); //method: getAllContactManifolds void ( ::btCollisionAlgorithm::* )( ::btManifoldArray & ) 
float btCollisionAlgorithm_calculateTimeOfImpact(void *c,void* p0,void* p1,void* p2,void* p3); //method: calculateTimeOfImpact ::btScalar ( ::btCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
void btCollisionAlgorithm_processCollision(void *c,void* p0,void* p1,void* p2,void* p3); //method: processCollision void ( ::btCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
void btCollisionAlgorithm_m_dispatcher_set(void *c,void* a); //attribute: ::btDispatcher * btCollisionAlgorithm->m_dispatcher
void* btCollisionAlgorithm_m_dispatcher_get(void *c); //attribute: ::btDispatcher * btCollisionAlgorithm->m_dispatcher
void* btCollisionAlgorithmConstructionInfo_new0(); //constructor: btCollisionAlgorithmConstructionInfo  ( ::btCollisionAlgorithmConstructionInfo::* )(  ) 
void* btCollisionAlgorithmConstructionInfo_new1(void* p0,int p1); //constructor: btCollisionAlgorithmConstructionInfo  ( ::btCollisionAlgorithmConstructionInfo::* )( ::btDispatcher *,int ) 
void btCollisionAlgorithmConstructionInfo_free(void *c); 
void btCollisionAlgorithmConstructionInfo_m_dispatcher1_set(void *c,void* a); //attribute: ::btDispatcher * btCollisionAlgorithmConstructionInfo->m_dispatcher1
void* btCollisionAlgorithmConstructionInfo_m_dispatcher1_get(void *c); //attribute: ::btDispatcher * btCollisionAlgorithmConstructionInfo->m_dispatcher1
void btCollisionAlgorithmConstructionInfo_m_manifold_set(void *c,void* a); //attribute: ::btPersistentManifold * btCollisionAlgorithmConstructionInfo->m_manifold
void* btCollisionAlgorithmConstructionInfo_m_manifold_get(void *c); //attribute: ::btPersistentManifold * btCollisionAlgorithmConstructionInfo->m_manifold
void* btDbvt_new(); //constructor: btDbvt  ( ::btDbvt::* )(  ) 
void btDbvt_free(void *c); 
//not supported method: nearest int (*)( int const *,::btDbvt::sStkNPS const *,::btScalar,int,int )
// error:  - unsupported, ::btDbvt::sStkNPS const * - ok, ::btScalar - ok, int - ok, int - ok, int - ok

void btDbvt_enumLeaves(void* p0,void* p1); //method: enumLeaves void (*)( ::btDbvtNode const *,::btDbvt::ICollide & )
void btDbvt_optimizeIncremental(void *c,int p0); //method: optimizeIncremental void ( ::btDbvt::* )( int ) 
void btDbvt_rayTest(void* p0,float* p1,float* p2,void* p3); //method: rayTest void (*)( ::btDbvtNode const *,::btVector3 const &,::btVector3 const &,::btDbvt::ICollide & )
void btDbvt_optimizeTopDown(void *c,int p0); //method: optimizeTopDown void ( ::btDbvt::* )( int ) 
void btDbvt_enumNodes(void* p0,void* p1); //method: enumNodes void (*)( ::btDbvtNode const *,::btDbvt::ICollide & )
void btDbvt_write(void *c,void* p0); //method: write void ( ::btDbvt::* )( ::btDbvt::IWriter * ) const
int btDbvt_allocate(void* p0,void* p1,void* p2); //method: allocate int (*)( ::btAlignedObjectArray<int> &,::btAlignedObjectArray<btDbvt::sStkNPS> &,::btDbvt::sStkNPS const & )
int btDbvt_empty(void *c); //method: empty bool ( ::btDbvt::* )(  ) const
void btDbvt_collideTV(void *c,void* p0,void* p1,void* p2); //method: collideTV void ( ::btDbvt::* )( ::btDbvtNode const *,::btDbvtVolume const &,::btDbvt::ICollide & ) 
void btDbvt_collideTU(void* p0,void* p1); //method: collideTU void (*)( ::btDbvtNode const *,::btDbvt::ICollide & )
void btDbvt_collideTT(void *c,void* p0,void* p1,void* p2); //method: collideTT void ( ::btDbvt::* )( ::btDbvtNode const *,::btDbvtNode const *,::btDbvt::ICollide & ) 
void btDbvt_collideTTpersistentStack(void *c,void* p0,void* p1,void* p2); //method: collideTTpersistentStack void ( ::btDbvt::* )( ::btDbvtNode const *,::btDbvtNode const *,::btDbvt::ICollide & ) 
void btDbvt_clone(void *c,void* p0,void* p1); //method: clone void ( ::btDbvt::* )( ::btDbvt &,::btDbvt::IClone * ) const
void btDbvt_benchmark(); //method: benchmark void (*)(  )
void btDbvt_update(void *c,void* p0,int p1); //method: update void ( ::btDbvt::* )( ::btDbvtNode *,int ) 
void btDbvt_update0(void *c,void* p0,int p1); //method: update void ( ::btDbvt::* )( ::btDbvtNode *,int ) 
void btDbvt_update1(void *c,void* p0,void* p1); //method: update void ( ::btDbvt::* )( ::btDbvtNode *,::btDbvtVolume & ) 
int btDbvt_update2(void *c,void* p0,void* p1,float* p2,float p3); //method: update bool ( ::btDbvt::* )( ::btDbvtNode *,::btDbvtVolume &,::btVector3 const &,::btScalar ) 
int btDbvt_update3(void *c,void* p0,void* p1,float* p2); //method: update bool ( ::btDbvt::* )( ::btDbvtNode *,::btDbvtVolume &,::btVector3 const & ) 
int btDbvt_update4(void *c,void* p0,void* p1,float p2); //method: update bool ( ::btDbvt::* )( ::btDbvtNode *,::btDbvtVolume &,::btScalar ) 
int btDbvt_countLeaves(void* p0); //method: countLeaves int (*)( ::btDbvtNode const * )
//not supported method: collideOCL void (*)( ::btDbvtNode const *,::btVector3 const *,::btScalar const *,::btVector3 const &,int,::btDbvt::ICollide &,bool )
// error: ::btDbvtNode const * - ok,  - unsupported,  - unsupported, ::btVector3 const & - ok, int - ok, ::btDbvt::ICollide & - ok, bool - ok, void - ok

void* btDbvt_insert(void *c,void* p0,void* p1); //method: insert ::btDbvtNode * ( ::btDbvt::* )( ::btDbvtVolume const &,void * ) 
//not supported method: collideKDOP void (*)( ::btDbvtNode const *,::btVector3 const *,::btScalar const *,int,::btDbvt::ICollide & )
// error: ::btDbvtNode const * - ok,  - unsupported,  - unsupported, int - ok, ::btDbvt::ICollide & - ok, void - ok

void btDbvt_extractLeaves(void* p0,void* p1); //method: extractLeaves void (*)( ::btDbvtNode const *,::btAlignedObjectArray<btDbvtNode const*> & )
void btDbvt_remove(void *c,void* p0); //method: remove void ( ::btDbvt::* )( ::btDbvtNode * ) 
//not supported method: rayTestInternal void ( ::btDbvt::* )( ::btDbvtNode const *,::btVector3 const &,::btVector3 const &,::btVector3 const &,unsigned int *,::btScalar,::btVector3 const &,::btVector3 const &,::btDbvt::ICollide & ) const
// error: ::btDbvtNode const * - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported, ::btScalar - ok, ::btVector3 const & - ok, ::btVector3 const & - ok, ::btDbvt::ICollide & - ok, void - ok

int btDbvt_maxdepth(void* p0); //method: maxdepth int (*)( ::btDbvtNode const * )
void btDbvt_clear(void *c); //method: clear void ( ::btDbvt::* )(  ) 
void btDbvt_optimizeBottomUp(void *c); //method: optimizeBottomUp void ( ::btDbvt::* )(  ) 
void btDbvt_m_free_set(void *c,void* a); //attribute: ::btDbvtNode * btDbvt->m_free
void* btDbvt_m_free_get(void *c); //attribute: ::btDbvtNode * btDbvt->m_free
void btDbvt_m_leaves_set(void *c,int a); //attribute: int btDbvt->m_leaves
int btDbvt_m_leaves_get(void *c); //attribute: int btDbvt->m_leaves
void btDbvt_m_lkhd_set(void *c,int a); //attribute: int btDbvt->m_lkhd
int btDbvt_m_lkhd_get(void *c); //attribute: int btDbvt->m_lkhd
void btDbvt_m_opath_set(void *c,unsigned int a); //attribute: unsigned int btDbvt->m_opath
unsigned int btDbvt_m_opath_get(void *c); //attribute: unsigned int btDbvt->m_opath
void btDbvt_m_root_set(void *c,void* a); //attribute: ::btDbvtNode * btDbvt->m_root
void* btDbvt_m_root_get(void *c); //attribute: ::btDbvtNode * btDbvt->m_root
void btDbvt_m_stkStack_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btDbvt::sStkNN> btDbvt->m_stkStack
void* btDbvt_m_stkStack_get(void *c); //attribute: ::btAlignedObjectArray<btDbvt::sStkNN> btDbvt->m_stkStack
void* btDbvtAabbMm_new(); //constructor: btDbvtAabbMm  ( ::btDbvtAabbMm::* )(  ) 
void btDbvtAabbMm_free(void *c); 
void btDbvtAabbMm_SignedExpand(void *c,float* p0); //method: SignedExpand void ( ::btDbvtAabbMm::* )( ::btVector3 const & ) 
void btDbvtAabbMm_Extents(void *c,float* ret); //method: Extents ::btVector3 ( ::btDbvtAabbMm::* )(  ) const
void btDbvtAabbMm_Center(void *c,float* ret); //method: Center ::btVector3 ( ::btDbvtAabbMm::* )(  ) const
void btDbvtAabbMm_Lengths(void *c,float* ret); //method: Lengths ::btVector3 ( ::btDbvtAabbMm::* )(  ) const
void btDbvtAabbMm_Maxs(void *c,float* ret); //method: Maxs ::btVector3 const & ( ::btDbvtAabbMm::* )(  ) const
//not supported method: FromCE ::btDbvtAabbMm (*)( ::btVector3 const &,::btVector3 const & )
// error: ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported

//not supported method: FromMM ::btDbvtAabbMm (*)( ::btVector3 const &,::btVector3 const & )
// error: ::btVector3 const & - ok, ::btVector3 const & - ok,  - unsupported

float btDbvtAabbMm_ProjectMinimum(void *c,float* p0,unsigned int p1); //method: ProjectMinimum ::btScalar ( ::btDbvtAabbMm::* )( ::btVector3 const &,unsigned int ) const
int btDbvtAabbMm_Classify(void *c,float* p0,float p1,int p2); //method: Classify int ( ::btDbvtAabbMm::* )( ::btVector3 const &,::btScalar,int ) const
int btDbvtAabbMm_Contain(void *c,void* p0); //method: Contain bool ( ::btDbvtAabbMm::* )( ::btDbvtAabbMm const & ) const
//not supported method: AddSpan void ( ::btDbvtAabbMm::* )( ::btVector3 const &,::btScalar &,::btScalar & ) const
// error: ::btVector3 const & - ok,  - unsupported,  - unsupported, void - ok

void btDbvtAabbMm_Mins(void *c,float* ret); //method: Mins ::btVector3 const & ( ::btDbvtAabbMm::* )(  ) const
//not supported method: FromCR ::btDbvtAabbMm (*)( ::btVector3 const &,::btScalar )
// error: ::btVector3 const & - ok, ::btScalar - ok,  - unsupported

void btDbvtAabbMm_Expand(void *c,float* p0); //method: Expand void ( ::btDbvtAabbMm::* )( ::btVector3 const & ) 
//not supported method: FromPoints ::btDbvtAabbMm (*)( ::btVector3 const *,int )
// error:  - unsupported, int - ok,  - unsupported

//not supported method: FromPoints ::btDbvtAabbMm (*)( ::btVector3 const *,int )
// error:  - unsupported, int - ok,  - unsupported

//not supported method: FromPoints ::btDbvtAabbMm (*)( ::btVector3 const * *,int )
// error:  - unsupported, int - ok,  - unsupported

void btDbvtAabbMm_mi_set(void *c,float* a); //attribute: ::btVector3 btDbvtAabbMm->mi
void btDbvtAabbMm_mi_get(void *c,float* a);
void btDbvtAabbMm_mx_set(void *c,float* a); //attribute: ::btVector3 btDbvtAabbMm->mx
void btDbvtAabbMm_mx_get(void *c,float* a);
void* btDbvtBroadphase_new(void* p0); //constructor: btDbvtBroadphase  ( ::btDbvtBroadphase::* )( ::btOverlappingPairCache * ) 
void btDbvtBroadphase_free(void *c); 
void btDbvtBroadphase_setVelocityPrediction(void *c,float p0); //method: setVelocityPrediction void ( ::btDbvtBroadphase::* )( ::btScalar ) 
void btDbvtBroadphase_rayTest(void *c,float* p0,float* p1,void* p2,float* p3,float* p4); //method: rayTest void ( ::btDbvtBroadphase::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseRayCallback &,::btVector3 const &,::btVector3 const & ) 
void btDbvtBroadphase_performDeferredRemoval(void *c,void* p0); //method: performDeferredRemoval void ( ::btDbvtBroadphase::* )( ::btDispatcher * ) 
void btDbvtBroadphase_setAabb(void *c,void* p0,float* p1,float* p2,void* p3); //method: setAabb void ( ::btDbvtBroadphase::* )( ::btBroadphaseProxy *,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btDbvtBroadphase_getBroadphaseAabb(void *c,float* p0,float* p1); //method: getBroadphaseAabb void ( ::btDbvtBroadphase::* )( ::btVector3 &,::btVector3 & ) const
float btDbvtBroadphase_getVelocityPrediction(void *c); //method: getVelocityPrediction ::btScalar ( ::btDbvtBroadphase::* )(  ) const
void btDbvtBroadphase_benchmark(void* p0); //method: benchmark void (*)( ::btBroadphaseInterface * )
void btDbvtBroadphase_collide(void *c,void* p0); //method: collide void ( ::btDbvtBroadphase::* )( ::btDispatcher * ) 
void btDbvtBroadphase_resetPool(void *c,void* p0); //method: resetPool void ( ::btDbvtBroadphase::* )( ::btDispatcher * ) 
void btDbvtBroadphase_optimize(void *c); //method: optimize void ( ::btDbvtBroadphase::* )(  ) 
void btDbvtBroadphase_calculateOverlappingPairs(void *c,void* p0); //method: calculateOverlappingPairs void ( ::btDbvtBroadphase::* )( ::btDispatcher * ) 
void btDbvtBroadphase_setAabbForceUpdate(void *c,void* p0,float* p1,float* p2,void* p3); //method: setAabbForceUpdate void ( ::btDbvtBroadphase::* )( ::btBroadphaseProxy *,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void btDbvtBroadphase_printStats(void *c); //method: printStats void ( ::btDbvtBroadphase::* )(  ) 
void btDbvtBroadphase_getAabb(void *c,void* p0,float* p1,float* p2); //method: getAabb void ( ::btDbvtBroadphase::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
void btDbvtBroadphase_aabbTest(void *c,float* p0,float* p1,void* p2); //method: aabbTest void ( ::btDbvtBroadphase::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseAabbCallback & ) 
void* btDbvtBroadphase_createProxy(void *c,float* p0,float* p1,int p2,void* p3,short int p4,short int p5,void* p6,void* p7); //method: createProxy ::btBroadphaseProxy * ( ::btDbvtBroadphase::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int,::btDispatcher *,void * ) 
void* btDbvtBroadphase_getOverlappingPairCache(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btDbvtBroadphase::* )(  ) 
void* btDbvtBroadphase_getOverlappingPairCache0(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btDbvtBroadphase::* )(  ) 
void* btDbvtBroadphase_getOverlappingPairCache1(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache const * ( ::btDbvtBroadphase::* )(  ) const
void btDbvtBroadphase_destroyProxy(void *c,void* p0,void* p1); //method: destroyProxy void ( ::btDbvtBroadphase::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btDbvtBroadphase_m_cid_set(void *c,int a); //attribute: int btDbvtBroadphase->m_cid
int btDbvtBroadphase_m_cid_get(void *c); //attribute: int btDbvtBroadphase->m_cid
void btDbvtBroadphase_m_cupdates_set(void *c,int a); //attribute: int btDbvtBroadphase->m_cupdates
int btDbvtBroadphase_m_cupdates_get(void *c); //attribute: int btDbvtBroadphase->m_cupdates
void btDbvtBroadphase_m_deferedcollide_set(void *c,int a); //attribute: bool btDbvtBroadphase->m_deferedcollide
int btDbvtBroadphase_m_deferedcollide_get(void *c); //attribute: bool btDbvtBroadphase->m_deferedcollide
void btDbvtBroadphase_m_dupdates_set(void *c,int a); //attribute: int btDbvtBroadphase->m_dupdates
int btDbvtBroadphase_m_dupdates_get(void *c); //attribute: int btDbvtBroadphase->m_dupdates
void btDbvtBroadphase_m_fixedleft_set(void *c,int a); //attribute: int btDbvtBroadphase->m_fixedleft
int btDbvtBroadphase_m_fixedleft_get(void *c); //attribute: int btDbvtBroadphase->m_fixedleft
void btDbvtBroadphase_m_fupdates_set(void *c,int a); //attribute: int btDbvtBroadphase->m_fupdates
int btDbvtBroadphase_m_fupdates_get(void *c); //attribute: int btDbvtBroadphase->m_fupdates
void btDbvtBroadphase_m_gid_set(void *c,int a); //attribute: int btDbvtBroadphase->m_gid
int btDbvtBroadphase_m_gid_get(void *c); //attribute: int btDbvtBroadphase->m_gid
void btDbvtBroadphase_m_needcleanup_set(void *c,int a); //attribute: bool btDbvtBroadphase->m_needcleanup
int btDbvtBroadphase_m_needcleanup_get(void *c); //attribute: bool btDbvtBroadphase->m_needcleanup
void btDbvtBroadphase_m_newpairs_set(void *c,int a); //attribute: int btDbvtBroadphase->m_newpairs
int btDbvtBroadphase_m_newpairs_get(void *c); //attribute: int btDbvtBroadphase->m_newpairs
void btDbvtBroadphase_m_paircache_set(void *c,void* a); //attribute: ::btOverlappingPairCache * btDbvtBroadphase->m_paircache
void* btDbvtBroadphase_m_paircache_get(void *c); //attribute: ::btOverlappingPairCache * btDbvtBroadphase->m_paircache
void btDbvtBroadphase_m_pid_set(void *c,int a); //attribute: int btDbvtBroadphase->m_pid
int btDbvtBroadphase_m_pid_get(void *c); //attribute: int btDbvtBroadphase->m_pid
void btDbvtBroadphase_m_prediction_set(void *c,float a); //attribute: ::btScalar btDbvtBroadphase->m_prediction
float btDbvtBroadphase_m_prediction_get(void *c); //attribute: ::btScalar btDbvtBroadphase->m_prediction
void btDbvtBroadphase_m_releasepaircache_set(void *c,int a); //attribute: bool btDbvtBroadphase->m_releasepaircache
int btDbvtBroadphase_m_releasepaircache_get(void *c); //attribute: bool btDbvtBroadphase->m_releasepaircache
// attribute not supported: //attribute: ::btDbvt[2] btDbvtBroadphase->m_sets
void btDbvtBroadphase_m_stageCurrent_set(void *c,int a); //attribute: int btDbvtBroadphase->m_stageCurrent
int btDbvtBroadphase_m_stageCurrent_get(void *c); //attribute: int btDbvtBroadphase->m_stageCurrent
// attribute not supported: //attribute: ::btDbvtProxy *[3] btDbvtBroadphase->m_stageRoots
void btDbvtBroadphase_m_updates_call_set(void *c,unsigned int a); //attribute: unsigned int btDbvtBroadphase->m_updates_call
unsigned int btDbvtBroadphase_m_updates_call_get(void *c); //attribute: unsigned int btDbvtBroadphase->m_updates_call
void btDbvtBroadphase_m_updates_done_set(void *c,unsigned int a); //attribute: unsigned int btDbvtBroadphase->m_updates_done
unsigned int btDbvtBroadphase_m_updates_done_get(void *c); //attribute: unsigned int btDbvtBroadphase->m_updates_done
void btDbvtBroadphase_m_updates_ratio_set(void *c,float a); //attribute: ::btScalar btDbvtBroadphase->m_updates_ratio
float btDbvtBroadphase_m_updates_ratio_get(void *c); //attribute: ::btScalar btDbvtBroadphase->m_updates_ratio
void* btDbvtNode_new(); //constructor: btDbvtNode  ( ::btDbvtNode::* )(  ) 
void btDbvtNode_free(void *c); 
int btDbvtNode_isinternal(void *c); //method: isinternal bool ( ::btDbvtNode::* )(  ) const
int btDbvtNode_isleaf(void *c); //method: isleaf bool ( ::btDbvtNode::* )(  ) const
// attribute not supported: //attribute: ::btDbvtNode btDbvtNode->
void btDbvtNode_parent_set(void *c,void* a); //attribute: ::btDbvtNode * btDbvtNode->parent
void* btDbvtNode_parent_get(void *c); //attribute: ::btDbvtNode * btDbvtNode->parent
void btDbvtNode_volume_set(void *c,void* a); //attribute: ::btDbvtVolume btDbvtNode->volume
void* btDbvtNode_volume_get(void *c); //attribute: ::btDbvtVolume btDbvtNode->volume
void* btDbvtProxy_new(float* p0,float* p1,void* p2,short int p3,short int p4); //constructor: btDbvtProxy  ( ::btDbvtProxy::* )( ::btVector3 const &,::btVector3 const &,void *,short int,short int ) 
void btDbvtProxy_free(void *c); 
void btDbvtProxy_leaf_set(void *c,void* a); //attribute: ::btDbvtNode * btDbvtProxy->leaf
void* btDbvtProxy_leaf_get(void *c); //attribute: ::btDbvtNode * btDbvtProxy->leaf
// attribute not supported: //attribute: ::btDbvtProxy *[2] btDbvtProxy->links
void btDbvtProxy_stage_set(void *c,int a); //attribute: int btDbvtProxy->stage
int btDbvtProxy_stage_get(void *c); //attribute: int btDbvtProxy->stage
void* btDispatcher_allocateCollisionAlgorithm(void *c,int p0); //method: allocateCollisionAlgorithm void * ( ::btDispatcher::* )( int ) 
void btDispatcher_releaseManifold(void *c,void* p0); //method: releaseManifold void ( ::btDispatcher::* )( ::btPersistentManifold * ) 
int btDispatcher_getNumManifolds(void *c); //method: getNumManifolds int ( ::btDispatcher::* )(  ) const
void btDispatcher_clearManifold(void *c,void* p0); //method: clearManifold void ( ::btDispatcher::* )( ::btPersistentManifold * ) 
void btDispatcher_freeCollisionAlgorithm(void *c,void* p0); //method: freeCollisionAlgorithm void ( ::btDispatcher::* )( void * ) 
//not supported method: getInternalManifoldPointer ::btPersistentManifold * * ( ::btDispatcher::* )(  ) 
// error:  - unsupported

void* btDispatcher_findAlgorithm(void *c,void* p0,void* p1,void* p2); //method: findAlgorithm ::btCollisionAlgorithm * ( ::btDispatcher::* )( ::btCollisionObject *,::btCollisionObject *,::btPersistentManifold * ) 
int btDispatcher_needsResponse(void *c,void* p0,void* p1); //method: needsResponse bool ( ::btDispatcher::* )( ::btCollisionObject *,::btCollisionObject * ) 
void* btDispatcher_getNewManifold(void *c,void* p0,void* p1); //method: getNewManifold ::btPersistentManifold * ( ::btDispatcher::* )( void *,void * ) 
void btDispatcher_dispatchAllCollisionPairs(void *c,void* p0,void* p1,void* p2); //method: dispatchAllCollisionPairs void ( ::btDispatcher::* )( ::btOverlappingPairCache *,::btDispatcherInfo const &,::btDispatcher * ) 
//not supported method: getInternalManifoldPool ::btPoolAllocator * ( ::btDispatcher::* )(  ) 
// error:  - unsupported

//not supported method: getInternalManifoldPool ::btPoolAllocator * ( ::btDispatcher::* )(  ) 
// error:  - unsupported

//not supported method: getInternalManifoldPool ::btPoolAllocator const * ( ::btDispatcher::* )(  ) const
// error:  - unsupported

int btDispatcher_needsCollision(void *c,void* p0,void* p1); //method: needsCollision bool ( ::btDispatcher::* )( ::btCollisionObject *,::btCollisionObject * ) 
void* btDispatcher_getManifoldByIndexInternal(void *c,int p0); //method: getManifoldByIndexInternal ::btPersistentManifold * ( ::btDispatcher::* )( int ) 
void* btDispatcherInfo_new(); //constructor: btDispatcherInfo  ( ::btDispatcherInfo::* )(  ) 
void btDispatcherInfo_free(void *c); 
void btDispatcherInfo_m_allowedCcdPenetration_set(void *c,float a); //attribute: ::btScalar btDispatcherInfo->m_allowedCcdPenetration
float btDispatcherInfo_m_allowedCcdPenetration_get(void *c); //attribute: ::btScalar btDispatcherInfo->m_allowedCcdPenetration
void btDispatcherInfo_m_convexConservativeDistanceThreshold_set(void *c,float a); //attribute: ::btScalar btDispatcherInfo->m_convexConservativeDistanceThreshold
float btDispatcherInfo_m_convexConservativeDistanceThreshold_get(void *c); //attribute: ::btScalar btDispatcherInfo->m_convexConservativeDistanceThreshold
void btDispatcherInfo_m_debugDraw_set(void *c,void* a); //attribute: ::btIDebugDraw * btDispatcherInfo->m_debugDraw
void* btDispatcherInfo_m_debugDraw_get(void *c); //attribute: ::btIDebugDraw * btDispatcherInfo->m_debugDraw
void btDispatcherInfo_m_dispatchFunc_set(void *c,int a); //attribute: int btDispatcherInfo->m_dispatchFunc
int btDispatcherInfo_m_dispatchFunc_get(void *c); //attribute: int btDispatcherInfo->m_dispatchFunc
void btDispatcherInfo_m_enableSPU_set(void *c,int a); //attribute: bool btDispatcherInfo->m_enableSPU
int btDispatcherInfo_m_enableSPU_get(void *c); //attribute: bool btDispatcherInfo->m_enableSPU
void btDispatcherInfo_m_enableSatConvex_set(void *c,int a); //attribute: bool btDispatcherInfo->m_enableSatConvex
int btDispatcherInfo_m_enableSatConvex_get(void *c); //attribute: bool btDispatcherInfo->m_enableSatConvex
void btDispatcherInfo_m_stackAllocator_set(void *c,void* a); //attribute: ::btStackAlloc * btDispatcherInfo->m_stackAllocator
void* btDispatcherInfo_m_stackAllocator_get(void *c); //attribute: ::btStackAlloc * btDispatcherInfo->m_stackAllocator
void btDispatcherInfo_m_stepCount_set(void *c,int a); //attribute: int btDispatcherInfo->m_stepCount
int btDispatcherInfo_m_stepCount_get(void *c); //attribute: int btDispatcherInfo->m_stepCount
void btDispatcherInfo_m_timeOfImpact_set(void *c,float a); //attribute: ::btScalar btDispatcherInfo->m_timeOfImpact
float btDispatcherInfo_m_timeOfImpact_get(void *c); //attribute: ::btScalar btDispatcherInfo->m_timeOfImpact
void btDispatcherInfo_m_timeStep_set(void *c,float a); //attribute: ::btScalar btDispatcherInfo->m_timeStep
float btDispatcherInfo_m_timeStep_get(void *c); //attribute: ::btScalar btDispatcherInfo->m_timeStep
void btDispatcherInfo_m_useContinuous_set(void *c,int a); //attribute: bool btDispatcherInfo->m_useContinuous
int btDispatcherInfo_m_useContinuous_get(void *c); //attribute: bool btDispatcherInfo->m_useContinuous
void btDispatcherInfo_m_useConvexConservativeDistanceUtil_set(void *c,int a); //attribute: bool btDispatcherInfo->m_useConvexConservativeDistanceUtil
int btDispatcherInfo_m_useConvexConservativeDistanceUtil_get(void *c); //attribute: bool btDispatcherInfo->m_useConvexConservativeDistanceUtil
void btDispatcherInfo_m_useEpa_set(void *c,int a); //attribute: bool btDispatcherInfo->m_useEpa
int btDispatcherInfo_m_useEpa_get(void *c); //attribute: bool btDispatcherInfo->m_useEpa
void* btHashedOverlappingPairCache_new(); //constructor: btHashedOverlappingPairCache  ( ::btHashedOverlappingPairCache::* )(  ) 
void btHashedOverlappingPairCache_free(void *c); 
void btHashedOverlappingPairCache_sortOverlappingPairs(void *c,void* p0); //method: sortOverlappingPairs void ( ::btHashedOverlappingPairCache::* )( ::btDispatcher * ) 
int btHashedOverlappingPairCache_equalsPair(void *c,void* p0,int p1,int p2); //method: equalsPair bool ( ::btHashedOverlappingPairCache::* )( ::btBroadphasePair const &,int,int ) 
void* btHashedOverlappingPairCache_internalFindPair(void *c,void* p0,void* p1,int p2); //method: internalFindPair ::btBroadphasePair * ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy *,int ) 
void* btHashedOverlappingPairCache_getOverlappingPairArray(void *c); //method: getOverlappingPairArray ::btBroadphasePairArray & ( ::btHashedOverlappingPairCache::* )(  ) 
void* btHashedOverlappingPairCache_getOverlappingPairArray0(void *c); //method: getOverlappingPairArray ::btBroadphasePairArray & ( ::btHashedOverlappingPairCache::* )(  ) 
void* btHashedOverlappingPairCache_getOverlappingPairArray1(void *c); //method: getOverlappingPairArray ::btBroadphasePairArray const & ( ::btHashedOverlappingPairCache::* )(  ) const
void btHashedOverlappingPairCache_processAllOverlappingPairs(void *c,void* p0,void* p1); //method: processAllOverlappingPairs void ( ::btHashedOverlappingPairCache::* )( ::btOverlapCallback *,::btDispatcher * ) 
int btHashedOverlappingPairCache_hasDeferredRemoval(void *c); //method: hasDeferredRemoval bool ( ::btHashedOverlappingPairCache::* )(  ) 
void btHashedOverlappingPairCache_cleanProxyFromPairs(void *c,void* p0,void* p1); //method: cleanProxyFromPairs void ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
int btHashedOverlappingPairCache_getNumOverlappingPairs(void *c); //method: getNumOverlappingPairs int ( ::btHashedOverlappingPairCache::* )(  ) const
void btHashedOverlappingPairCache_cleanOverlappingPair(void *c,void* p0,void* p1); //method: cleanOverlappingPair void ( ::btHashedOverlappingPairCache::* )( ::btBroadphasePair &,::btDispatcher * ) 
void btHashedOverlappingPairCache_setOverlapFilterCallback(void *c,void* p0); //method: setOverlapFilterCallback void ( ::btHashedOverlappingPairCache::* )( ::btOverlapFilterCallback * ) 
void btHashedOverlappingPairCache_setInternalGhostPairCallback(void *c,void* p0); //method: setInternalGhostPairCallback void ( ::btHashedOverlappingPairCache::* )( ::btOverlappingPairCallback * ) 
void* btHashedOverlappingPairCache_addOverlappingPair(void *c,void* p0,void* p1); //method: addOverlappingPair ::btBroadphasePair * ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
int btHashedOverlappingPairCache_needsBroadphaseCollision(void *c,void* p0,void* p1); //method: needsBroadphaseCollision bool ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) const
void* btHashedOverlappingPairCache_findPair(void *c,void* p0,void* p1); //method: findPair ::btBroadphasePair * ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void* btHashedOverlappingPairCache_getOverlappingPairArrayPtr(void *c); //method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btHashedOverlappingPairCache::* )(  ) 
void* btHashedOverlappingPairCache_getOverlappingPairArrayPtr0(void *c); //method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btHashedOverlappingPairCache::* )(  ) 
void* btHashedOverlappingPairCache_getOverlappingPairArrayPtr1(void *c); //method: getOverlappingPairArrayPtr ::btBroadphasePair const * ( ::btHashedOverlappingPairCache::* )(  ) const
void* btHashedOverlappingPairCache_getOverlapFilterCallback(void *c); //method: getOverlapFilterCallback ::btOverlapFilterCallback * ( ::btHashedOverlappingPairCache::* )(  ) 
void btHashedOverlappingPairCache_removeOverlappingPairsContainingProxy(void *c,void* p0,void* p1); //method: removeOverlappingPairsContainingProxy void ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void* btHashedOverlappingPairCache_internalAddPair(void *c,void* p0,void* p1); //method: internalAddPair ::btBroadphasePair * ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void btHashedOverlappingPairCache_growTables(void *c); //method: growTables void ( ::btHashedOverlappingPairCache::* )(  ) 
void* btHashedOverlappingPairCache_removeOverlappingPair(void *c,void* p0,void* p1,void* p2); //method: removeOverlappingPair void * ( ::btHashedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy *,::btDispatcher * ) 
int btHashedOverlappingPairCache_GetCount(void *c); //method: GetCount int ( ::btHashedOverlappingPairCache::* )(  ) const
unsigned int btHashedOverlappingPairCache_getHash(void *c,unsigned int p0,unsigned int p1); //method: getHash unsigned int ( ::btHashedOverlappingPairCache::* )( unsigned int,unsigned int ) 
void btHashedOverlappingPairCache_m_overlappingPairArray_set(void *c,void* a); //attribute: ::btBroadphasePairArray btHashedOverlappingPairCache->m_overlappingPairArray
void* btHashedOverlappingPairCache_m_overlappingPairArray_get(void *c); //attribute: ::btBroadphasePairArray btHashedOverlappingPairCache->m_overlappingPairArray
void btHashedOverlappingPairCache_m_overlapFilterCallback_set(void *c,void* a); //attribute: ::btOverlapFilterCallback * btHashedOverlappingPairCache->m_overlapFilterCallback
void* btHashedOverlappingPairCache_m_overlapFilterCallback_get(void *c); //attribute: ::btOverlapFilterCallback * btHashedOverlappingPairCache->m_overlapFilterCallback
void btHashedOverlappingPairCache_m_blockedForChanges_set(void *c,int a); //attribute: bool btHashedOverlappingPairCache->m_blockedForChanges
int btHashedOverlappingPairCache_m_blockedForChanges_get(void *c); //attribute: bool btHashedOverlappingPairCache->m_blockedForChanges
void btHashedOverlappingPairCache_m_hashTable_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashedOverlappingPairCache->m_hashTable
void* btHashedOverlappingPairCache_m_hashTable_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashedOverlappingPairCache->m_hashTable
void btHashedOverlappingPairCache_m_next_set(void *c,void* a); //attribute: ::btAlignedObjectArray<int> btHashedOverlappingPairCache->m_next
void* btHashedOverlappingPairCache_m_next_get(void *c); //attribute: ::btAlignedObjectArray<int> btHashedOverlappingPairCache->m_next
void btHashedOverlappingPairCache_m_ghostPairCallback_set(void *c,void* a); //attribute: ::btOverlappingPairCallback * btHashedOverlappingPairCache->m_ghostPairCallback
void* btHashedOverlappingPairCache_m_ghostPairCallback_get(void *c); //attribute: ::btOverlappingPairCallback * btHashedOverlappingPairCache->m_ghostPairCallback
void btMultiSapBroadphase_addToChildBroadphase(void *c,void* p0,void* p1,void* p2); //method: addToChildBroadphase void ( ::btMultiSapBroadphase::* )( ::btMultiSapBroadphase::btMultiSapProxy *,::btBroadphaseProxy *,::btBroadphaseInterface * ) 
void btMultiSapBroadphase_rayTest(void *c,float* p0,float* p1,void* p2,float* p3,float* p4); //method: rayTest void ( ::btMultiSapBroadphase::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseRayCallback &,::btVector3 const &,::btVector3 const & ) 
void btMultiSapBroadphase_setAabb(void *c,void* p0,float* p1,float* p2,void* p3); //method: setAabb void ( ::btMultiSapBroadphase::* )( ::btBroadphaseProxy *,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
void* btMultiSapBroadphase_getOverlappingPairCache(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btMultiSapBroadphase::* )(  ) 
void* btMultiSapBroadphase_getOverlappingPairCache0(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btMultiSapBroadphase::* )(  ) 
void* btMultiSapBroadphase_getOverlappingPairCache1(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache const * ( ::btMultiSapBroadphase::* )(  ) const
void btMultiSapBroadphase_buildTree(void *c,float* p0,float* p1); //method: buildTree void ( ::btMultiSapBroadphase::* )( ::btVector3 const &,::btVector3 const & ) 
void btMultiSapBroadphase_resetPool(void *c,void* p0); //method: resetPool void ( ::btMultiSapBroadphase::* )( ::btDispatcher * ) 
void btMultiSapBroadphase_calculateOverlappingPairs(void *c,void* p0); //method: calculateOverlappingPairs void ( ::btMultiSapBroadphase::* )( ::btDispatcher * ) 
int btMultiSapBroadphase_testAabbOverlap(void *c,void* p0,void* p1); //method: testAabbOverlap bool ( ::btMultiSapBroadphase::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void btMultiSapBroadphase_getAabb(void *c,void* p0,float* p1,float* p2); //method: getAabb void ( ::btMultiSapBroadphase::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
void* btMultiSapBroadphase_getBroadphaseArray(void *c); //method: getBroadphaseArray ::btSapBroadphaseArray & ( ::btMultiSapBroadphase::* )(  ) 
void* btMultiSapBroadphase_getBroadphaseArray0(void *c); //method: getBroadphaseArray ::btSapBroadphaseArray & ( ::btMultiSapBroadphase::* )(  ) 
void* btMultiSapBroadphase_getBroadphaseArray1(void *c); //method: getBroadphaseArray ::btSapBroadphaseArray const & ( ::btMultiSapBroadphase::* )(  ) const
void* btMultiSapBroadphase_createProxy(void *c,float* p0,float* p1,int p2,void* p3,short int p4,short int p5,void* p6,void* p7); //method: createProxy ::btBroadphaseProxy * ( ::btMultiSapBroadphase::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int,::btDispatcher *,void * ) 
void btMultiSapBroadphase_printStats(void *c); //method: printStats void ( ::btMultiSapBroadphase::* )(  ) 
void btMultiSapBroadphase_getBroadphaseAabb(void *c,float* p0,float* p1); //method: getBroadphaseAabb void ( ::btMultiSapBroadphase::* )( ::btVector3 &,::btVector3 & ) const
void btMultiSapBroadphase_destroyProxy(void *c,void* p0,void* p1); //method: destroyProxy void ( ::btMultiSapBroadphase::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btMultiSapBroadphase_m_sapBroadphases_set(void *c,void* a); //attribute: ::btSapBroadphaseArray btMultiSapBroadphase->m_sapBroadphases
void* btMultiSapBroadphase_m_sapBroadphases_get(void *c); //attribute: ::btSapBroadphaseArray btMultiSapBroadphase->m_sapBroadphases
void btMultiSapBroadphase_m_simpleBroadphase_set(void *c,void* a); //attribute: ::btSimpleBroadphase * btMultiSapBroadphase->m_simpleBroadphase
void* btMultiSapBroadphase_m_simpleBroadphase_get(void *c); //attribute: ::btSimpleBroadphase * btMultiSapBroadphase->m_simpleBroadphase
void btMultiSapBroadphase_m_overlappingPairs_set(void *c,void* a); //attribute: ::btOverlappingPairCache * btMultiSapBroadphase->m_overlappingPairs
void* btMultiSapBroadphase_m_overlappingPairs_get(void *c); //attribute: ::btOverlappingPairCache * btMultiSapBroadphase->m_overlappingPairs
void btMultiSapBroadphase_m_optimizedAabbTree_set(void *c,void* a); //attribute: ::btQuantizedBvh * btMultiSapBroadphase->m_optimizedAabbTree
void* btMultiSapBroadphase_m_optimizedAabbTree_get(void *c); //attribute: ::btQuantizedBvh * btMultiSapBroadphase->m_optimizedAabbTree
void btMultiSapBroadphase_m_ownsPairCache_set(void *c,int a); //attribute: bool btMultiSapBroadphase->m_ownsPairCache
int btMultiSapBroadphase_m_ownsPairCache_get(void *c); //attribute: bool btMultiSapBroadphase->m_ownsPairCache
void btMultiSapBroadphase_m_filterCallback_set(void *c,void* a); //attribute: ::btOverlapFilterCallback * btMultiSapBroadphase->m_filterCallback
void* btMultiSapBroadphase_m_filterCallback_get(void *c); //attribute: ::btOverlapFilterCallback * btMultiSapBroadphase->m_filterCallback
void btMultiSapBroadphase_m_invalidPair_set(void *c,int a); //attribute: int btMultiSapBroadphase->m_invalidPair
int btMultiSapBroadphase_m_invalidPair_get(void *c); //attribute: int btMultiSapBroadphase->m_invalidPair
void btMultiSapBroadphase_m_multiSapProxies_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*> btMultiSapBroadphase->m_multiSapProxies
void* btMultiSapBroadphase_m_multiSapProxies_get(void *c); //attribute: ::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*> btMultiSapBroadphase->m_multiSapProxies
void* btMultiSapBroadphase_btMultiSapProxy_new(float* p0,float* p1,int p2,void* p3,short int p4,short int p5); //constructor: btMultiSapProxy  ( ::btMultiSapBroadphase::btMultiSapProxy::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int ) 
void btMultiSapBroadphase_btMultiSapProxy_free(void *c); 
void btMultiSapBroadphase_btMultiSapProxy_m_aabbMax_set(void *c,float* a); //attribute: ::btVector3 btMultiSapBroadphase_btMultiSapProxy->m_aabbMax
void btMultiSapBroadphase_btMultiSapProxy_m_aabbMax_get(void *c,float* a);
void btMultiSapBroadphase_btMultiSapProxy_m_aabbMin_set(void *c,float* a); //attribute: ::btVector3 btMultiSapBroadphase_btMultiSapProxy->m_aabbMin
void btMultiSapBroadphase_btMultiSapProxy_m_aabbMin_get(void *c,float* a);
void btMultiSapBroadphase_btMultiSapProxy_m_bridgeProxies_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*> btMultiSapBroadphase_btMultiSapProxy->m_bridgeProxies
void* btMultiSapBroadphase_btMultiSapProxy_m_bridgeProxies_get(void *c); //attribute: ::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*> btMultiSapBroadphase_btMultiSapProxy->m_bridgeProxies
void btMultiSapBroadphase_btMultiSapProxy_m_shapeType_set(void *c,int a); //attribute: int btMultiSapBroadphase_btMultiSapProxy->m_shapeType
int btMultiSapBroadphase_btMultiSapProxy_m_shapeType_get(void *c); //attribute: int btMultiSapBroadphase_btMultiSapProxy->m_shapeType
void btNodeOverlapCallback_processNode(void *c,int p0,int p1); //method: processNode void ( ::btNodeOverlapCallback::* )( int,int ) 
void* btNullPairCache_new(); //constructor: btNullPairCache  ( ::btNullPairCache::* )(  ) 
void btNullPairCache_free(void *c); 
void btNullPairCache_sortOverlappingPairs(void *c,void* p0); //method: sortOverlappingPairs void ( ::btNullPairCache::* )( ::btDispatcher * ) 
void btNullPairCache_setInternalGhostPairCallback(void *c,void* p0); //method: setInternalGhostPairCallback void ( ::btNullPairCache::* )( ::btOverlappingPairCallback * ) 
void* btNullPairCache_addOverlappingPair(void *c,void* p0,void* p1); //method: addOverlappingPair ::btBroadphasePair * ( ::btNullPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void btNullPairCache_removeOverlappingPairsContainingProxy(void *c,void* p0,void* p1); //method: removeOverlappingPairsContainingProxy void ( ::btNullPairCache::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
int btNullPairCache_hasDeferredRemoval(void *c); //method: hasDeferredRemoval bool ( ::btNullPairCache::* )(  ) 
void* btNullPairCache_getOverlappingPairArray(void *c); //method: getOverlappingPairArray ::btBroadphasePairArray & ( ::btNullPairCache::* )(  ) 
void* btNullPairCache_findPair(void *c,void* p0,void* p1); //method: findPair ::btBroadphasePair * ( ::btNullPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void btNullPairCache_cleanProxyFromPairs(void *c,void* p0,void* p1); //method: cleanProxyFromPairs void ( ::btNullPairCache::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btNullPairCache_cleanOverlappingPair(void *c,void* p0,void* p1); //method: cleanOverlappingPair void ( ::btNullPairCache::* )( ::btBroadphasePair &,::btDispatcher * ) 
int btNullPairCache_getNumOverlappingPairs(void *c); //method: getNumOverlappingPairs int ( ::btNullPairCache::* )(  ) const
void* btNullPairCache_removeOverlappingPair(void *c,void* p0,void* p1,void* p2); //method: removeOverlappingPair void * ( ::btNullPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy *,::btDispatcher * ) 
void btNullPairCache_setOverlapFilterCallback(void *c,void* p0); //method: setOverlapFilterCallback void ( ::btNullPairCache::* )( ::btOverlapFilterCallback * ) 
void* btNullPairCache_getOverlappingPairArrayPtr(void *c); //method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btNullPairCache::* )(  ) 
void* btNullPairCache_getOverlappingPairArrayPtr0(void *c); //method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btNullPairCache::* )(  ) 
void* btNullPairCache_getOverlappingPairArrayPtr1(void *c); //method: getOverlappingPairArrayPtr ::btBroadphasePair const * ( ::btNullPairCache::* )(  ) const
void btNullPairCache_processAllOverlappingPairs(void *c,void* p0,void* p1); //method: processAllOverlappingPairs void ( ::btNullPairCache::* )( ::btOverlapCallback *,::btDispatcher * ) 
void btNullPairCache_m_overlappingPairArray_set(void *c,void* a); //attribute: ::btBroadphasePairArray btNullPairCache->m_overlappingPairArray
void* btNullPairCache_m_overlappingPairArray_get(void *c); //attribute: ::btBroadphasePairArray btNullPairCache->m_overlappingPairArray
void* btOptimizedBvhNode_new(); //constructor: btOptimizedBvhNode  ( ::btOptimizedBvhNode::* )(  ) 
void btOptimizedBvhNode_free(void *c); 
void btOptimizedBvhNode_m_aabbMaxOrg_set(void *c,float* a); //attribute: ::btVector3 btOptimizedBvhNode->m_aabbMaxOrg
void btOptimizedBvhNode_m_aabbMaxOrg_get(void *c,float* a);
void btOptimizedBvhNode_m_aabbMinOrg_set(void *c,float* a); //attribute: ::btVector3 btOptimizedBvhNode->m_aabbMinOrg
void btOptimizedBvhNode_m_aabbMinOrg_get(void *c,float* a);
void btOptimizedBvhNode_m_escapeIndex_set(void *c,int a); //attribute: int btOptimizedBvhNode->m_escapeIndex
int btOptimizedBvhNode_m_escapeIndex_get(void *c); //attribute: int btOptimizedBvhNode->m_escapeIndex
// attribute not supported: //attribute: char[20] btOptimizedBvhNode->m_padding
void btOptimizedBvhNode_m_subPart_set(void *c,int a); //attribute: int btOptimizedBvhNode->m_subPart
int btOptimizedBvhNode_m_subPart_get(void *c); //attribute: int btOptimizedBvhNode->m_subPart
void btOptimizedBvhNode_m_triangleIndex_set(void *c,int a); //attribute: int btOptimizedBvhNode->m_triangleIndex
int btOptimizedBvhNode_m_triangleIndex_get(void *c); //attribute: int btOptimizedBvhNode->m_triangleIndex
void* btOptimizedBvhNodeDoubleData_new(); //constructor: btOptimizedBvhNodeDoubleData  ( ::btOptimizedBvhNodeDoubleData::* )(  ) 
void btOptimizedBvhNodeDoubleData_free(void *c); 
void btOptimizedBvhNodeDoubleData_m_aabbMinOrg_set(void *c,void* a); //attribute: ::btVector3DoubleData btOptimizedBvhNodeDoubleData->m_aabbMinOrg
void* btOptimizedBvhNodeDoubleData_m_aabbMinOrg_get(void *c); //attribute: ::btVector3DoubleData btOptimizedBvhNodeDoubleData->m_aabbMinOrg
void btOptimizedBvhNodeDoubleData_m_aabbMaxOrg_set(void *c,void* a); //attribute: ::btVector3DoubleData btOptimizedBvhNodeDoubleData->m_aabbMaxOrg
void* btOptimizedBvhNodeDoubleData_m_aabbMaxOrg_get(void *c); //attribute: ::btVector3DoubleData btOptimizedBvhNodeDoubleData->m_aabbMaxOrg
void btOptimizedBvhNodeDoubleData_m_escapeIndex_set(void *c,int a); //attribute: int btOptimizedBvhNodeDoubleData->m_escapeIndex
int btOptimizedBvhNodeDoubleData_m_escapeIndex_get(void *c); //attribute: int btOptimizedBvhNodeDoubleData->m_escapeIndex
void btOptimizedBvhNodeDoubleData_m_subPart_set(void *c,int a); //attribute: int btOptimizedBvhNodeDoubleData->m_subPart
int btOptimizedBvhNodeDoubleData_m_subPart_get(void *c); //attribute: int btOptimizedBvhNodeDoubleData->m_subPart
void btOptimizedBvhNodeDoubleData_m_triangleIndex_set(void *c,int a); //attribute: int btOptimizedBvhNodeDoubleData->m_triangleIndex
int btOptimizedBvhNodeDoubleData_m_triangleIndex_get(void *c); //attribute: int btOptimizedBvhNodeDoubleData->m_triangleIndex
// attribute not supported: //attribute: char[4] btOptimizedBvhNodeDoubleData->m_pad
void* btOptimizedBvhNodeFloatData_new(); //constructor: btOptimizedBvhNodeFloatData  ( ::btOptimizedBvhNodeFloatData::* )(  ) 
void btOptimizedBvhNodeFloatData_free(void *c); 
void btOptimizedBvhNodeFloatData_m_aabbMinOrg_set(void *c,void* a); //attribute: ::btVector3FloatData btOptimizedBvhNodeFloatData->m_aabbMinOrg
void* btOptimizedBvhNodeFloatData_m_aabbMinOrg_get(void *c); //attribute: ::btVector3FloatData btOptimizedBvhNodeFloatData->m_aabbMinOrg
void btOptimizedBvhNodeFloatData_m_aabbMaxOrg_set(void *c,void* a); //attribute: ::btVector3FloatData btOptimizedBvhNodeFloatData->m_aabbMaxOrg
void* btOptimizedBvhNodeFloatData_m_aabbMaxOrg_get(void *c); //attribute: ::btVector3FloatData btOptimizedBvhNodeFloatData->m_aabbMaxOrg
void btOptimizedBvhNodeFloatData_m_escapeIndex_set(void *c,int a); //attribute: int btOptimizedBvhNodeFloatData->m_escapeIndex
int btOptimizedBvhNodeFloatData_m_escapeIndex_get(void *c); //attribute: int btOptimizedBvhNodeFloatData->m_escapeIndex
void btOptimizedBvhNodeFloatData_m_subPart_set(void *c,int a); //attribute: int btOptimizedBvhNodeFloatData->m_subPart
int btOptimizedBvhNodeFloatData_m_subPart_get(void *c); //attribute: int btOptimizedBvhNodeFloatData->m_subPart
void btOptimizedBvhNodeFloatData_m_triangleIndex_set(void *c,int a); //attribute: int btOptimizedBvhNodeFloatData->m_triangleIndex
int btOptimizedBvhNodeFloatData_m_triangleIndex_get(void *c); //attribute: int btOptimizedBvhNodeFloatData->m_triangleIndex
// attribute not supported: //attribute: char[4] btOptimizedBvhNodeFloatData->m_pad
int btOverlapCallback_processOverlap(void *c,void* p0); //method: processOverlap bool ( ::btOverlapCallback::* )( ::btBroadphasePair & ) 
int btOverlapFilterCallback_needBroadphaseCollision(void *c,void* p0,void* p1); //method: needBroadphaseCollision bool ( ::btOverlapFilterCallback::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) const
void btOverlappingPairCache_sortOverlappingPairs(void *c,void* p0); //method: sortOverlappingPairs void ( ::btOverlappingPairCache::* )( ::btDispatcher * ) 
void btOverlappingPairCache_setInternalGhostPairCallback(void *c,void* p0); //method: setInternalGhostPairCallback void ( ::btOverlappingPairCache::* )( ::btOverlappingPairCallback * ) 
void btOverlappingPairCache_setOverlapFilterCallback(void *c,void* p0); //method: setOverlapFilterCallback void ( ::btOverlappingPairCache::* )( ::btOverlapFilterCallback * ) 
void* btOverlappingPairCache_getOverlappingPairArray(void *c); //method: getOverlappingPairArray ::btBroadphasePairArray & ( ::btOverlappingPairCache::* )(  ) 
void* btOverlappingPairCache_findPair(void *c,void* p0,void* p1); //method: findPair ::btBroadphasePair * ( ::btOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void btOverlappingPairCache_cleanProxyFromPairs(void *c,void* p0,void* p1); //method: cleanProxyFromPairs void ( ::btOverlappingPairCache::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btOverlappingPairCache_cleanOverlappingPair(void *c,void* p0,void* p1); //method: cleanOverlappingPair void ( ::btOverlappingPairCache::* )( ::btBroadphasePair &,::btDispatcher * ) 
int btOverlappingPairCache_getNumOverlappingPairs(void *c); //method: getNumOverlappingPairs int ( ::btOverlappingPairCache::* )(  ) const
void btOverlappingPairCache_processAllOverlappingPairs(void *c,void* p0,void* p1); //method: processAllOverlappingPairs void ( ::btOverlappingPairCache::* )( ::btOverlapCallback *,::btDispatcher * ) 
void* btOverlappingPairCache_getOverlappingPairArrayPtr(void *c); //method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btOverlappingPairCache::* )(  ) 
void* btOverlappingPairCache_getOverlappingPairArrayPtr0(void *c); //method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btOverlappingPairCache::* )(  ) 
void* btOverlappingPairCache_getOverlappingPairArrayPtr1(void *c); //method: getOverlappingPairArrayPtr ::btBroadphasePair const * ( ::btOverlappingPairCache::* )(  ) const
int btOverlappingPairCache_hasDeferredRemoval(void *c); //method: hasDeferredRemoval bool ( ::btOverlappingPairCache::* )(  ) 
void* btOverlappingPairCallback_addOverlappingPair(void *c,void* p0,void* p1); //method: addOverlappingPair ::btBroadphasePair * ( ::btOverlappingPairCallback::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void* btOverlappingPairCallback_removeOverlappingPair(void *c,void* p0,void* p1,void* p2); //method: removeOverlappingPair void * ( ::btOverlappingPairCallback::* )( ::btBroadphaseProxy *,::btBroadphaseProxy *,::btDispatcher * ) 
void btOverlappingPairCallback_removeOverlappingPairsContainingProxy(void *c,void* p0,void* p1); //method: removeOverlappingPairsContainingProxy void ( ::btOverlappingPairCallback::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void* btQuantizedBvh_new0(); //constructor: btQuantizedBvh  ( ::btQuantizedBvh::* )(  ) 
void* btQuantizedBvh_new1(void* p0,int p1); //constructor: btQuantizedBvh  ( ::btQuantizedBvh::* )( ::btQuantizedBvh &,bool ) 
void btQuantizedBvh_free(void *c); 
int btQuantizedBvh_calcSplittingAxis(void *c,int p0,int p1); //method: calcSplittingAxis int ( ::btQuantizedBvh::* )( int,int ) 
void btQuantizedBvh_buildInternal(void *c); //method: buildInternal void ( ::btQuantizedBvh::* )(  ) 
int btQuantizedBvh_serialize(void *c,void* p0,unsigned int p1,int p2); //method: serialize bool ( ::btQuantizedBvh::* )( void *,unsigned int,bool ) const
int btQuantizedBvh_serialize0(void *c,void* p0,unsigned int p1,int p2); //method: serialize bool ( ::btQuantizedBvh::* )( void *,unsigned int,bool ) const
char const * btQuantizedBvh_serialize1(void *c,void* p0,void* p1); //method: serialize char const * ( ::btQuantizedBvh::* )( void *,::btSerializer * ) const
void btQuantizedBvh_deSerializeDouble(void *c,void* p0); //method: deSerializeDouble void ( ::btQuantizedBvh::* )( ::btQuantizedBvhDoubleData & ) 
void btQuantizedBvh_setQuantizationValues(void *c,float* p0,float* p1,float p2); //method: setQuantizationValues void ( ::btQuantizedBvh::* )( ::btVector3 const &,::btVector3 const &,::btScalar ) 
void btQuantizedBvh_deSerializeFloat(void *c,void* p0); //method: deSerializeFloat void ( ::btQuantizedBvh::* )( ::btQuantizedBvhFloatData & ) 
//not supported method: setTraversalMode void ( ::btQuantizedBvh::* )( ::btQuantizedBvh::btTraversalMode ) 
// error:  - unsupported, void - ok

void btQuantizedBvh_setInternalNodeAabbMin(void *c,int p0,float* p1); //method: setInternalNodeAabbMin void ( ::btQuantizedBvh::* )( int,::btVector3 const & ) 
int btQuantizedBvh_isQuantized(void *c); //method: isQuantized bool ( ::btQuantizedBvh::* )(  ) 
unsigned int btQuantizedBvh_getAlignmentSerializationPadding(); //method: getAlignmentSerializationPadding unsigned int (*)(  )
unsigned int btQuantizedBvh_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize unsigned int ( ::btQuantizedBvh::* )(  ) const
int btQuantizedBvh_sortAndCalcSplittingIndex(void *c,int p0,int p1,int p2); //method: sortAndCalcSplittingIndex int ( ::btQuantizedBvh::* )( int,int,int ) 
void btQuantizedBvh_reportAabbOverlappingNodex(void *c,void* p0,float* p1,float* p2); //method: reportAabbOverlappingNodex void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,::btVector3 const &,::btVector3 const & ) const
void btQuantizedBvh_swapLeafNodes(void *c,int p0,int p1); //method: swapLeafNodes void ( ::btQuantizedBvh::* )( int,int ) 
void* btQuantizedBvh_getQuantizedNodeArray(void *c); //method: getQuantizedNodeArray ::QuantizedNodeArray & ( ::btQuantizedBvh::* )(  ) 
void btQuantizedBvh_buildTree(void *c,int p0,int p1); //method: buildTree void ( ::btQuantizedBvh::* )( int,int ) 
//not supported method: walkStacklessQuantizedTreeCacheFriendly void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,short unsigned int *,short unsigned int * ) const
// error: ::btNodeOverlapCallback * - ok,  - unsupported,  - unsupported, void - ok

void btQuantizedBvh_reportRayOverlappingNodex(void *c,void* p0,float* p1,float* p2); //method: reportRayOverlappingNodex void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,::btVector3 const &,::btVector3 const & ) const
void btQuantizedBvh_walkStacklessTree(void *c,void* p0,float* p1,float* p2); //method: walkStacklessTree void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,::btVector3 const &,::btVector3 const & ) const
void btQuantizedBvh_walkStacklessQuantizedTreeAgainstRay(void *c,void* p0,float* p1,float* p2,float* p3,float* p4,int p5,int p6); //method: walkStacklessQuantizedTreeAgainstRay void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,int,int ) const
void btQuantizedBvh_updateSubtreeHeaders(void *c,int p0,int p1); //method: updateSubtreeHeaders void ( ::btQuantizedBvh::* )( int,int ) 
void* btQuantizedBvh_deSerializeInPlace(void* p0,unsigned int p1,int p2); //method: deSerializeInPlace ::btQuantizedBvh * (*)( void *,unsigned int,bool )
void btQuantizedBvh_mergeInternalNodeAabb(void *c,int p0,float* p1,float* p2); //method: mergeInternalNodeAabb void ( ::btQuantizedBvh::* )( int,::btVector3 const &,::btVector3 const & ) 
//not supported method: quantizeWithClamp void ( ::btQuantizedBvh::* )( short unsigned int *,::btVector3 const &,int ) const
// error:  - unsupported, ::btVector3 const & - ok, int - ok, void - ok

void btQuantizedBvh_getAabbMin(void *c,int p0,float* ret); //method: getAabbMin ::btVector3 ( ::btQuantizedBvh::* )( int ) const
void btQuantizedBvh_walkStacklessTreeAgainstRay(void *c,void* p0,float* p1,float* p2,float* p3,float* p4,int p5,int p6); //method: walkStacklessTreeAgainstRay void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,int,int ) const
//not supported method: walkRecursiveQuantizedTreeAgainstQueryAabb void ( ::btQuantizedBvh::* )( ::btQuantizedBvhNode const *,::btNodeOverlapCallback *,short unsigned int *,short unsigned int * ) const
// error: ::btQuantizedBvhNode const * - ok, ::btNodeOverlapCallback * - ok,  - unsupported,  - unsupported, void - ok

void* btQuantizedBvh_getLeafNodeArray(void *c); //method: getLeafNodeArray ::QuantizedNodeArray & ( ::btQuantizedBvh::* )(  ) 
int btQuantizedBvh_calculateSerializeBufferSizeNew(void *c); //method: calculateSerializeBufferSizeNew int ( ::btQuantizedBvh::* )(  ) const
void btQuantizedBvh_setInternalNodeEscapeIndex(void *c,int p0,int p1); //method: setInternalNodeEscapeIndex void ( ::btQuantizedBvh::* )( int,int ) 
void btQuantizedBvh_getAabbMax(void *c,int p0,float* ret); //method: getAabbMax ::btVector3 ( ::btQuantizedBvh::* )( int ) const
//not supported method: quantize void ( ::btQuantizedBvh::* )( short unsigned int *,::btVector3 const &,int ) const
// error:  - unsupported, ::btVector3 const & - ok, int - ok, void - ok

void* btQuantizedBvh_getSubtreeInfoArray(void *c); //method: getSubtreeInfoArray ::BvhSubtreeInfoArray & ( ::btQuantizedBvh::* )(  ) 
void btQuantizedBvh_setInternalNodeAabbMax(void *c,int p0,float* p1); //method: setInternalNodeAabbMax void ( ::btQuantizedBvh::* )( int,::btVector3 const & ) 
//not supported method: unQuantize ::btVector3 ( ::btQuantizedBvh::* )( short unsigned int const * ) const
// error:  - unsupported, ::btVector3 - ok

void btQuantizedBvh_reportBoxCastOverlappingNodex(void *c,void* p0,float* p1,float* p2,float* p3,float* p4); //method: reportBoxCastOverlappingNodex void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) const
//not supported method: walkStacklessQuantizedTree void ( ::btQuantizedBvh::* )( ::btNodeOverlapCallback *,short unsigned int *,short unsigned int *,int,int ) const
// error: ::btNodeOverlapCallback * - ok,  - unsupported,  - unsupported, int - ok, int - ok, void - ok

void btQuantizedBvh_assignInternalNodeFromLeafNode(void *c,int p0,int p1); //method: assignInternalNodeFromLeafNode void ( ::btQuantizedBvh::* )( int,int ) 
void btQuantizedBvh_m_SubtreeHeaders_set(void *c,void* a); //attribute: ::BvhSubtreeInfoArray btQuantizedBvh->m_SubtreeHeaders
void* btQuantizedBvh_m_SubtreeHeaders_get(void *c); //attribute: ::BvhSubtreeInfoArray btQuantizedBvh->m_SubtreeHeaders
void btQuantizedBvh_m_bulletVersion_set(void *c,int a); //attribute: int btQuantizedBvh->m_bulletVersion
int btQuantizedBvh_m_bulletVersion_get(void *c); //attribute: int btQuantizedBvh->m_bulletVersion
void btQuantizedBvh_m_bvhAabbMax_set(void *c,float* a); //attribute: ::btVector3 btQuantizedBvh->m_bvhAabbMax
void btQuantizedBvh_m_bvhAabbMax_get(void *c,float* a);
void btQuantizedBvh_m_bvhAabbMin_set(void *c,float* a); //attribute: ::btVector3 btQuantizedBvh->m_bvhAabbMin
void btQuantizedBvh_m_bvhAabbMin_get(void *c,float* a);
void btQuantizedBvh_m_bvhQuantization_set(void *c,float* a); //attribute: ::btVector3 btQuantizedBvh->m_bvhQuantization
void btQuantizedBvh_m_bvhQuantization_get(void *c,float* a);
void btQuantizedBvh_m_contiguousNodes_set(void *c,void* a); //attribute: ::NodeArray btQuantizedBvh->m_contiguousNodes
void* btQuantizedBvh_m_contiguousNodes_get(void *c); //attribute: ::NodeArray btQuantizedBvh->m_contiguousNodes
void btQuantizedBvh_m_curNodeIndex_set(void *c,int a); //attribute: int btQuantizedBvh->m_curNodeIndex
int btQuantizedBvh_m_curNodeIndex_get(void *c); //attribute: int btQuantizedBvh->m_curNodeIndex
void btQuantizedBvh_m_leafNodes_set(void *c,void* a); //attribute: ::NodeArray btQuantizedBvh->m_leafNodes
void* btQuantizedBvh_m_leafNodes_get(void *c); //attribute: ::NodeArray btQuantizedBvh->m_leafNodes
void btQuantizedBvh_m_quantizedContiguousNodes_set(void *c,void* a); //attribute: ::QuantizedNodeArray btQuantizedBvh->m_quantizedContiguousNodes
void* btQuantizedBvh_m_quantizedContiguousNodes_get(void *c); //attribute: ::QuantizedNodeArray btQuantizedBvh->m_quantizedContiguousNodes
void btQuantizedBvh_m_quantizedLeafNodes_set(void *c,void* a); //attribute: ::QuantizedNodeArray btQuantizedBvh->m_quantizedLeafNodes
void* btQuantizedBvh_m_quantizedLeafNodes_get(void *c); //attribute: ::QuantizedNodeArray btQuantizedBvh->m_quantizedLeafNodes
void btQuantizedBvh_m_subtreeHeaderCount_set(void *c,int a); //attribute: int btQuantizedBvh->m_subtreeHeaderCount
int btQuantizedBvh_m_subtreeHeaderCount_get(void *c); //attribute: int btQuantizedBvh->m_subtreeHeaderCount
// attribute not supported: //attribute: ::btQuantizedBvh::btTraversalMode btQuantizedBvh->m_traversalMode
void btQuantizedBvh_m_useQuantization_set(void *c,int a); //attribute: bool btQuantizedBvh->m_useQuantization
int btQuantizedBvh_m_useQuantization_get(void *c); //attribute: bool btQuantizedBvh->m_useQuantization
void* btQuantizedBvhDoubleData_new(); //constructor: btQuantizedBvhDoubleData  ( ::btQuantizedBvhDoubleData::* )(  ) 
void btQuantizedBvhDoubleData_free(void *c); 
void btQuantizedBvhDoubleData_m_bvhAabbMax_set(void *c,void* a); //attribute: ::btVector3DoubleData btQuantizedBvhDoubleData->m_bvhAabbMax
void* btQuantizedBvhDoubleData_m_bvhAabbMax_get(void *c); //attribute: ::btVector3DoubleData btQuantizedBvhDoubleData->m_bvhAabbMax
void btQuantizedBvhDoubleData_m_bvhAabbMin_set(void *c,void* a); //attribute: ::btVector3DoubleData btQuantizedBvhDoubleData->m_bvhAabbMin
void* btQuantizedBvhDoubleData_m_bvhAabbMin_get(void *c); //attribute: ::btVector3DoubleData btQuantizedBvhDoubleData->m_bvhAabbMin
void btQuantizedBvhDoubleData_m_bvhQuantization_set(void *c,void* a); //attribute: ::btVector3DoubleData btQuantizedBvhDoubleData->m_bvhQuantization
void* btQuantizedBvhDoubleData_m_bvhQuantization_get(void *c); //attribute: ::btVector3DoubleData btQuantizedBvhDoubleData->m_bvhQuantization
void btQuantizedBvhDoubleData_m_contiguousNodesPtr_set(void *c,void* a); //attribute: ::btOptimizedBvhNodeDoubleData * btQuantizedBvhDoubleData->m_contiguousNodesPtr
void* btQuantizedBvhDoubleData_m_contiguousNodesPtr_get(void *c); //attribute: ::btOptimizedBvhNodeDoubleData * btQuantizedBvhDoubleData->m_contiguousNodesPtr
void btQuantizedBvhDoubleData_m_curNodeIndex_set(void *c,int a); //attribute: int btQuantizedBvhDoubleData->m_curNodeIndex
int btQuantizedBvhDoubleData_m_curNodeIndex_get(void *c); //attribute: int btQuantizedBvhDoubleData->m_curNodeIndex
void btQuantizedBvhDoubleData_m_numContiguousLeafNodes_set(void *c,int a); //attribute: int btQuantizedBvhDoubleData->m_numContiguousLeafNodes
int btQuantizedBvhDoubleData_m_numContiguousLeafNodes_get(void *c); //attribute: int btQuantizedBvhDoubleData->m_numContiguousLeafNodes
void btQuantizedBvhDoubleData_m_numQuantizedContiguousNodes_set(void *c,int a); //attribute: int btQuantizedBvhDoubleData->m_numQuantizedContiguousNodes
int btQuantizedBvhDoubleData_m_numQuantizedContiguousNodes_get(void *c); //attribute: int btQuantizedBvhDoubleData->m_numQuantizedContiguousNodes
void btQuantizedBvhDoubleData_m_numSubtreeHeaders_set(void *c,int a); //attribute: int btQuantizedBvhDoubleData->m_numSubtreeHeaders
int btQuantizedBvhDoubleData_m_numSubtreeHeaders_get(void *c); //attribute: int btQuantizedBvhDoubleData->m_numSubtreeHeaders
void btQuantizedBvhDoubleData_m_quantizedContiguousNodesPtr_set(void *c,void* a); //attribute: ::btQuantizedBvhNodeData * btQuantizedBvhDoubleData->m_quantizedContiguousNodesPtr
void* btQuantizedBvhDoubleData_m_quantizedContiguousNodesPtr_get(void *c); //attribute: ::btQuantizedBvhNodeData * btQuantizedBvhDoubleData->m_quantizedContiguousNodesPtr
void btQuantizedBvhDoubleData_m_subTreeInfoPtr_set(void *c,void* a); //attribute: ::btBvhSubtreeInfoData * btQuantizedBvhDoubleData->m_subTreeInfoPtr
void* btQuantizedBvhDoubleData_m_subTreeInfoPtr_get(void *c); //attribute: ::btBvhSubtreeInfoData * btQuantizedBvhDoubleData->m_subTreeInfoPtr
void btQuantizedBvhDoubleData_m_traversalMode_set(void *c,int a); //attribute: int btQuantizedBvhDoubleData->m_traversalMode
int btQuantizedBvhDoubleData_m_traversalMode_get(void *c); //attribute: int btQuantizedBvhDoubleData->m_traversalMode
void btQuantizedBvhDoubleData_m_useQuantization_set(void *c,int a); //attribute: int btQuantizedBvhDoubleData->m_useQuantization
int btQuantizedBvhDoubleData_m_useQuantization_get(void *c); //attribute: int btQuantizedBvhDoubleData->m_useQuantization
void* btQuantizedBvhFloatData_new(); //constructor: btQuantizedBvhFloatData  ( ::btQuantizedBvhFloatData::* )(  ) 
void btQuantizedBvhFloatData_free(void *c); 
void btQuantizedBvhFloatData_m_bvhAabbMax_set(void *c,void* a); //attribute: ::btVector3FloatData btQuantizedBvhFloatData->m_bvhAabbMax
void* btQuantizedBvhFloatData_m_bvhAabbMax_get(void *c); //attribute: ::btVector3FloatData btQuantizedBvhFloatData->m_bvhAabbMax
void btQuantizedBvhFloatData_m_bvhAabbMin_set(void *c,void* a); //attribute: ::btVector3FloatData btQuantizedBvhFloatData->m_bvhAabbMin
void* btQuantizedBvhFloatData_m_bvhAabbMin_get(void *c); //attribute: ::btVector3FloatData btQuantizedBvhFloatData->m_bvhAabbMin
void btQuantizedBvhFloatData_m_bvhQuantization_set(void *c,void* a); //attribute: ::btVector3FloatData btQuantizedBvhFloatData->m_bvhQuantization
void* btQuantizedBvhFloatData_m_bvhQuantization_get(void *c); //attribute: ::btVector3FloatData btQuantizedBvhFloatData->m_bvhQuantization
void btQuantizedBvhFloatData_m_contiguousNodesPtr_set(void *c,void* a); //attribute: ::btOptimizedBvhNodeFloatData * btQuantizedBvhFloatData->m_contiguousNodesPtr
void* btQuantizedBvhFloatData_m_contiguousNodesPtr_get(void *c); //attribute: ::btOptimizedBvhNodeFloatData * btQuantizedBvhFloatData->m_contiguousNodesPtr
void btQuantizedBvhFloatData_m_curNodeIndex_set(void *c,int a); //attribute: int btQuantizedBvhFloatData->m_curNodeIndex
int btQuantizedBvhFloatData_m_curNodeIndex_get(void *c); //attribute: int btQuantizedBvhFloatData->m_curNodeIndex
void btQuantizedBvhFloatData_m_numContiguousLeafNodes_set(void *c,int a); //attribute: int btQuantizedBvhFloatData->m_numContiguousLeafNodes
int btQuantizedBvhFloatData_m_numContiguousLeafNodes_get(void *c); //attribute: int btQuantizedBvhFloatData->m_numContiguousLeafNodes
void btQuantizedBvhFloatData_m_numQuantizedContiguousNodes_set(void *c,int a); //attribute: int btQuantizedBvhFloatData->m_numQuantizedContiguousNodes
int btQuantizedBvhFloatData_m_numQuantizedContiguousNodes_get(void *c); //attribute: int btQuantizedBvhFloatData->m_numQuantizedContiguousNodes
void btQuantizedBvhFloatData_m_numSubtreeHeaders_set(void *c,int a); //attribute: int btQuantizedBvhFloatData->m_numSubtreeHeaders
int btQuantizedBvhFloatData_m_numSubtreeHeaders_get(void *c); //attribute: int btQuantizedBvhFloatData->m_numSubtreeHeaders
void btQuantizedBvhFloatData_m_quantizedContiguousNodesPtr_set(void *c,void* a); //attribute: ::btQuantizedBvhNodeData * btQuantizedBvhFloatData->m_quantizedContiguousNodesPtr
void* btQuantizedBvhFloatData_m_quantizedContiguousNodesPtr_get(void *c); //attribute: ::btQuantizedBvhNodeData * btQuantizedBvhFloatData->m_quantizedContiguousNodesPtr
void btQuantizedBvhFloatData_m_subTreeInfoPtr_set(void *c,void* a); //attribute: ::btBvhSubtreeInfoData * btQuantizedBvhFloatData->m_subTreeInfoPtr
void* btQuantizedBvhFloatData_m_subTreeInfoPtr_get(void *c); //attribute: ::btBvhSubtreeInfoData * btQuantizedBvhFloatData->m_subTreeInfoPtr
void btQuantizedBvhFloatData_m_traversalMode_set(void *c,int a); //attribute: int btQuantizedBvhFloatData->m_traversalMode
int btQuantizedBvhFloatData_m_traversalMode_get(void *c); //attribute: int btQuantizedBvhFloatData->m_traversalMode
void btQuantizedBvhFloatData_m_useQuantization_set(void *c,int a); //attribute: int btQuantizedBvhFloatData->m_useQuantization
int btQuantizedBvhFloatData_m_useQuantization_get(void *c); //attribute: int btQuantizedBvhFloatData->m_useQuantization
void* btQuantizedBvhNode_new(); //constructor: btQuantizedBvhNode  ( ::btQuantizedBvhNode::* )(  ) 
void btQuantizedBvhNode_free(void *c); 
int btQuantizedBvhNode_getEscapeIndex(void *c); //method: getEscapeIndex int ( ::btQuantizedBvhNode::* )(  ) const
int btQuantizedBvhNode_getTriangleIndex(void *c); //method: getTriangleIndex int ( ::btQuantizedBvhNode::* )(  ) const
int btQuantizedBvhNode_getPartId(void *c); //method: getPartId int ( ::btQuantizedBvhNode::* )(  ) const
int btQuantizedBvhNode_isLeafNode(void *c); //method: isLeafNode bool ( ::btQuantizedBvhNode::* )(  ) const
void btQuantizedBvhNode_m_escapeIndexOrTriangleIndex_set(void *c,int a); //attribute: int btQuantizedBvhNode->m_escapeIndexOrTriangleIndex
int btQuantizedBvhNode_m_escapeIndexOrTriangleIndex_get(void *c); //attribute: int btQuantizedBvhNode->m_escapeIndexOrTriangleIndex
// attribute not supported: //attribute: short unsigned int[3] btQuantizedBvhNode->m_quantizedAabbMax
// attribute not supported: //attribute: short unsigned int[3] btQuantizedBvhNode->m_quantizedAabbMin
void* btQuantizedBvhNodeData_new(); //constructor: btQuantizedBvhNodeData  ( ::btQuantizedBvhNodeData::* )(  ) 
void btQuantizedBvhNodeData_free(void *c); 
void btQuantizedBvhNodeData_m_escapeIndexOrTriangleIndex_set(void *c,int a); //attribute: int btQuantizedBvhNodeData->m_escapeIndexOrTriangleIndex
int btQuantizedBvhNodeData_m_escapeIndexOrTriangleIndex_get(void *c); //attribute: int btQuantizedBvhNodeData->m_escapeIndexOrTriangleIndex
// attribute not supported: //attribute: short unsigned int[3] btQuantizedBvhNodeData->m_quantizedAabbMax
// attribute not supported: //attribute: short unsigned int[3] btQuantizedBvhNodeData->m_quantizedAabbMin
void* btSimpleBroadphase_new(int p0,void* p1); //constructor: btSimpleBroadphase  ( ::btSimpleBroadphase::* )( int,::btOverlappingPairCache * ) 
void btSimpleBroadphase_free(void *c); 
void* btSimpleBroadphase_getOverlappingPairCache(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btSimpleBroadphase::* )(  ) 
void* btSimpleBroadphase_getOverlappingPairCache0(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache * ( ::btSimpleBroadphase::* )(  ) 
void* btSimpleBroadphase_getOverlappingPairCache1(void *c); //method: getOverlappingPairCache ::btOverlappingPairCache const * ( ::btSimpleBroadphase::* )(  ) const
void btSimpleBroadphase_rayTest(void *c,float* p0,float* p1,void* p2,float* p3,float* p4); //method: rayTest void ( ::btSimpleBroadphase::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseRayCallback &,::btVector3 const &,::btVector3 const & ) 
void btSimpleBroadphase_setAabb(void *c,void* p0,float* p1,float* p2,void* p3); //method: setAabb void ( ::btSimpleBroadphase::* )( ::btBroadphaseProxy *,::btVector3 const &,::btVector3 const &,::btDispatcher * ) 
int btSimpleBroadphase_allocHandle(void *c); //method: allocHandle int ( ::btSimpleBroadphase::* )(  ) 
void btSimpleBroadphase_resetPool(void *c,void* p0); //method: resetPool void ( ::btSimpleBroadphase::* )( ::btDispatcher * ) 
int btSimpleBroadphase_testAabbOverlap(void *c,void* p0,void* p1); //method: testAabbOverlap bool ( ::btSimpleBroadphase::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void btSimpleBroadphase_calculateOverlappingPairs(void *c,void* p0); //method: calculateOverlappingPairs void ( ::btSimpleBroadphase::* )( ::btDispatcher * ) 
void btSimpleBroadphase_freeHandle(void *c,void* p0); //method: freeHandle void ( ::btSimpleBroadphase::* )( ::btSimpleBroadphaseProxy * ) 
void btSimpleBroadphase_printStats(void *c); //method: printStats void ( ::btSimpleBroadphase::* )(  ) 
void btSimpleBroadphase_getAabb(void *c,void* p0,float* p1,float* p2); //method: getAabb void ( ::btSimpleBroadphase::* )( ::btBroadphaseProxy *,::btVector3 &,::btVector3 & ) const
void btSimpleBroadphase_aabbTest(void *c,float* p0,float* p1,void* p2); //method: aabbTest void ( ::btSimpleBroadphase::* )( ::btVector3 const &,::btVector3 const &,::btBroadphaseAabbCallback & ) 
void* btSimpleBroadphase_createProxy(void *c,float* p0,float* p1,int p2,void* p3,short int p4,short int p5,void* p6,void* p7); //method: createProxy ::btBroadphaseProxy * ( ::btSimpleBroadphase::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int,::btDispatcher *,void * ) 
void* btSimpleBroadphase_getSimpleProxyFromProxy(void *c,void* p0); //method: getSimpleProxyFromProxy ::btSimpleBroadphaseProxy * ( ::btSimpleBroadphase::* )( ::btBroadphaseProxy * ) 
void* btSimpleBroadphase_getSimpleProxyFromProxy0(void *c,void* p0); //method: getSimpleProxyFromProxy ::btSimpleBroadphaseProxy * ( ::btSimpleBroadphase::* )( ::btBroadphaseProxy * ) 
void* btSimpleBroadphase_getSimpleProxyFromProxy1(void *c,void* p0); //method: getSimpleProxyFromProxy ::btSimpleBroadphaseProxy const * ( ::btSimpleBroadphase::* )( ::btBroadphaseProxy * ) const
void btSimpleBroadphase_validate(void *c); //method: validate void ( ::btSimpleBroadphase::* )(  ) 
int btSimpleBroadphase_aabbOverlap(void* p0,void* p1); //method: aabbOverlap bool (*)( ::btSimpleBroadphaseProxy *,::btSimpleBroadphaseProxy * )
void btSimpleBroadphase_getBroadphaseAabb(void *c,float* p0,float* p1); //method: getBroadphaseAabb void ( ::btSimpleBroadphase::* )( ::btVector3 &,::btVector3 & ) const
void btSimpleBroadphase_destroyProxy(void *c,void* p0,void* p1); //method: destroyProxy void ( ::btSimpleBroadphase::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btSimpleBroadphase_m_LastHandleIndex_set(void *c,int a); //attribute: int btSimpleBroadphase->m_LastHandleIndex
int btSimpleBroadphase_m_LastHandleIndex_get(void *c); //attribute: int btSimpleBroadphase->m_LastHandleIndex
void btSimpleBroadphase_m_firstFreeHandle_set(void *c,int a); //attribute: int btSimpleBroadphase->m_firstFreeHandle
int btSimpleBroadphase_m_firstFreeHandle_get(void *c); //attribute: int btSimpleBroadphase->m_firstFreeHandle
void btSimpleBroadphase_m_invalidPair_set(void *c,int a); //attribute: int btSimpleBroadphase->m_invalidPair
int btSimpleBroadphase_m_invalidPair_get(void *c); //attribute: int btSimpleBroadphase->m_invalidPair
void btSimpleBroadphase_m_maxHandles_set(void *c,int a); //attribute: int btSimpleBroadphase->m_maxHandles
int btSimpleBroadphase_m_maxHandles_get(void *c); //attribute: int btSimpleBroadphase->m_maxHandles
void btSimpleBroadphase_m_numHandles_set(void *c,int a); //attribute: int btSimpleBroadphase->m_numHandles
int btSimpleBroadphase_m_numHandles_get(void *c); //attribute: int btSimpleBroadphase->m_numHandles
void btSimpleBroadphase_m_ownsPairCache_set(void *c,int a); //attribute: bool btSimpleBroadphase->m_ownsPairCache
int btSimpleBroadphase_m_ownsPairCache_get(void *c); //attribute: bool btSimpleBroadphase->m_ownsPairCache
void btSimpleBroadphase_m_pHandles_set(void *c,void* a); //attribute: ::btSimpleBroadphaseProxy * btSimpleBroadphase->m_pHandles
void* btSimpleBroadphase_m_pHandles_get(void *c); //attribute: ::btSimpleBroadphaseProxy * btSimpleBroadphase->m_pHandles
void btSimpleBroadphase_m_pHandlesRawPtr_set(void *c,void* a); //attribute: void * btSimpleBroadphase->m_pHandlesRawPtr
void* btSimpleBroadphase_m_pHandlesRawPtr_get(void *c); //attribute: void * btSimpleBroadphase->m_pHandlesRawPtr
void btSimpleBroadphase_m_pairCache_set(void *c,void* a); //attribute: ::btOverlappingPairCache * btSimpleBroadphase->m_pairCache
void* btSimpleBroadphase_m_pairCache_get(void *c); //attribute: ::btOverlappingPairCache * btSimpleBroadphase->m_pairCache
void* btSimpleBroadphaseProxy_new0(); //constructor: btSimpleBroadphaseProxy  ( ::btSimpleBroadphaseProxy::* )(  ) 
void* btSimpleBroadphaseProxy_new1(float* p0,float* p1,int p2,void* p3,short int p4,short int p5,void* p6); //constructor: btSimpleBroadphaseProxy  ( ::btSimpleBroadphaseProxy::* )( ::btVector3 const &,::btVector3 const &,int,void *,short int,short int,void * ) 
void btSimpleBroadphaseProxy_free(void *c); 
int btSimpleBroadphaseProxy_GetNextFree(void *c); //method: GetNextFree int ( ::btSimpleBroadphaseProxy::* )(  ) const
void btSimpleBroadphaseProxy_SetNextFree(void *c,int p0); //method: SetNextFree void ( ::btSimpleBroadphaseProxy::* )( int ) 
void btSimpleBroadphaseProxy_m_nextFree_set(void *c,int a); //attribute: int btSimpleBroadphaseProxy->m_nextFree
int btSimpleBroadphaseProxy_m_nextFree_get(void *c); //attribute: int btSimpleBroadphaseProxy->m_nextFree
void* btSortedOverlappingPairCache_new(); //constructor: btSortedOverlappingPairCache  ( ::btSortedOverlappingPairCache::* )(  ) 
void btSortedOverlappingPairCache_free(void *c); 
void btSortedOverlappingPairCache_sortOverlappingPairs(void *c,void* p0); //method: sortOverlappingPairs void ( ::btSortedOverlappingPairCache::* )( ::btDispatcher * ) 
void btSortedOverlappingPairCache_setInternalGhostPairCallback(void *c,void* p0); //method: setInternalGhostPairCallback void ( ::btSortedOverlappingPairCache::* )( ::btOverlappingPairCallback * ) 
void* btSortedOverlappingPairCache_getOverlapFilterCallback(void *c); //method: getOverlapFilterCallback ::btOverlapFilterCallback * ( ::btSortedOverlappingPairCache::* )(  ) 
void* btSortedOverlappingPairCache_addOverlappingPair(void *c,void* p0,void* p1); //method: addOverlappingPair ::btBroadphasePair * ( ::btSortedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void btSortedOverlappingPairCache_removeOverlappingPairsContainingProxy(void *c,void* p0,void* p1); //method: removeOverlappingPairsContainingProxy void ( ::btSortedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
int btSortedOverlappingPairCache_needsBroadphaseCollision(void *c,void* p0,void* p1); //method: needsBroadphaseCollision bool ( ::btSortedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) const
int btSortedOverlappingPairCache_hasDeferredRemoval(void *c); //method: hasDeferredRemoval bool ( ::btSortedOverlappingPairCache::* )(  ) 
void* btSortedOverlappingPairCache_getOverlappingPairArray(void *c); //method: getOverlappingPairArray ::btBroadphasePairArray & ( ::btSortedOverlappingPairCache::* )(  ) 
void* btSortedOverlappingPairCache_getOverlappingPairArray0(void *c); //method: getOverlappingPairArray ::btBroadphasePairArray & ( ::btSortedOverlappingPairCache::* )(  ) 
void* btSortedOverlappingPairCache_getOverlappingPairArray1(void *c); //method: getOverlappingPairArray ::btBroadphasePairArray const & ( ::btSortedOverlappingPairCache::* )(  ) const
void* btSortedOverlappingPairCache_findPair(void *c,void* p0,void* p1); //method: findPair ::btBroadphasePair * ( ::btSortedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void btSortedOverlappingPairCache_cleanProxyFromPairs(void *c,void* p0,void* p1); //method: cleanProxyFromPairs void ( ::btSortedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void btSortedOverlappingPairCache_cleanOverlappingPair(void *c,void* p0,void* p1); //method: cleanOverlappingPair void ( ::btSortedOverlappingPairCache::* )( ::btBroadphasePair &,::btDispatcher * ) 
int btSortedOverlappingPairCache_getNumOverlappingPairs(void *c); //method: getNumOverlappingPairs int ( ::btSortedOverlappingPairCache::* )(  ) const
void* btSortedOverlappingPairCache_removeOverlappingPair(void *c,void* p0,void* p1,void* p2); //method: removeOverlappingPair void * ( ::btSortedOverlappingPairCache::* )( ::btBroadphaseProxy *,::btBroadphaseProxy *,::btDispatcher * ) 
void btSortedOverlappingPairCache_processAllOverlappingPairs(void *c,void* p0,void* p1); //method: processAllOverlappingPairs void ( ::btSortedOverlappingPairCache::* )( ::btOverlapCallback *,::btDispatcher * ) 
void* btSortedOverlappingPairCache_getOverlappingPairArrayPtr(void *c); //method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btSortedOverlappingPairCache::* )(  ) 
void* btSortedOverlappingPairCache_getOverlappingPairArrayPtr0(void *c); //method: getOverlappingPairArrayPtr ::btBroadphasePair * ( ::btSortedOverlappingPairCache::* )(  ) 
void* btSortedOverlappingPairCache_getOverlappingPairArrayPtr1(void *c); //method: getOverlappingPairArrayPtr ::btBroadphasePair const * ( ::btSortedOverlappingPairCache::* )(  ) const
void btSortedOverlappingPairCache_setOverlapFilterCallback(void *c,void* p0); //method: setOverlapFilterCallback void ( ::btSortedOverlappingPairCache::* )( ::btOverlapFilterCallback * ) 
void btSortedOverlappingPairCache_m_overlappingPairArray_set(void *c,void* a); //attribute: ::btBroadphasePairArray btSortedOverlappingPairCache->m_overlappingPairArray
void* btSortedOverlappingPairCache_m_overlappingPairArray_get(void *c); //attribute: ::btBroadphasePairArray btSortedOverlappingPairCache->m_overlappingPairArray
void btSortedOverlappingPairCache_m_blockedForChanges_set(void *c,int a); //attribute: bool btSortedOverlappingPairCache->m_blockedForChanges
int btSortedOverlappingPairCache_m_blockedForChanges_get(void *c); //attribute: bool btSortedOverlappingPairCache->m_blockedForChanges
void btSortedOverlappingPairCache_m_hasDeferredRemoval_set(void *c,int a); //attribute: bool btSortedOverlappingPairCache->m_hasDeferredRemoval
int btSortedOverlappingPairCache_m_hasDeferredRemoval_get(void *c); //attribute: bool btSortedOverlappingPairCache->m_hasDeferredRemoval
void btSortedOverlappingPairCache_m_overlapFilterCallback_set(void *c,void* a); //attribute: ::btOverlapFilterCallback * btSortedOverlappingPairCache->m_overlapFilterCallback
void* btSortedOverlappingPairCache_m_overlapFilterCallback_get(void *c); //attribute: ::btOverlapFilterCallback * btSortedOverlappingPairCache->m_overlapFilterCallback
void btSortedOverlappingPairCache_m_ghostPairCallback_set(void *c,void* a); //attribute: ::btOverlappingPairCallback * btSortedOverlappingPairCache->m_ghostPairCallback
void* btSortedOverlappingPairCache_m_ghostPairCallback_get(void *c); //attribute: ::btOverlappingPairCallback * btSortedOverlappingPairCache->m_ghostPairCallback
void* btDbvt_sStkCLN_new(void* p0,void* p1); //constructor: sStkCLN  ( ::btDbvt::sStkCLN::* )( ::btDbvtNode const *,::btDbvtNode * ) 
void btDbvt_sStkCLN_free(void *c); 
void btDbvt_sStkCLN_node_set(void *c,void* a); //attribute: ::btDbvtNode const * btDbvt_sStkCLN->node
void* btDbvt_sStkCLN_node_get(void *c); //attribute: ::btDbvtNode const * btDbvt_sStkCLN->node
void btDbvt_sStkCLN_parent_set(void *c,void* a); //attribute: ::btDbvtNode * btDbvt_sStkCLN->parent
void* btDbvt_sStkCLN_parent_get(void *c); //attribute: ::btDbvtNode * btDbvt_sStkCLN->parent
void* btDbvt_sStkNN_new0(); //constructor: sStkNN  ( ::btDbvt::sStkNN::* )(  ) 
void* btDbvt_sStkNN_new1(void* p0,void* p1); //constructor: sStkNN  ( ::btDbvt::sStkNN::* )( ::btDbvtNode const *,::btDbvtNode const * ) 
void btDbvt_sStkNN_free(void *c); 
void btDbvt_sStkNN_a_set(void *c,void* a); //attribute: ::btDbvtNode const * btDbvt_sStkNN->a
void* btDbvt_sStkNN_a_get(void *c); //attribute: ::btDbvtNode const * btDbvt_sStkNN->a
void btDbvt_sStkNN_b_set(void *c,void* a); //attribute: ::btDbvtNode const * btDbvt_sStkNN->b
void* btDbvt_sStkNN_b_get(void *c); //attribute: ::btDbvtNode const * btDbvt_sStkNN->b
void* btDbvt_sStkNP_new(void* p0,unsigned int p1); //constructor: sStkNP  ( ::btDbvt::sStkNP::* )( ::btDbvtNode const *,unsigned int ) 
void btDbvt_sStkNP_free(void *c); 
void btDbvt_sStkNP_mask_set(void *c,int a); //attribute: int btDbvt_sStkNP->mask
int btDbvt_sStkNP_mask_get(void *c); //attribute: int btDbvt_sStkNP->mask
void btDbvt_sStkNP_node_set(void *c,void* a); //attribute: ::btDbvtNode const * btDbvt_sStkNP->node
void* btDbvt_sStkNP_node_get(void *c); //attribute: ::btDbvtNode const * btDbvt_sStkNP->node
void* btDbvt_sStkNPS_new0(); //constructor: sStkNPS  ( ::btDbvt::sStkNPS::* )(  ) 
void* btDbvt_sStkNPS_new1(void* p0,unsigned int p1,float p2); //constructor: sStkNPS  ( ::btDbvt::sStkNPS::* )( ::btDbvtNode const *,unsigned int,::btScalar ) 
void btDbvt_sStkNPS_free(void *c); 
void btDbvt_sStkNPS_mask_set(void *c,int a); //attribute: int btDbvt_sStkNPS->mask
int btDbvt_sStkNPS_mask_get(void *c); //attribute: int btDbvt_sStkNPS->mask
void btDbvt_sStkNPS_node_set(void *c,void* a); //attribute: ::btDbvtNode const * btDbvt_sStkNPS->node
void* btDbvt_sStkNPS_node_get(void *c); //attribute: ::btDbvtNode const * btDbvt_sStkNPS->node
void btDbvt_sStkNPS_value_set(void *c,float a); //attribute: ::btScalar btDbvt_sStkNPS->value
float btDbvt_sStkNPS_value_get(void *c); //attribute: ::btScalar btDbvt_sStkNPS->value
void* btDiscreteCollisionDetectorInterface_ClosestPointInput_new(); //constructor: ClosestPointInput  ( ::btDiscreteCollisionDetectorInterface::ClosestPointInput::* )(  ) 
void btDiscreteCollisionDetectorInterface_ClosestPointInput_free(void *c); 
void btDiscreteCollisionDetectorInterface_ClosestPointInput_m_transformA_set(void *c,float* a); //attribute: ::btTransform btDiscreteCollisionDetectorInterface_ClosestPointInput->m_transformA
void btDiscreteCollisionDetectorInterface_ClosestPointInput_m_transformA_get(void *c,float* a);
void btDiscreteCollisionDetectorInterface_ClosestPointInput_m_transformB_set(void *c,float* a); //attribute: ::btTransform btDiscreteCollisionDetectorInterface_ClosestPointInput->m_transformB
void btDiscreteCollisionDetectorInterface_ClosestPointInput_m_transformB_get(void *c,float* a);
void btDiscreteCollisionDetectorInterface_ClosestPointInput_m_maximumDistanceSquared_set(void *c,float a); //attribute: ::btScalar btDiscreteCollisionDetectorInterface_ClosestPointInput->m_maximumDistanceSquared
float btDiscreteCollisionDetectorInterface_ClosestPointInput_m_maximumDistanceSquared_get(void *c); //attribute: ::btScalar btDiscreteCollisionDetectorInterface_ClosestPointInput->m_maximumDistanceSquared
void btDiscreteCollisionDetectorInterface_ClosestPointInput_m_stackAlloc_set(void *c,void* a); //attribute: ::btStackAlloc * btDiscreteCollisionDetectorInterface_ClosestPointInput->m_stackAlloc
void* btDiscreteCollisionDetectorInterface_ClosestPointInput_m_stackAlloc_get(void *c); //attribute: ::btStackAlloc * btDiscreteCollisionDetectorInterface_ClosestPointInput->m_stackAlloc
void btDiscreteCollisionDetectorInterface_Result_setShapeIdentifiersB(void *c,int p0,int p1); //method: setShapeIdentifiersB void ( ::btDiscreteCollisionDetectorInterface::Result::* )( int,int ) 
void btDiscreteCollisionDetectorInterface_Result_setShapeIdentifiersA(void *c,int p0,int p1); //method: setShapeIdentifiersA void ( ::btDiscreteCollisionDetectorInterface::Result::* )( int,int ) 
void btDiscreteCollisionDetectorInterface_Result_addContactPoint(void *c,float* p0,float* p1,float p2); //method: addContactPoint void ( ::btDiscreteCollisionDetectorInterface::Result::* )( ::btVector3 const &,::btVector3 const &,::btScalar ) 
void* btConstraintRow_new(); //constructor: btConstraintRow  ( ::btConstraintRow::* )(  ) 
void btConstraintRow_free(void *c); 
// attribute not supported: //attribute: ::btScalar[3] btConstraintRow->m_normal
void btConstraintRow_m_rhs_set(void *c,float a); //attribute: ::btScalar btConstraintRow->m_rhs
float btConstraintRow_m_rhs_get(void *c); //attribute: ::btScalar btConstraintRow->m_rhs
void btConstraintRow_m_jacDiagInv_set(void *c,float a); //attribute: ::btScalar btConstraintRow->m_jacDiagInv
float btConstraintRow_m_jacDiagInv_get(void *c); //attribute: ::btScalar btConstraintRow->m_jacDiagInv
void btConstraintRow_m_lowerLimit_set(void *c,float a); //attribute: ::btScalar btConstraintRow->m_lowerLimit
float btConstraintRow_m_lowerLimit_get(void *c); //attribute: ::btScalar btConstraintRow->m_lowerLimit
void btConstraintRow_m_upperLimit_set(void *c,float a); //attribute: ::btScalar btConstraintRow->m_upperLimit
float btConstraintRow_m_upperLimit_get(void *c); //attribute: ::btScalar btConstraintRow->m_upperLimit
void btConstraintRow_m_accumImpulse_set(void *c,float a); //attribute: ::btScalar btConstraintRow->m_accumImpulse
float btConstraintRow_m_accumImpulse_get(void *c); //attribute: ::btScalar btConstraintRow->m_accumImpulse
void btDiscreteCollisionDetectorInterface_getClosestPoints(void *c,void* p0,void* p1,void* p2,int p3); //method: getClosestPoints void ( ::btDiscreteCollisionDetectorInterface::* )( ::btDiscreteCollisionDetectorInterface::ClosestPointInput const &,::btDiscreteCollisionDetectorInterface::Result &,::btIDebugDraw *,bool ) 
void* btGjkEpaSolver2_new(); //constructor: btGjkEpaSolver2  ( ::btGjkEpaSolver2::* )(  ) 
void btGjkEpaSolver2_free(void *c); 
int btGjkEpaSolver2_StackSizeRequirement(); //method: StackSizeRequirement int (*)(  )
int btGjkEpaSolver2_Distance(void* p0,float* p1,void* p2,float* p3,float* p4,void* p5); //method: Distance bool (*)( ::btConvexShape const *,::btTransform const &,::btConvexShape const *,::btTransform const &,::btVector3 const &,::btGjkEpaSolver2::sResults & )
int btGjkEpaSolver2_Penetration(void* p0,float* p1,void* p2,float* p3,float* p4,void* p5,int p6); //method: Penetration bool (*)( ::btConvexShape const *,::btTransform const &,::btConvexShape const *,::btTransform const &,::btVector3 const &,::btGjkEpaSolver2::sResults &,bool )
float btGjkEpaSolver2_SignedDistance(float* p0,float p1,void* p2,float* p3,void* p4); //method: SignedDistance ::btScalar (*)( ::btVector3 const &,::btScalar,::btConvexShape const *,::btTransform const &,::btGjkEpaSolver2::sResults & )
float btGjkEpaSolver2_SignedDistance0(float* p0,float p1,void* p2,float* p3,void* p4); //method: SignedDistance ::btScalar (*)( ::btVector3 const &,::btScalar,::btConvexShape const *,::btTransform const &,::btGjkEpaSolver2::sResults & )
int btGjkEpaSolver2_SignedDistance1(void* p0,float* p1,void* p2,float* p3,float* p4,void* p5); //method: SignedDistance bool (*)( ::btConvexShape const *,::btTransform const &,::btConvexShape const *,::btTransform const &,::btVector3 const &,::btGjkEpaSolver2::sResults & )
//not supported constructor: btGjkPairDetector  ( ::btGjkPairDetector::* )( ::btConvexShape const *,::btConvexShape const *,::btVoronoiSimplexSolver *,::btConvexPenetrationDepthSolver * ) 
// error: ::btConvexShape const * - ok, ::btConvexShape const * - ok, ::btVoronoiSimplexSolver * - ok,  - unsupported

//not supported constructor: btGjkPairDetector  ( ::btGjkPairDetector::* )( ::btConvexShape const *,::btConvexShape const *,int,int,::btScalar,::btScalar,::btVoronoiSimplexSolver *,::btConvexPenetrationDepthSolver * ) 
// error: ::btConvexShape const * - ok, ::btConvexShape const * - ok, int - ok, int - ok, ::btScalar - ok, ::btScalar - ok, ::btVoronoiSimplexSolver * - ok,  - unsupported

void btGjkPairDetector_free(void *c); 
void btGjkPairDetector_setCachedSeperatingAxis(void *c,float* p0); //method: setCachedSeperatingAxis void ( ::btGjkPairDetector::* )( ::btVector3 const & ) 
void btGjkPairDetector_getCachedSeparatingAxis(void *c,float* ret); //method: getCachedSeparatingAxis ::btVector3 const & ( ::btGjkPairDetector::* )(  ) const
//not supported method: setPenetrationDepthSolver void ( ::btGjkPairDetector::* )( ::btConvexPenetrationDepthSolver * ) 
// error:  - unsupported, void - ok

void btGjkPairDetector_getClosestPoints(void *c,void* p0,void* p1,void* p2,int p3); //method: getClosestPoints void ( ::btGjkPairDetector::* )( ::btDiscreteCollisionDetectorInterface::ClosestPointInput const &,::btDiscreteCollisionDetectorInterface::Result &,::btIDebugDraw *,bool ) 
void btGjkPairDetector_setMinkowskiA(void *c,void* p0); //method: setMinkowskiA void ( ::btGjkPairDetector::* )( ::btConvexShape * ) 
void btGjkPairDetector_setMinkowskiB(void *c,void* p0); //method: setMinkowskiB void ( ::btGjkPairDetector::* )( ::btConvexShape * ) 
void btGjkPairDetector_setIgnoreMargin(void *c,int p0); //method: setIgnoreMargin void ( ::btGjkPairDetector::* )( bool ) 
void btGjkPairDetector_getClosestPointsNonVirtual(void *c,void* p0,void* p1,void* p2); //method: getClosestPointsNonVirtual void ( ::btGjkPairDetector::* )( ::btDiscreteCollisionDetectorInterface::ClosestPointInput const &,::btDiscreteCollisionDetectorInterface::Result &,::btIDebugDraw * ) 
float btGjkPairDetector_getCachedSeparatingDistance(void *c); //method: getCachedSeparatingDistance ::btScalar ( ::btGjkPairDetector::* )(  ) const
void btGjkPairDetector_m_cachedSeparatingAxis_set(void *c,float* a); //attribute: ::btVector3 btGjkPairDetector->m_cachedSeparatingAxis
void btGjkPairDetector_m_cachedSeparatingAxis_get(void *c,float* a);
// attribute not supported: //attribute: ::btConvexPenetrationDepthSolver * btGjkPairDetector->m_penetrationDepthSolver
void btGjkPairDetector_m_simplexSolver_set(void *c,void* a); //attribute: ::btVoronoiSimplexSolver * btGjkPairDetector->m_simplexSolver
void* btGjkPairDetector_m_simplexSolver_get(void *c); //attribute: ::btVoronoiSimplexSolver * btGjkPairDetector->m_simplexSolver
void btGjkPairDetector_m_minkowskiA_set(void *c,void* a); //attribute: ::btConvexShape const * btGjkPairDetector->m_minkowskiA
void* btGjkPairDetector_m_minkowskiA_get(void *c); //attribute: ::btConvexShape const * btGjkPairDetector->m_minkowskiA
void btGjkPairDetector_m_minkowskiB_set(void *c,void* a); //attribute: ::btConvexShape const * btGjkPairDetector->m_minkowskiB
void* btGjkPairDetector_m_minkowskiB_get(void *c); //attribute: ::btConvexShape const * btGjkPairDetector->m_minkowskiB
void btGjkPairDetector_m_shapeTypeA_set(void *c,int a); //attribute: int btGjkPairDetector->m_shapeTypeA
int btGjkPairDetector_m_shapeTypeA_get(void *c); //attribute: int btGjkPairDetector->m_shapeTypeA
void btGjkPairDetector_m_shapeTypeB_set(void *c,int a); //attribute: int btGjkPairDetector->m_shapeTypeB
int btGjkPairDetector_m_shapeTypeB_get(void *c); //attribute: int btGjkPairDetector->m_shapeTypeB
void btGjkPairDetector_m_marginA_set(void *c,float a); //attribute: ::btScalar btGjkPairDetector->m_marginA
float btGjkPairDetector_m_marginA_get(void *c); //attribute: ::btScalar btGjkPairDetector->m_marginA
void btGjkPairDetector_m_marginB_set(void *c,float a); //attribute: ::btScalar btGjkPairDetector->m_marginB
float btGjkPairDetector_m_marginB_get(void *c); //attribute: ::btScalar btGjkPairDetector->m_marginB
void btGjkPairDetector_m_ignoreMargin_set(void *c,int a); //attribute: bool btGjkPairDetector->m_ignoreMargin
int btGjkPairDetector_m_ignoreMargin_get(void *c); //attribute: bool btGjkPairDetector->m_ignoreMargin
void btGjkPairDetector_m_cachedSeparatingDistance_set(void *c,float a); //attribute: ::btScalar btGjkPairDetector->m_cachedSeparatingDistance
float btGjkPairDetector_m_cachedSeparatingDistance_get(void *c); //attribute: ::btScalar btGjkPairDetector->m_cachedSeparatingDistance
void btGjkPairDetector_m_lastUsedMethod_set(void *c,int a); //attribute: int btGjkPairDetector->m_lastUsedMethod
int btGjkPairDetector_m_lastUsedMethod_get(void *c); //attribute: int btGjkPairDetector->m_lastUsedMethod
void btGjkPairDetector_m_curIter_set(void *c,int a); //attribute: int btGjkPairDetector->m_curIter
int btGjkPairDetector_m_curIter_get(void *c); //attribute: int btGjkPairDetector->m_curIter
void btGjkPairDetector_m_degenerateSimplex_set(void *c,int a); //attribute: int btGjkPairDetector->m_degenerateSimplex
int btGjkPairDetector_m_degenerateSimplex_get(void *c); //attribute: int btGjkPairDetector->m_degenerateSimplex
void btGjkPairDetector_m_catchDegeneracies_set(void *c,int a); //attribute: int btGjkPairDetector->m_catchDegeneracies
int btGjkPairDetector_m_catchDegeneracies_get(void *c); //attribute: int btGjkPairDetector->m_catchDegeneracies
void* btManifoldPoint_new0(); //constructor: btManifoldPoint  ( ::btManifoldPoint::* )(  ) 
void* btManifoldPoint_new1(float* p0,float* p1,float* p2,float p3); //constructor: btManifoldPoint  ( ::btManifoldPoint::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btScalar ) 
void btManifoldPoint_free(void *c); 
void btManifoldPoint_setDistance(void *c,float p0); //method: setDistance void ( ::btManifoldPoint::* )( ::btScalar ) 
int btManifoldPoint_getLifeTime(void *c); //method: getLifeTime int ( ::btManifoldPoint::* )(  ) const
float btManifoldPoint_getDistance(void *c); //method: getDistance ::btScalar ( ::btManifoldPoint::* )(  ) const
void btManifoldPoint_getPositionWorldOnB(void *c,float* ret); //method: getPositionWorldOnB ::btVector3 const & ( ::btManifoldPoint::* )(  ) const
float btManifoldPoint_getAppliedImpulse(void *c); //method: getAppliedImpulse ::btScalar ( ::btManifoldPoint::* )(  ) const
void btManifoldPoint_getPositionWorldOnA(void *c,float* ret); //method: getPositionWorldOnA ::btVector3 const & ( ::btManifoldPoint::* )(  ) const
// attribute not supported: //attribute: ::btConstraintRow[3] btManifoldPoint->mConstraintRow
void btManifoldPoint_m_appliedImpulse_set(void *c,float a); //attribute: ::btScalar btManifoldPoint->m_appliedImpulse
float btManifoldPoint_m_appliedImpulse_get(void *c); //attribute: ::btScalar btManifoldPoint->m_appliedImpulse
void btManifoldPoint_m_appliedImpulseLateral1_set(void *c,float a); //attribute: ::btScalar btManifoldPoint->m_appliedImpulseLateral1
float btManifoldPoint_m_appliedImpulseLateral1_get(void *c); //attribute: ::btScalar btManifoldPoint->m_appliedImpulseLateral1
void btManifoldPoint_m_appliedImpulseLateral2_set(void *c,float a); //attribute: ::btScalar btManifoldPoint->m_appliedImpulseLateral2
float btManifoldPoint_m_appliedImpulseLateral2_get(void *c); //attribute: ::btScalar btManifoldPoint->m_appliedImpulseLateral2
void btManifoldPoint_m_combinedFriction_set(void *c,float a); //attribute: ::btScalar btManifoldPoint->m_combinedFriction
float btManifoldPoint_m_combinedFriction_get(void *c); //attribute: ::btScalar btManifoldPoint->m_combinedFriction
void btManifoldPoint_m_combinedRestitution_set(void *c,float a); //attribute: ::btScalar btManifoldPoint->m_combinedRestitution
float btManifoldPoint_m_combinedRestitution_get(void *c); //attribute: ::btScalar btManifoldPoint->m_combinedRestitution
void btManifoldPoint_m_contactCFM1_set(void *c,float a); //attribute: ::btScalar btManifoldPoint->m_contactCFM1
float btManifoldPoint_m_contactCFM1_get(void *c); //attribute: ::btScalar btManifoldPoint->m_contactCFM1
void btManifoldPoint_m_contactCFM2_set(void *c,float a); //attribute: ::btScalar btManifoldPoint->m_contactCFM2
float btManifoldPoint_m_contactCFM2_get(void *c); //attribute: ::btScalar btManifoldPoint->m_contactCFM2
void btManifoldPoint_m_contactMotion1_set(void *c,float a); //attribute: ::btScalar btManifoldPoint->m_contactMotion1
float btManifoldPoint_m_contactMotion1_get(void *c); //attribute: ::btScalar btManifoldPoint->m_contactMotion1
void btManifoldPoint_m_contactMotion2_set(void *c,float a); //attribute: ::btScalar btManifoldPoint->m_contactMotion2
float btManifoldPoint_m_contactMotion2_get(void *c); //attribute: ::btScalar btManifoldPoint->m_contactMotion2
void btManifoldPoint_m_distance1_set(void *c,float a); //attribute: ::btScalar btManifoldPoint->m_distance1
float btManifoldPoint_m_distance1_get(void *c); //attribute: ::btScalar btManifoldPoint->m_distance1
void btManifoldPoint_m_index0_set(void *c,int a); //attribute: int btManifoldPoint->m_index0
int btManifoldPoint_m_index0_get(void *c); //attribute: int btManifoldPoint->m_index0
void btManifoldPoint_m_index1_set(void *c,int a); //attribute: int btManifoldPoint->m_index1
int btManifoldPoint_m_index1_get(void *c); //attribute: int btManifoldPoint->m_index1
void btManifoldPoint_m_lateralFrictionDir1_set(void *c,float* a); //attribute: ::btVector3 btManifoldPoint->m_lateralFrictionDir1
void btManifoldPoint_m_lateralFrictionDir1_get(void *c,float* a);
void btManifoldPoint_m_lateralFrictionDir2_set(void *c,float* a); //attribute: ::btVector3 btManifoldPoint->m_lateralFrictionDir2
void btManifoldPoint_m_lateralFrictionDir2_get(void *c,float* a);
void btManifoldPoint_m_lateralFrictionInitialized_set(void *c,int a); //attribute: bool btManifoldPoint->m_lateralFrictionInitialized
int btManifoldPoint_m_lateralFrictionInitialized_get(void *c); //attribute: bool btManifoldPoint->m_lateralFrictionInitialized
void btManifoldPoint_m_lifeTime_set(void *c,int a); //attribute: int btManifoldPoint->m_lifeTime
int btManifoldPoint_m_lifeTime_get(void *c); //attribute: int btManifoldPoint->m_lifeTime
void btManifoldPoint_m_localPointA_set(void *c,float* a); //attribute: ::btVector3 btManifoldPoint->m_localPointA
void btManifoldPoint_m_localPointA_get(void *c,float* a);
void btManifoldPoint_m_localPointB_set(void *c,float* a); //attribute: ::btVector3 btManifoldPoint->m_localPointB
void btManifoldPoint_m_localPointB_get(void *c,float* a);
void btManifoldPoint_m_normalWorldOnB_set(void *c,float* a); //attribute: ::btVector3 btManifoldPoint->m_normalWorldOnB
void btManifoldPoint_m_normalWorldOnB_get(void *c,float* a);
void btManifoldPoint_m_partId0_set(void *c,int a); //attribute: int btManifoldPoint->m_partId0
int btManifoldPoint_m_partId0_get(void *c); //attribute: int btManifoldPoint->m_partId0
void btManifoldPoint_m_partId1_set(void *c,int a); //attribute: int btManifoldPoint->m_partId1
int btManifoldPoint_m_partId1_get(void *c); //attribute: int btManifoldPoint->m_partId1
void btManifoldPoint_m_positionWorldOnA_set(void *c,float* a); //attribute: ::btVector3 btManifoldPoint->m_positionWorldOnA
void btManifoldPoint_m_positionWorldOnA_get(void *c,float* a);
void btManifoldPoint_m_positionWorldOnB_set(void *c,float* a); //attribute: ::btVector3 btManifoldPoint->m_positionWorldOnB
void btManifoldPoint_m_positionWorldOnB_get(void *c,float* a);
void btManifoldPoint_m_userPersistentData_set(void *c,void* a); //attribute: void * btManifoldPoint->m_userPersistentData
void* btManifoldPoint_m_userPersistentData_get(void *c); //attribute: void * btManifoldPoint->m_userPersistentData
void* btPersistentManifold_new0(); //constructor: btPersistentManifold  ( ::btPersistentManifold::* )(  ) 
void* btPersistentManifold_new1(void* p0,void* p1,int p2,float p3,float p4); //constructor: btPersistentManifold  ( ::btPersistentManifold::* )( void *,void *,int,::btScalar,::btScalar ) 
void btPersistentManifold_free(void *c); 
void btPersistentManifold_setBodies(void *c,void* p0,void* p1); //method: setBodies void ( ::btPersistentManifold::* )( void *,void * ) 
void btPersistentManifold_replaceContactPoint(void *c,void* p0,int p1); //method: replaceContactPoint void ( ::btPersistentManifold::* )( ::btManifoldPoint const &,int ) 
void btPersistentManifold_clearUserCache(void *c,void* p0); //method: clearUserCache void ( ::btPersistentManifold::* )( ::btManifoldPoint & ) 
void* btPersistentManifold_getBody1(void *c); //method: getBody1 void * ( ::btPersistentManifold::* )(  ) 
void* btPersistentManifold_getBody10(void *c); //method: getBody1 void * ( ::btPersistentManifold::* )(  ) 
//not supported method: getBody1 void const * ( ::btPersistentManifold::* )(  ) const
// error:  - unsupported

float btPersistentManifold_getContactProcessingThreshold(void *c); //method: getContactProcessingThreshold ::btScalar ( ::btPersistentManifold::* )(  ) const
void btPersistentManifold_clearManifold(void *c); //method: clearManifold void ( ::btPersistentManifold::* )(  ) 
int btPersistentManifold_getNumContacts(void *c); //method: getNumContacts int ( ::btPersistentManifold::* )(  ) const
void* btPersistentManifold_getBody0(void *c); //method: getBody0 void * ( ::btPersistentManifold::* )(  ) 
void* btPersistentManifold_getBody00(void *c); //method: getBody0 void * ( ::btPersistentManifold::* )(  ) 
//not supported method: getBody0 void const * ( ::btPersistentManifold::* )(  ) const
// error:  - unsupported

int btPersistentManifold_addManifoldPoint(void *c,void* p0); //method: addManifoldPoint int ( ::btPersistentManifold::* )( ::btManifoldPoint const & ) 
int btPersistentManifold_getCacheEntry(void *c,void* p0); //method: getCacheEntry int ( ::btPersistentManifold::* )( ::btManifoldPoint const & ) const
int btPersistentManifold_validContactDistance(void *c,void* p0); //method: validContactDistance bool ( ::btPersistentManifold::* )( ::btManifoldPoint const & ) const
void btPersistentManifold_removeContactPoint(void *c,int p0); //method: removeContactPoint void ( ::btPersistentManifold::* )( int ) 
void* btPersistentManifold_getContactPoint(void *c,int p0); //method: getContactPoint ::btManifoldPoint const & ( ::btPersistentManifold::* )( int ) const
void* btPersistentManifold_getContactPoint0(void *c,int p0); //method: getContactPoint ::btManifoldPoint const & ( ::btPersistentManifold::* )( int ) const
void* btPersistentManifold_getContactPoint1(void *c,int p0); //method: getContactPoint ::btManifoldPoint & ( ::btPersistentManifold::* )( int ) 
void btPersistentManifold_refreshContactPoints(void *c,float* p0,float* p1); //method: refreshContactPoints void ( ::btPersistentManifold::* )( ::btTransform const &,::btTransform const & ) 
float btPersistentManifold_getContactBreakingThreshold(void *c); //method: getContactBreakingThreshold ::btScalar ( ::btPersistentManifold::* )(  ) const
void btPersistentManifold_m_companionIdA_set(void *c,int a); //attribute: int btPersistentManifold->m_companionIdA
int btPersistentManifold_m_companionIdA_get(void *c); //attribute: int btPersistentManifold->m_companionIdA
void btPersistentManifold_m_companionIdB_set(void *c,int a); //attribute: int btPersistentManifold->m_companionIdB
int btPersistentManifold_m_companionIdB_get(void *c); //attribute: int btPersistentManifold->m_companionIdB
void btPersistentManifold_m_index1a_set(void *c,int a); //attribute: int btPersistentManifold->m_index1a
int btPersistentManifold_m_index1a_get(void *c); //attribute: int btPersistentManifold->m_index1a
void btStorageResult_addContactPoint(void *c,float* p0,float* p1,float p2); //method: addContactPoint void ( ::btStorageResult::* )( ::btVector3 const &,::btVector3 const &,::btScalar ) 
void btStorageResult_m_normalOnSurfaceB_set(void *c,float* a); //attribute: ::btVector3 btStorageResult->m_normalOnSurfaceB
void btStorageResult_m_normalOnSurfaceB_get(void *c,float* a);
void btStorageResult_m_closestPointInB_set(void *c,float* a); //attribute: ::btVector3 btStorageResult->m_closestPointInB
void btStorageResult_m_closestPointInB_get(void *c,float* a);
void btStorageResult_m_distance_set(void *c,float a); //attribute: ::btScalar btStorageResult->m_distance
float btStorageResult_m_distance_get(void *c); //attribute: ::btScalar btStorageResult->m_distance
void* btSubSimplexClosestResult_new(); //constructor: btSubSimplexClosestResult  ( ::btSubSimplexClosestResult::* )(  ) 
void btSubSimplexClosestResult_free(void *c); 
void btSubSimplexClosestResult_reset(void *c); //method: reset void ( ::btSubSimplexClosestResult::* )(  ) 
int btSubSimplexClosestResult_isValid(void *c); //method: isValid bool ( ::btSubSimplexClosestResult::* )(  ) 
void btSubSimplexClosestResult_setBarycentricCoordinates(void *c,float p0,float p1,float p2,float p3); //method: setBarycentricCoordinates void ( ::btSubSimplexClosestResult::* )( ::btScalar,::btScalar,::btScalar,::btScalar ) 
void btSubSimplexClosestResult_m_closestPointOnSimplex_set(void *c,float* a); //attribute: ::btVector3 btSubSimplexClosestResult->m_closestPointOnSimplex
void btSubSimplexClosestResult_m_closestPointOnSimplex_get(void *c,float* a);
void btSubSimplexClosestResult_m_usedVertices_set(void *c,void* a); //attribute: ::btUsageBitfield btSubSimplexClosestResult->m_usedVertices
void* btSubSimplexClosestResult_m_usedVertices_get(void *c); //attribute: ::btUsageBitfield btSubSimplexClosestResult->m_usedVertices
// attribute not supported: //attribute: ::btScalar[4] btSubSimplexClosestResult->m_barycentricCoords
void btSubSimplexClosestResult_m_degenerate_set(void *c,int a); //attribute: bool btSubSimplexClosestResult->m_degenerate
int btSubSimplexClosestResult_m_degenerate_get(void *c); //attribute: bool btSubSimplexClosestResult->m_degenerate
void* btUsageBitfield_new(); //constructor: btUsageBitfield  ( ::btUsageBitfield::* )(  ) 
void btUsageBitfield_free(void *c); 
void btUsageBitfield_reset(void *c); //method: reset void ( ::btUsageBitfield::* )(  ) 
void btUsageBitfield_unused1_set(void *c,short unsigned int a); //attribute: short unsigned int btUsageBitfield->unused1
short unsigned int btUsageBitfield_unused1_get(void *c); //attribute: short unsigned int btUsageBitfield->unused1
void btUsageBitfield_unused2_set(void *c,short unsigned int a); //attribute: short unsigned int btUsageBitfield->unused2
short unsigned int btUsageBitfield_unused2_get(void *c); //attribute: short unsigned int btUsageBitfield->unused2
void btUsageBitfield_unused3_set(void *c,short unsigned int a); //attribute: short unsigned int btUsageBitfield->unused3
short unsigned int btUsageBitfield_unused3_get(void *c); //attribute: short unsigned int btUsageBitfield->unused3
void btUsageBitfield_unused4_set(void *c,short unsigned int a); //attribute: short unsigned int btUsageBitfield->unused4
short unsigned int btUsageBitfield_unused4_get(void *c); //attribute: short unsigned int btUsageBitfield->unused4
void btUsageBitfield_usedVertexA_set(void *c,short unsigned int a); //attribute: short unsigned int btUsageBitfield->usedVertexA
short unsigned int btUsageBitfield_usedVertexA_get(void *c); //attribute: short unsigned int btUsageBitfield->usedVertexA
void btUsageBitfield_usedVertexB_set(void *c,short unsigned int a); //attribute: short unsigned int btUsageBitfield->usedVertexB
short unsigned int btUsageBitfield_usedVertexB_get(void *c); //attribute: short unsigned int btUsageBitfield->usedVertexB
void btUsageBitfield_usedVertexC_set(void *c,short unsigned int a); //attribute: short unsigned int btUsageBitfield->usedVertexC
short unsigned int btUsageBitfield_usedVertexC_get(void *c); //attribute: short unsigned int btUsageBitfield->usedVertexC
void btUsageBitfield_usedVertexD_set(void *c,short unsigned int a); //attribute: short unsigned int btUsageBitfield->usedVertexD
short unsigned int btUsageBitfield_usedVertexD_get(void *c); //attribute: short unsigned int btUsageBitfield->usedVertexD
void* btVoronoiSimplexSolver_new(); //constructor: btVoronoiSimplexSolver  ( ::btVoronoiSimplexSolver::* )(  ) 
void btVoronoiSimplexSolver_free(void *c); 
void btVoronoiSimplexSolver_reset(void *c); //method: reset void ( ::btVoronoiSimplexSolver::* )(  ) 
int btVoronoiSimplexSolver_updateClosestVectorAndPoints(void *c); //method: updateClosestVectorAndPoints bool ( ::btVoronoiSimplexSolver::* )(  ) 
void btVoronoiSimplexSolver_setEqualVertexThreshold(void *c,float p0); //method: setEqualVertexThreshold void ( ::btVoronoiSimplexSolver::* )( ::btScalar ) 
int btVoronoiSimplexSolver_inSimplex(void *c,float* p0); //method: inSimplex bool ( ::btVoronoiSimplexSolver::* )( ::btVector3 const & ) 
int btVoronoiSimplexSolver_closest(void *c,float* p0); //method: closest bool ( ::btVoronoiSimplexSolver::* )( ::btVector3 & ) 
int btVoronoiSimplexSolver_closestPtPointTetrahedron(void *c,float* p0,float* p1,float* p2,float* p3,float* p4,void* p5); //method: closestPtPointTetrahedron bool ( ::btVoronoiSimplexSolver::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btSubSimplexClosestResult & ) 
int btVoronoiSimplexSolver_closestPtPointTriangle(void *c,float* p0,float* p1,float* p2,float* p3,void* p4); //method: closestPtPointTriangle bool ( ::btVoronoiSimplexSolver::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btSubSimplexClosestResult & ) 
int btVoronoiSimplexSolver_pointOutsideOfPlane(void *c,float* p0,float* p1,float* p2,float* p3,float* p4); //method: pointOutsideOfPlane int ( ::btVoronoiSimplexSolver::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
int btVoronoiSimplexSolver_emptySimplex(void *c); //method: emptySimplex bool ( ::btVoronoiSimplexSolver::* )(  ) const
//not supported method: getSimplex int ( ::btVoronoiSimplexSolver::* )( ::btVector3 *,::btVector3 *,::btVector3 * ) const
// error:  - unsupported,  - unsupported,  - unsupported, int - ok

float btVoronoiSimplexSolver_maxVertex(void *c); //method: maxVertex ::btScalar ( ::btVoronoiSimplexSolver::* )(  ) 
void btVoronoiSimplexSolver_addVertex(void *c,float* p0,float* p1,float* p2); //method: addVertex void ( ::btVoronoiSimplexSolver::* )( ::btVector3 const &,::btVector3 const &,::btVector3 const & ) 
void btVoronoiSimplexSolver_reduceVertices(void *c,void* p0); //method: reduceVertices void ( ::btVoronoiSimplexSolver::* )( ::btUsageBitfield const & ) 
void btVoronoiSimplexSolver_backup_closest(void *c,float* p0); //method: backup_closest void ( ::btVoronoiSimplexSolver::* )( ::btVector3 & ) 
void btVoronoiSimplexSolver_removeVertex(void *c,int p0); //method: removeVertex void ( ::btVoronoiSimplexSolver::* )( int ) 
float btVoronoiSimplexSolver_getEqualVertexThreshold(void *c); //method: getEqualVertexThreshold ::btScalar ( ::btVoronoiSimplexSolver::* )(  ) const
void btVoronoiSimplexSolver_compute_points(void *c,float* p0,float* p1); //method: compute_points void ( ::btVoronoiSimplexSolver::* )( ::btVector3 &,::btVector3 & ) 
int btVoronoiSimplexSolver_fullSimplex(void *c); //method: fullSimplex bool ( ::btVoronoiSimplexSolver::* )(  ) const
int btVoronoiSimplexSolver_numVertices(void *c); //method: numVertices int ( ::btVoronoiSimplexSolver::* )(  ) const
void btVoronoiSimplexSolver_m_cachedBC_set(void *c,void* a); //attribute: ::btSubSimplexClosestResult btVoronoiSimplexSolver->m_cachedBC
void* btVoronoiSimplexSolver_m_cachedBC_get(void *c); //attribute: ::btSubSimplexClosestResult btVoronoiSimplexSolver->m_cachedBC
void btVoronoiSimplexSolver_m_cachedP1_set(void *c,float* a); //attribute: ::btVector3 btVoronoiSimplexSolver->m_cachedP1
void btVoronoiSimplexSolver_m_cachedP1_get(void *c,float* a);
void btVoronoiSimplexSolver_m_cachedP2_set(void *c,float* a); //attribute: ::btVector3 btVoronoiSimplexSolver->m_cachedP2
void btVoronoiSimplexSolver_m_cachedP2_get(void *c,float* a);
void btVoronoiSimplexSolver_m_cachedV_set(void *c,float* a); //attribute: ::btVector3 btVoronoiSimplexSolver->m_cachedV
void btVoronoiSimplexSolver_m_cachedV_get(void *c,float* a);
void btVoronoiSimplexSolver_m_cachedValidClosest_set(void *c,int a); //attribute: bool btVoronoiSimplexSolver->m_cachedValidClosest
int btVoronoiSimplexSolver_m_cachedValidClosest_get(void *c); //attribute: bool btVoronoiSimplexSolver->m_cachedValidClosest
void btVoronoiSimplexSolver_m_equalVertexThreshold_set(void *c,float a); //attribute: ::btScalar btVoronoiSimplexSolver->m_equalVertexThreshold
float btVoronoiSimplexSolver_m_equalVertexThreshold_get(void *c); //attribute: ::btScalar btVoronoiSimplexSolver->m_equalVertexThreshold
void btVoronoiSimplexSolver_m_lastW_set(void *c,float* a); //attribute: ::btVector3 btVoronoiSimplexSolver->m_lastW
void btVoronoiSimplexSolver_m_lastW_get(void *c,float* a);
void btVoronoiSimplexSolver_m_needsUpdate_set(void *c,int a); //attribute: bool btVoronoiSimplexSolver->m_needsUpdate
int btVoronoiSimplexSolver_m_needsUpdate_get(void *c); //attribute: bool btVoronoiSimplexSolver->m_needsUpdate
void btVoronoiSimplexSolver_m_numVertices_set(void *c,int a); //attribute: int btVoronoiSimplexSolver->m_numVertices
int btVoronoiSimplexSolver_m_numVertices_get(void *c); //attribute: int btVoronoiSimplexSolver->m_numVertices
// attribute not supported: //attribute: ::btVector3[5] btVoronoiSimplexSolver->m_simplexPointsP
// attribute not supported: //attribute: ::btVector3[5] btVoronoiSimplexSolver->m_simplexPointsQ
// attribute not supported: //attribute: ::btVector3[5] btVoronoiSimplexSolver->m_simplexVectorW
void* btGjkEpaSolver2_sResults_new(); //constructor: sResults  ( ::btGjkEpaSolver2::sResults::* )(  ) 
void btGjkEpaSolver2_sResults_free(void *c); 
void btGjkEpaSolver2_sResults_distance_set(void *c,float a); //attribute: ::btScalar btGjkEpaSolver2_sResults->distance
float btGjkEpaSolver2_sResults_distance_get(void *c); //attribute: ::btScalar btGjkEpaSolver2_sResults->distance
void btGjkEpaSolver2_sResults_normal_set(void *c,float* a); //attribute: ::btVector3 btGjkEpaSolver2_sResults->normal
void btGjkEpaSolver2_sResults_normal_get(void *c,float* a);
// attribute not supported: //attribute: ::btGjkEpaSolver2::sResults::eStatus btGjkEpaSolver2_sResults->status
// attribute not supported: //attribute: ::btVector3[2] btGjkEpaSolver2_sResults->witnesses
void* btCollisionWorld_AllHitsRayResultCallback_new(float* p0,float* p1); //constructor: AllHitsRayResultCallback  ( ::btCollisionWorld::AllHitsRayResultCallback::* )( ::btVector3 const &,::btVector3 const & ) 
void btCollisionWorld_AllHitsRayResultCallback_free(void *c); 
float btCollisionWorld_AllHitsRayResultCallback_addSingleResult(void *c,void* p0,int p1); //method: addSingleResult ::btScalar ( ::btCollisionWorld::AllHitsRayResultCallback::* )( ::btCollisionWorld::LocalRayResult &,bool ) 
void btCollisionWorld_AllHitsRayResultCallback_m_collisionObjects_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btCollisionObject*> btCollisionWorld_AllHitsRayResultCallback->m_collisionObjects
void* btCollisionWorld_AllHitsRayResultCallback_m_collisionObjects_get(void *c); //attribute: ::btAlignedObjectArray<btCollisionObject*> btCollisionWorld_AllHitsRayResultCallback->m_collisionObjects
void btCollisionWorld_AllHitsRayResultCallback_m_hitFractions_set(void *c,void* a); //attribute: ::btAlignedObjectArray<float> btCollisionWorld_AllHitsRayResultCallback->m_hitFractions
void* btCollisionWorld_AllHitsRayResultCallback_m_hitFractions_get(void *c); //attribute: ::btAlignedObjectArray<float> btCollisionWorld_AllHitsRayResultCallback->m_hitFractions
void btCollisionWorld_AllHitsRayResultCallback_m_hitNormalWorld_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btVector3> btCollisionWorld_AllHitsRayResultCallback->m_hitNormalWorld
void* btCollisionWorld_AllHitsRayResultCallback_m_hitNormalWorld_get(void *c); //attribute: ::btAlignedObjectArray<btVector3> btCollisionWorld_AllHitsRayResultCallback->m_hitNormalWorld
void btCollisionWorld_AllHitsRayResultCallback_m_hitPointWorld_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btVector3> btCollisionWorld_AllHitsRayResultCallback->m_hitPointWorld
void* btCollisionWorld_AllHitsRayResultCallback_m_hitPointWorld_get(void *c); //attribute: ::btAlignedObjectArray<btVector3> btCollisionWorld_AllHitsRayResultCallback->m_hitPointWorld
void btCollisionWorld_AllHitsRayResultCallback_m_rayFromWorld_set(void *c,float* a); //attribute: ::btVector3 btCollisionWorld_AllHitsRayResultCallback->m_rayFromWorld
void btCollisionWorld_AllHitsRayResultCallback_m_rayFromWorld_get(void *c,float* a);
void btCollisionWorld_AllHitsRayResultCallback_m_rayToWorld_set(void *c,float* a); //attribute: ::btVector3 btCollisionWorld_AllHitsRayResultCallback->m_rayToWorld
void btCollisionWorld_AllHitsRayResultCallback_m_rayToWorld_get(void *c,float* a);
void* btCollisionWorld_ClosestConvexResultCallback_new(float* p0,float* p1); //constructor: ClosestConvexResultCallback  ( ::btCollisionWorld::ClosestConvexResultCallback::* )( ::btVector3 const &,::btVector3 const & ) 
void btCollisionWorld_ClosestConvexResultCallback_free(void *c); 
float btCollisionWorld_ClosestConvexResultCallback_addSingleResult(void *c,void* p0,int p1); //method: addSingleResult ::btScalar ( ::btCollisionWorld::ClosestConvexResultCallback::* )( ::btCollisionWorld::LocalConvexResult &,bool ) 
void btCollisionWorld_ClosestConvexResultCallback_m_convexFromWorld_set(void *c,float* a); //attribute: ::btVector3 btCollisionWorld_ClosestConvexResultCallback->m_convexFromWorld
void btCollisionWorld_ClosestConvexResultCallback_m_convexFromWorld_get(void *c,float* a);
void btCollisionWorld_ClosestConvexResultCallback_m_convexToWorld_set(void *c,float* a); //attribute: ::btVector3 btCollisionWorld_ClosestConvexResultCallback->m_convexToWorld
void btCollisionWorld_ClosestConvexResultCallback_m_convexToWorld_get(void *c,float* a);
void btCollisionWorld_ClosestConvexResultCallback_m_hitCollisionObject_set(void *c,void* a); //attribute: ::btCollisionObject * btCollisionWorld_ClosestConvexResultCallback->m_hitCollisionObject
void* btCollisionWorld_ClosestConvexResultCallback_m_hitCollisionObject_get(void *c); //attribute: ::btCollisionObject * btCollisionWorld_ClosestConvexResultCallback->m_hitCollisionObject
void btCollisionWorld_ClosestConvexResultCallback_m_hitNormalWorld_set(void *c,float* a); //attribute: ::btVector3 btCollisionWorld_ClosestConvexResultCallback->m_hitNormalWorld
void btCollisionWorld_ClosestConvexResultCallback_m_hitNormalWorld_get(void *c,float* a);
void btCollisionWorld_ClosestConvexResultCallback_m_hitPointWorld_set(void *c,float* a); //attribute: ::btVector3 btCollisionWorld_ClosestConvexResultCallback->m_hitPointWorld
void btCollisionWorld_ClosestConvexResultCallback_m_hitPointWorld_get(void *c,float* a);
void* btCollisionWorld_ClosestRayResultCallback_new(float* p0,float* p1); //constructor: ClosestRayResultCallback  ( ::btCollisionWorld::ClosestRayResultCallback::* )( ::btVector3 const &,::btVector3 const & ) 
void btCollisionWorld_ClosestRayResultCallback_free(void *c); 
float btCollisionWorld_ClosestRayResultCallback_addSingleResult(void *c,void* p0,int p1); //method: addSingleResult ::btScalar ( ::btCollisionWorld::ClosestRayResultCallback::* )( ::btCollisionWorld::LocalRayResult &,bool ) 
void btCollisionWorld_ClosestRayResultCallback_m_hitNormalWorld_set(void *c,float* a); //attribute: ::btVector3 btCollisionWorld_ClosestRayResultCallback->m_hitNormalWorld
void btCollisionWorld_ClosestRayResultCallback_m_hitNormalWorld_get(void *c,float* a);
void btCollisionWorld_ClosestRayResultCallback_m_hitPointWorld_set(void *c,float* a); //attribute: ::btVector3 btCollisionWorld_ClosestRayResultCallback->m_hitPointWorld
void btCollisionWorld_ClosestRayResultCallback_m_hitPointWorld_get(void *c,float* a);
void btCollisionWorld_ClosestRayResultCallback_m_rayFromWorld_set(void *c,float* a); //attribute: ::btVector3 btCollisionWorld_ClosestRayResultCallback->m_rayFromWorld
void btCollisionWorld_ClosestRayResultCallback_m_rayFromWorld_get(void *c,float* a);
void btCollisionWorld_ClosestRayResultCallback_m_rayToWorld_set(void *c,float* a); //attribute: ::btVector3 btCollisionWorld_ClosestRayResultCallback->m_rayToWorld
void btCollisionWorld_ClosestRayResultCallback_m_rayToWorld_get(void *c,float* a);
float btCollisionWorld_ContactResultCallback_addSingleResult(void *c,void* p0,void* p1,int p2,int p3,void* p4,int p5,int p6); //method: addSingleResult ::btScalar ( ::btCollisionWorld::ContactResultCallback::* )( ::btManifoldPoint &,::btCollisionObject const *,int,int,::btCollisionObject const *,int,int ) 
int btCollisionWorld_ContactResultCallback_needsCollision(void *c,void* p0); //method: needsCollision bool ( ::btCollisionWorld::ContactResultCallback::* )( ::btBroadphaseProxy * ) const
void btCollisionWorld_ContactResultCallback_m_collisionFilterGroup_set(void *c,short int a); //attribute: short int btCollisionWorld_ContactResultCallback->m_collisionFilterGroup
short int btCollisionWorld_ContactResultCallback_m_collisionFilterGroup_get(void *c); //attribute: short int btCollisionWorld_ContactResultCallback->m_collisionFilterGroup
void btCollisionWorld_ContactResultCallback_m_collisionFilterMask_set(void *c,short int a); //attribute: short int btCollisionWorld_ContactResultCallback->m_collisionFilterMask
short int btCollisionWorld_ContactResultCallback_m_collisionFilterMask_get(void *c); //attribute: short int btCollisionWorld_ContactResultCallback->m_collisionFilterMask
float btCollisionWorld_ConvexResultCallback_addSingleResult(void *c,void* p0,int p1); //method: addSingleResult ::btScalar ( ::btCollisionWorld::ConvexResultCallback::* )( ::btCollisionWorld::LocalConvexResult &,bool ) 
int btCollisionWorld_ConvexResultCallback_needsCollision(void *c,void* p0); //method: needsCollision bool ( ::btCollisionWorld::ConvexResultCallback::* )( ::btBroadphaseProxy * ) const
int btCollisionWorld_ConvexResultCallback_hasHit(void *c); //method: hasHit bool ( ::btCollisionWorld::ConvexResultCallback::* )(  ) const
void btCollisionWorld_ConvexResultCallback_m_closestHitFraction_set(void *c,float a); //attribute: ::btScalar btCollisionWorld_ConvexResultCallback->m_closestHitFraction
float btCollisionWorld_ConvexResultCallback_m_closestHitFraction_get(void *c); //attribute: ::btScalar btCollisionWorld_ConvexResultCallback->m_closestHitFraction
void btCollisionWorld_ConvexResultCallback_m_collisionFilterGroup_set(void *c,short int a); //attribute: short int btCollisionWorld_ConvexResultCallback->m_collisionFilterGroup
short int btCollisionWorld_ConvexResultCallback_m_collisionFilterGroup_get(void *c); //attribute: short int btCollisionWorld_ConvexResultCallback->m_collisionFilterGroup
void btCollisionWorld_ConvexResultCallback_m_collisionFilterMask_set(void *c,short int a); //attribute: short int btCollisionWorld_ConvexResultCallback->m_collisionFilterMask
short int btCollisionWorld_ConvexResultCallback_m_collisionFilterMask_get(void *c); //attribute: short int btCollisionWorld_ConvexResultCallback->m_collisionFilterMask
void* btSphereSphereCollisionAlgorithm_CreateFunc_new(); //constructor: CreateFunc  ( ::btSphereSphereCollisionAlgorithm::CreateFunc::* )(  ) 
void btSphereSphereCollisionAlgorithm_CreateFunc_free(void *c); 
void* btSphereSphereCollisionAlgorithm_CreateFunc_CreateCollisionAlgorithm(void *c,void* p0,void* p1,void* p2); //method: CreateCollisionAlgorithm ::btCollisionAlgorithm * ( ::btSphereSphereCollisionAlgorithm::CreateFunc::* )( ::btCollisionAlgorithmConstructionInfo &,::btCollisionObject *,::btCollisionObject * ) 
//not supported constructor: CreateFunc  ( ::btConvexConvexAlgorithm::CreateFunc::* )( ::btVoronoiSimplexSolver *,::btConvexPenetrationDepthSolver * ) 
// error: ::btVoronoiSimplexSolver * - ok,  - unsupported

void btConvexConvexAlgorithm_CreateFunc_free(void *c); 
void* btConvexConvexAlgorithm_CreateFunc_CreateCollisionAlgorithm(void *c,void* p0,void* p1,void* p2); //method: CreateCollisionAlgorithm ::btCollisionAlgorithm * ( ::btConvexConvexAlgorithm::CreateFunc::* )( ::btCollisionAlgorithmConstructionInfo &,::btCollisionObject *,::btCollisionObject * ) 
// attribute not supported: //attribute: ::btConvexPenetrationDepthSolver * btConvexConvexAlgorithm_CreateFunc->m_pdSolver
void btConvexConvexAlgorithm_CreateFunc_m_simplexSolver_set(void *c,void* a); //attribute: ::btVoronoiSimplexSolver * btConvexConvexAlgorithm_CreateFunc->m_simplexSolver
void* btConvexConvexAlgorithm_CreateFunc_m_simplexSolver_get(void *c); //attribute: ::btVoronoiSimplexSolver * btConvexConvexAlgorithm_CreateFunc->m_simplexSolver
void btConvexConvexAlgorithm_CreateFunc_m_numPerturbationIterations_set(void *c,int a); //attribute: int btConvexConvexAlgorithm_CreateFunc->m_numPerturbationIterations
int btConvexConvexAlgorithm_CreateFunc_m_numPerturbationIterations_get(void *c); //attribute: int btConvexConvexAlgorithm_CreateFunc->m_numPerturbationIterations
void btConvexConvexAlgorithm_CreateFunc_m_minimumPointsPerturbationThreshold_set(void *c,int a); //attribute: int btConvexConvexAlgorithm_CreateFunc->m_minimumPointsPerturbationThreshold
int btConvexConvexAlgorithm_CreateFunc_m_minimumPointsPerturbationThreshold_get(void *c); //attribute: int btConvexConvexAlgorithm_CreateFunc->m_minimumPointsPerturbationThreshold
void* btCollisionWorld_LocalConvexResult_new(void* p0,void* p1,float* p2,float* p3,float p4); //constructor: LocalConvexResult  ( ::btCollisionWorld::LocalConvexResult::* )( ::btCollisionObject *,::btCollisionWorld::LocalShapeInfo *,::btVector3 const &,::btVector3 const &,::btScalar ) 
void btCollisionWorld_LocalConvexResult_free(void *c); 
void btCollisionWorld_LocalConvexResult_m_hitCollisionObject_set(void *c,void* a); //attribute: ::btCollisionObject * btCollisionWorld_LocalConvexResult->m_hitCollisionObject
void* btCollisionWorld_LocalConvexResult_m_hitCollisionObject_get(void *c); //attribute: ::btCollisionObject * btCollisionWorld_LocalConvexResult->m_hitCollisionObject
void btCollisionWorld_LocalConvexResult_m_hitFraction_set(void *c,float a); //attribute: ::btScalar btCollisionWorld_LocalConvexResult->m_hitFraction
float btCollisionWorld_LocalConvexResult_m_hitFraction_get(void *c); //attribute: ::btScalar btCollisionWorld_LocalConvexResult->m_hitFraction
void btCollisionWorld_LocalConvexResult_m_hitNormalLocal_set(void *c,float* a); //attribute: ::btVector3 btCollisionWorld_LocalConvexResult->m_hitNormalLocal
void btCollisionWorld_LocalConvexResult_m_hitNormalLocal_get(void *c,float* a);
void btCollisionWorld_LocalConvexResult_m_hitPointLocal_set(void *c,float* a); //attribute: ::btVector3 btCollisionWorld_LocalConvexResult->m_hitPointLocal
void btCollisionWorld_LocalConvexResult_m_hitPointLocal_get(void *c,float* a);
void btCollisionWorld_LocalConvexResult_m_localShapeInfo_set(void *c,void* a); //attribute: ::btCollisionWorld::LocalShapeInfo * btCollisionWorld_LocalConvexResult->m_localShapeInfo
void* btCollisionWorld_LocalConvexResult_m_localShapeInfo_get(void *c); //attribute: ::btCollisionWorld::LocalShapeInfo * btCollisionWorld_LocalConvexResult->m_localShapeInfo
void* btCollisionWorld_LocalRayResult_new(void* p0,void* p1,float* p2,float p3); //constructor: LocalRayResult  ( ::btCollisionWorld::LocalRayResult::* )( ::btCollisionObject *,::btCollisionWorld::LocalShapeInfo *,::btVector3 const &,::btScalar ) 
void btCollisionWorld_LocalRayResult_free(void *c); 
void btCollisionWorld_LocalRayResult_m_collisionObject_set(void *c,void* a); //attribute: ::btCollisionObject * btCollisionWorld_LocalRayResult->m_collisionObject
void* btCollisionWorld_LocalRayResult_m_collisionObject_get(void *c); //attribute: ::btCollisionObject * btCollisionWorld_LocalRayResult->m_collisionObject
void btCollisionWorld_LocalRayResult_m_hitFraction_set(void *c,float a); //attribute: ::btScalar btCollisionWorld_LocalRayResult->m_hitFraction
float btCollisionWorld_LocalRayResult_m_hitFraction_get(void *c); //attribute: ::btScalar btCollisionWorld_LocalRayResult->m_hitFraction
void btCollisionWorld_LocalRayResult_m_hitNormalLocal_set(void *c,float* a); //attribute: ::btVector3 btCollisionWorld_LocalRayResult->m_hitNormalLocal
void btCollisionWorld_LocalRayResult_m_hitNormalLocal_get(void *c,float* a);
void btCollisionWorld_LocalRayResult_m_localShapeInfo_set(void *c,void* a); //attribute: ::btCollisionWorld::LocalShapeInfo * btCollisionWorld_LocalRayResult->m_localShapeInfo
void* btCollisionWorld_LocalRayResult_m_localShapeInfo_get(void *c); //attribute: ::btCollisionWorld::LocalShapeInfo * btCollisionWorld_LocalRayResult->m_localShapeInfo
void* btCollisionWorld_LocalShapeInfo_new(); //constructor: LocalShapeInfo  ( ::btCollisionWorld::LocalShapeInfo::* )(  ) 
void btCollisionWorld_LocalShapeInfo_free(void *c); 
void btCollisionWorld_LocalShapeInfo_m_shapePart_set(void *c,int a); //attribute: int btCollisionWorld_LocalShapeInfo->m_shapePart
int btCollisionWorld_LocalShapeInfo_m_shapePart_get(void *c); //attribute: int btCollisionWorld_LocalShapeInfo->m_shapePart
void btCollisionWorld_LocalShapeInfo_m_triangleIndex_set(void *c,int a); //attribute: int btCollisionWorld_LocalShapeInfo->m_triangleIndex
int btCollisionWorld_LocalShapeInfo_m_triangleIndex_get(void *c); //attribute: int btCollisionWorld_LocalShapeInfo->m_triangleIndex
float btCollisionWorld_RayResultCallback_addSingleResult(void *c,void* p0,int p1); //method: addSingleResult ::btScalar ( ::btCollisionWorld::RayResultCallback::* )( ::btCollisionWorld::LocalRayResult &,bool ) 
int btCollisionWorld_RayResultCallback_needsCollision(void *c,void* p0); //method: needsCollision bool ( ::btCollisionWorld::RayResultCallback::* )( ::btBroadphaseProxy * ) const
int btCollisionWorld_RayResultCallback_hasHit(void *c); //method: hasHit bool ( ::btCollisionWorld::RayResultCallback::* )(  ) const
void btCollisionWorld_RayResultCallback_m_closestHitFraction_set(void *c,float a); //attribute: ::btScalar btCollisionWorld_RayResultCallback->m_closestHitFraction
float btCollisionWorld_RayResultCallback_m_closestHitFraction_get(void *c); //attribute: ::btScalar btCollisionWorld_RayResultCallback->m_closestHitFraction
void btCollisionWorld_RayResultCallback_m_collisionFilterGroup_set(void *c,short int a); //attribute: short int btCollisionWorld_RayResultCallback->m_collisionFilterGroup
short int btCollisionWorld_RayResultCallback_m_collisionFilterGroup_get(void *c); //attribute: short int btCollisionWorld_RayResultCallback->m_collisionFilterGroup
void btCollisionWorld_RayResultCallback_m_collisionFilterMask_set(void *c,short int a); //attribute: short int btCollisionWorld_RayResultCallback->m_collisionFilterMask
short int btCollisionWorld_RayResultCallback_m_collisionFilterMask_get(void *c); //attribute: short int btCollisionWorld_RayResultCallback->m_collisionFilterMask
void btCollisionWorld_RayResultCallback_m_collisionObject_set(void *c,void* a); //attribute: ::btCollisionObject * btCollisionWorld_RayResultCallback->m_collisionObject
void* btCollisionWorld_RayResultCallback_m_collisionObject_get(void *c); //attribute: ::btCollisionObject * btCollisionWorld_RayResultCallback->m_collisionObject
void btCollisionWorld_RayResultCallback_m_flags_set(void *c,unsigned int a); //attribute: unsigned int btCollisionWorld_RayResultCallback->m_flags
unsigned int btCollisionWorld_RayResultCallback_m_flags_get(void *c); //attribute: unsigned int btCollisionWorld_RayResultCallback->m_flags
void* btCollisionAlgorithmCreateFunc_new(); //constructor: btCollisionAlgorithmCreateFunc  ( ::btCollisionAlgorithmCreateFunc::* )(  ) 
void btCollisionAlgorithmCreateFunc_free(void *c); 
void* btCollisionAlgorithmCreateFunc_CreateCollisionAlgorithm(void *c,void* p0,void* p1,void* p2); //method: CreateCollisionAlgorithm ::btCollisionAlgorithm * ( ::btCollisionAlgorithmCreateFunc::* )( ::btCollisionAlgorithmConstructionInfo &,::btCollisionObject *,::btCollisionObject * ) 
void btCollisionAlgorithmCreateFunc_m_swapped_set(void *c,int a); //attribute: bool btCollisionAlgorithmCreateFunc->m_swapped
int btCollisionAlgorithmCreateFunc_m_swapped_get(void *c); //attribute: bool btCollisionAlgorithmCreateFunc->m_swapped
//not supported method: getPersistentManifoldPool ::btPoolAllocator * ( ::btCollisionConfiguration::* )(  ) 
// error:  - unsupported

void* btCollisionConfiguration_getStackAllocator(void *c); //method: getStackAllocator ::btStackAlloc * ( ::btCollisionConfiguration::* )(  ) 
//not supported method: getCollisionAlgorithmPool ::btPoolAllocator * ( ::btCollisionConfiguration::* )(  ) 
// error:  - unsupported

void* btCollisionConfiguration_getCollisionAlgorithmCreateFunc(void *c,int p0,int p1); //method: getCollisionAlgorithmCreateFunc ::btCollisionAlgorithmCreateFunc * ( ::btCollisionConfiguration::* )( int,int ) 
void* btCollisionDispatcher_new(void* p0); //constructor: btCollisionDispatcher  ( ::btCollisionDispatcher::* )( ::btCollisionConfiguration * ) 
void btCollisionDispatcher_free(void *c); 
void* btCollisionDispatcher_allocateCollisionAlgorithm(void *c,int p0); //method: allocateCollisionAlgorithm void * ( ::btCollisionDispatcher::* )( int ) 
int btCollisionDispatcher_getDispatcherFlags(void *c); //method: getDispatcherFlags int ( ::btCollisionDispatcher::* )(  ) const
void* btCollisionDispatcher_getCollisionConfiguration(void *c); //method: getCollisionConfiguration ::btCollisionConfiguration * ( ::btCollisionDispatcher::* )(  ) 
void* btCollisionDispatcher_getCollisionConfiguration0(void *c); //method: getCollisionConfiguration ::btCollisionConfiguration * ( ::btCollisionDispatcher::* )(  ) 
void* btCollisionDispatcher_getCollisionConfiguration1(void *c); //method: getCollisionConfiguration ::btCollisionConfiguration const * ( ::btCollisionDispatcher::* )(  ) const
void btCollisionDispatcher_setDispatcherFlags(void *c,int p0); //method: setDispatcherFlags void ( ::btCollisionDispatcher::* )( int ) 
void btCollisionDispatcher_releaseManifold(void *c,void* p0); //method: releaseManifold void ( ::btCollisionDispatcher::* )( ::btPersistentManifold * ) 
void btCollisionDispatcher_setCollisionConfiguration(void *c,void* p0); //method: setCollisionConfiguration void ( ::btCollisionDispatcher::* )( ::btCollisionConfiguration * ) 
int btCollisionDispatcher_getNumManifolds(void *c); //method: getNumManifolds int ( ::btCollisionDispatcher::* )(  ) const
void btCollisionDispatcher_clearManifold(void *c,void* p0); //method: clearManifold void ( ::btCollisionDispatcher::* )( ::btPersistentManifold * ) 
void btCollisionDispatcher_freeCollisionAlgorithm(void *c,void* p0); //method: freeCollisionAlgorithm void ( ::btCollisionDispatcher::* )( void * ) 
//not supported method: getInternalManifoldPointer ::btPersistentManifold * * ( ::btCollisionDispatcher::* )(  ) 
// error:  - unsupported

void btCollisionDispatcher_registerCollisionCreateFunc(void *c,int p0,int p1,void* p2); //method: registerCollisionCreateFunc void ( ::btCollisionDispatcher::* )( int,int,::btCollisionAlgorithmCreateFunc * ) 
void btCollisionDispatcher_defaultNearCallback(void* p0,void* p1,void* p2); //method: defaultNearCallback void (*)( ::btBroadphasePair &,::btCollisionDispatcher &,::btDispatcherInfo const & )
//not supported method: getNearCallback ::btNearCallback ( ::btCollisionDispatcher::* )(  ) const
// error:  - unsupported

void* btCollisionDispatcher_findAlgorithm(void *c,void* p0,void* p1,void* p2); //method: findAlgorithm ::btCollisionAlgorithm * ( ::btCollisionDispatcher::* )( ::btCollisionObject *,::btCollisionObject *,::btPersistentManifold * ) 
int btCollisionDispatcher_needsResponse(void *c,void* p0,void* p1); //method: needsResponse bool ( ::btCollisionDispatcher::* )( ::btCollisionObject *,::btCollisionObject * ) 
void* btCollisionDispatcher_getNewManifold(void *c,void* p0,void* p1); //method: getNewManifold ::btPersistentManifold * ( ::btCollisionDispatcher::* )( void *,void * ) 
void btCollisionDispatcher_dispatchAllCollisionPairs(void *c,void* p0,void* p1,void* p2); //method: dispatchAllCollisionPairs void ( ::btCollisionDispatcher::* )( ::btOverlappingPairCache *,::btDispatcherInfo const &,::btDispatcher * ) 
//not supported method: getInternalManifoldPool ::btPoolAllocator * ( ::btCollisionDispatcher::* )(  ) 
// error:  - unsupported

//not supported method: getInternalManifoldPool ::btPoolAllocator * ( ::btCollisionDispatcher::* )(  ) 
// error:  - unsupported

//not supported method: getInternalManifoldPool ::btPoolAllocator const * ( ::btCollisionDispatcher::* )(  ) const
// error:  - unsupported

int btCollisionDispatcher_needsCollision(void *c,void* p0,void* p1); //method: needsCollision bool ( ::btCollisionDispatcher::* )( ::btCollisionObject *,::btCollisionObject * ) 
void* btCollisionDispatcher_getManifoldByIndexInternal(void *c,int p0); //method: getManifoldByIndexInternal ::btPersistentManifold * ( ::btCollisionDispatcher::* )( int ) 
void* btCollisionDispatcher_getManifoldByIndexInternal0(void *c,int p0); //method: getManifoldByIndexInternal ::btPersistentManifold * ( ::btCollisionDispatcher::* )( int ) 
void* btCollisionDispatcher_getManifoldByIndexInternal1(void *c,int p0); //method: getManifoldByIndexInternal ::btPersistentManifold const * ( ::btCollisionDispatcher::* )( int ) const
//not supported method: setNearCallback void ( ::btCollisionDispatcher::* )( ::btNearCallback ) 
// error:  - unsupported, void - ok

// attribute not supported: //attribute: ::btPoolAllocator * btCollisionDispatcher->m_collisionAlgorithmPoolAllocator
void btCollisionDispatcher_m_collisionConfiguration_set(void *c,void* a); //attribute: ::btCollisionConfiguration * btCollisionDispatcher->m_collisionConfiguration
void* btCollisionDispatcher_m_collisionConfiguration_get(void *c); //attribute: ::btCollisionConfiguration * btCollisionDispatcher->m_collisionConfiguration
void btCollisionDispatcher_m_defaultManifoldResult_set(void *c,void* a); //attribute: ::btManifoldResult btCollisionDispatcher->m_defaultManifoldResult
void* btCollisionDispatcher_m_defaultManifoldResult_get(void *c); //attribute: ::btManifoldResult btCollisionDispatcher->m_defaultManifoldResult
void btCollisionDispatcher_m_dispatcherFlags_set(void *c,int a); //attribute: int btCollisionDispatcher->m_dispatcherFlags
int btCollisionDispatcher_m_dispatcherFlags_get(void *c); //attribute: int btCollisionDispatcher->m_dispatcherFlags
// attribute not supported: //attribute: ::btCollisionAlgorithmCreateFunc *[36][36] btCollisionDispatcher->m_doubleDispatch
void btCollisionDispatcher_m_manifoldsPtr_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btPersistentManifold*> btCollisionDispatcher->m_manifoldsPtr
void* btCollisionDispatcher_m_manifoldsPtr_get(void *c); //attribute: ::btAlignedObjectArray<btPersistentManifold*> btCollisionDispatcher->m_manifoldsPtr
// attribute not supported: //attribute: ::btNearCallback btCollisionDispatcher->m_nearCallback
// attribute not supported: //attribute: ::btPoolAllocator * btCollisionDispatcher->m_persistentManifoldPoolAllocator
void* btCollisionObject_new(); //constructor: btCollisionObject  ( ::btCollisionObject::* )(  ) 
void btCollisionObject_free(void *c); 
float btCollisionObject_getCcdSquareMotionThreshold(void *c); //method: getCcdSquareMotionThreshold ::btScalar ( ::btCollisionObject::* )(  ) const
void btCollisionObject_activate(void *c,int p0); //method: activate void ( ::btCollisionObject::* )( bool ) 
void btCollisionObject_setInterpolationLinearVelocity(void *c,float* p0); //method: setInterpolationLinearVelocity void ( ::btCollisionObject::* )( ::btVector3 const & ) 
float btCollisionObject_getFriction(void *c); //method: getFriction ::btScalar ( ::btCollisionObject::* )(  ) const
void btCollisionObject_setCompanionId(void *c,int p0); //method: setCompanionId void ( ::btCollisionObject::* )( int ) 
void btCollisionObject_setInterpolationAngularVelocity(void *c,float* p0); //method: setInterpolationAngularVelocity void ( ::btCollisionObject::* )( ::btVector3 const & ) 
char const * btCollisionObject_serialize(void *c,void* p0,void* p1); //method: serialize char const * ( ::btCollisionObject::* )( void *,::btSerializer * ) const
void btCollisionObject_setWorldTransform(void *c,float* p0); //method: setWorldTransform void ( ::btCollisionObject::* )( ::btTransform const & ) 
int btCollisionObject_getCompanionId(void *c); //method: getCompanionId int ( ::btCollisionObject::* )(  ) const
void btCollisionObject_internalSetExtensionPointer(void *c,void* p0); //method: internalSetExtensionPointer void ( ::btCollisionObject::* )( void * ) 
void btCollisionObject_setContactProcessingThreshold(void *c,float p0); //method: setContactProcessingThreshold void ( ::btCollisionObject::* )( ::btScalar ) 
void btCollisionObject_setInterpolationWorldTransform(void *c,float* p0); //method: setInterpolationWorldTransform void ( ::btCollisionObject::* )( ::btTransform const & ) 
void btCollisionObject_getInterpolationLinearVelocity(void *c,float* ret); //method: getInterpolationLinearVelocity ::btVector3 const & ( ::btCollisionObject::* )(  ) const
int btCollisionObject_mergesSimulationIslands(void *c); //method: mergesSimulationIslands bool ( ::btCollisionObject::* )(  ) const
void btCollisionObject_setCollisionShape(void *c,void* p0); //method: setCollisionShape void ( ::btCollisionObject::* )( ::btCollisionShape * ) 
void btCollisionObject_setCcdMotionThreshold(void *c,float p0); //method: setCcdMotionThreshold void ( ::btCollisionObject::* )( ::btScalar ) 
int btCollisionObject_getIslandTag(void *c); //method: getIslandTag int ( ::btCollisionObject::* )(  ) const
int btCollisionObject_calculateSerializeBufferSize(void *c); //method: calculateSerializeBufferSize int ( ::btCollisionObject::* )(  ) const
float btCollisionObject_getCcdMotionThreshold(void *c); //method: getCcdMotionThreshold ::btScalar ( ::btCollisionObject::* )(  ) const
void btCollisionObject_setUserPointer(void *c,void* p0); //method: setUserPointer void ( ::btCollisionObject::* )( void * ) 
int btCollisionObject_checkCollideWith(void *c,void* p0); //method: checkCollideWith bool ( ::btCollisionObject::* )( ::btCollisionObject * ) 
void btCollisionObject_getAnisotropicFriction(void *c,float* ret); //method: getAnisotropicFriction ::btVector3 const & ( ::btCollisionObject::* )(  ) const
void btCollisionObject_getInterpolationAngularVelocity(void *c,float* ret); //method: getInterpolationAngularVelocity ::btVector3 const & ( ::btCollisionObject::* )(  ) const
void btCollisionObject_forceActivationState(void *c,int p0); //method: forceActivationState void ( ::btCollisionObject::* )( int ) 
int btCollisionObject_isStaticObject(void *c); //method: isStaticObject bool ( ::btCollisionObject::* )(  ) const
void btCollisionObject_setFriction(void *c,float p0); //method: setFriction void ( ::btCollisionObject::* )( ::btScalar ) 
void btCollisionObject_getInterpolationWorldTransform(void *c,float* ret); //method: getInterpolationWorldTransform ::btTransform const & ( ::btCollisionObject::* )(  ) const
void btCollisionObject_getInterpolationWorldTransform0(void *c,float* ret); //method: getInterpolationWorldTransform ::btTransform const & ( ::btCollisionObject::* )(  ) const
void btCollisionObject_getInterpolationWorldTransform1(void *c,float* ret); //method: getInterpolationWorldTransform ::btTransform & ( ::btCollisionObject::* )(  ) 
void btCollisionObject_setIslandTag(void *c,int p0); //method: setIslandTag void ( ::btCollisionObject::* )( int ) 
void btCollisionObject_setHitFraction(void *c,float p0); //method: setHitFraction void ( ::btCollisionObject::* )( ::btScalar ) 
void btCollisionObject_serializeSingleObject(void *c,void* p0); //method: serializeSingleObject void ( ::btCollisionObject::* )( ::btSerializer * ) const
int btCollisionObject_getCollisionFlags(void *c); //method: getCollisionFlags int ( ::btCollisionObject::* )(  ) const
float btCollisionObject_getDeactivationTime(void *c); //method: getDeactivationTime ::btScalar ( ::btCollisionObject::* )(  ) const
void* btCollisionObject_getCollisionShape(void *c); //method: getCollisionShape ::btCollisionShape const * ( ::btCollisionObject::* )(  ) const
void* btCollisionObject_getCollisionShape0(void *c); //method: getCollisionShape ::btCollisionShape const * ( ::btCollisionObject::* )(  ) const
void* btCollisionObject_getCollisionShape1(void *c); //method: getCollisionShape ::btCollisionShape * ( ::btCollisionObject::* )(  ) 
void btCollisionObject_setAnisotropicFriction(void *c,float* p0); //method: setAnisotropicFriction void ( ::btCollisionObject::* )( ::btVector3 const & ) 
int btCollisionObject_checkCollideWithOverride(void *c,void* p0); //method: checkCollideWithOverride bool ( ::btCollisionObject::* )( ::btCollisionObject * ) 
void* btCollisionObject_getBroadphaseHandle(void *c); //method: getBroadphaseHandle ::btBroadphaseProxy * ( ::btCollisionObject::* )(  ) 
void* btCollisionObject_getBroadphaseHandle0(void *c); //method: getBroadphaseHandle ::btBroadphaseProxy * ( ::btCollisionObject::* )(  ) 
void* btCollisionObject_getBroadphaseHandle1(void *c); //method: getBroadphaseHandle ::btBroadphaseProxy const * ( ::btCollisionObject::* )(  ) const
void* btCollisionObject_getUserPointer(void *c); //method: getUserPointer void * ( ::btCollisionObject::* )(  ) const
void btCollisionObject_setCcdSweptSphereRadius(void *c,float p0); //method: setCcdSweptSphereRadius void ( ::btCollisionObject::* )( ::btScalar ) 
void btCollisionObject_getWorldTransform(void *c,float* ret); //method: getWorldTransform ::btTransform & ( ::btCollisionObject::* )(  ) 
void btCollisionObject_getWorldTransform0(void *c,float* ret); //method: getWorldTransform ::btTransform & ( ::btCollisionObject::* )(  ) 
void btCollisionObject_getWorldTransform1(void *c,float* ret); //method: getWorldTransform ::btTransform const & ( ::btCollisionObject::* )(  ) const
void btCollisionObject_setCollisionFlags(void *c,int p0); //method: setCollisionFlags void ( ::btCollisionObject::* )( int ) 
void btCollisionObject_internalSetTemporaryCollisionShape(void *c,void* p0); //method: internalSetTemporaryCollisionShape void ( ::btCollisionObject::* )( ::btCollisionShape * ) 
float btCollisionObject_getHitFraction(void *c); //method: getHitFraction ::btScalar ( ::btCollisionObject::* )(  ) const
int btCollisionObject_isActive(void *c); //method: isActive bool ( ::btCollisionObject::* )(  ) const
void btCollisionObject_setActivationState(void *c,int p0); //method: setActivationState void ( ::btCollisionObject::* )( int ) 
int btCollisionObject_getInternalType(void *c); //method: getInternalType int ( ::btCollisionObject::* )(  ) const
int btCollisionObject_getActivationState(void *c); //method: getActivationState int ( ::btCollisionObject::* )(  ) const
int btCollisionObject_hasContactResponse(void *c); //method: hasContactResponse bool ( ::btCollisionObject::* )(  ) const
void* btCollisionObject_getRootCollisionShape(void *c); //method: getRootCollisionShape ::btCollisionShape const * ( ::btCollisionObject::* )(  ) const
void* btCollisionObject_getRootCollisionShape0(void *c); //method: getRootCollisionShape ::btCollisionShape const * ( ::btCollisionObject::* )(  ) const
void* btCollisionObject_getRootCollisionShape1(void *c); //method: getRootCollisionShape ::btCollisionShape * ( ::btCollisionObject::* )(  ) 
float btCollisionObject_getRestitution(void *c); //method: getRestitution ::btScalar ( ::btCollisionObject::* )(  ) const
float btCollisionObject_getCcdSweptSphereRadius(void *c); //method: getCcdSweptSphereRadius ::btScalar ( ::btCollisionObject::* )(  ) const
float btCollisionObject_getContactProcessingThreshold(void *c); //method: getContactProcessingThreshold ::btScalar ( ::btCollisionObject::* )(  ) const
void btCollisionObject_setDeactivationTime(void *c,float p0); //method: setDeactivationTime void ( ::btCollisionObject::* )( ::btScalar ) 
void* btCollisionObject_internalGetExtensionPointer(void *c); //method: internalGetExtensionPointer void * ( ::btCollisionObject::* )(  ) const
int btCollisionObject_isStaticOrKinematicObject(void *c); //method: isStaticOrKinematicObject bool ( ::btCollisionObject::* )(  ) const
void btCollisionObject_setRestitution(void *c,float p0); //method: setRestitution void ( ::btCollisionObject::* )( ::btScalar ) 
int btCollisionObject_hasAnisotropicFriction(void *c); //method: hasAnisotropicFriction bool ( ::btCollisionObject::* )(  ) const
void btCollisionObject_setBroadphaseHandle(void *c,void* p0); //method: setBroadphaseHandle void ( ::btCollisionObject::* )( ::btBroadphaseProxy * ) 
int btCollisionObject_isKinematicObject(void *c); //method: isKinematicObject bool ( ::btCollisionObject::* )(  ) const
void btCollisionObject_m_activationState1_set(void *c,int a); //attribute: int btCollisionObject->m_activationState1
int btCollisionObject_m_activationState1_get(void *c); //attribute: int btCollisionObject->m_activationState1
void btCollisionObject_m_anisotropicFriction_set(void *c,float* a); //attribute: ::btVector3 btCollisionObject->m_anisotropicFriction
void btCollisionObject_m_anisotropicFriction_get(void *c,float* a);
void btCollisionObject_m_broadphaseHandle_set(void *c,void* a); //attribute: ::btBroadphaseProxy * btCollisionObject->m_broadphaseHandle
void* btCollisionObject_m_broadphaseHandle_get(void *c); //attribute: ::btBroadphaseProxy * btCollisionObject->m_broadphaseHandle
void btCollisionObject_m_ccdMotionThreshold_set(void *c,float a); //attribute: ::btScalar btCollisionObject->m_ccdMotionThreshold
float btCollisionObject_m_ccdMotionThreshold_get(void *c); //attribute: ::btScalar btCollisionObject->m_ccdMotionThreshold
void btCollisionObject_m_ccdSweptSphereRadius_set(void *c,float a); //attribute: ::btScalar btCollisionObject->m_ccdSweptSphereRadius
float btCollisionObject_m_ccdSweptSphereRadius_get(void *c); //attribute: ::btScalar btCollisionObject->m_ccdSweptSphereRadius
void btCollisionObject_m_checkCollideWith_set(void *c,int a); //attribute: int btCollisionObject->m_checkCollideWith
int btCollisionObject_m_checkCollideWith_get(void *c); //attribute: int btCollisionObject->m_checkCollideWith
void btCollisionObject_m_collisionFlags_set(void *c,int a); //attribute: int btCollisionObject->m_collisionFlags
int btCollisionObject_m_collisionFlags_get(void *c); //attribute: int btCollisionObject->m_collisionFlags
void btCollisionObject_m_collisionShape_set(void *c,void* a); //attribute: ::btCollisionShape * btCollisionObject->m_collisionShape
void* btCollisionObject_m_collisionShape_get(void *c); //attribute: ::btCollisionShape * btCollisionObject->m_collisionShape
void btCollisionObject_m_companionId_set(void *c,int a); //attribute: int btCollisionObject->m_companionId
int btCollisionObject_m_companionId_get(void *c); //attribute: int btCollisionObject->m_companionId
void btCollisionObject_m_contactProcessingThreshold_set(void *c,float a); //attribute: ::btScalar btCollisionObject->m_contactProcessingThreshold
float btCollisionObject_m_contactProcessingThreshold_get(void *c); //attribute: ::btScalar btCollisionObject->m_contactProcessingThreshold
void btCollisionObject_m_deactivationTime_set(void *c,float a); //attribute: ::btScalar btCollisionObject->m_deactivationTime
float btCollisionObject_m_deactivationTime_get(void *c); //attribute: ::btScalar btCollisionObject->m_deactivationTime
void btCollisionObject_m_extensionPointer_set(void *c,void* a); //attribute: void * btCollisionObject->m_extensionPointer
void* btCollisionObject_m_extensionPointer_get(void *c); //attribute: void * btCollisionObject->m_extensionPointer
void btCollisionObject_m_friction_set(void *c,float a); //attribute: ::btScalar btCollisionObject->m_friction
float btCollisionObject_m_friction_get(void *c); //attribute: ::btScalar btCollisionObject->m_friction
void btCollisionObject_m_hasAnisotropicFriction_set(void *c,int a); //attribute: int btCollisionObject->m_hasAnisotropicFriction
int btCollisionObject_m_hasAnisotropicFriction_get(void *c); //attribute: int btCollisionObject->m_hasAnisotropicFriction
void btCollisionObject_m_hitFraction_set(void *c,float a); //attribute: ::btScalar btCollisionObject->m_hitFraction
float btCollisionObject_m_hitFraction_get(void *c); //attribute: ::btScalar btCollisionObject->m_hitFraction
void btCollisionObject_m_internalType_set(void *c,int a); //attribute: int btCollisionObject->m_internalType
int btCollisionObject_m_internalType_get(void *c); //attribute: int btCollisionObject->m_internalType
void btCollisionObject_m_interpolationAngularVelocity_set(void *c,float* a); //attribute: ::btVector3 btCollisionObject->m_interpolationAngularVelocity
void btCollisionObject_m_interpolationAngularVelocity_get(void *c,float* a);
void btCollisionObject_m_interpolationLinearVelocity_set(void *c,float* a); //attribute: ::btVector3 btCollisionObject->m_interpolationLinearVelocity
void btCollisionObject_m_interpolationLinearVelocity_get(void *c,float* a);
void btCollisionObject_m_interpolationWorldTransform_set(void *c,float* a); //attribute: ::btTransform btCollisionObject->m_interpolationWorldTransform
void btCollisionObject_m_interpolationWorldTransform_get(void *c,float* a);
void btCollisionObject_m_islandTag1_set(void *c,int a); //attribute: int btCollisionObject->m_islandTag1
int btCollisionObject_m_islandTag1_get(void *c); //attribute: int btCollisionObject->m_islandTag1
void btCollisionObject_m_restitution_set(void *c,float a); //attribute: ::btScalar btCollisionObject->m_restitution
float btCollisionObject_m_restitution_get(void *c); //attribute: ::btScalar btCollisionObject->m_restitution
void btCollisionObject_m_rootCollisionShape_set(void *c,void* a); //attribute: ::btCollisionShape * btCollisionObject->m_rootCollisionShape
void* btCollisionObject_m_rootCollisionShape_get(void *c); //attribute: ::btCollisionShape * btCollisionObject->m_rootCollisionShape
void btCollisionObject_m_userObjectPointer_set(void *c,void* a); //attribute: void * btCollisionObject->m_userObjectPointer
void* btCollisionObject_m_userObjectPointer_get(void *c); //attribute: void * btCollisionObject->m_userObjectPointer
void btCollisionObject_m_worldTransform_set(void *c,float* a); //attribute: ::btTransform btCollisionObject->m_worldTransform
void btCollisionObject_m_worldTransform_get(void *c,float* a);
void* btCollisionObjectDoubleData_new(); //constructor: btCollisionObjectDoubleData  ( ::btCollisionObjectDoubleData::* )(  ) 
void btCollisionObjectDoubleData_free(void *c); 
void btCollisionObjectDoubleData_m_activationState1_set(void *c,int a); //attribute: int btCollisionObjectDoubleData->m_activationState1
int btCollisionObjectDoubleData_m_activationState1_get(void *c); //attribute: int btCollisionObjectDoubleData->m_activationState1
void btCollisionObjectDoubleData_m_anisotropicFriction_set(void *c,void* a); //attribute: ::btVector3DoubleData btCollisionObjectDoubleData->m_anisotropicFriction
void* btCollisionObjectDoubleData_m_anisotropicFriction_get(void *c); //attribute: ::btVector3DoubleData btCollisionObjectDoubleData->m_anisotropicFriction
void btCollisionObjectDoubleData_m_broadphaseHandle_set(void *c,void* a); //attribute: void * btCollisionObjectDoubleData->m_broadphaseHandle
void* btCollisionObjectDoubleData_m_broadphaseHandle_get(void *c); //attribute: void * btCollisionObjectDoubleData->m_broadphaseHandle
void btCollisionObjectDoubleData_m_ccdMotionThreshold_set(void *c,double a); //attribute: double btCollisionObjectDoubleData->m_ccdMotionThreshold
double btCollisionObjectDoubleData_m_ccdMotionThreshold_get(void *c); //attribute: double btCollisionObjectDoubleData->m_ccdMotionThreshold
void btCollisionObjectDoubleData_m_ccdSweptSphereRadius_set(void *c,double a); //attribute: double btCollisionObjectDoubleData->m_ccdSweptSphereRadius
double btCollisionObjectDoubleData_m_ccdSweptSphereRadius_get(void *c); //attribute: double btCollisionObjectDoubleData->m_ccdSweptSphereRadius
void btCollisionObjectDoubleData_m_checkCollideWith_set(void *c,int a); //attribute: int btCollisionObjectDoubleData->m_checkCollideWith
int btCollisionObjectDoubleData_m_checkCollideWith_get(void *c); //attribute: int btCollisionObjectDoubleData->m_checkCollideWith
void btCollisionObjectDoubleData_m_collisionFlags_set(void *c,int a); //attribute: int btCollisionObjectDoubleData->m_collisionFlags
int btCollisionObjectDoubleData_m_collisionFlags_get(void *c); //attribute: int btCollisionObjectDoubleData->m_collisionFlags
void btCollisionObjectDoubleData_m_collisionShape_set(void *c,void* a); //attribute: void * btCollisionObjectDoubleData->m_collisionShape
void* btCollisionObjectDoubleData_m_collisionShape_get(void *c); //attribute: void * btCollisionObjectDoubleData->m_collisionShape
void btCollisionObjectDoubleData_m_companionId_set(void *c,int a); //attribute: int btCollisionObjectDoubleData->m_companionId
int btCollisionObjectDoubleData_m_companionId_get(void *c); //attribute: int btCollisionObjectDoubleData->m_companionId
void btCollisionObjectDoubleData_m_contactProcessingThreshold_set(void *c,double a); //attribute: double btCollisionObjectDoubleData->m_contactProcessingThreshold
double btCollisionObjectDoubleData_m_contactProcessingThreshold_get(void *c); //attribute: double btCollisionObjectDoubleData->m_contactProcessingThreshold
void btCollisionObjectDoubleData_m_deactivationTime_set(void *c,double a); //attribute: double btCollisionObjectDoubleData->m_deactivationTime
double btCollisionObjectDoubleData_m_deactivationTime_get(void *c); //attribute: double btCollisionObjectDoubleData->m_deactivationTime
void btCollisionObjectDoubleData_m_friction_set(void *c,double a); //attribute: double btCollisionObjectDoubleData->m_friction
double btCollisionObjectDoubleData_m_friction_get(void *c); //attribute: double btCollisionObjectDoubleData->m_friction
void btCollisionObjectDoubleData_m_hasAnisotropicFriction_set(void *c,int a); //attribute: int btCollisionObjectDoubleData->m_hasAnisotropicFriction
int btCollisionObjectDoubleData_m_hasAnisotropicFriction_get(void *c); //attribute: int btCollisionObjectDoubleData->m_hasAnisotropicFriction
void btCollisionObjectDoubleData_m_hitFraction_set(void *c,double a); //attribute: double btCollisionObjectDoubleData->m_hitFraction
double btCollisionObjectDoubleData_m_hitFraction_get(void *c); //attribute: double btCollisionObjectDoubleData->m_hitFraction
void btCollisionObjectDoubleData_m_internalType_set(void *c,int a); //attribute: int btCollisionObjectDoubleData->m_internalType
int btCollisionObjectDoubleData_m_internalType_get(void *c); //attribute: int btCollisionObjectDoubleData->m_internalType
void btCollisionObjectDoubleData_m_interpolationAngularVelocity_set(void *c,void* a); //attribute: ::btVector3DoubleData btCollisionObjectDoubleData->m_interpolationAngularVelocity
void* btCollisionObjectDoubleData_m_interpolationAngularVelocity_get(void *c); //attribute: ::btVector3DoubleData btCollisionObjectDoubleData->m_interpolationAngularVelocity
void btCollisionObjectDoubleData_m_interpolationLinearVelocity_set(void *c,void* a); //attribute: ::btVector3DoubleData btCollisionObjectDoubleData->m_interpolationLinearVelocity
void* btCollisionObjectDoubleData_m_interpolationLinearVelocity_get(void *c); //attribute: ::btVector3DoubleData btCollisionObjectDoubleData->m_interpolationLinearVelocity
void btCollisionObjectDoubleData_m_interpolationWorldTransform_set(void *c,void* a); //attribute: ::btTransformDoubleData btCollisionObjectDoubleData->m_interpolationWorldTransform
void* btCollisionObjectDoubleData_m_interpolationWorldTransform_get(void *c); //attribute: ::btTransformDoubleData btCollisionObjectDoubleData->m_interpolationWorldTransform
void btCollisionObjectDoubleData_m_islandTag1_set(void *c,int a); //attribute: int btCollisionObjectDoubleData->m_islandTag1
int btCollisionObjectDoubleData_m_islandTag1_get(void *c); //attribute: int btCollisionObjectDoubleData->m_islandTag1
void btCollisionObjectDoubleData_m_name_set(void *c,char * a); //attribute: char * btCollisionObjectDoubleData->m_name
char * btCollisionObjectDoubleData_m_name_get(void *c); //attribute: char * btCollisionObjectDoubleData->m_name
// attribute not supported: //attribute: char[4] btCollisionObjectDoubleData->m_padding
void btCollisionObjectDoubleData_m_restitution_set(void *c,double a); //attribute: double btCollisionObjectDoubleData->m_restitution
double btCollisionObjectDoubleData_m_restitution_get(void *c); //attribute: double btCollisionObjectDoubleData->m_restitution
void btCollisionObjectDoubleData_m_rootCollisionShape_set(void *c,void* a); //attribute: ::btCollisionShapeData * btCollisionObjectDoubleData->m_rootCollisionShape
void* btCollisionObjectDoubleData_m_rootCollisionShape_get(void *c); //attribute: ::btCollisionShapeData * btCollisionObjectDoubleData->m_rootCollisionShape
void btCollisionObjectDoubleData_m_worldTransform_set(void *c,void* a); //attribute: ::btTransformDoubleData btCollisionObjectDoubleData->m_worldTransform
void* btCollisionObjectDoubleData_m_worldTransform_get(void *c); //attribute: ::btTransformDoubleData btCollisionObjectDoubleData->m_worldTransform
void* btCollisionObjectFloatData_new(); //constructor: btCollisionObjectFloatData  ( ::btCollisionObjectFloatData::* )(  ) 
void btCollisionObjectFloatData_free(void *c); 
void btCollisionObjectFloatData_m_activationState1_set(void *c,int a); //attribute: int btCollisionObjectFloatData->m_activationState1
int btCollisionObjectFloatData_m_activationState1_get(void *c); //attribute: int btCollisionObjectFloatData->m_activationState1
void btCollisionObjectFloatData_m_anisotropicFriction_set(void *c,void* a); //attribute: ::btVector3FloatData btCollisionObjectFloatData->m_anisotropicFriction
void* btCollisionObjectFloatData_m_anisotropicFriction_get(void *c); //attribute: ::btVector3FloatData btCollisionObjectFloatData->m_anisotropicFriction
void btCollisionObjectFloatData_m_broadphaseHandle_set(void *c,void* a); //attribute: void * btCollisionObjectFloatData->m_broadphaseHandle
void* btCollisionObjectFloatData_m_broadphaseHandle_get(void *c); //attribute: void * btCollisionObjectFloatData->m_broadphaseHandle
void btCollisionObjectFloatData_m_ccdMotionThreshold_set(void *c,float a); //attribute: float btCollisionObjectFloatData->m_ccdMotionThreshold
float btCollisionObjectFloatData_m_ccdMotionThreshold_get(void *c); //attribute: float btCollisionObjectFloatData->m_ccdMotionThreshold
void btCollisionObjectFloatData_m_ccdSweptSphereRadius_set(void *c,float a); //attribute: float btCollisionObjectFloatData->m_ccdSweptSphereRadius
float btCollisionObjectFloatData_m_ccdSweptSphereRadius_get(void *c); //attribute: float btCollisionObjectFloatData->m_ccdSweptSphereRadius
void btCollisionObjectFloatData_m_checkCollideWith_set(void *c,int a); //attribute: int btCollisionObjectFloatData->m_checkCollideWith
int btCollisionObjectFloatData_m_checkCollideWith_get(void *c); //attribute: int btCollisionObjectFloatData->m_checkCollideWith
void btCollisionObjectFloatData_m_collisionFlags_set(void *c,int a); //attribute: int btCollisionObjectFloatData->m_collisionFlags
int btCollisionObjectFloatData_m_collisionFlags_get(void *c); //attribute: int btCollisionObjectFloatData->m_collisionFlags
void btCollisionObjectFloatData_m_collisionShape_set(void *c,void* a); //attribute: void * btCollisionObjectFloatData->m_collisionShape
void* btCollisionObjectFloatData_m_collisionShape_get(void *c); //attribute: void * btCollisionObjectFloatData->m_collisionShape
void btCollisionObjectFloatData_m_companionId_set(void *c,int a); //attribute: int btCollisionObjectFloatData->m_companionId
int btCollisionObjectFloatData_m_companionId_get(void *c); //attribute: int btCollisionObjectFloatData->m_companionId
void btCollisionObjectFloatData_m_contactProcessingThreshold_set(void *c,float a); //attribute: float btCollisionObjectFloatData->m_contactProcessingThreshold
float btCollisionObjectFloatData_m_contactProcessingThreshold_get(void *c); //attribute: float btCollisionObjectFloatData->m_contactProcessingThreshold
void btCollisionObjectFloatData_m_deactivationTime_set(void *c,float a); //attribute: float btCollisionObjectFloatData->m_deactivationTime
float btCollisionObjectFloatData_m_deactivationTime_get(void *c); //attribute: float btCollisionObjectFloatData->m_deactivationTime
void btCollisionObjectFloatData_m_friction_set(void *c,float a); //attribute: float btCollisionObjectFloatData->m_friction
float btCollisionObjectFloatData_m_friction_get(void *c); //attribute: float btCollisionObjectFloatData->m_friction
void btCollisionObjectFloatData_m_hasAnisotropicFriction_set(void *c,int a); //attribute: int btCollisionObjectFloatData->m_hasAnisotropicFriction
int btCollisionObjectFloatData_m_hasAnisotropicFriction_get(void *c); //attribute: int btCollisionObjectFloatData->m_hasAnisotropicFriction
void btCollisionObjectFloatData_m_hitFraction_set(void *c,float a); //attribute: float btCollisionObjectFloatData->m_hitFraction
float btCollisionObjectFloatData_m_hitFraction_get(void *c); //attribute: float btCollisionObjectFloatData->m_hitFraction
void btCollisionObjectFloatData_m_internalType_set(void *c,int a); //attribute: int btCollisionObjectFloatData->m_internalType
int btCollisionObjectFloatData_m_internalType_get(void *c); //attribute: int btCollisionObjectFloatData->m_internalType
void btCollisionObjectFloatData_m_interpolationAngularVelocity_set(void *c,void* a); //attribute: ::btVector3FloatData btCollisionObjectFloatData->m_interpolationAngularVelocity
void* btCollisionObjectFloatData_m_interpolationAngularVelocity_get(void *c); //attribute: ::btVector3FloatData btCollisionObjectFloatData->m_interpolationAngularVelocity
void btCollisionObjectFloatData_m_interpolationLinearVelocity_set(void *c,void* a); //attribute: ::btVector3FloatData btCollisionObjectFloatData->m_interpolationLinearVelocity
void* btCollisionObjectFloatData_m_interpolationLinearVelocity_get(void *c); //attribute: ::btVector3FloatData btCollisionObjectFloatData->m_interpolationLinearVelocity
void btCollisionObjectFloatData_m_interpolationWorldTransform_set(void *c,void* a); //attribute: ::btTransformFloatData btCollisionObjectFloatData->m_interpolationWorldTransform
void* btCollisionObjectFloatData_m_interpolationWorldTransform_get(void *c); //attribute: ::btTransformFloatData btCollisionObjectFloatData->m_interpolationWorldTransform
void btCollisionObjectFloatData_m_islandTag1_set(void *c,int a); //attribute: int btCollisionObjectFloatData->m_islandTag1
int btCollisionObjectFloatData_m_islandTag1_get(void *c); //attribute: int btCollisionObjectFloatData->m_islandTag1
void btCollisionObjectFloatData_m_name_set(void *c,char * a); //attribute: char * btCollisionObjectFloatData->m_name
char * btCollisionObjectFloatData_m_name_get(void *c); //attribute: char * btCollisionObjectFloatData->m_name
void btCollisionObjectFloatData_m_restitution_set(void *c,float a); //attribute: float btCollisionObjectFloatData->m_restitution
float btCollisionObjectFloatData_m_restitution_get(void *c); //attribute: float btCollisionObjectFloatData->m_restitution
void btCollisionObjectFloatData_m_rootCollisionShape_set(void *c,void* a); //attribute: ::btCollisionShapeData * btCollisionObjectFloatData->m_rootCollisionShape
void* btCollisionObjectFloatData_m_rootCollisionShape_get(void *c); //attribute: ::btCollisionShapeData * btCollisionObjectFloatData->m_rootCollisionShape
void btCollisionObjectFloatData_m_worldTransform_set(void *c,void* a); //attribute: ::btTransformFloatData btCollisionObjectFloatData->m_worldTransform
void* btCollisionObjectFloatData_m_worldTransform_get(void *c); //attribute: ::btTransformFloatData btCollisionObjectFloatData->m_worldTransform
void* btCollisionWorld_new(void* p0,void* p1,void* p2); //constructor: btCollisionWorld  ( ::btCollisionWorld::* )( ::btDispatcher *,::btBroadphaseInterface *,::btCollisionConfiguration * ) 
void btCollisionWorld_free(void *c); 
void btCollisionWorld_setBroadphase(void *c,void* p0); //method: setBroadphase void ( ::btCollisionWorld::* )( ::btBroadphaseInterface * ) 
void btCollisionWorld_serialize(void *c,void* p0); //method: serialize void ( ::btCollisionWorld::* )( ::btSerializer * ) 
void* btCollisionWorld_getDispatcher(void *c); //method: getDispatcher ::btDispatcher * ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getDispatcher0(void *c); //method: getDispatcher ::btDispatcher * ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getDispatcher1(void *c); //method: getDispatcher ::btDispatcher const * ( ::btCollisionWorld::* )(  ) const
void* btCollisionWorld_getDispatchInfo(void *c); //method: getDispatchInfo ::btDispatcherInfo & ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getDispatchInfo0(void *c); //method: getDispatchInfo ::btDispatcherInfo & ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getDispatchInfo1(void *c); //method: getDispatchInfo ::btDispatcherInfo const & ( ::btCollisionWorld::* )(  ) const
void* btCollisionWorld_getDebugDrawer(void *c); //method: getDebugDrawer ::btIDebugDraw * ( ::btCollisionWorld::* )(  ) 
void btCollisionWorld_performDiscreteCollisionDetection(void *c); //method: performDiscreteCollisionDetection void ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getCollisionObjectArray(void *c); //method: getCollisionObjectArray ::btCollisionObjectArray & ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getCollisionObjectArray0(void *c); //method: getCollisionObjectArray ::btCollisionObjectArray & ( ::btCollisionWorld::* )(  ) 
void* btCollisionWorld_getCollisionObjectArray1(void *c); //method: getCollisionObjectArray ::btCollisionObjectArray const & ( ::btCollisionWorld::* )(  ) const
void btCollisionWorld_debugDrawObject(void *c,float* p0,void* p1,float* p2); //method: debugDrawObject void ( ::btCollisionWorld::* )( ::btTransform const &,::btCollisionShape const *,::btVector3 const & ) 
void btCollisionWorld_rayTest(void *c,float* p0,float* p1,void* p2); //method: rayTest void ( ::btCollisionWorld::* )( ::btVector3 const &,::btVector3 const &,::btCollisionWorld::RayResultCallback & ) const
void btCollisionWorld_addCollisionObject(void *c,void* p0,short int p1,short int p2); //method: addCollisionObject void ( ::btCollisionWorld::* )( ::btCollisionObject *,short int,short int ) 
void btCollisionWorld_setForceUpdateAllAabbs(void *c,int p0); //method: setForceUpdateAllAabbs void ( ::btCollisionWorld::* )( bool ) 
void btCollisionWorld_contactTest(void *c,void* p0,void* p1); //method: contactTest void ( ::btCollisionWorld::* )( ::btCollisionObject *,::btCollisionWorld::ContactResultCallback & ) 
int btCollisionWorld_getForceUpdateAllAabbs(void *c); //method: getForceUpdateAllAabbs bool ( ::btCollisionWorld::* )(  ) const
void btCollisionWorld_updateAabbs(void *c); //method: updateAabbs void ( ::btCollisionWorld::* )(  ) 
void btCollisionWorld_setDebugDrawer(void *c,void* p0); //method: setDebugDrawer void ( ::btCollisionWorld::* )( ::btIDebugDraw * ) 
void btCollisionWorld_debugDrawWorld(void *c); //method: debugDrawWorld void ( ::btCollisionWorld::* )(  ) 
void btCollisionWorld_convexSweepTest(void *c,void* p0,float* p1,float* p2,void* p3,float p4); //method: convexSweepTest void ( ::btCollisionWorld::* )( ::btConvexShape const *,::btTransform const &,::btTransform const &,::btCollisionWorld::ConvexResultCallback &,::btScalar ) const
int btCollisionWorld_getNumCollisionObjects(void *c); //method: getNumCollisionObjects int ( ::btCollisionWorld::* )(  ) const
void btCollisionWorld_contactPairTest(void *c,void* p0,void* p1,void* p2); //method: contactPairTest void ( ::btCollisionWorld::* )( ::btCollisionObject *,::btCollisionObject *,::btCollisionWorld::ContactResultCallback & ) 
void* btCollisionWorld_getBroadphase(void *c); //method: getBroadphase ::btBroadphaseInterface const * ( ::btCollisionWorld::* )(  ) const
void* btCollisionWorld_getBroadphase0(void *c); //method: getBroadphase ::btBroadphaseInterface const * ( ::btCollisionWorld::* )(  ) const
void* btCollisionWorld_getBroadphase1(void *c); //method: getBroadphase ::btBroadphaseInterface * ( ::btCollisionWorld::* )(  ) 
void btCollisionWorld_rayTestSingle(float* p0,float* p1,void* p2,void* p3,float* p4,void* p5); //method: rayTestSingle void (*)( ::btTransform const &,::btTransform const &,::btCollisionObject *,::btCollisionShape const *,::btTransform const &,::btCollisionWorld::RayResultCallback & )
void btCollisionWorld_objectQuerySingle(void* p0,float* p1,float* p2,void* p3,void* p4,float* p5,void* p6,float p7); //method: objectQuerySingle void (*)( ::btConvexShape const *,::btTransform const &,::btTransform const &,::btCollisionObject *,::btCollisionShape const *,::btTransform const &,::btCollisionWorld::ConvexResultCallback &,::btScalar )
void btCollisionWorld_updateSingleAabb(void *c,void* p0); //method: updateSingleAabb void ( ::btCollisionWorld::* )( ::btCollisionObject * ) 
void btCollisionWorld_serializeCollisionObjects(void *c,void* p0); //method: serializeCollisionObjects void ( ::btCollisionWorld::* )( ::btSerializer * ) 
void* btCollisionWorld_getPairCache(void *c); //method: getPairCache ::btOverlappingPairCache * ( ::btCollisionWorld::* )(  ) 
void btCollisionWorld_removeCollisionObject(void *c,void* p0); //method: removeCollisionObject void ( ::btCollisionWorld::* )( ::btCollisionObject * ) 
void btCollisionWorld_m_broadphasePairCache_set(void *c,void* a); //attribute: ::btBroadphaseInterface * btCollisionWorld->m_broadphasePairCache
void* btCollisionWorld_m_broadphasePairCache_get(void *c); //attribute: ::btBroadphaseInterface * btCollisionWorld->m_broadphasePairCache
void btCollisionWorld_m_collisionObjects_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btCollisionObject*> btCollisionWorld->m_collisionObjects
void* btCollisionWorld_m_collisionObjects_get(void *c); //attribute: ::btAlignedObjectArray<btCollisionObject*> btCollisionWorld->m_collisionObjects
void btCollisionWorld_m_debugDrawer_set(void *c,void* a); //attribute: ::btIDebugDraw * btCollisionWorld->m_debugDrawer
void* btCollisionWorld_m_debugDrawer_get(void *c); //attribute: ::btIDebugDraw * btCollisionWorld->m_debugDrawer
void btCollisionWorld_m_dispatchInfo_set(void *c,void* a); //attribute: ::btDispatcherInfo btCollisionWorld->m_dispatchInfo
void* btCollisionWorld_m_dispatchInfo_get(void *c); //attribute: ::btDispatcherInfo btCollisionWorld->m_dispatchInfo
void btCollisionWorld_m_dispatcher1_set(void *c,void* a); //attribute: ::btDispatcher * btCollisionWorld->m_dispatcher1
void* btCollisionWorld_m_dispatcher1_get(void *c); //attribute: ::btDispatcher * btCollisionWorld->m_dispatcher1
void btCollisionWorld_m_forceUpdateAllAabbs_set(void *c,int a); //attribute: bool btCollisionWorld->m_forceUpdateAllAabbs
int btCollisionWorld_m_forceUpdateAllAabbs_get(void *c); //attribute: bool btCollisionWorld->m_forceUpdateAllAabbs
void btCollisionWorld_m_stackAlloc_set(void *c,void* a); //attribute: ::btStackAlloc * btCollisionWorld->m_stackAlloc
void* btCollisionWorld_m_stackAlloc_get(void *c); //attribute: ::btStackAlloc * btCollisionWorld->m_stackAlloc
//not supported constructor: btConvexConvexAlgorithm  ( ::btConvexConvexAlgorithm::* )( ::btPersistentManifold *,::btCollisionAlgorithmConstructionInfo const &,::btCollisionObject *,::btCollisionObject *,::btVoronoiSimplexSolver *,::btConvexPenetrationDepthSolver *,int,int ) 
// error: ::btPersistentManifold * - ok, ::btCollisionAlgorithmConstructionInfo const & - ok, ::btCollisionObject * - ok, ::btCollisionObject * - ok, ::btVoronoiSimplexSolver * - ok,  - unsupported, int - ok, int - ok

void btConvexConvexAlgorithm_free(void *c); 
void btConvexConvexAlgorithm_getAllContactManifolds(void *c,void* p0); //method: getAllContactManifolds void ( ::btConvexConvexAlgorithm::* )( ::btManifoldArray & ) 
float btConvexConvexAlgorithm_calculateTimeOfImpact(void *c,void* p0,void* p1,void* p2,void* p3); //method: calculateTimeOfImpact ::btScalar ( ::btConvexConvexAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
void btConvexConvexAlgorithm_setLowLevelOfDetail(void *c,int p0); //method: setLowLevelOfDetail void ( ::btConvexConvexAlgorithm::* )( bool ) 
void btConvexConvexAlgorithm_processCollision(void *c,void* p0,void* p1,void* p2,void* p3); //method: processCollision void ( ::btConvexConvexAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
void* btConvexConvexAlgorithm_getManifold(void *c); //method: getManifold ::btPersistentManifold const * ( ::btConvexConvexAlgorithm::* )(  ) 
void btConvexConvexAlgorithm_m_simplexSolver_set(void *c,void* a); //attribute: ::btVoronoiSimplexSolver * btConvexConvexAlgorithm->m_simplexSolver
void* btConvexConvexAlgorithm_m_simplexSolver_get(void *c); //attribute: ::btVoronoiSimplexSolver * btConvexConvexAlgorithm->m_simplexSolver
// attribute not supported: //attribute: ::btConvexPenetrationDepthSolver * btConvexConvexAlgorithm->m_pdSolver
void btConvexConvexAlgorithm_m_ownManifold_set(void *c,int a); //attribute: bool btConvexConvexAlgorithm->m_ownManifold
int btConvexConvexAlgorithm_m_ownManifold_get(void *c); //attribute: bool btConvexConvexAlgorithm->m_ownManifold
void btConvexConvexAlgorithm_m_manifoldPtr_set(void *c,void* a); //attribute: ::btPersistentManifold * btConvexConvexAlgorithm->m_manifoldPtr
void* btConvexConvexAlgorithm_m_manifoldPtr_get(void *c); //attribute: ::btPersistentManifold * btConvexConvexAlgorithm->m_manifoldPtr
void btConvexConvexAlgorithm_m_lowLevelOfDetail_set(void *c,int a); //attribute: bool btConvexConvexAlgorithm->m_lowLevelOfDetail
int btConvexConvexAlgorithm_m_lowLevelOfDetail_get(void *c); //attribute: bool btConvexConvexAlgorithm->m_lowLevelOfDetail
void btConvexConvexAlgorithm_m_numPerturbationIterations_set(void *c,int a); //attribute: int btConvexConvexAlgorithm->m_numPerturbationIterations
int btConvexConvexAlgorithm_m_numPerturbationIterations_get(void *c); //attribute: int btConvexConvexAlgorithm->m_numPerturbationIterations
void btConvexConvexAlgorithm_m_minimumPointsPerturbationThreshold_set(void *c,int a); //attribute: int btConvexConvexAlgorithm->m_minimumPointsPerturbationThreshold
int btConvexConvexAlgorithm_m_minimumPointsPerturbationThreshold_get(void *c); //attribute: int btConvexConvexAlgorithm->m_minimumPointsPerturbationThreshold
void* btDefaultCollisionConfiguration_new(void* p0); //constructor: btDefaultCollisionConfiguration  ( ::btDefaultCollisionConfiguration::* )( ::btDefaultCollisionConstructionInfo const & ) 
void btDefaultCollisionConfiguration_free(void *c); 
void* btDefaultCollisionConfiguration_getStackAllocator(void *c); //method: getStackAllocator ::btStackAlloc * ( ::btDefaultCollisionConfiguration::* )(  ) 
//not supported method: getPersistentManifoldPool ::btPoolAllocator * ( ::btDefaultCollisionConfiguration::* )(  ) 
// error:  - unsupported

void btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations(void *c,int p0,int p1); //method: setPlaneConvexMultipointIterations void ( ::btDefaultCollisionConfiguration::* )( int,int ) 
void* btDefaultCollisionConfiguration_getSimplexSolver(void *c); //method: getSimplexSolver ::btVoronoiSimplexSolver * ( ::btDefaultCollisionConfiguration::* )(  ) 
void btDefaultCollisionConfiguration_setConvexConvexMultipointIterations(void *c,int p0,int p1); //method: setConvexConvexMultipointIterations void ( ::btDefaultCollisionConfiguration::* )( int,int ) 
//not supported method: getCollisionAlgorithmPool ::btPoolAllocator * ( ::btDefaultCollisionConfiguration::* )(  ) 
// error:  - unsupported

void* btDefaultCollisionConfiguration_getCollisionAlgorithmCreateFunc(void *c,int p0,int p1); //method: getCollisionAlgorithmCreateFunc ::btCollisionAlgorithmCreateFunc * ( ::btDefaultCollisionConfiguration::* )( int,int ) 
void btDefaultCollisionConfiguration_m_persistentManifoldPoolSize_set(void *c,int a); //attribute: int btDefaultCollisionConfiguration->m_persistentManifoldPoolSize
int btDefaultCollisionConfiguration_m_persistentManifoldPoolSize_get(void *c); //attribute: int btDefaultCollisionConfiguration->m_persistentManifoldPoolSize
void btDefaultCollisionConfiguration_m_stackAlloc_set(void *c,void* a); //attribute: ::btStackAlloc * btDefaultCollisionConfiguration->m_stackAlloc
void* btDefaultCollisionConfiguration_m_stackAlloc_get(void *c); //attribute: ::btStackAlloc * btDefaultCollisionConfiguration->m_stackAlloc
void btDefaultCollisionConfiguration_m_ownsStackAllocator_set(void *c,int a); //attribute: bool btDefaultCollisionConfiguration->m_ownsStackAllocator
int btDefaultCollisionConfiguration_m_ownsStackAllocator_get(void *c); //attribute: bool btDefaultCollisionConfiguration->m_ownsStackAllocator
// attribute not supported: //attribute: ::btPoolAllocator * btDefaultCollisionConfiguration->m_persistentManifoldPool
void btDefaultCollisionConfiguration_m_ownsPersistentManifoldPool_set(void *c,int a); //attribute: bool btDefaultCollisionConfiguration->m_ownsPersistentManifoldPool
int btDefaultCollisionConfiguration_m_ownsPersistentManifoldPool_get(void *c); //attribute: bool btDefaultCollisionConfiguration->m_ownsPersistentManifoldPool
// attribute not supported: //attribute: ::btPoolAllocator * btDefaultCollisionConfiguration->m_collisionAlgorithmPool
void btDefaultCollisionConfiguration_m_ownsCollisionAlgorithmPool_set(void *c,int a); //attribute: bool btDefaultCollisionConfiguration->m_ownsCollisionAlgorithmPool
int btDefaultCollisionConfiguration_m_ownsCollisionAlgorithmPool_get(void *c); //attribute: bool btDefaultCollisionConfiguration->m_ownsCollisionAlgorithmPool
void btDefaultCollisionConfiguration_m_simplexSolver_set(void *c,void* a); //attribute: ::btVoronoiSimplexSolver * btDefaultCollisionConfiguration->m_simplexSolver
void* btDefaultCollisionConfiguration_m_simplexSolver_get(void *c); //attribute: ::btVoronoiSimplexSolver * btDefaultCollisionConfiguration->m_simplexSolver
// attribute not supported: //attribute: ::btConvexPenetrationDepthSolver * btDefaultCollisionConfiguration->m_pdSolver
void btDefaultCollisionConfiguration_m_convexConvexCreateFunc_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_convexConvexCreateFunc
void* btDefaultCollisionConfiguration_m_convexConvexCreateFunc_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_convexConvexCreateFunc
void btDefaultCollisionConfiguration_m_convexConcaveCreateFunc_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_convexConcaveCreateFunc
void* btDefaultCollisionConfiguration_m_convexConcaveCreateFunc_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_convexConcaveCreateFunc
void btDefaultCollisionConfiguration_m_swappedConvexConcaveCreateFunc_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_swappedConvexConcaveCreateFunc
void* btDefaultCollisionConfiguration_m_swappedConvexConcaveCreateFunc_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_swappedConvexConcaveCreateFunc
void btDefaultCollisionConfiguration_m_compoundCreateFunc_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_compoundCreateFunc
void* btDefaultCollisionConfiguration_m_compoundCreateFunc_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_compoundCreateFunc
void btDefaultCollisionConfiguration_m_swappedCompoundCreateFunc_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_swappedCompoundCreateFunc
void* btDefaultCollisionConfiguration_m_swappedCompoundCreateFunc_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_swappedCompoundCreateFunc
void btDefaultCollisionConfiguration_m_emptyCreateFunc_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_emptyCreateFunc
void* btDefaultCollisionConfiguration_m_emptyCreateFunc_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_emptyCreateFunc
void btDefaultCollisionConfiguration_m_sphereSphereCF_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_sphereSphereCF
void* btDefaultCollisionConfiguration_m_sphereSphereCF_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_sphereSphereCF
void btDefaultCollisionConfiguration_m_boxBoxCF_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_boxBoxCF
void* btDefaultCollisionConfiguration_m_boxBoxCF_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_boxBoxCF
void btDefaultCollisionConfiguration_m_sphereTriangleCF_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_sphereTriangleCF
void* btDefaultCollisionConfiguration_m_sphereTriangleCF_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_sphereTriangleCF
void btDefaultCollisionConfiguration_m_triangleSphereCF_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_triangleSphereCF
void* btDefaultCollisionConfiguration_m_triangleSphereCF_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_triangleSphereCF
void btDefaultCollisionConfiguration_m_planeConvexCF_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_planeConvexCF
void* btDefaultCollisionConfiguration_m_planeConvexCF_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_planeConvexCF
void btDefaultCollisionConfiguration_m_convexPlaneCF_set(void *c,void* a); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_convexPlaneCF
void* btDefaultCollisionConfiguration_m_convexPlaneCF_get(void *c); //attribute: ::btCollisionAlgorithmCreateFunc * btDefaultCollisionConfiguration->m_convexPlaneCF
void* btDefaultCollisionConstructionInfo_new(); //constructor: btDefaultCollisionConstructionInfo  ( ::btDefaultCollisionConstructionInfo::* )(  ) 
void btDefaultCollisionConstructionInfo_free(void *c); 
// attribute not supported: //attribute: ::btPoolAllocator * btDefaultCollisionConstructionInfo->m_collisionAlgorithmPool
void btDefaultCollisionConstructionInfo_m_customCollisionAlgorithmMaxElementSize_set(void *c,int a); //attribute: int btDefaultCollisionConstructionInfo->m_customCollisionAlgorithmMaxElementSize
int btDefaultCollisionConstructionInfo_m_customCollisionAlgorithmMaxElementSize_get(void *c); //attribute: int btDefaultCollisionConstructionInfo->m_customCollisionAlgorithmMaxElementSize
void btDefaultCollisionConstructionInfo_m_defaultMaxCollisionAlgorithmPoolSize_set(void *c,int a); //attribute: int btDefaultCollisionConstructionInfo->m_defaultMaxCollisionAlgorithmPoolSize
int btDefaultCollisionConstructionInfo_m_defaultMaxCollisionAlgorithmPoolSize_get(void *c); //attribute: int btDefaultCollisionConstructionInfo->m_defaultMaxCollisionAlgorithmPoolSize
void btDefaultCollisionConstructionInfo_m_defaultMaxPersistentManifoldPoolSize_set(void *c,int a); //attribute: int btDefaultCollisionConstructionInfo->m_defaultMaxPersistentManifoldPoolSize
int btDefaultCollisionConstructionInfo_m_defaultMaxPersistentManifoldPoolSize_get(void *c); //attribute: int btDefaultCollisionConstructionInfo->m_defaultMaxPersistentManifoldPoolSize
void btDefaultCollisionConstructionInfo_m_defaultStackAllocatorSize_set(void *c,int a); //attribute: int btDefaultCollisionConstructionInfo->m_defaultStackAllocatorSize
int btDefaultCollisionConstructionInfo_m_defaultStackAllocatorSize_get(void *c); //attribute: int btDefaultCollisionConstructionInfo->m_defaultStackAllocatorSize
// attribute not supported: //attribute: ::btPoolAllocator * btDefaultCollisionConstructionInfo->m_persistentManifoldPool
void btDefaultCollisionConstructionInfo_m_stackAlloc_set(void *c,void* a); //attribute: ::btStackAlloc * btDefaultCollisionConstructionInfo->m_stackAlloc
void* btDefaultCollisionConstructionInfo_m_stackAlloc_get(void *c); //attribute: ::btStackAlloc * btDefaultCollisionConstructionInfo->m_stackAlloc
void btDefaultCollisionConstructionInfo_m_useEpaPenetrationAlgorithm_set(void *c,int a); //attribute: int btDefaultCollisionConstructionInfo->m_useEpaPenetrationAlgorithm
int btDefaultCollisionConstructionInfo_m_useEpaPenetrationAlgorithm_get(void *c); //attribute: int btDefaultCollisionConstructionInfo->m_useEpaPenetrationAlgorithm
void* btGhostObject_new(); //constructor: btGhostObject  ( ::btGhostObject::* )(  ) 
void btGhostObject_free(void *c); 
void btGhostObject_convexSweepTest(void *c,void* p0,float* p1,float* p2,void* p3,float p4); //method: convexSweepTest void ( ::btGhostObject::* )( ::btConvexShape const *,::btTransform const &,::btTransform const &,::btCollisionWorld::ConvexResultCallback &,::btScalar ) const
void btGhostObject_removeOverlappingObjectInternal(void *c,void* p0,void* p1,void* p2); //method: removeOverlappingObjectInternal void ( ::btGhostObject::* )( ::btBroadphaseProxy *,::btDispatcher *,::btBroadphaseProxy * ) 
int btGhostObject_getNumOverlappingObjects(void *c); //method: getNumOverlappingObjects int ( ::btGhostObject::* )(  ) const
void btGhostObject_addOverlappingObjectInternal(void *c,void* p0,void* p1); //method: addOverlappingObjectInternal void ( ::btGhostObject::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void btGhostObject_rayTest(void *c,float* p0,float* p1,void* p2); //method: rayTest void ( ::btGhostObject::* )( ::btVector3 const &,::btVector3 const &,::btCollisionWorld::RayResultCallback & ) const
void* btGhostObject_getOverlappingPairs(void *c); //method: getOverlappingPairs ::btAlignedObjectArray<btCollisionObject*> & ( ::btGhostObject::* )(  ) 
void* btGhostObject_getOverlappingPairs0(void *c); //method: getOverlappingPairs ::btAlignedObjectArray<btCollisionObject*> & ( ::btGhostObject::* )(  ) 
//not supported method: getOverlappingPairs ::btAlignedObjectArray<btCollisionObject*> const ( ::btGhostObject::* )(  ) const
// error:  - unsupported

void* btGhostObject_upcast(void* p0); //method: upcast ::btGhostObject const * (*)( ::btCollisionObject const * )
void* btGhostObject_upcast0(void* p0); //method: upcast ::btGhostObject const * (*)( ::btCollisionObject const * )
void* btGhostObject_upcast1(void* p0); //method: upcast ::btGhostObject * (*)( ::btCollisionObject * )
void* btGhostObject_getOverlappingObject(void *c,int p0); //method: getOverlappingObject ::btCollisionObject * ( ::btGhostObject::* )( int ) 
void* btGhostObject_getOverlappingObject0(void *c,int p0); //method: getOverlappingObject ::btCollisionObject * ( ::btGhostObject::* )( int ) 
void* btGhostObject_getOverlappingObject1(void *c,int p0); //method: getOverlappingObject ::btCollisionObject const * ( ::btGhostObject::* )( int ) const
void btGhostObject_m_overlappingObjects_set(void *c,void* a); //attribute: ::btAlignedObjectArray<btCollisionObject*> btGhostObject->m_overlappingObjects
void* btGhostObject_m_overlappingObjects_get(void *c); //attribute: ::btAlignedObjectArray<btCollisionObject*> btGhostObject->m_overlappingObjects
void* btGhostPairCallback_new(); //constructor: btGhostPairCallback  ( ::btGhostPairCallback::* )(  ) 
void btGhostPairCallback_free(void *c); 
void* btGhostPairCallback_addOverlappingPair(void *c,void* p0,void* p1); //method: addOverlappingPair ::btBroadphasePair * ( ::btGhostPairCallback::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void* btGhostPairCallback_removeOverlappingPair(void *c,void* p0,void* p1,void* p2); //method: removeOverlappingPair void * ( ::btGhostPairCallback::* )( ::btBroadphaseProxy *,::btBroadphaseProxy *,::btDispatcher * ) 
void btGhostPairCallback_removeOverlappingPairsContainingProxy(void *c,void* p0,void* p1); //method: removeOverlappingPairsContainingProxy void ( ::btGhostPairCallback::* )( ::btBroadphaseProxy *,::btDispatcher * ) 
void* btManifoldResult_new0(); //constructor: btManifoldResult  ( ::btManifoldResult::* )(  ) 
void* btManifoldResult_new1(void* p0,void* p1); //constructor: btManifoldResult  ( ::btManifoldResult::* )( ::btCollisionObject *,::btCollisionObject * ) 
void btManifoldResult_free(void *c); 
void* btManifoldResult_getPersistentManifold(void *c); //method: getPersistentManifold ::btPersistentManifold const * ( ::btManifoldResult::* )(  ) const
void* btManifoldResult_getPersistentManifold0(void *c); //method: getPersistentManifold ::btPersistentManifold const * ( ::btManifoldResult::* )(  ) const
void* btManifoldResult_getPersistentManifold1(void *c); //method: getPersistentManifold ::btPersistentManifold * ( ::btManifoldResult::* )(  ) 
void* btManifoldResult_getBody0Internal(void *c); //method: getBody0Internal ::btCollisionObject const * ( ::btManifoldResult::* )(  ) const
void btManifoldResult_addContactPoint(void *c,float* p0,float* p1,float p2); //method: addContactPoint void ( ::btManifoldResult::* )( ::btVector3 const &,::btVector3 const &,::btScalar ) 
void* btManifoldResult_getBody1Internal(void *c); //method: getBody1Internal ::btCollisionObject const * ( ::btManifoldResult::* )(  ) const
void btManifoldResult_setShapeIdentifiersB(void *c,int p0,int p1); //method: setShapeIdentifiersB void ( ::btManifoldResult::* )( int,int ) 
void btManifoldResult_setShapeIdentifiersA(void *c,int p0,int p1); //method: setShapeIdentifiersA void ( ::btManifoldResult::* )( int,int ) 
void btManifoldResult_refreshContactPoints(void *c); //method: refreshContactPoints void ( ::btManifoldResult::* )(  ) 
void btManifoldResult_setPersistentManifold(void *c,void* p0); //method: setPersistentManifold void ( ::btManifoldResult::* )( ::btPersistentManifold * ) 
void btManifoldResult_m_body0_set(void *c,void* a); //attribute: ::btCollisionObject * btManifoldResult->m_body0
void* btManifoldResult_m_body0_get(void *c); //attribute: ::btCollisionObject * btManifoldResult->m_body0
void btManifoldResult_m_body1_set(void *c,void* a); //attribute: ::btCollisionObject * btManifoldResult->m_body1
void* btManifoldResult_m_body1_get(void *c); //attribute: ::btCollisionObject * btManifoldResult->m_body1
void btManifoldResult_m_index0_set(void *c,int a); //attribute: int btManifoldResult->m_index0
int btManifoldResult_m_index0_get(void *c); //attribute: int btManifoldResult->m_index0
void btManifoldResult_m_index1_set(void *c,int a); //attribute: int btManifoldResult->m_index1
int btManifoldResult_m_index1_get(void *c); //attribute: int btManifoldResult->m_index1
void btManifoldResult_m_manifoldPtr_set(void *c,void* a); //attribute: ::btPersistentManifold * btManifoldResult->m_manifoldPtr
void* btManifoldResult_m_manifoldPtr_get(void *c); //attribute: ::btPersistentManifold * btManifoldResult->m_manifoldPtr
void btManifoldResult_m_partId0_set(void *c,int a); //attribute: int btManifoldResult->m_partId0
int btManifoldResult_m_partId0_get(void *c); //attribute: int btManifoldResult->m_partId0
void btManifoldResult_m_partId1_set(void *c,int a); //attribute: int btManifoldResult->m_partId1
int btManifoldResult_m_partId1_get(void *c); //attribute: int btManifoldResult->m_partId1
void btManifoldResult_m_rootTransA_set(void *c,float* a); //attribute: ::btTransform btManifoldResult->m_rootTransA
void btManifoldResult_m_rootTransA_get(void *c,float* a);
void btManifoldResult_m_rootTransB_set(void *c,float* a); //attribute: ::btTransform btManifoldResult->m_rootTransB
void btManifoldResult_m_rootTransB_get(void *c,float* a);
void* btPairCachingGhostObject_new(); //constructor: btPairCachingGhostObject  ( ::btPairCachingGhostObject::* )(  ) 
void btPairCachingGhostObject_free(void *c); 
void btPairCachingGhostObject_removeOverlappingObjectInternal(void *c,void* p0,void* p1,void* p2); //method: removeOverlappingObjectInternal void ( ::btPairCachingGhostObject::* )( ::btBroadphaseProxy *,::btDispatcher *,::btBroadphaseProxy * ) 
void* btPairCachingGhostObject_getOverlappingPairCache(void *c); //method: getOverlappingPairCache ::btHashedOverlappingPairCache * ( ::btPairCachingGhostObject::* )(  ) 
void btPairCachingGhostObject_addOverlappingObjectInternal(void *c,void* p0,void* p1); //method: addOverlappingObjectInternal void ( ::btPairCachingGhostObject::* )( ::btBroadphaseProxy *,::btBroadphaseProxy * ) 
void btPairCachingGhostObject_m_hashPairCache_set(void *c,void* a); //attribute: ::btHashedOverlappingPairCache * btPairCachingGhostObject->m_hashPairCache
void* btPairCachingGhostObject_m_hashPairCache_get(void *c); //attribute: ::btHashedOverlappingPairCache * btPairCachingGhostObject->m_hashPairCache
void* btSphereSphereCollisionAlgorithm_new0(void* p0,void* p1,void* p2,void* p3); //constructor: btSphereSphereCollisionAlgorithm  ( ::btSphereSphereCollisionAlgorithm::* )( ::btPersistentManifold *,::btCollisionAlgorithmConstructionInfo const &,::btCollisionObject *,::btCollisionObject * ) 
void* btSphereSphereCollisionAlgorithm_new1(void* p0); //constructor: btSphereSphereCollisionAlgorithm  ( ::btSphereSphereCollisionAlgorithm::* )( ::btCollisionAlgorithmConstructionInfo const & ) 
void btSphereSphereCollisionAlgorithm_free(void *c); 
void btSphereSphereCollisionAlgorithm_getAllContactManifolds(void *c,void* p0); //method: getAllContactManifolds void ( ::btSphereSphereCollisionAlgorithm::* )( ::btManifoldArray & ) 
float btSphereSphereCollisionAlgorithm_calculateTimeOfImpact(void *c,void* p0,void* p1,void* p2,void* p3); //method: calculateTimeOfImpact ::btScalar ( ::btSphereSphereCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
void btSphereSphereCollisionAlgorithm_processCollision(void *c,void* p0,void* p1,void* p2,void* p3); //method: processCollision void ( ::btSphereSphereCollisionAlgorithm::* )( ::btCollisionObject *,::btCollisionObject *,::btDispatcherInfo const &,::btManifoldResult * ) 
void btSphereSphereCollisionAlgorithm_m_ownManifold_set(void *c,int a); //attribute: bool btSphereSphereCollisionAlgorithm->m_ownManifold
int btSphereSphereCollisionAlgorithm_m_ownManifold_get(void *c); //attribute: bool btSphereSphereCollisionAlgorithm->m_ownManifold
void btSphereSphereCollisionAlgorithm_m_manifoldPtr_set(void *c,void* a); //attribute: ::btPersistentManifold * btSphereSphereCollisionAlgorithm->m_manifoldPtr
void* btSphereSphereCollisionAlgorithm_m_manifoldPtr_get(void *c); //attribute: ::btPersistentManifold * btSphereSphereCollisionAlgorithm->m_manifoldPtr
#ifdef __cplusplus
} 
#endif
